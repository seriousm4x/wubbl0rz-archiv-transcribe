wir haben nicht so viel zeit 145 mal gucken ob er dort gescheit was auf die reihe kriegen ich
erzähle euch auch gleich um was es geht nämlich meine sound settings richtig gemacht habe ein
bisschen bisschen was ein spannenderes angemacht habe das haben wir denn hier genau das ist mit
vocals vocals das sagt das legt mich ab das kann ich mir nicht geben weg das gut
das ist nice da freuen die sich bestimmt meine ist auch richtig happy seit die seit
ist ja schon ein bisschen seitdem ich den sound da gebaut habe also diese diesen ich
habe ja unseren so eine terrasse zum hof hin mit so einem wie nennt man das so so
so so so so so so so so so so so so so so so so so so so so so so so so so so so so so so so so
das ist kein sound es ist so netznetz ja die beiden vom stream titel das war heute auch das
war doch ich mache meine vor allem inner aus finalPatzen aber halt auch während der stream
so richtig anläuft nicht ein bisschen was erzähle tech wirker daher danke für den sap cleaning
iberus teile geht's abfeuers wieder als erstes am start so muss das sein aber man hat ich bin
mir gar nicht sicher habe ich auf der neuen vor allem überhaupt schon mein main.net entwicklungs
zeug eingerichtet
Ist da überhaupt schon was drauf?
Wenn nicht, muss ich irgendwie mal ein Passwort resetten und so.
Mal gucken.
Ich mache jetzt erstmal schnell Package-Updates.
Und dann erzähle ich euch, um was es geht.
Denn ich habe nämlich was sehr Cooles gelesen.
Es gab jetzt ein .NET 8 Preview-Version.
Lass mich mal kurz checken.
Ah, okay, Rider habe ich installiert.
Das heißt wahrscheinlich auch, ich habe die Toolbox installiert.
Okay, ich bin schon eingeloggt.
Nice, okay, pock.
So, darfst du es mal upgraden.
Pac-Man.
Darauf alles upgraden.
Upgrade einfach mal alles, dann ist gut.
Nein, heute nicht.
Heute machen wir was anderes.
Ich bin mir gar nicht sicher, ob heute alles, wahrscheinlich nicht komplett,
aber zumindest in Ansätzen, ob wir heute da was auf die Reihe kriegen.
Aber das muss ich mir angucken, weil ich bin da wirklich gespannt drauf,
ob die das auf die Reihe bekommen haben in .NET.
So, dass das vielleicht in einem Bereich Konkurrenz zu Go wird,
wo Go bisher wirklich ungeschlagen nice ist.
Und was ist eurer Meinung nach, vielleicht könnt ihr euch ja schon überlegen, was ich meine.
Was ist der Bereich, in dem, also ich meine jetzt nicht unbedingt die Sprache an sich,
sondern so das Handling von Go.
Also was macht Go wirklich richtig gut, was sonst keine Sprache ähnlich gut ist.
Ich meine keine Sprachfeature oder kein Framework-Feature.
Single Binaries, richtig, genau das meine ich.
Das meine ich, Single Binaries.
Das Blixer hat wieder hier, higher IQ.
Wusste, wusste gleich schon, was Sache ist.
Single Binary.
You Launcher.
War fort.
Ja, ja.
So, das Ganze hier noch updaten und dann haben wir es eigentlich.
Genau.
Single Binary, da sage ich gleich was dazu.
Single Binaries, das meine ich.
Und zwar, ich habe ein Blogpost gelesen von dem .NET Team.
Und die haben geschrieben, dass sie ihre Ahead of Time Compilation,
was scheuer das Wort ist, also im Prinzip das, was man so normal unter Kompilieren versteht,
jetzt verbessern wollen mit .8.
Und wenn das stimmt, könnte das vielleicht,
in diesem Beispiel,
in diesem Bereich, Go, ein bisschen Konkurrenz machen.
Natürlich wird das noch nicht so geil sein, wie mit Go.
Ich meine, Single Binaries in Go sind extrem nice gemacht.
Die sind lauffähig.
Die sind lauffähig, ja, zurück bis Kernel 2, 6, 38 oder sowas.
Go Binaries kannst du überall drauf laufen lassen.
Also, ganz so geil wird das nicht.
Aber wenn es schon auf Linux in den letzten fünf, sechs Jahren läuft, ist ja eigentlich auch okay.
So, folgenden Blogpost gab es.
Und da labert man.
Da läuft Microsoft wieder viel rum.
Was, wenn der Tag lang ist?
Könnte was von ChatGPT geschrieben sein.
Jetzt weiß ich auch, warum Microsoft da mit dran beteiligt ist,
um solche komischen Blogposts zu schreiben.
So, und irgendwann kommt dann Native Ahead of Time.
Also, das haben die ja schon eine Weile drin.
Das haben die ja schon eine Weile drin.
Und zwar, dass du .NET nicht nur mit der .NET Runtime ausführen kannst.
Also, quasi.
Jit.
Nicht Shit, Shit.
Jit, Jitten.
Also, dass da quasi zur Laufzeit generiert, was ausgeführt wird.
Das ist ja immer noch der Default-Weg, wie .NET Programme ausgeführt werden.
Also, ein bisschen so wie...
Also, was heißt ein bisschen?
Im Prinzip so genau, wie Java das macht.
Nur, dass es nicht Java ist.
Oder wie das sogar JavaScript mittlerweile teilweise macht.
Zumindest, das war ja bisher so der Weg, wie man .NET ausgeführt hat.
Zumindest, das war ja bisher so der Weg, wie man .NET ausgeführt hat.
Und seit .NET 7 haben die jetzt besseren Support eingebaut,
für das man sein komplettes .NET Programm fix und fertig kompilieren kann,
als Single Binary und es dann läuft.
Dass es einfach läuft, ist auch ein bisschen zu viel des Guten.
Je nachdem, was für Features man nutzt, läuft es gar nicht.
Und das hoffe ich halt, dass es besser wird damit.
Und die Größe von .NET Binaries ist noch ein bisschen heftig.
So, und das will ich heute mal ausprobieren.
Ich habe mir auch eine coole Anwendungsidee überlegt.
Wir können mal was basteln.
Weil, um sowas zu testen, ja.
Hier schreiben sie ja zum Beispiel auch, ein Hello World Programm ist jetzt 1,84 Megabyte.
Ja, was interessiert mich in Hello World Programm?
Ich brauche ja schon ein paar Libraries dabei und ein bisschen Features dabei.
Am Ende sind wir bestimmt nicht bei 1,84 MB.
Aber wenn wir unter 20 MB oder so sind, für ein Binary, was ausgeführt wird.
Und das ist ja auch eine coole Anwendungsidee.
Und wenn man das schnell startet, dann ist das wirklich gut.
So viel kleiner ist, wenn du Go mit ordentlichen Features verwendest, das auch nicht.
Ja, und da bin ich wirklich mal gespannt.
So, haben wir jetzt alles geupdatet.
Dann kann ich nämlich abschließend nochmal neu starten.
Und dann kann ich noch den, während es neu startet, Chat beantworten.
Hier war doch irgendwas.
Hau mal deine Meinung raus.
Hab die Möglichkeit, über eine Arbeitnehmerüberlassung in DevOps-Priorität einzuhängen.
Die checken aber nicht, dass ich wenig praktische Erfahrung habe.
Ich habe nur trotzdem Wagen.
Ganz ehrlich, Arbeitnehmerüberlassung.
Arbeitnehmerüberlassung klingt immer so ein bisschen nach Personalverschacher-Ding.
Ja, das ist ja nicht wild.
Wir haben auch ein paar Externe, die über eine Zwischenfirma gekommen sind.
Boah, keine Ahnung.
Kann ich dir jetzt so aus dem Bauch nichts sagen.
Kommt auch ein bisschen auf die Vermittlerfirma.
Und vor allem kommt es auf die Firma an, wo du dann hingehst.
Also, wenn du die Firma nice findest oder Bock drauf hast, dass du wenig praktische Erfahrung hast, ist das jetzt nicht so wild.
Wichtig ist, dass du gut googeln kannst und nicht schnell einarbeiten kannst.
Es ist immer ein Unterschied, ob du die Technologie kennst oder ob du weißt, wie sie eingesetzt wird.
Also, nee, das muss ich anders sagen.
Es ist ein Unterschied, ob du jetzt beispielsweise Technologie XY kennst, weil du weißt ja immer noch nicht, wie sie genau eingesetzt wird.
Und das kann von Unternehmen zu Unternehmen variieren.
Also, nur weil du eine Technologie kennst, heißt das nicht, dass du automatisch weißt, wie das dort eingesetzt wird.
Das heißt, das ist nicht so wild.
Wie hast du FZN für die History eingerichtet?
So, aber ich mache das wieder aus.
Ich habe meine Confi noch nicht gesynct.
Der anderen VM habe ich das schon wieder aus.
Ich habe das jetzt ein paar Wochen ausprobiert.
Ich muss ehrlich sagen, meins ist es nicht.
Okay, da.
Nee, das nicht.
Das ist Blödsinn.
Das hier.
FZ8 Keybindings, die haben so ein automatisches ZSH-Skript.
Aber ich bin...
Ich finde das nicht so gut.
Ich finde das nicht so gut.
Ich mag die klassische History mit Steuerung eher hoch und runter tatsächlich lieber als das.
Da ist mir das mit Substream-Matching und alles schon ein bisschen zu viel des Guten, weil der findet ja Dinger, die du gar nicht finden willst.
Ich weiß nicht, ob überhaupt...
Ja, das stimmt.
Das stimmt bis jetzt ja auch.
Nee.
Haben wir nicht.
Welche Distribution hast du?
Das ist Arch.
Warte mal.
Für euch habe ich doch immer...
Ich habe den Kram hier noch am Start.
Guck.
Arch, by the way.
Was sonst?
Was sonst?
Nur Arch only.
Gut.
So.
.NET install curl.
Die haben noch so ein komisches Installer-Skript.
Installieren wir uns mal .NET 8.
Und dann...
Immer, immer ganz wichtig.
Immer fremde Sachen aus dem Internet.
Nach...
Curl nach Bashpipen.
Ganz wichtig.
So macht man es.
Äh, Channel 8.0 brauchen wir, glaube ich.
Am besten noch sudo davor.
Genau.
Direkt blind aus dem Internet.
Von Reddit.
Von 4chan am besten noch.
Blind alles reinpasten.
Okay.
Repos.
MKDier.
Und anhand des Verzeichnis-Namens erkennt ihr vielleicht schon, was wir heute machen.
Wir legen VMs an.
Für...
Oh, ich hab gar keinen, gar keinen Lib-Wirt und so noch.
Wir legen KVM-VMs lokal an.
Einfach weil es geht.
Weil ich irgendwas brauche.
Was Low-Level-Shit benutzt.
Also Interop mit C-Libraries.
Ich brauch irgendwas, was...
...ein bisschen advancedere .NET Abhängigkeiten hat.
Und dann halt gucken, lässt sich das kompilieren und wie klein ist es am Ende.
Ja, und...
Ich hab mir... Das ist nicht auf GitHub.
Ich hab mir ein Tool gebaut vor einer Weile.
Da kann ich sowas hier machen.
Ich hab das hier nicht drauf.
Da kann ich sowas hier machen.
VM Start Kekkel.
So, und dann legt er mir eine temporäre lokale VM mit dem Debian an.
Und wenn ich so mache, schmeißt er die alle wieder weg.
Weil ich brauche manchmal trotz Container...
Trotz Container brauche ich manchmal eine richtig echte VM.
Um Sachen mal schnell auszuprobieren.
Ja.
Zum Beispiel um einen Runner zu installieren.
Für GitLab oder sowas.
Und das macht man am besten in der VM.
Wenn man Docker in Docker bauen will.
Manchmal ist es praktisch.
Außerdem ist das jetzt nur...
...für die...
...für den Versuch, ja.
Ich hoffe wir kriegen da irgendwas Annehmbares hin bis 22 Uhr.
So, also dann legen wir mal ein .NET Projekt an.
.NET
.NET
New Console
Alles klar.
Und dann machen wir RIDER mal auf.
Ja, ja, alles gut.
Wir trusten.
GachiBuzz.
So.
Loading Project.
Loading Error.
Geht schon gut los.
Ich glaube ich weiß warum.
Weil...
...der .NET 8 noch gar nicht erkannt hat.
Obwohl ich schon installiert habe.
Probieren wir das mal aus.
Ja guck, der hat .NET 8 nicht erkannt.
Kack, noob.
So, wunderbar.
So, wenn wir jetzt Glück haben.
Sollte er das alles erkennen.
Oder auch nicht.
Reload Project.
Ah, jetzt hat er alles erkannt.
Nice, nice, nice, nice.
Sehr schön.
Okay.
Da machen wir ein ordentliches Farbschema.
Sonst wird das ja nix.
RIDER.
Wir wollen Visual Studio.
Visual...
Wo ist es denn?
Visual Studio Dark.
Wollen wir haben.
Dass es so schön Microsoft .NET mäßig aussieht.
Gut.
Hello World Programm.
Also, Repos vor MChamp.
Und jetzt gucken wir, jetzt vergleichen wir mal.
Gucken wir mal kurz, ob das stimmt.
Überhaupt, was Microsoft da schreibt.
Microsoft selbst sagt ja.
Dass ein .NET Programm nur noch 1,4 MB oder sowas groß ist.
Und das testen wir jetzt mal.
Das probieren wir jetzt mal aus.
Ob das denn überhaupt stimmt.
Ne, Dracula mag ich nicht.
Ob das denn überhaupt stimmt.
Was Microsoft da so sagt.
Ähm.
Hier.
Microsoft sagt.
Ein Hello World .NET 8 Programm mit.
Wenn es kompiliert ist.
Braucht nur noch 1,84 MB.
Das heißt.
Wir testen das jetzt mal.
Und gucken.
Wow.
What the fuck.
Java.
Geh mal fort.
Ähm.
Und testen mal, ob das jetzt auch wirklich der Fall ist.
Also.
.NET.
Publish.
So.
Wenn ich den Kram noch aus dem Kopf wüssten würde.
Es ist "-p".
Und dann irgendwie.
Publish.
AOT.
Gleich True.
Kann das sein?
Ergibt das Sinn?
Output.
Build Directory.
Ok.
Er kackt schon mal nicht ab.
Ok.
Wahrscheinlich stimmt das, was ich gemacht habe.
So.
Build.
Das .NET Programm ist.
Wait a minute.
Das ist aber.
Das ist aber.
Was.
Was zum.
Ah.
Was ist mit meiner Shell los, Mann?
Was war das denn jetzt?
Hat komische Zeichen reingepastet.
So.
Also.
Ohne zu strippen.
Ist das schon einmal.
Sehe ich das richtig?
Das ist.
Wie viel ist das?
9 MB?
Ja.
9 MB groß.
Ok.
Strip.
Strip.
Symbols.
Lasst uns mal schauen, wie groß es jetzt ist.
Immer noch 8,9 MB.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
.NET.
Also das ist ja weit von dem entfernt, was Microsoft sich da...
Ah, guck mal jetzt.
Sag mal, was zum Teufel ist mit meinem Terminal los?
Ah, das ist schon besser.
1,9 MB, das ist richtig, was Microsoft da sagt.
Tatsächlich, guck mal.
Nur noch 1,9 MB groß der VM-Champ.
Okay, das funktioniert.
Jetzt vergleichen wir das mal auf die Schnelle.
Ich stelle mal kurz hier um auf .NET.
Die Debug-Datei, da sind Symbole drin, also sprich, wie die Funktionen heißen und sonst was.
Wofür braucht man das?
Das braucht man, dass du es ordentlich debuggen kannst.
Mit irgendeinem Debugger, dass du weißt, wie die Funktionen noch heißen.
Also, wenn eine Funktion aufgerufen wird...
Und die Debug-Datei nicht hast, dann weißt du nicht mal, wie die ursprünglich hieß.
Die Debug-Datei würde ich ja auch nicht ausliefern.
Die ist für dich zum ausprobieren.
Also, wenn du wirklich debuggen musst, dass du weißt, wo er gerade ist und was er gerade aufruft.
Weil, wenn die Funktionen heißen octopus.output, dann weißt du schon mal, was Bescheid ist.
Wenn die Funktionen so heißen, dann weißt du nicht so genau gibt es die Funktionen?
was das ist. Sag mal, was zum Teufel ist mit
meiner Shell los?
Klar kannst du die ausführen ohne Debug-File.
Das ist überhaupt kein Ding. Guck mal.
AM, VM-Champ,
Debug. Geht immer noch.
Überhaupt kein Problem.
Das ist nicht Fleet.
Das ist Rider mit dem neuen UI.
So, wir stellen das jetzt mal testweise
um. Auf .
Kann man das hier nicht umstellen? Auf .NET
8.
Ich stelle es auf .NET Standard um.
Easy. Dann sollte es auf jeden Fall gehen.
Ähm.
Publish.
Alter, was geht mit
meinem Terminal ab, Alter?
Das kann doch nicht sein, dass das Laufen kaputt ist.
Ich krieg hier Anfälle.
Okay, ähm.
Kann ich das nicht hier auf
.NET 8 raus?
Unallable, okay.
Darf ich das jetzt übersetzen
vielleicht? Was?
Alter.
Alter.
Ich will keine fucking Class Library, Mann.
Ach, kann man das nicht machen, oder wie?
Ah, das ist ja doof.
Äh.
Warum kann ich in die .NET-Version nicht runtergehen?
Warum geht das nicht?
Ich mein, ich kann, ich kann sagen
Unload. Wo ist denn der
Unload-Knopf überhaupt jetzt?
Unload Project.
So.
Ich, ich kann da in .NET 7 reinschreiben.
So, easy.
Oh, jetzt funktioniert's auch.
Äh, Liga, da kann ich dir gleich was zu sagen.
Wenn ich mich nicht hundertprozentig sehen kann.
Wenn ich sicher bin.
So.
Guck mal, wie groß das ist.
Okay.
Das ist schon ein Unterschied. Guck mal.
Mit der alten .NET-Version ist es
5,6 MB für ein publisches
Hello-World-Kurs. Und mit der neuen ist es
1,9.
Das ist, das ist tatsächlich echt
eine gute Verbesserung.
Da kann man nix sagen.
So. Also.
Ähm. Ich bin nicht zu stark.
Ich seh unsere Pipelines, die empfehlen .NET Restore,
aber auch .NET Build.
Doch, die Sache ist bloß die,
ich hab keine Ahnung, warum die Leute überhaupt
noch Build und Restore verwenden.
Die können einfach Publish verwenden.
Das macht beides in einem.
Also, keine Ahnung, warum das über...
Ich weiß, sogar das offizielle .NET
Docker-File-Example
macht das mit, mit Restore.
Vielleicht um,
vielleicht fürs Caching von den Containern.
Das kann natürlich sein,
wenn sich der Source-Code ändert,
tun das nicht, ähm,
jedes Mal...
Also, du kannst ja, wenn du,
wenn du ein Docker-File hast,
dann merkt das sich ja, an welchem,
an welchem Step du was geändert hast
und macht dann ab da weiter.
So, wenn du quasi Publish, also quasi den Restore
für die Dependencies und die Nougat-Packages
und alles, wenn du das
in einem Befehl hast mit Publish
und in Build und du änderst am Build-Befehl was,
dann muss er das alles wieder machen.
Also, vielleicht ist das
ein Restore und dann ein Publish
hinterher und dann Build, ist
vielleicht, dass das Docker-Caching
das besser hinbekommt.
Aber ansonsten kannst du einfach .NET Publish verwenden.
Das macht alles in einem. Also, eigentlich braucht man das
gar nicht.
Eigentlich overrated, outdated,
gbated.
So. Alles klar.
Dann können wir jetzt hier anfangen.
Ich hab die .NET-Version
wieder hochgestellt.
Gucken wir mal, ob das wieder funktioniert.
.NET Publish.
So. Und jetzt
passt mal auf, was wir heute
probieren werden. Ich bin mir nicht sicher, ob wir das überhaupt
auf die Reihe bekommen.
Ich muss gerade erst mal schnell
KVM installieren. Und zwar,
man kann ja auf der Linux-Kiste,
ja, ja, ich weiß, es läuft gerade nichts.
Man kann ja auf der Linux-Kiste lokal VMs benutzen.
So. Und ich wollte schon immer mal
gucken, wie man
VMs erstellt
über die
Linux-VM-Erstellungs-API.
Das hat nicht wirklich
so viel Sinn.
Ich hab mir letztens so ein Tool zusammengescriptet.
Aber wir können das ja
mal über die API machen.
Und das Gute ist,
das eignet sich dementsprechend auch wunderbar als
Compiler-Testprojekt,
weil ich muss Low-Level-Kram verwenden, plus
ein paar ein bisschen etwas anstehende Libraries.
Ich muss mir jetzt aber erst mal
libvirt und qemo und den ganzen Shit erstellen.
Gucken wir mal, ob das überhaupt
funktioniert, damit
ich da drauf zugreifen kann.
Okay.
Libvirt gibt es nicht.
Dann meinetwegen muss ich das noch starten.
Systemctl enable libvirt.
Not exist.
Okay. Start.
Sag mal,
warum ist denn das so
lahm, meine Tastatur?
Ah, viel besser.
Okay.
Kann man das jetzt laufen?
Kann man KVM laufen?
Nee, wir haben kein
KVM. Oh fuck, ich habe schon
lange kein KVM mehr installiert.
KVM?
Okay, KVM ist, ja.
Ach du Kacke.
Arch KVM install.
Das müssen wir jetzt mal auf die Schnelle gucken.
Check
support.
Okay, kann meine CPU in der VM das?
Nein. Das heißt, ich muss meine
VM erst mal wieder ausschalten.
Und in den
Settings nested Virtualisierung einschalten.
Sonst wird das nämlich nicht funktionieren.
nested Virtualisierung.
Okay.
Also, wenn ich eine VM
in einer VM starten will, dann geht das
nicht. Das geht nur, wenn man nested
Virtualisierung einschaltet. Also falls ihr irgendwann mal
Probleme habt und euch
fragt, warum ihr in eurer VM keine
VM starten könnt, dann liegt das höchstwahrscheinlich
daran, weil keine nested Virtualisierung
eingeschaltet ist.
Normalerweise braucht es ja auch niemand.
Habt ihr schon mal VMs in einer VM laufen
lassen und
wenn ja,
warum? Okay.
Virtualisierung ist enabled.
Proxmox Test Setup. Ja, verstehe.
Dafür ist es sinnvoll.
Auf jeden Fall.
WSL. Ja gut, WSL.
WSL ist
doch keine nested Virtualisierung.
Es sei denn, du hast Windows in der VM und dann WSL.
Zu schauen, wie scheiße die Performance ist.
Die Performance ist nicht gut, aber so
ist ja eh die Scheiße, dass es unbenutzbar ist.
Ist es gar nicht.
Es geht sogar halbwegs.
So.
Geht
mein KVM denn jetzt?
Was ist denn das hier mit J?
No hypervisor options
found. Okay.
Habe ich kein QEMO? Da muss ich mal kurz
gucken, wie installiert man den ganzen Krempel?
Okay, war das klar?
Nein, nein, nein, nein.
Moment.
Was muss ich denn installieren?
QEMO? KVM?
Hm. Wie heißt denn das Package,
was ich da...
QEMO Full vielleicht? Gibt es?
Okay. Ja, ja.
Hau drauf. Gib ihm.
So.
Hoffen wir mal, dass ich
jetzt ein funktionierendes...
Ah, jetzt funktioniert es.
Okay. Jetzt kann ich VMs starten.
Alles gut.
So. Dann muss ich mich
wahrscheinlich noch in die libvirt Gruppe
packen.
User add libvirt
glaube ich zumindest. Sonst darf ich von mir
aus nicht darauf zugreifen.
Wobei, brauche
ich das überhaupt?
Add connections
user session. Okay.
Ach ja.
Okay. Das testen wir jetzt mal.
Debian Cloud
Image Download. Wir gucken mal, ob
die VM in der VM funktioniert.
Bullseye Latest.
Klingt eigentlich ganz gut.
AMD 64
QCow
Image. Genau das brauchen wir.
Debian 1 Generic.
Cloud Generic.
Wunderbar. Gib ihm.
So. Schauen wir mal, ob meine VM lokal
funktioniert.
Mit dem Wirt Manager. Wie gesagt,
das, was ich hier jetzt mit dem Wirt Manager
mache, das will ich
über die KVM
oder die libvirt API machen.
Das muss man über irgendwelche C-APIs
aufrufen. Das wird ganz aberhandig gleich.
Aber dann sehen wir auch, ob
die Kompilierung von .NET was taugt,
wenn das alles funktioniert. Falls
ich überhaupt was auf die Reihe kriege.
So.
Ja, ja. Local Install
Media. Boah, wie geht
denn der Kram? Ich benutze das eigentlich
nie. Download.
Debian.
Select. Ja, Linux.
Linux 20
2020.
Perfekt. Das wollte ich schon immer haben.
Zwei. Eine
CPU reicht. 1024 MB
reicht auch.
Storage.
Ja. Perfekt. Wunderbar.
Alles klar.
Finish.
Ok. Funktioniert.
Funktioniert.
Also ich meine,
die VM bootet nicht,
aber die VM startet. Das reicht.
Das reicht mir eigentlich schon.
Das ist kein ISO. Du hast Recht.
Das ist kein ISO. Das ist ein komplettes
VM-Image. Ok. Aber
die VM startet. Das ist das Eigentliche, was
ich haben will.
Delete.
Funktioniert. Gut. So.
Und jetzt gucken wir mal, wie wir das
über die API machen können.
Das wird
was.
Das wird was.
Lib wird
API.
Documentation.
Oh, jetzt wird es abartig.
Äh.
API-Reference. Excellent.
Ok.
Ähm.
Domain. Aus irgendwelchen Gründen
nennt sich eine VM in KVM Domain.
Ich weiß auch nicht, warum.
Es hat nichts mit DNS und so.
Ach du Scheiße.
Alter.
MonkaW. Ok. Ich gebe zu,
ich habe im Vorfeld schon ein bisschen gespickt.
Ich weiß ein bisschen, nach was ich gucken muss.
Connection gucken.
Äh. Ne. Nach Connect
muss ich gucken.
Wenn ich das, wenn ich das richtig in Erinnerung habe. Connect.
Hier. Connect.
Connect.
Aha. Nope.
Wird nicht connected. Wo ist das denn?
Also. Das funktioniert folgendermaßen.
Eine VM über die
über die Linux-API anzulegen.
Man muss
als erstes connect zu
libvirt.
libvirt ist dieses Ding, was
der Wirt-Manager auch verwendet.
Also keiner spricht direkt KVM.
Die sprechen alle über diese API-Schnittstelle damit.
Sondern man muss sich zu libvirt connecten.
Am Ende muss man
die Connection wieder closen.
Dann muss man
create-vm machen.
Wie auch immer.
Dann muss man aufs Netzwerk warten,
dass das Ganze funktioniert.
Und dann ist gut. Dann ist die VM wieder da.
GitHub Code Pile. Frag mal.
Okay.
Connect.
Also wie connecten wir uns zu libvirt?
Das funktioniert
so wie hier.
Man muss dann hier irgendwie so eine Connection
angeben.
qemo://session
Und
dann funktioniert das. Aber ich muss jetzt erstmal die richtigen
die richtigen APIs finden.
Das heißt auf jeden Fall connect.
So viel habe ich im Vorfeld schon raus
rausbekommen.
Oh.
Obvious.
Ja ich meine cringe wer das nicht weiß,
dass es qemo://systemsession ist.
Wo könnte das denn hier drinnen stehen?
Wo könnte das denn hier drinnen stehen?
Erstellst du gerade eine Linux-VM
in eine Linux-VM?
Richtig.
Wo ist das Problem?
Das ist dann zwar nicht mal blazingly fast,
aber schnell genug.
Host. Host muss ich bestimmt gucken.
Connect.
What the fuck man.
Highlight all.
Connect.
Hier das sieht doch gut aus.
Das sieht doch gut aus.
Wir connect.
Hört sich ein bisschen
Wir connect.
Das hört sich ein bisschen an wie
Jetzt fehlen uns bloß noch Carlos Matos.
Jetzt fehlen uns bloß noch Carlos Matos.
Ach es geht ja noch weiter.
Carlos Matos
from New York City, New York.
Hier.
Wir connect open.
Hier. Wir connect open.
Das brauchen wir. Alles klar.
IRQ shit.
Wir connect open.
So jetzt wird es spannend Leute.
Native C Funktionen
Native C Funktionen
aus .NET aufrufen.
Also.
Okay erstmal.
Okay erstmal.
Erstmal allow unsafe code.
Unsafe code wird das auf jeden Fall nicht funktionieren.
Unsafe code wird das auf jeden Fall nicht funktionieren.
DLL import.
So jetzt muss ich abgucken.
Ich muss abgucken weil
Ich hab mir im Vorfeld schon ein Beispiel
angeguckt und hab mir das hier
ins Notepad auf
auf dem anderen Bildschirm kopiert.
Weil sonst
plick ich da nicht durch wie das aussehen muss
der Aufruf.
So muss das aussehen.
Sekunde.
Ja so muss das aussehen.
Hab ich schon rausgesucht.
So muss das aussehen.
Obviously muss das so aussehen.
Also
cringe wem nicht klar ist
dass das so aussehen muss.
So und jetzt müssen wir nur noch diese C Funktion
irgendwie übersetzen in eine gültige
C Sharp Funktionssignatur.
Also das ganze muss
schon mal in extra Klasse rein.
Es gibt
wird C Sharp Bindings. Ne die gibt es nicht.
Hab ich im Vorfeld geguckt. Gibt es keine
gescheiten. Es gibt offizielle
Bindings. Die sind nur für .NET Framework.
Wer auch immer seriously mit
.NET Framework von Windows aus
libvirt verwenden will. Und der Rest ist outdated
und hat so Sachen wie Netzwerk
Infos und so nicht drin. Es gibt keine
gescheiten libvirt bindings. Leider.
Sonst hätte ich die tatsächlich genommen.
Okay. Wir connect
pointer return der. Das ist mir doch
egal was der return.
So. Wir connect open.
Das gibt
ein String. Das sollte der richtig hinbekommen.
Public
class
interop
dll import
unsave. Ne.
Achso method.
Okay. Public
static extern
wirste. Gut.
So. Das müsste
als Definition ausreichen um mich
connecten zu können zu meinem
lokal laufenden libvirt.
Jetzt bin ich mal gespannt. Gucken wir mal.
Also er return. Was returnt denn der überhaupt?
Was ist denn das?
Was ist denn das?
This should be called first to get a
connection to the hypervisor.
Ja das ist nice.
If name is null
default environment
environment will be used. Okay.
Pointer to the hype.
Jetzt gehts los mit pointer.
Was auch sonst logischerweise.
A pointer to the hypervisor
connection or null in case of error.
Alles
klar.
So.
Probieren wir mal aus.
Interop
connection open
qemo
doppelpunkt doppelpunkt
doppelpunkt slash slash slash
session. Warum?
Weil zu ist.
So. Und da kommt irgendeine ID zurück. Irgendein
Pointer. Wir gucken
jetzt mal ob das null ist.
Und wenn das null ist
ist es kaputt oder ist es gecrashed oder
wenn es eine Zahl ist dann funktioniert es. Hoffentlich.
Wo sind wir denn?
Repo
vmchamp
.net
Ja. Geh mal weg.
.net run
forcechamp
Es geht.
Glaube ich zumindest.
Es könnte auch ein Pointer
ins nicht sein.
Man weiß es nicht genau.
Es könnte auch
sonst wo hin pointen.
Ja .net 8 alpha ist raus.
Ist rausgekommen vor zwei Wochen.
Könnte auch irgendein int
im RAM sein. Random.
Okay. Wir haben.
Es sieht aus als hätten wir einen Pointer auf
irgendwas wo ich nicht genau weiß auf was.
Nehmen wir auch mal. Okay wir können
hier mal Mist eintragen. Das stimmt schon.
Ja geht dann
auch nicht. Dann meckert er wegen
irgendwelchen Rechten rum.
Was System. Auf System habe ich auf jeden Fall
keine Rechte. Ja tatsächlich.
Okay da gehts
da gehts kaputt an der Stelle. Wenn ich
irgendwas anderes eintrage.
Das sieht schon mal so aus als funktioniert das
ganz. Okay.
Weiter. Weiter im Text.
So. Connection. Connection
open. Wie erstellt man damit.
Achso. Jetzt brauchen wir das ganze natürlich noch für
Connection closed.
Ich predikte
einfach mal das es closed heißt.
Ich hoffe es heißt nicht stopp
oder sowas.
Und dann braucht das
hier.
Ach ne hier. Und dann braucht es
diesen Pointer um es wieder zu closen.
Also.
In Pointer.
Connection.
Schauen wir mal. Schauen wir mal ob das Connection herstellen
und schließen wenigstens funktioniert.
Close.
Con-ID.
So und wenn er jetzt nicht crasht.
Bin ich happy.
Er crasht nicht. Das sieht doch schon mal ganz gut aus.
Okay.
Nice.
Und jetzt.
Also wir können schon mal.
Wir können schon mal eine Verbindung herstellen.
Also halber Wirt Manager ist fertig programmiert.
Wir können eine Verbindung zu dem Wirt herstellen.
Das reicht.
Rest kommt von alleine.
Okay. Create
Domain. Ne. Fuck.
Aber ich bin ja auch
falsch. Ich bin ja auch
in Horus. Ich muss zu Domains. Create Domain.
Create Domain.
Fuck. Create.
Wie erstellt man jetzt
Vm?
Wir Domain create Linux.
Was?
Was zum?
Wir Domain create Linux.
Wir Domain create
XML. Wir Domain create
with fi-
Ach Domain create gibt es auch einfach.
Okay. Gucken wir mal was das macht.
Launch a defined Domain.
Ach ne. Moment. Ich hab ja nix. Ich hab ja nix
defined.
Launch a defined Domain. If the call is successful
it moves from the defined running domain. Ne.
Ne. Ne. Ne. Ne.
Domain create with
XML.
Wir brauchen
Wir Domain create XML.
Brauchen wir anscheinend.
Guck mal.
Launch a new guest domain
based on an XML description.
Die wollen uns quälen heute, oder?
XML shit.
Create
XML flags.
Was sind flags?
Arrays or supported
Wir Domain create flags.
Wir Domain post,
auto, bypass.
Okay. Juckt mich nicht.
Okay. Also.
Wir Domain.
Wir Domain create XML.
Alles klar. Kopieren wir das mal.
Das wird was.
Ich bin echt gespannt ob ich in der Lage bin
eine Vm zu erstellen über die
CAP.
So. Also.
Domain pointer kommt zurück.
Wunderbar, kann in Pointer bleiben.
So, wir Connection Pointer, ist richtig.
XML Description.
String XML.
Leute, wenn man das so macht, teilweise gibt es Memory Leaks.
Das ist aber nicht schlimm, weil die Anwendung startet und stoppt sich eh wieder und wird alles aufgeräumt.
Scheiß drauf, ob es Memory Leaks gibt oder nicht.
Unsigned Int Flex.
Flex.
Okay, das setzen wir mal auf 0.
Ich will eigentlich keine Flex setzen.
Jetzt ist nur die Frage, wo kriegen wir mal ein gültiges XML für eine VM her?
Interop.
Create XML.
So.
Connection ID von meiner LibWirt Connection.
Wenn man was wie macht, gibt es Leaks, wenn man so Native Funktionen aufruft und Managed Datentypen übergibt.
In dem Fall in die Richtung geht es.
Aber das ist...
Das ist dann problematisch, sollte das die andere Seite irgendwie freigeben oder sowas.
Also es gibt manchmal Probleme, wenn man Managed Datentypen hin und her schiebt.
Und da muss man genau drauf achten, wer wie wann wo was freigeben muss.
LibWirt DOM XML Example.
Okay, das ist sehr kurz und knackig.
Das ist sehr kurz und knackig.
Das probieren wir jetzt mal aus.
Okay, also.
War XML.
Jetzt können wir hier das neue String-Literal-Syntax verwenden.
So.
Okay.
Übrigens, da müsst ihr drauf achten.
Das kann ich euch an der Stelle nochmal kurz erzählen, weil da macht man sich Probleme und sucht danach ewig Fehler.
Also, das erinnert vielleicht ein bisschen an Python hier an der Stelle.
Das geht allerdings auch seit .NET 7, glaube ich, erst.
Oder 6 oder 7, ich weiß nicht.
Seit einem der allerletzten, recent C-Sharp-Version.
Dass man Multi-Line-Strings so mit dreifachen Anführungszeichen machen kann.
Es gibt noch mehr Varianten, wie man das machen kann.
Aber wichtig ist, die schließenden Triple Quotes, die müssen auf der Höhe stehen, wo euer Text in der Datei anfangen soll.
Wenn ich das so habe, wenn ich das hier so habe, dann...
Moment, hier ist es mal neu.
Wenn ich das so habe, dann landet es mit einem Text.
Und dann ist es mit einem Tab in der Datei.
Und je nachdem ist das dann vielleicht nicht gültig.
Also, bei XML jetzt egal, aber das kann durchaus sein.
Das heißt, man muss immer darauf achten, wo man hier die klausenden Triple Quotes platziert.
Weil ihr seht es ja hier auch an dem Blauen.
Das ist quasi die Baseline, wo es dann am Ende...
Ja, mit Jammel wird es dann Fehler geben, genau.
Das ist so die Baseline, wie es am Ende dann auch wieder rauskommt.
Also, da muss man gucken.
Also, man macht instinktiv es vorne, aber es ist falsch.
Es muss dort sein, wo der Text aufhören soll.
Weil, wenn ich die weiter einrücke, dann will er nicht.
Und sagt, das geht nicht.
Also, man muss das wirklich hier an der Stelle machen.
Das haben die in Rider auch gut gemacht, dass man hier so eine blaue Linie bekommt.
Okay, also, wir müssen ein paar Sachen generieren, dass man die vor allem anlegen kann anscheinend.
Good, gleich, good, new.
New?
So, dann setzen wir das mal hier ein.
Memory, ja, wunderbar.
Reine CPU, wunderbar, wunderbar.
Local Time, wunderbar, alles gut.
Emulator, User Bin, QEMO, KVM, wunderbar.
Source Files, wahr, lib, lib wird, Images, Demo 2, Image.
Latest, Moment.
Debian Cloud, hier.
Wir müssen mal kurz noch ein Debian Cloud Image runterladen, um zu gucken, ob das dann auch funktioniert.
Generic Cloud.
Copy Link.
WGET.
Schön.
32 Bit? Ach so.
Ja, hm, was muss man da einstellen?
Ich mein, ich kann es mal so lassen, es ist ja nicht...
Es sollte ja nicht davon...
Es sollte ja nicht davon...
...kaputt gehen, oder?
Wir können es doch einfach mal raus...
Ne, komm, wir machen Arch...
Ja, keine Ahnung, wie das aussehen muss.
X...
...86, 64 oder so?
HVM?
Was...
Was ist HVM?
Wir sollten uns mal so ein XML-File von irgendwo kopieren.
Die MAC-Adresse schmeißen wir raus.
So, ich muss gucken, ob mein...
...Network...
Ah, Mist, das Netzwerk ist noch gar nicht da.
Aber das ist jetzt erstmal egal.
Keymap, Graphics, Output brauchen wir nicht.
Target Device, HDA.
Äh, File...
...ist...
Ich bin mir gar nicht sicher, ob man das absolut angeben muss, aber wahrscheinlich.
Ja, also File ist Debian Image.
Bin ich mal gespannt, ob das funktioniert.
Alter, lul.
Ich hab ja so meine...
...so meine Zweifel, ob...
Moment.
Muss ich auch an der Stelle...
...QEMU...
...QEMU System...
...AMD64, wo ist das denn?
Ne, das ist irgendwo.
Ne, System X86 heißt das, glaube ich.
Hier, X86.
Das muss ich auch eintragen, sonst kann das an der Stelle auch schon mal nicht funktionieren.
Ja.
Okay, nice.
Jetzt bin ich mal gespannt.
Demo 2.
Ja, Demo 2 ist perfekter Name für die HVM.
Alles klar.
Okay, dann probieren wir das mal aus, ob er die HVM jetzt erstellt.
Da...
Im Leben nicht, Alter, im Leben nicht.
XML.
Okay, gib ihm.
Run.
Network not found.
No network with machine...
...with matching name default.
Ja.
Toll.
Ähm, warum, warum nicht?
Wir lassen Network...
Aber das Netzwerk brauche ich ja spielen.
Wir lassen das Network einfach mal weg zum Ausprobieren.
Not let's run.
Die VM läuft.
Die, die geht einfach.
Okay, wir wissen nicht, ob sie geht, weil wir haben keine grafische Ausgabe, aber...
Moment mal, ich, ich delete das nochmal.
Ich delete das nochmal.
Wo war das jetzt mit dem VNC?
Wo war das jetzt mit dem VNC?
Ich hab doch irgendwo ein VNC gelöscht.
Graphics.
Hier, VNC kommt da unten nochmal rein.
Dass ich, dass ich auch was sehe.
Run.
Run.
Run.
No boot...
No bootable device?
Okay, die VM erstellt das schon mal und jetzt?
IDE-Disk.
Äh, nee, das wird so wahrscheinlich nix.
Okay, delete.
Ihr habt recht.
Ich, ich, ich kopiere mir hier eine raus.
Was hier?
Zack.
Wird, wird install.
Example.
Wird install.
Okay, gut, hab ich drauf.
Ähm, also, ich hab KVM-Install-Github, ja, ich verwende aktuell bei mir lokal so dieses
Bash-Script vom Geo-Torres, um mir ab und zu lokal Test-VMs anzulegen.
Das geht sehr zackig und sowas könnte man ja auch mal in C-Sharp bauen.
Allerdings kann man uns da abgucken, wie wird, wie wird install funktioniert?
Nämlich so.
So.
Also.
Wird install.
Graphics-Options brauchen wir nicht.
Graphics-Options brauchen wir nicht.
OS-Variant.
Hm, bin ich mir unschlüssig, was da rein muss.
Äh, Network-Options.
Disk-Options.
Äh, ey, da kann man uns gar nicht mehr nix so zusammen reimen gerade.
Shit.
Okay, wir müssen das, wir müssen das anders machen.
Wir müssen hier eine VM erstellen.
Test.
Also, Create-New-Virtual-Machine.
Manual-Manual-Install.
X8664-VM.
Äh, Linux.
2020 soll da Kram.
Oder Linux, ja, Generic-Linux, wunderbar.
Ja, meinetwegen zwei CPUs.
Select-Create-Custom-Storage.
So.
Und da wollen wir jetzt an der Stelle haben.
Wo hab ich das runtergeladen?
Repos.
Repos.
Repos.
Repos.
Repos.
Repos.
Repos.
Repos.
Repos.
Repos.
Repos.
Repos.
Repos.
Repos.
Repos.
Repos.
Genere Cloud-Image.
Network-Section.
User-Mode.
Bridge.
Bridge-Device.
Was haben wir denn da?
Hab ich, hab ich ein VIA, VIA-0 oder sowas?
VIA-BR.
Sudo.
Legt er nicht standardmäßig ein Netzwerk-Interface an?
Was ist doch hier?
Default.
Warum ist das inactive?
Was ist da los?
What?
Unable to find DNS-Mask.
Was der alles haben will.
Was ist das?
Was ist das?
Was ist das?
Was ist das denn?
DNS-Mask.
Gib ihm.
Nice.
DNS-Mask.
Auch drauf.
On-Boot-Active.
Apply.
So, jetzt sollten wir, jetzt sollten wir einen Virtual-Interface.
Okay, VIA-BR-0 wollen wir haben.
VIA-BR.
Wobei, oder, oder einfach Default.
Jetzt bin ich mal gespannt, ob das bootet, Alter.
Okay.
Bam.
Debian bootet schon mal.
Poggers.
Aber Debian, ich hab keinen User und sonst was gesetzt.
Das muss ich über Cloud.
In den später machen.
Aber Debian bootet.
Ich bin, ich bin begeistert.
Das heißt, hier können wir uns gleich die VM schon mal crappen.
Also das XML von der VM crappen.
Und mal gucken, ob sich das nach IP zählt.
Das ist eine Nested-VM, ja?
Das ist eine Nested-VM.
Wir testen auch gleich mal, wie viel Nested-VM ich abkann.
Wie viel da geht.
Okay, das sieht, das sieht, sieht doch eigentlich alles ganz gut aus.
XML.
Boah.
Alter, was hat der hier denn alles?
Zieht es sich, zieht es sich in der IP?
Äh, sieht nicht so aus.
Sollte das nicht gehen.
Naja, weil das sehr, äh, ja, wackelig aussieht alles.
Ey, da zieht sich so, so kein.
Wahrscheinlich habe ich keine Rechte auf die, auf das Interface.
Die meisten Prozessoren schützen das nicht mit Nested-Virtualisierung.
Doch, das kann so gut wie jede moderne CPU.
Nested-Virtualisierung.
Du musst es in den VM-Settings einschalten.
Aber Nested-Virtualisierung geht einem schon lange.
Was macht eine Nested-VM?
Die macht das gleich wie eine normale VM, nur dass sie selbst wiederum in einer VM läuft.
Also guck, ich habe Linux in einer VM laufen und in meiner VM habe ich ein weiteres Linux laufen.
Okay, das mit...
Brrr, CTL, Show.
Okay, da sind schlicht und klar keine Interfaces dran.
Wahrscheinlich habe ich keine Rechte.
Wahrscheinlich, ich gehe davon aus, dass ich keine Rechte habe.
Kann ich, kann ich vielleicht...
Wir...
Brrr, Null-Netzwerk-Interface machen.
Okay.
Testen wir mal.
Shutdown.
Force-Off, ja, ja.
Weiter.
Put a VM in my VM, genau.
Natürlich, kein VM while I am VMing.
Party, dankeschön für den Sub.
Was ist der Vorteil von einer VM in einer VM?
Naja, für die VM selber nix.
Du kannst es allerdings von dem System managen, was du in der VM betreibst.
Was ganz praktisch ist.
So, jetzt bin ich mal gespannt, ob der sich jetzt hier was zieht.
Aha, schon hängt ein Interface an meiner Bridge dran.
Interessant, interessant.
Jetzt kriegt er auch eine IP.
Pog.
Okay, das funktioniert schon mal.
Das finde ich nice.
Ping.
Ping tut die VM auch.
Ich habe kein Login, aber das XML können wir uns crappen.
Das ist Pogas, das XML, das brauchen wir.
So, delete.
Delete.
Alles klar, das XML nehmen wir.
Jetzt, perfektes XML.
Nice, so XML.
Alter, ist das viel.
Alter, ist das viel.
What the fuck.
MonkaS, da muss die Hälfte raus von.
Da muss die Hälfte raus von.
WCF, das hört ja gar nicht mehr auf.
Okay, was haben wir hier?
Generic Linux, hier, das.
Da muss wieder meine ID rein.
Great.
Memory.
Memory.
Nee.
Bytes to Gigabytes dürften genau.
Ach nee, nee.
Gibi?
Nee, Gibi?
Äh.
Das ist ein.
Peter Byte?
Was?
Aber warum?
Was?
Nein, nein, nein.
Ja, ja.
To Megabyte.
PMB?
Nee.
Ach, Moment.
Nein, das ist ein Unit Kilobyte.
Ah, nee, nee, nee, nee, nee.
Okay, das sind, das sind, das sind.
Kilo.
Kibi, Kibi Byte zu, zu Megabyte.
Also, das zu Gibi.
Heißt die Gibi?
Gibi?
Ja, okay.
Also, 4 Gigabyte.
Sehr, sehr gut.
So, das heißt, wenn ich einfach nur, sagen wir mal.
Wenn ich, wenn ich das Ganze nur in 500, das reicht ja.
Als erstes Mal.
Man muss ja jetzt übertreiben.
Okay, wunderbar.
Man kann die Unit anpassen, wahrscheinlich schon, aber so ist, ist okay.
Was Memory, Current Memory?
Ach so, naja, das interessiert mich nicht.
Static, V, was, V, Out CPU, Placement, Static, 1, reicht.
Boot Device, HD, das klingt, sieht doch, sieht doch ganz gut aus.
Features, ja, wunderbar, genau.
GPU, was, CPU Mode, Host Model, was, wie, ne, Host, was, Host, Pass to Check None, My Creatable On.
Kein Schimmer.
Okay, gut.
Clock, yep, yep, Clock.
Power of Destroy, PM, Devices, okay, jetzt, jetzt, jetzt interessant, Devices.
Emulator.
Disk.
Okay.
Hier ist mein Image drin, Controller Type, USB, ne, das, würde ich sagen, brauchen wir, wobei, scheiß drauf, ich pass da einfach nix, ich pass, ich pass einfach nix dran an, ist doch, ist doch egal, ich, ich lass es einfach, komm, alles gut so, wir, wir lassen es einfach.
Das Einzige, was ich ändern muss, ist die MAC-Adresse von, die schmeißen wir einfach raus, in der Hoffnung, er generiert da eine neue.
Was da alles drin ist, man.
Ich lass es einfach so.
Ich, ich lass es einfach so.
Okay, und jetzt kriegen wir ne VM, Run.
Zack.
Da ist ne VM.
Und warum heißt das Linux 2020?
Weil, ah, weil ich den Namen nicht geändert hab.
Der Name muss ja, keine Ahnung, VM Name gleich Test VM.
Irgendwie so.
So.
So.
Das scheint zu funktionieren.
Ich bin, ich bin begeistert.
Und wenn ich das jetzt erstelle?
Dann heißt es auch Test VM.
Das ist ja extrem, extremly nice.
Ne, ne, ne, so einfach ist das nicht.
Wir können uns aber mal die, die, die Publish Size zwischendurch angucken.
So, so einfach machen wir das der ganzen Sache ja hier noch nicht, ja.
Weil ich kann mich ja da beispielsweise per Netzwerk gar nicht drauf einloggen.
Guckt mal.
Das Ding zieht sich zwar an der IP, aber das Ding zieht sich zwar an der IP, aber das Ding zieht sich zwar an der IP, aber das Ding zieht sich zwar an der IP, aber das Ding zieht sich zwar an der IP, aber das Ding zieht sich zwar an der IP.
Aber ich wette mit euch, SSH, SSH Login ist nicht möglich.
Ne, ne, ne, ne.
Da brauchen wir jetzt noch einen Cloud Init File, was wir rein, ranhängen oder so.
So, aber löschen wir erstmal die VM.
Ja.
Exzellent.
Und mal gucken, wie groß das Ganze jetzt ist.
Publish.
Das dürfte noch nicht sonderlich groß sein.
Wir haben ja keine zusätzlichen Libraries drinne und sonst was.
Ja, aber wenn man das jetzt.
Was?
Sag mal.
Was genau geht mit meinem Terminal da ab?
Immer noch 1,8 MB groß.
Ja, das ist doch nicht schlecht.
Das ist Rider.
Ja, richtig.
1,8 MB.
Ja, wir haben ja auch noch nichts ernstzunehmendes gemacht.
Boah, ist das ein abartig fettes, großes XML, Mann.
So.
War das Hello World nicht 1,9?
Gute Frage.
Weiß ich nicht mehr.
Kann schon sein.
So, also wir haben ja mega hässliches XML, Interop mit C.
Die Datei ist immer noch klein.
Das ist schon mal nice.
Jetzt müssen wir noch mal ein paar andere Sachen ausprobieren.
Wir machen jetzt noch mal ein paar Libraries dazu, damit man einfach mal sehen, ob, wie schnell das größer wird.
Wir machen mal ein bisschen farbige Konsolen Ausgabe.
Weil wer will keine farbige Konsolen Ausgabe beim VM erstellen?
So.
Markup.
Ah, wir müssen noch warten, ob das Netzwerk...
Wir müssen warten, wenn die VM richtig hochgefahren ist und das Netzwerk ready ist.
Ja, das müssen wir natürlich noch machen.
Markup, Interpolated, was auch immer.
Markup.
Markuplein.
So.
In...
In...
In...
Gelb.
Starting-VM.
Vm-Name.
So, jetzt kriegen wir das in Gelb.
Richtig advanced aus, langsam.
So, jetzt ist das Binary garantiert viel fetter.
Könnte ich wetten.
Weil jetzt ist noch Spectre-Console dabei.
Das ist eine recht, recht fette Library.
Bild.
Hä?
Schon 3,8 MB groß.
Schon 3,8 MB groß.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Genau.
3,8 MB groß.
Es wächst.
Aber es ist immer noch komplett im Rahmen...
Ich mein...
Was sind...
Was sind 3,8 heutzutage?
Easy.
Ist doch kein Problem, oder?
Ich mein, also...
Ne Go-Anwendung ist jetzt auch nicht soo viel kleiner.
Ich weiß nicht.
Habt ihr mal den Plan von euch?
Wie groß ist eine Hello World Go-Anwendung?
Manchmal-.
Wahrscheinlich auch ungefähr in dem...
...Kram...
...Irgendwie 2 MB oder sowas, ja.
1,2 MB...
das sind log files größer ja das stimmt so wie kriegen wir denn jetzt raus ob die vm eine
gültige ip hat da gibt es doch bestimmt irgend irgendwelche c functions wieder so suchen wir
einfach mal hier ip address ok wir domain ip address wie du mein ip address das was ist das
pc connect als weil ja wenn schon mal das hier mit was haben wir denn hier wir domain interface
addresses okay das ist das ist ein pointer zur vm das ist ein was ist das denn
ein array pointer auf dem array herr sowas in der richtung an sein source flex oh jetzt wird
es eklig jetzt wird es eklig ok auf geht's wie kriegen wir hier die wie kriegen wir jetzt hier
die ip von der vm raus also das ganze ding als schon mal wir domain interface address
ob wir es lieb wie soll es so anders heißen dann
haben wir ein in pointer und das ist halt die vm die domain heißt das bei
denen immer so dann brauchen wir ein vier domain interface pointer auf
pointer auf pointer und mein ist das ist das ein triple pointer oder was ein ein
pointer zu einem pointer der auf den potter will ich nicht aus für wenn schon
muss das über die api gehen welche klippe und manager benutzt du das ist
green clip mit rufi integrationen ok wir machen wir machen wir die
unstrittigen teile an sein int also wir brauchen hier irgendwie so ein schritt
wo ich auch keine ahnung wie man das ganze abbilden aber zeilen umbruch
zeilen umbruch zeilen umbruch und dann brauchen wir sonst und flex flex
laufenden
lassen wir auch auf null ok wie kriegen wir diesen krempel dahin interfaces
wir domain interface pointer wir domain interface das ist das ist wirklich ein
triple pointer ein pointer auf den pointer der auf den point als acht du
große scheiße man ok jetzt haben wir das das truck ok dann brauchen wir uns truck
truck
ich ahne schlimmes public an safe truck so keine charakter wir wollen das als
beide haben
ein an public public moment ich muss das kann man weg machen so also hardware
address nächste ist hat wird das wahrscheinlich die mac oder sowas in der
richtung
interfaces sein sind addresses ich ahne schlimmes und dann haben wir
als letztes einen weiteren point of point
trocken
26
ok damit Agriculture
setzt uns erstmal nicht weiter auseinander gucken ob bis dahin
funktioniert
Ebola
ja sage man network.
ーshore house int legion
ちょっと want to talk again log ao health information
Kirsty bless das kommt zu hause ab think you know i already get out eat or die ab so the other day you j grill too much sagt mir okay man aber oh das könnte man mal ich moderator oder ich sehr vieleics habt ihr auch in Evennet field계ac undo check it i loft audience about the entrepreneur trial and do you think about that chat lief er nach der Dig because of the bahms Pods network DHCP lies also sachter
so und das heißt jetzt wie zum teufel muss das hier sein das sind interfaces pointer auf was
hat er hier für schmerzen an das ganze ding ist an safe mann an safe pointer auf pointer
auf pointer fragt man ok kommt an safe auf geht's ja in pointer auf die domain ok create
xml das gibt glaube ich eine id zurück stimmt das gibt eine id zurück ja das war was man dann
wiederum braucht um auf das andere zu zeigen ok domain kommt mich jetzt einfach vor mld
da weiß ich wenigstens was gemeint ist ok interop wisst ihr wisst ok wir haben noch
eine vm mit ip laufen das ist perfekt ach nee wir müssen ja neu erstellen sonst klappt's ja
nicht das ist mega sas hat um nicht zu sagen hypersas ich löscht es mal weil um die vm id
rauszukriegen müssen wir die vm erstellen sonst krieg ich die id nicht mehr raus und das ist
dieses keine richtige id das ist ein pointer das heißt dass nachdem das pointer ausgelöst
ist oder gesagt wird oder so muss ich einfach den pointer auswählen also ich schau aber
ich muss mal genau gucken was ich da drauf hab ich das hier drauf jetzt noch mal ich
muss alles hier drüber ach ich bin nicht sicher wie ich hier alles drüber angeblieben
hab und ich muss alles jetzt einfach an der struktur auswählen ja der pointer auf das
ist nicht wie es eigentlich passiert okay ich mach jetzt mal so du kannst hier ein
tällатель oder so was zählen hier für die interop in dem fall also ich hab jetzt mal
ein pointer auf pointer auf monga w ich halte hier 내가 ich halte ingen an ich halte hier
das ist eigentlich oder ich habe das bei von von dem wem ich hier auch nur die man momentan
Was ist denn jetzt? Ah, hier Null.
Ah, ne, das ist nicht so.
Ah, wir Interface.
Unsafe.
Weil es nicht.
Und jetzt?
Ne.
Doppel, Doppelpointern muss ich.
Inter, und jetzt?
Und?
Adresse auf
Interfaces.
Okay.
Und dann
Source Null flaggen.
Ich hoffe mal, dass Source Null ist.
Was ist denn Source?
Source ist
Source.
Source ist
Leases. Das klingt doch gut.
Agent oder Arb.
Ach du Scheiße.
Warum geht es jetzt nicht?
Weil
Inter... Moment, ist das?
Das ist ein Triple Pointer.
Seht ihr das?
Triple Pointer.
Also ich muss quasi hier sagen.
Pointer, Pointer.
Ach du Scheiße, man.
Was ist das denn?
Seriously?
Pointer, Pointer.
Das funktioniert.
So.
Und das soll jetzt gehen, oder was?
Pointer Champ.
Ja.
Pointer Champ. Ja.
Was returnt denn das eigentlich?
Was mache ich?
Ich versuche eine VM zu erstellen über die CAP unter Linux.
Was prinzipiell funktioniert.
Aber jetzt will ich rausbekommen.
Okay, das ist ein Count quasi.
N.
N ist immer die beste Bezeichnung.
Da weiß man Bescheid.
Okay, hier haben wir die VM-ID.
So, und das müssen wir jetzt
in der Schleife machen, Leute.
Weil, das braucht hier eine Weile,
bis die True
Await
Oh, Moment.
Awaiten kann man nicht
in Unsafe, oder?
Natürlich. Natürlich kann man nicht
kann man keine Await machen in Unsafe.
Das ist natürlich klar.
Also müssen wir den Klassiker rausholen.
Threat, Sleep.
Für eine Sekunde.
Und dann probieren wir das Ganze nochmal aus.
Bin ich auch mal gespannt.
Run.
Okay.
Noch haben wir keine IP.
Noch haben wir keine IP.
Noch keine IP.
Keine IP.
Jetzt haben wir eine IP.
Äh.
Das interessiert ihn aber nicht.
Das ist dem ziemlich egal.
Na gut.
Abbrechen.
Das probieren wir mal aus.
Auf der Shell.
Wie geht denn das?
Domain Interface.
Adress. Ja.
Alter, meine Shell ist übelst kaputt.
Was ist denn das für ein Kack, Mann?
Requires Domain.
Achso, ich habe jetzt gar keine VM mehr angelegt.
Doch, doch. Habe ich noch.
Test-VM.
Mit der offiziellen
Kommandozeile
findet man auch keine IP.
Warum das denn?
Special Hyper Secrets IP?
Oder wie?
Was ist ein Pointer?
Also das Konzept an sich
ist relativ simpel.
Insgesamt
schießt er dir aber relativ schnell in den Fuß.
Also ein Pointer ist eine Kombination
aus zwei Sachen.
Ein Pointer ist einmal
die Arbeitsspeicheradresse
wo etwas liegt
und die Typinformation
was an dieser
Speicheradresse liegt.
Also wenn du die Information hast
ein
16 Bit
Int liegt an
dieser Speicheradresse
dann kannst du das auslesen.
Du gehst zu dieser Speicheradresse hin
und weißt du musst 2 Byte
auslesen beginnend
an der Pointeradresse
dass du dein 16 Bit
dein Int 16 bekommst.
Also ein Pointer ist nicht wirklich nur ein Zeiger
auch wenn sich das immer so anhört.
Ein Pointer ist die Kombination aus
Speicheradresse plus
Typ.
Wollt Pointer außen vor
das sind nur Pointer.
Ja wenn du sowas hier hast in C
dann ist das die Information
ähm
es ist ein Int
was dort im Speicher steht
also die Speicheradresse
plus die Typinformation.
Und nun?
Jetzt hast du mehr RAM.
Ohne RAM zu downloaden.
So also
noch nicht mal die offizielle
das offizielle
Kommandozeilentool kriegt das raus.
Was kann man hier hinten noch?
Source angeben. Lease.
Das ist das was ich gerade mache.
Was haben wir sonst noch zu bieten?
Agent. No Agent. ARP.
Aha! ARP funktioniert.
Ok. Warum auch immer.
Ich wills gar nicht wissen.
ARP ist
Magic 2
Ok. Alles klar.
Also muss ich hier Source 2
reinschreiben.
Und jetzt probieren wir das ganze nochmal.
Delete.
Run.
Ups.
Ja ja. Nein nein 2.
Run.
Bam.
Was passiert dann wenn ich meinen
Pointer hin und her caste?
Dann sagst du
du weißt es besser als dein Compiler.
Du sagst ihm ey
an dieser Stelle ist gar kein Int
sondern eigentlich ein
anderes Ding.
Das muss nicht zwangsläufig so sein
aber das kannst du ihm sagen
dass du das besser weißt.
Wenn du einen Pointer ohne Typ
Informationen hast dann musst du es sogar machen.
Und was ja in C relativ
Oh was ist das?
Was ist das?
Wait a minute. Der erkennt das es
eine IP hat. Pog.
Das geht einfach.
Stellt euch das mal vor.
Das muss man den Linux Leuten
ja echt lassen.
Das sieht immer abartig aus.
Weil du halt irgendwelchen
C Interop machen musst.
Aber unterm Strich
funktioniert es meistens einfach.
Natürlich
kannst du dir bei jedem Schritt
selbst in den Fuß schießen.
Aber es funktioniert meistens
einfach.
Und die Dinger sind ja recht gut zu bedienen
auch. Kann man nichts sagen.
So und jetzt.
Und jetzt ist die Frage.
Wie kann ich
jetzt auf meine Interfaces zugreifen?
Also wenn ich jetzt
ein Interface gefunden habe.
Dann müsste ich doch eigentlich sagen können
Interfaces
0. Weil ich habe ja
mindestens eins gefunden.
Interfaces 0.
Und dann number of addresses ausgeben.
So.
Wie wird die VM erstellt?
Also woher weiß der welches Image?
Hier her.
Weil ich ein riesen fettes ekliges XML habe.
Wo das alles drin steht.
Wo man die Hälfte wahrscheinlich entfernen könnte draus.
Muss ich auch mal gucken.
Wie man das XML vielleicht.
So viele PCI und Serial und so.
Brauche ich. SATA brauche ich alles gar nicht.
Oh was jetzt?
198?
Was habe ich jetzt
verkehrt gemacht?
Ah ich kann nicht drauf zugreifen logischerweise.
Ich bin ja auch doof.
Ich kann nicht drauf zugreifen solange es noch nicht angelegt ist.
Ok das ist natürlich klar.
Das kann nicht funktionieren.
Also muss ich checken ob das
Kann man nicht einfach 0 check machen?
Ne.
Ich muss einfach check if
n größer 0.
So und nur dann mache ich das.
Ansonsten warten wir ab.
Auf geht's.
Let's go.
So.
Wir sollten jetzt gleich die IP Adresse sehen.
Sobald er hier eine IP Adresse bekommt.
Bin ich gespannt.
Number of address is 1.
Ok der kann sogar die Adresse da raus holen.
Nicht schlecht.
Nicht schlecht.
Wir machen das mal alles auf dem Desktop hier.
Sonst müssen wir so viel hin und her switchen.
So.
Eigentlich könnten wir gleich noch ein delete hinterher machen.
Wobei er dann das Image wahrscheinlich auch löscht.
Wobei er dann das Image wahrscheinlich auch löscht.
So.
Und jetzt muss ich die Adressen da raus holen.
Wie hole ich die Adressen da raus?
Wie hole ich die Adressen da raus?
Wir Domain Interface.
Wir Domain IP Adress Pointer.
Wir Domain IP Adress Pointer.
Wir Domain IP Adress Pointer.
Hier.
Das brauche ich auch noch.
Als Struct.
Public unsaved Struct.
Wir Domain IP Adress.
Wir Domain IP Adress.
Wir Domain IP Adress.
So machen wir das mal weg.
Also.
Was brauchen wir denn hier jetzt?
Wir brauchen ein Typ.
Wir brauchen ein Typ.
Das ist ein Int.
Das ist ein Int.
Ein Typ.
Die Adresse als String.
Als Byte.
Ist wahrscheinlich sinniger.
Und dann ein Prefix.
Als unsigned Int.
Als unsigned Int.
So.
Und davon wollen wir jetzt ein Array haben.
Und davon wollen wir jetzt ein Array haben.
Das ist sowas.
Ich blick nicht mehr durch.
Wo muss man hin?
Das ist dann ja sowas hier.
Ein Pointer.
Auf.
Das Start Element von einem Array.
Das ist dann ja sowas hier.
Ein Pointer.
Auf.
Das Start Element von einem Array.
Ich bin mir nicht sicher ob ich sowas machen darf.
Ob er das dann richtig erkennt.
Okay, so.
greifen da jetzt einfach drauf zu scheiß drauf addresses und davon die erste und davon dann die
moment das ist ein byte wie bekomme ich aus einem byte array einen string geht das
gescheit ein null terminiertes byte array zu einem string wie funktioniert das in c sharp
gescheit irgendwie sowas hier ne encoding utf 8 ich hoffe mal dass du dir was get string und
dann vom beiz aber da brauche ich ein byte count shit woher weiß ich denn woher weiß ich okay na
ip-adresse ist einfach 8 irgendwas nicht wirklich aber die ersten wir machen einfach mal die ersten
acht charakters das ist dann quasi 192 punkt 168
punkt also dass der anfang von der ip müsste ich dann zumindest sehen hier jetzt habe ich den wird
manager geschlossen ich nur okay jetzt jetzt crash wahrscheinlich gleich so der holt sich
jetzt eine ip die vm muss erst ein bisschen dauert auch ein bisschen bis sie startet und
alles funktioniert oh nee das war ein zeilenumbruch problem hier es geht
einfach aber wie kriege ich das ist das problem ist nicht gelöst wie kriege ich ein null terminierten
string ag da muss das der overflow fragen weit weiter 0 terminated to string da gibt es doch da
gibt es auch bestimmt chat gpt fragen das kriege ich auch ohne chat chat chat gpt da gibt es doch
bestimmt irgendein irgendein trick da gibt es doch bestimmt irgendein trick wie man das wie man das
also das ist ein utf 8 string höchstwahrscheinlich ein null terminated utf 8 string und das will ich
in den c sharp string ach ja übrigens nur mal so ich ich zeige euch mal was weil ihr weil ihr
vielleicht mal das problem haben könntet man denkt sich jetzt ja so als würde ich jetzt mal das problem
haben könnte man denkt sich jetzt ja so als würde ich jetzt mal das problem haben könnte man denkt
sich jetzt ja so als würde ich jetzt mal das problem haben könnte man denkt sich jetzt ja so an der stelle gucke mal warum nehmen wir nicht charakter könnte man sich ja denken warum nehmen wir nicht charakter weil es ist es sind es sind ja sind ja buchstaben und jetzt machen wir mal passt mal auf new string weil das ist dann relativ einfach dann darf man das direkt null terminiert reinmachen und jetzt machen wir mal passt mal auf new string weil das ist dann relativ einfach dann darf man das direkt null terminiert reinmachen und jetzt machen wir mal passt mal auf new string weil das ist dann relativ einfach dann darf man das direkt null terminiert reinmachen und jetzt machen wir mal passt mal auf new string weil das ist dann relativ einfach dann darf man das direkt null terminiert reinmachen und jetzt machen wir mal passt mal auf new string weil das ist dann relativ einfach dann darf man das direkt null terminiert reinmachen und jetzt machen wir mal passt mal auf new string weil das ist dann relativ einfach dann darf man das direkt null terminiert reinmachen und jetzt machen wir mal passt mal auf
So, was meint ihr, was jetzt passiert?
Sieht doch jetzt eigentlich richtig aus.
Ich kann euch sagen, dass es nicht funktionieren wird.
Glaube ich zumindest.
Es gibt einen schon Skid an.
Was sonst?
Was sonst?
So, also ich könnte wetten, dass es nicht funktioniert.
Dass es abkackt oder sehr merkwürdige Zeichen ausgibt auf der Kommandozeile.
Ja, macht es.
Es funktioniert nicht.
Und mein Terminal sagt, es kackt gleich ab.
Jaja.
Tja, Chad, warum funktioniert das nicht?
Es ist ein Null-Terminated-Character-Array.
Das ist schon richtig.
Aber warum geht das nicht?
Also sprich, warum ist das hier so nicht möglich, obwohl das doch ihr Charakter ist?
Das liegt daran, was ist das, was ich euch zeigen wollte?
Das liegt daran, weil ein Charakter in C-Sharp nicht ein Byte ist.
Normalerweise ist ein Charakter, zumindest in C ist das so.
Ist ein Charakter gleich ein Byte.
In C-Sharp nicht.
In C-Sharp ist ein Charakter.
Chad, wer weiß es?
Wie viel Byte hat ein Charakter in C-Sharp?
Pausierungschamp?
Wer ist High IQ und wer ist es?
Vier?
Ne, fast.
Sixty-nine?
Fast richtig.
Sechzehn?
Ne.
Du bist mit sechzehn aber schon mal nicht verkehrt.
Es sind bloß nicht sechzehn Byte.
Es sind zwei.
Richtig.
Es sind zwei.
Zwei.
Es sind zwei Byte.
Es sind sechzehn Byte.
Es ist quasi UTF-16, wie C-Sharp intern arbeitet.
Warum?
Das weiß nur Microsoft.
Historisch, weil das wahrscheinlich vor der Erfindung von UTF-8 war.
Ja.
Das sind sechzehn Byte.
Deswegen funktioniert das nicht richtig.
Deswegen funktioniert das nicht richtig.
Deswegen muss ich explizit sagen, hier guck mal.
Das ist ein Byte.
Und jetzt muss ich mir überlegen, okay.
Wie bekomme ich denn, bitteschön, aus diesen Bytes, aus diesen UTF-8 Bytes, jetzt ein C-Sharp-String?
So, wo ist die John Skeet-Antwort, Leute?
Fastest way to convert a possibly null-terminated ASCII Byte to String.
Ja, Moment.
Das ist, das ist, das zählt nicht.
Das, das zählt nicht, weil da ist, das ist ja schon im Array.
Und im Array.
Ist ja schon eine Längen-Information drinne.
Es muss.
Zweite oder dritte Antwort?
Nope, das stimmt nicht.
Das, das bringt nix.
Das, das bringt nix.
Das geht so nicht.
Ich mein, eine Schleife, das funktioniert.
Ich könnte eine Schleife machen und das selbst rausholen.
Was haben wir denn hier zu bieten?
Okay, C-Sharp.
UTF-8.
Pointer to String.
Native UTF-8.
Native UTF-8.
Native UTF-8.
Native UTF-8.
Managed String.
Boah, was zum...
Gibt's da nix Fertiges?
Marshall Pointer to String UTF...
Ja!
Das sieht gut aus!
Der Marshall wieder mal.
Der Marshall.
UTF-8.
Pointer to String.
UTF-8.
Pointer, okay.
Okay.
Okay, Bites.
Okay, das will er als Endpointer wahrscheinlich haben.
Das ist okay.
Darf er.
Wenn er meint.
Okay, String.
Alles klar.
Löschen wir die 4M und gucken, ob es jetzt funktioniert.
By the way, Leute, ich hab mich wieder übel sidetracken lassen.
Eigentlich wollte ich mich mit der...
Meine Schelle ist kaputt.
Mit der Größe von Binarys beschäftigen.
Was wir wieder nur zum Teil gemacht haben.
Aber wieder was gelernt.
So, wenn jetzt alles klappt, krieg ich die IP-Adresse von...
Der 4M ausgespuckt.
Nice!
Easy!
Eckermann-Shit.
Easy as fuck.
E-E-Easy as fuck.
Easy.
Get rekt.
Easy as fuck.
Der Marshall war's wieder.
Der Marshall war am Start.
Ist es jetzt möglich, Unsafety-Sharp-Inline-Assembly zu schreiben?
Ich weiß es nicht.
Ich weiß es nicht.
Ich hab keine Ahnung, ob das geht.
Also, direkt in der Sprache integriert ist es nicht.
Aber es gibt bestimmt irgendwelche Zusatzdinger, wo das tut.
Marshalak.
Ja, das ist gut hier.
Das find ich nice.
Was passiert eigentlich, wenn ich die 4M lösche?
Crash das dann, weil der Pointer nicht mehr gültig ist?
Oder was passiert?
Jetzt bin ich gespannt.
Oh, ja.
Es crasht.
Domain not found.
Object instance not set.
Okay.
Man darf ihm das nicht unterm S weglöschen.
Dann kackt er ab.
Aber das ist cool.
Das hätte ich nicht gedacht, dass das so geht.
Publish.
Wie groß ist das Executable jetzt?
Build.
3,8 MB.
Das ist ja nix.
Was?
Also.
Warum ist meine Shell so abgefuckt, kaputt?
Was ist da los?
Das ist cool.
Weil das in Kernel pointed.
Nee.
Weil...
Das ist nicht gecrashed.
Weil es irgendwie unmanaged Probleme gegeben hat.
Das ist gecrashed, weil...
Er anscheinend versucht hat, hier drauf zuzugreifen.
Weil es noch größer...
Also, ich hab es wahrscheinlich gerade in dem Moment gelöscht,
wo es das...
noch größer als null war und dann hat er versucht hier drauf zuzugreifen oder in welcher zeile 201
ja genau also ich habe das gelöscht wo der check das war ein ganz unglückliches timing anscheinend
na oder na oder das ist doch irgendwie im abgeschrieben dass das gefunden hat was auch
immer jeder ist der ist gecrasht weil ich hier versucht habe auf interfaces zuzugreifen auf den
ersten index und das gab es da nicht mehr weil ich gelöscht hatte ja aber gut man war ja war
irgendwie zu erwarten sollte man sollte man auch nicht machen haben wir wieder was gelernt leute
wie man bekommt wie man per api also per pc library interface vms erstellt unter linux
was das war auf die schnelle machen können ich glaube nicht was ich mich jetzt
noch frage ist was ich mir jetzt noch frage ist worauf sind diese beine resets lauffähig
dass das müsste man vielleicht mal schnell ausprobieren noch ich kommentiere mal alles
aus ich komme ein thema alles aus ablisch habe ich jetzt wieder mit so worauf worauf
sind die lauffähig also mama docker ran doch ran
linux support und netz ja das ist was die supporten das geht aber meistens trotzdem
eine ganze ecke weiter weiter zurück minimum ja ich brauch für dort 98 ich brauch ich brauch für
dort 88 haben wir da schon ein review haben sie nicht rein geschrieben ich weiß nicht was
minimum support ist für für für dort 88 alles das kann man das kann man einfach auch
ausprobieren können wir sagen einfach dokka ran nicht portman borgherr m und zwar ubuntu
2004 sollte auf jeden fall noch noch gehen das ist glaube ich kein problem 2004 so als
müssen wir mountain mein docker stellt ist zu lange her wie ging das jetzt pbd slash bild
mounted nach bild mache ich das richtig so einer warum ist meine chance so im arsch ich will ich
will das irgendwie kaputt meine meine vorwärts rückwärts tasten bin das testen wir jetzt mal
wo das worauf das läuft cd
bild ja vor allem champ es ich verstehe wenn ich wenn ich das kompilieren dann nimmt es die
c libraries von meinem host das ist ein sonderfall zu also wenn ich das normale erstellen vorne von
einem executable machen mit dotnet dann benutzt er die sachen die schon drin sind die quasi
eingebaut
sind wenn ich es allerdings komplett kompilieren so dass gar keine dotnet runtime mehr vorhanden ist
dann heißt es ich benutze die von meinem bild von meinem host system okay das ist natürlich blöd das
heißt im endeffekt ich müsste quasi ein docker file bauen wird heute vielleicht bis sie knapp
müssten docker fall bauen wo die sachen drin gebaut werden wir machen mal klickt die die
kurzvariante von dem docker fall und zwar wir nehmen mal ubuntu wir machen jetzt gar kein docker
fall ich maute das jetzt hier rein ich maute das jetzt hier rein install dotnet müssen wir jetzt hier
machen minus 8.0 also ich meine alter
alter
alter
alter
alter
alter
alter
alter
alter
alter
alter
alter
alter
alter
alter
alter
Es ist kein Curl installiert, ich fass es nicht.
Na gut, es sind minimale Container-Images.
Aber muss heute auch Curl drauf sein.
Kann man sich das so vorstellen wie Server-Side-Rendering?
Was? Hä? Wie jetzt?
Das verstehe ich nicht.
Doch, du kannst ein Image von Microsoft nehmen.
Das bringt allerdings an der Stelle nichts,
weil du das älteste Image, also das älteste OS nehmen musst,
was du mit deinem Output-Binary supporten musst.
Weil wir machen kein normales .NET-Bild,
wir machen diese experimentelle .NET 8 Komplett-Kompilierung.
Okay, Bild.
Das ist schon mal, da sieht man mal schon wieder,
das ist schon mal abfuck im Vergleich zu Go.
Mit Go hast du die Probleme schlicht und ergreifend nicht.
Weißt du, das ist schon mal doof.
Das ist schon mal nicht gut.
Ico, Alter.
Wie heißt denn der Kram?
Wie heißt das?
Hier, was ist da?
Das brauchen wir.
Go-Syntax ist halt bodenlos.
Ja, Go-Syntax ist, meine Güte, jetzt ist es ja mal gut hier.
Go-Syntax ist, aber ist schon halbwegs erträglich, geht schon.
Aber wirklich schön, muss ich sagen, also wirklich, wirklich warm,
so komplett werde ich mit der Go-Syntax auch nicht.
Plattform-Linker, not found.
Bild, wie heißt das?
Bild Essentials?
Nee, ähm, Base-Bild, ah, fuck, wie heißt denn das unter Debian?
Einfach, ah, okay, easy.
Einfach ohne S, na dann, easy.
Also unter Ubuntu 20.0, alles klar, natürlich, was, was sonst?
Ich finde, das ist ganz eindeutig, was das uns sagen soll.
Komplett klar, ja.
Also, wenn sich das noch nicht mal, ja, ja, ja, ja, ja.
Wenn sich das noch nicht mal gescheit unter Ubuntu 20.04 übersetzen lässt,
dann kannst du es ja fast, fast komplett.
Was hat er denn jetzt, was will er mir eigentlich sagen?
Bist du nicht auf V20, doch?
Was, .NET 7 supportet doch nicht erst ab 22.10.
.NET 7 geht, glaube ich, bis Ubuntu 18.04 oder so?
Ja, Commercial Support ist doch egal.
Ihr Minimum.
Minimum Lib C, muss man gucken.
Es ist bis Debian 10 und Ubuntu 18.04, siehste?
Die Chance, dass es auf noch älteren läuft, ist sogar gar nicht so, gar nicht so unnötig.
Also, was der hier für Schmerzen hat, ich habe absolut keinen plassen Schimmer.
Also, ich weiß auch nicht, was er für Probleme hat, ehrlich gesagt, weil,
also, ich habe garantiert irgendeine Abhängigkeit nicht.
Aber man weiß es halt nicht.
Ich kann es mal bilden, ich kann es mal bilden ohne Ahead of Time.
Ja, easy, gar kein Problem.
Ich habe Dependencies.
Dependencies, müssen wir mal kurz gucken.
.NET 7 Dependencies, was brauchen wir denn hier?
GNU C++ Library, okay, das müssen wir bestimmt alles.
Upt, Install, Lib.
Ne.
Das ist doch mit Build Essentials, Build Essentials bestimmt, bestimmt drauf.
Oder nicht?
Welche davon denn jetzt?
Welche davon?
Geht anscheinend nicht drauf.
Welche, welche davon denn jetzt überhaupt?
Kann man, kann man nicht einfach...
Gibt es da nicht so eine Standard oder so?
Ja, ich weiß nicht welche.
Ich installiere jetzt einfach alle.
So.
Was will der eigentlich alles haben, Mann?
Ach, hat er, stand es da drin, ne?
Moment.
Hätte ich mir vielleicht mit Output-Richtung angucken sollen.
Cannot find?
Wo zum Teufel siehst du das?
Das da?
Cannot find.
Wo steht da?
Wo steht Cannot find minus LZ?
Ach da!
Zlib.
Wie heißt denn das?
Zlib Dev?
Ne.
Warum heißt die ganze?
Warum heißt die ganzen Sachen immer so unintuitiv?
Zlib C.
Äh.
Ja, das war bestimmt das Falsche.
Zlib 1G.
Natürlich, natürlich.
Was, was sonst?
Die Header brauchen wir ja.
Ich geb dir Header.
Ah, guck mal.
Jetzt hat das funktioniert.
Also 2204 ist überhaupt kein Problem zu bilden.
Build.
Build.
Vm-Champ.
Ja.
Ja.
Okay.
Eine Sache.
Nochmal kurz gucken.
1604.
Das wird sich überhaupt nicht mehr installieren lassen, glaub ich jetzt.
Und das wird sich, glaub ich, gar nicht mehr installieren lassen.
Also ich geh nicht davon aus, dass es überhaupt läuft.
Okay, 1604 läuft auch.
Moment.
Dotnet.
Dotnet.
Info.
Ja, ja.
Leute.
Ja, ja.
Ja, ja.
Ja, ja.
Ja, ja.
Ja, ja.
Ja, ja.
Ja, ja.
Ja, ja.
Ja, ja.
Ja, ja.
Ja, ja.
Ja, ja.
Ja, ja.
Ja, ja.
Live IQ 66 hieß der Krempel oder?
Dev.
Ich hasse diesen Namen von den...
Das kann es doch keiner merken, man.
55.
Wir 66 waren gestern 55 war damals.
Obviously.
Und jetzt war das was.
Z clip.
ist Okay, dass das das heißt einfach immer gleich.
Das ist richtig.
irit und lies dass sie alleine.
cd bild okay mal gucken wir beim abkacken zu plattform linke ach so ja
ab install install bild essentials deswegen macht man sich dann
normalerweise docker fall hast du das problem nicht und muss sich von hand
machen in general okay sie kommen das läuft sogar das läuft sogar auf ubuntu
16 04 noch hier das ist dass das doch gar kein problem
das ist doch gar kein ding also 16 04 ist mir alt genug
sage ich euch ganz ehrlich 1,9 1,9 mb library und ich meine das ist über sechs
jahre alt des linux das ist doch schon das doch in ordnung wo wir noch mal
just for fun okay wir machen jetzt wir machen jetzt als letzte amts handlung
heute wie überspringen jetzt 16 04 wir machen jetzt 12
4 12 04 okay wir wissen jetzt ja langsam wie es geht ab update damals gab
es noch nicht mal ab
get update das ist so alt oh fuck leute dafür gibt es noch nicht mal mehr
packages okay wir können das nicht verwenden die
mirrors sind offline okay keine chance okay 14 04 kommt
ist 14 russen mir jetzt genau okay da gab es ab schon jetzt halte ich schaue
mal kurz ob das funst
ok download klappt noch ab install das da und bild essential jetzt will mal
gespannt ob der bild klappt ich glaube ich glaube ja nicht ja genau wunderbar
wunderbar
Excellent, excellent.
Upt-Search.
Wie hieß das Ding damals?
Upt-Install. Ah, 52.
52 sind wir jetzt.
Es wird immer älter.
So, und jetzt bauen wir das Ganze mal.
CD-Build.
Oh.
Cannot get required symbol.
SSL-Z.
Z-Alpen-Protoss. Alles klar.
Die Alpen-Protoss sind am Start.
Wusste gar nicht, dass die auch in den Alpen sind.
Die Alpen-Protoss machen nicht mal mit.
Okay, also.
Ubuntu 14.04 funktioniert nicht mehr.
Das ist zu alt.
Man könnte jetzt sicherlich rumbasteln
und SSL-Support deaktivieren
und solche Geschichten, aber
scheiß drauf.
Also das funktioniert nicht mehr.
16.04 ist das Letzte, wo es drauf läuft.
Obwohl der offizielle Support schon
bei 18.04 Plus ist.
Also finde ich okay.
Offiziellen
Support auf 18.04 stellen
und
in Wirklichkeit noch 16.04
supporten.
Beziehungsweise lauffähig sein.
Support wird es ja nicht.
Ja, nice. Also ich gehe mal
davon aus, mit einem gebauten Binary,
was so alt ist,
dann geht das schon.
Guck, das läuft auch hier drauf.
Kann ja mehr oder weniger Zufall sein.
Aber das ist gut.
Das ist gut.
Dann sind die Binarys nämlich tatsächlich auch,
lauffähig
auf den wichtigsten Systemen.
Ich meine,
braucht man wirklich was,
was eine C-Library
voraussetzt,
die älter ist als
sechs Jahre rausgekommen,
ist die ja wahrscheinlich noch früher.
Also die, guck mal mal,
Ubuntu 16.04
LibC Version.
Okay.
Okay.
LibC Release
Date
2016.
Ja, sieben Jahre alt
ist das jetzt genau.
Also ich würde sagen,
sieben Jahre alte C-Library,
damit läuft es noch.
Das ist zwar nicht so krass, wie mit
Go. Ich meine, Go-Binarys,
also alles, was
Go-Only-Sachen verwendet, wohlgemerkt
nur, also mit irgendwelchen Abhängigkeiten
drumherum hast du dann auch wieder andere Probleme.
Auf der,
auf der Seite wurde das sogar erwähnt.
Weißt du, lass uns mal mal schnell gucken.
Aber das ist, das ist, das ist nicht so krass wie Go.
Mein Go-Binarys sind ja lauffähig
bis zurück zu
Kernel 2.6.8.30
oder sowas. Du kannst ja quasi
aktuelle Go-Programme auf
Linux-System laufen lassen von
vor 20 Jahren oder so.
Ja, nicht ganz, aber von vor
15 Jahren oder so.
Hier steht nix.
Ups. Hier steht nix von
Ach, hätte ich das,
hätte ich das mal gewusst, da hätte ich das einfach copy-pasten können.
Ja, Go,
Go ist lauffähig auf
Linux-Systemen, die älter sind als Go selbst.
Ja.
Also hier steht nichts von 16.04.
Auf der, auf der Tabelle der
Linux-Version. Hier?
Äh, 18.04 steht da drin.
16. Ach, hier.
Ach, das ist die,
ah, GLIB C2
16. Ja, gut.
Ähm, das passt ja.
Wir haben ja 26, äh,
223 bei, bei Ubuntu
16.04 gehabt.
Aber trotzdem, das ist,
das ist alt, das ist alt genug.
Kann man nix sagen. Also ich glaub,
das ist echt ganz gute Alternative, wenn man
Bock hat, die Sachen in C-Sharp zu programmieren.
Und die Libraries und alles das
drumherum gescheit funktioniert
mit dem, wir haben ja heute nicht so
viele eingebunden, also Sp-
Reflection kannst du dir eh wahrscheinlich
abschminken mit, mit irgendwelchen
Native-Kompilierungssachen.
Aber trotzdem, das ist cool, dass das
geht. Okay, Leute,
macht's gut. Ich geh jetzt pennen.
Bis denn. See you.
