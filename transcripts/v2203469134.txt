So Leute, es wird ernst.
Echt, was gab es für Werbung?
Ich sehe keine Werbung.
Vielleicht sieht man bei seinem eigenen Stream auch keine Werbung.
Könnte aber auch dahin, dass ich überall aktuelle Werbeblocker am Start habe.
Ach, auf dem iPad, ja, Paintschamp.
Das kenne ich, das Problem.
Wobei, ich schaue noch kaum noch Twitch auf dem iPad und auf dem iPhone.
Nur die Channels, wo ich subscribed habe.
Sonst hört man die Werbung nämlich auch zu viel.
Bist du Hyper-Turbo-Subscriber?
Ja, bei mir hast du keine Werbung.
Wobei, ist das das Turbo?
Ne, das ist das VIP.
Also wenn du Twitch-Turbo hast, zusätzlich nochmal, dann nicht.
Selfmade-Eis, danke für den Sub.
Keck-Alu, warum auch immer Keck-Alu?
Ich weiß es selbst nicht so genau.
Ja, und wenn es bei mir Werbung gibt auf manchen Webseiten, die sich nicht überspringen lässt,
dann mache ich den Ton aus, minimiere den Browser und gucke später wieder rein.
Wobei, dass ja manche Webseiten auch versuchen zu detecten.
Kleinen Pipi.
Was?
Ich habe vorhin, als ich den Stream ausgemacht habe, habe ich direkt etwas gefuttert.
Das war dann so um...
Na, direkt war das nicht.
Hat schon ein bisschen gedauert.
Also, sagen wir mal, ich habe um eins etwas gefuttert oder so, ja?
Und ich könnte jetzt schon wieder etwas essen.
Aber es dauert noch, dauert noch zwei Stunden.
Dann hole ich mir etwas.
Twitch macht das.
Ja, du darfst ja auch...
Nein, nein, nein, du darfst den Tab nicht wechseln.
Du kannst aber den Browser zumachen.
Oder, was ich meistens mache, ist nicht Browser minimieren, sondern einfach einen anderen Browser in den Vordergrund.
Das scheint schwieriger festzustellen.
Ja, ich habe gehört und mein Thermometer sagt auch, dass es draußen war.
Lass mich mal kurz hier Home Assistant gucken.
Außentemperatur.
30,61 Grad Celsius.
Am besten ist immer noch die Anzeige von meiner Wetterstation.
Da steht drauf, also ich habe das ja hier im Home Assistant forwarded über Funk, ja?
Nicht WiFi.
Ich sage absichtlich nicht WiFi, weil es ist nicht WiFi.
Es ist Oldschool 433 Megahertz Funk von der Wetterstation.
Da steht dann 30...
Oh, jetzt ist es...
Oh, Leute, es ist kühler geworden.
30,39 Grad Celsius.
Also, bei mir steht da Außentemperatur.
30,39 Grad Celsius.
Gefühlt.
30,39 Grad Celsius.
30,39 Grad Celsius.
30,39 Grad Celsius.
30,39 Grad Celsius.
30,39 Grad Celsius.
30,39 Grad Celsius.
30,39 Grad Celsius.
30,39 Grad Celsius.
30,39 Grad Celsius.
Das ist kein Unterschied zwischen gefühlt und Außentemperatur.
Warum das immer zwei Sachen anzeigen muss und gefühlt und Außentemperatur exakt immer gleich hoch ist,
den Sinn habe ich noch nicht so genau verstanden von der Anzeige.
Gefühlt würde ich eigentlich erwarten, dass da, wenn Regen ist oder so,
oder Wind, dass es dann sich kühler...
Aber das ist immer exakt die gleiche Temperatur, die da steht.
Das ist wirklich Kek-Alu-Verschwörung.
Wer auch immer diese Wetterstation programmiert hat.
Das ist eigentlich ganz nice.
Das ist eigentlich ganz nice.
Das ist auch eine billige Wetterstation gewesen von Amazon.
Irgend so eine China-Chinesen-Wetterstation.
Also sprich, da ist so ein Windrichtungsding drauf,
ein Temperatursensor drauf, Regenmenge und sowas.
Also es ist eine Wetterstation, aber jetzt nichts super wissenschaftlich Akkurates.
Hat aber auch nur irgendwie 80 Euro oder 120, ich glaube 120 Euro oder so gekostet.
Aber das Coole ist, die hat ein Solarpanel drauf
und da kommen zwei aufladbare Batterien rein.
Und mit dem Solarpanel legt die die auf.
Ich musste die jetzt in den Jahren, ich habe die bestimmt schon drei Jahre oder so jetzt,
nicht einmal aufladen.
Die ist auch etwas unzugänglich im Hof, die Wetterstation.
Deswegen ist es ganz gut, dass man die nicht aufladen muss.
Die sich selbst auflöst, selbst auflädt,
weil auch nicht öfters die Batterien wechseln.
Das ist eigentlich ganz nice.
Und die Wetterstation selbst funkt ihre Werte über 433 MHz raus.
Theoretisch könnte der Nachbar die auch abgreifen.
Oder sollte ich mal keinen Bock mehr auf eine Wetterstation haben und mein Nachbar hat eine,
könnte ich die von meinem Nachbar abgreifen.
Keck, wait, wait, keck, keck, keck, wait, wait, wait, wait, wait, keck, keck.
So.
Leute, es wird ernst.
Ich hoffe, ich habe das richtig gemacht, dass man das Terminal sieht, trotz Chico.
Ich glaube so ist besser.
Ah, jetzt guckt der Kopf von Chico noch ein bisschen rein.
So ist es.
Excellent.
Excellent.
Chico Protection.
Ja.
Jetzt ist Chicos Ohr genau hier unten an der.
Excellent.
Ja, Chat, was machen wir heute?
Ich habe es dir heute Morgen schon mal kurz gesagt.
Ich habe gesehen, dass die China-Chinesen von Espressif eine neue ESP-IDF-Version rausgebracht haben.
Und da haben die jetzt einen Website.
Da haben die jetzt einen Webserver dabei, der asynchron HTTP-Requests verarbeiten kann.
Also mehrere gleichzeitig und sowas.
Und das wollte ich mal ausprobieren.
Wer keine Ahnung hat, was ESP-IDF ist, was ich mal vermute, was die meisten sind.
Ja, das wird ganz grausam jetzt.
Ich weiß das jetzt schon.
Wer keine Ahnung hat, was ESP-IDF ist, und das dürften wahrscheinlich die meisten sein.
Das ist ein Microcontroller-Framework für die Microcontroller von Espressif.
Die Microcontroller von Espressif.
Der bekannteste dürfte der ESP32 und der ESP2866 sein.
Das sind so die Feld-, Wald- und Wiesencontroller, die in den meisten China-Geräten drin stecken.
Die kann man sich aber auch so kaufen und benutzen.
Und davon...
Jetzt wird's, jetzt wird's...
Ja, wobei man sagen muss, ESP-IDF selbst ist ja in reinem C.
Also ist das dann mit irgendwelcher Callback-Hölle des Todes.
Weiß ich nicht.
Weiß ich noch nicht genau.
Mal gucken, wie's funktioniert.
Wie gesagt, ich bin mir da selbst nicht ganz sicher.
Erstmal müssen wir WiFi-Connection herstellen.
Und ihr habt gesehen, dass die Sachen jetzt neu sind.
Denn die sind enthalten im Prerelease von ESP-IDF V5.3-RC1.
Also das ist ganz neu.
Erst vor zwei Wochen wurde das Ganze released.
Und das probieren wir mal aus.
Es sieht dann ungefähr so aus.
Ich kann euch mal von der Idee her zeigen, was da rauskommt.
Also, nur mal zur Erklärung.
Nochmal.
Hier das, wie so ein Controller aussieht.
Sie hat im Prinzip die Größe von einem Raspberry Pi Pico.
Gab's aber vorher schon und gibt jetzt auch deutlich bessere.
Und ich hab hier beispielsweise so einen.
Gerade liegen.
Dieses Teil mit Display.
Ist vollkommen egal, ob das ein Display ist, mit Display ist oder nicht.
So eine, ja.
Die Kiste liegt hier gerade.
Das Teil hat auch zig GPIO-Pins, wo man Sachen dran anschließen kann.
Machen wir heute aber nicht.
Wir lassen dann drauf einen Webserver laufen.
Das ist nichts Neues.
Das haben wir schon gemacht.
Ja, ich hab hier das Projekt, wo wir das letzte Mal aufgehört haben.
By the way, ich sag's nur mal.
Nicht für den Fall der Fehler, dass ich nicht dran denke.
Secrets.h bitte nicht anklicken, Max.
Heute.
Ansonsten muss ich in meinen.
Mich nebenbei in meinen WLAN-Access Point einloggen und das WLAN deaktivieren.
Ich hab glücklicherweise extra WLAN nur für solche Bastelzwecke aufgemacht.
Sollte ich doch was leaken.
Also ist das nicht so schlimm.
Ja.
Wir haben das schon mal gemacht.
Allerdings nicht asynchron.
Also wir haben das letzte Mal auch schon einen Webserver gebaut.
Der dann über Websocket.
Über Websocket Sachen ausgeliefert hat und so.
Das ist echt ganz angenehm zu programmieren.
ESP, EDF.
Ist ganz okay, ja.
Also ist eines der angenehmsten Frameworks, die ich da kenne in der Richtung.
Und ich hab das Projekt vom letzten Mal genommen.
Hab einfach alles andere sonst rausgelöscht.
Und das ist alles, was wir gerade aktuell haben.
Mehr gibt's nicht.
Und den Rest lass ich drinne.
Weil ich reverte das danach auch wieder, wenn's funktioniert.
Und bau das ins richtige Projekt ein.
Also das Ziel ist heute folgendes.
Und zwar.
Wir wollen einen HTTP Post Request bekommen.
Auf dem.
Also hier schicken wir einen per Curl oder so.
Wir schicken einen HTTP Post Request an den Microcontroller.
Auf dem ein Webserver läuft.
Und dieser Post Request soll asynchron bearbeitet werden.
Also nicht, dass der Webserver hängt beim bearbeiten.
Sondern, dass er noch weitere Requests bearbeiten kann.
Während er den Post Request verarbeitet.
Um das zu testen.
Werden wir einfach mal.
Keine Ahnung.
1, 2 MB.
Oder 500 KB große Dummy-Files hochladen.
Mit denen wir nichts machen.
Die wir einfach nur einlesen und wegschmeißen.
Aber das ist jetzt ganz neu.
Und zwar.
Sieht man das auch hier.
Das gibt's quasi erst seit ein paar Wochen.
Dementsprechend keine Ahnung, wie gut das funktioniert.
Ich kann euch mal ein Beispiel zeigen.
Wie das.
Von der Theorie her am Ende aussieht.
Das ist übrigens auch ganz gut.
Die haben für das meiste ziemlich gute Beispiele.
Die China-Chinesen von Espressif.
So, gucken wir mal hier.
HTTP-Webserver.
Async-Handlers.
Also von der Idee her.
Ist nicht ganz sonderlich übersichtlich.
Von der Idee her.
Das müssen wir jetzt auch machen.
Dass das WiFi funktioniert.
Von der Idee her sieht das dann irgendwie.
So aus.
Man macht irgendwie.
Man macht irgendeinen Threadpool auf.
Und dann.
Muss man ihm sagen.
Dass man diesen Request irgendwie Async handhaben will.
Und whatever.
Ich hab's mir selbst noch nicht so genau angeguckt.
Aber ich bin mal gespannt, wie das funktioniert.
Ich hab.
Dass man auch durchblickt.
Eigentlich noch nichts drinne.
Ich habe im Prinzip nur ein leeres Projekt.
Wenn man so will.
Ja.
Also ich habe eine Main-Datei.
Ich habe eine Secrets.
Ich habe eine Secrets.h-Datei.
Da steht mein Webserver.
Da steht meine WLAN.
Meine WLAN-SSID.
Und meine.
Mein WLAN-Passwort drinne.
Für ich.
Das ist.
Aber wie gesagt.
Wenn ich's leake.
Ist das nicht schlimm.
Das ist bloß ein Test.
WLAN.
Nenn ich das.
Der Chat gleich wieder eskaliert.
Und sagt.
Ha.
Leaked Max.
Ich bin drin.
Ich kann das einfach ausschalten.
Dann passiert nichts.
Außerdem kommt mein WLAN eh nirgends wo hin.
Ja.
Und von der Idee her.
Können wir das gerade mal machen.
Von der Idee her.
Ist das nicht viel mehr als so eine Art Hello World Projekt.
Was ich hier hab.
Flash.
Wir flashen das mal auf den Microcontroller.
Der.
Nicht funktioniert.
Ah.
Ich bin im falschen Verzeichnis.
Äh.
Der nicht eingehängt ist.
Das da ist das richtige.
Das muss man auch wissen.
Steht nicht dran.
Nun.
So.
Wir flashen das jetzt mal.
Auf den Microcontroller drauf.
Und.
Ich hoffe man erkennt was.
Wenn nicht mach ich das ein bisschen größer.
Wenn nicht machen wir das einfach hier.
Ich glaub wir machen's hier.
Ja.
Ich.
Wir machen's.
Flash.
So.
Wir flashen das jetzt auf den Microcontroller drauf.
Und man sieht.
Das der aktuell eigentlich nichts macht.
Außer hier.
Alle halbe Sekunde einmal Tick auszugeben.
Das sieht man da.
Ansonsten macht der nur ein bisschen Init Kram.
Komm.
Wir machen hier das Terminal einfach zu.
Wir machen das hier im Fullscreen.
Dann erkennt man's auch besser.
Also im Prinzip passiert noch gar nix.
Der initialisiert seinen Flash.
Der initialisiert das ganze Netzwerk.
Wifi Zeug.
Der legt.
Die ESP EDF Event Loop an.
Wo man dann auch noch mal.
So.
So.
So.
So.
So.
So.
So.
Und dann kommt das auf Event Loop an.
Wo man dann gucken kann.
Was auf dem Controller.
Also asynchron gucken kann.
Was auf dem Controller passiert.
Und sagt.
Wir wollen benachrichtigt werden.
Bei jedem Event.
Event ist sowas wie.
WLAN Interface hoch und runter gefahren.
Und sowas.
Und ansonsten gibt der alle halbe Sekunde Tick aus.
Das war's.
Mehr passiert noch nicht.
Und.
Probieren wir das einfach mal aus.
Ausdrinken.
Es ist by the way.
Weil das jemand geschrieben hat.
Im Chat.
Es ist ein reines C Framework.
Es ist also nicht wirklich richtig.
Asynchrones.
C++.
Es ist.
Asynchrones.
C in C++.
Ja.
Mit Rust.
Haben wir es auch schon probiert.
In ESP32.
Zu programmieren.
Das ging.
Für das.
Wie.
Kurz.
Ist dieses Projekt.
Quasi.
Erst gibt.
Erstaunlich gut.
Aber insgesamt.
Fehlt da noch einiges.
Was wir kommen.
Ja.
C++.
Leider.
Nicht.
Vorbei.
Ich würde gar keinen empfehlen.
Ich habe auch keinen mehr.
Wenn ich einen empfehle.
Wenn ich einen mit.
Automatischer.
Staubsauger holen würde.
Dann einen mit.
Automatischer.
Entleerstation.
Das war so das.
Woran es bei mir.
Dann am Ende.
Auch.
Hakte.
Ich habe.
Ich hatte.
Ich hatte keinen Bock.
Das Ding.
Regelmäßig sauber zu machen.
Ich.
Ich.
Ich.
Persönlich.
Finde es immer noch angenehmer.
Einfach.
Mal hier schnell.
Im Staubsauger.
Durch zu rennen.
Anstatt.
Ja.
Das heißt.
Dass der Roboter.
Das Ding.
Raus holen.
Umdrehen.
Staub raus machen.
Und so.
Also.
Wenn.
Dann nur.
Einen mit.
Basisstation.
Den sauber machte.
Wurde dann quasi.
Nur einmal die Woche.
Oder alle 14 Tage.
Je nachdem.
Wie oft es fahren lässt.
Den.
Die Tonne ausleerst.
Gut ist.
Das ist okay.
Ansonsten.
Wirklich.
Großartig.
Empfehlen.
Kann ich.
Kein.
Weil.
Ich habe keinen mehr.
Und.
Noch.
Bock drauf.
Habt ihr.
Zu benutzen.
Das funktioniert.
Alles.
Nur mit.
China Chinesen.
Cloud.
Und.
Das sagt.
Du.
Bist.
Doch.
Der.
Meister.
Max.
Naja.
Ich.
Verdiene.
Mein.
Geld.
Mit.
Das.
Heißt.
Er.
Noch.
Lange.
Nicht.
Wie.
Ist.
Dieses.
Kram.
Wie.
Ist.
Dieses.
Zeug.
Nicht.
Temo.
Temo.
Ist.
Eine.
Eigene.
Firma.
Gibt.
Sich.
Mehr.
Für.
Die.
Neuen.
Tuja.
Meine.
Ich.
Tuja.
Tuja.
Ist.
So.
Noch.
Nicht.
So.
Entscheiden.
Ist.
Am.
Ende.
Ob.
Man.
Grafana.
Benutzt.
Oder.
Nicht.
Wichtig.
Ist.
Wie.
Man.
Seine.
Metriken.
Und.
Seine.
Werte.
Bekommt.
Seine.
Traces.
Und.
Seine.
Metriken.
Und.
Seine.
Werte.
Und.
Seine.
Werte.
Die.
Die.
Und.
Seine.
Werte.
Ist.
Das.
Ist.
Er.
Ist.
Es.
Noch.
Ein.
Zehn.
Es.
Zehn.
Und.
Zwei.
Und.
Zehn.
Und.
Zehn.
Und.
Zwei.
Zwei.
Was habe ich denn für eins installiert?
Zeig mal her.
Ja, wo habe ich denn das?
Okay.
Und wo sind wir hier?
Home, Max, ESP.
Ja, das ist ziemlich dämlich, das da hin zu installieren.
Okay.
Git, Clone.
Da haben wir es doch.
So.
Nicht 514, sondern V53.
Wie hieß das Ding?
Was ich gesagt habe, was erst seit ein paar Tagen raus ist.
Nicht wie dieses.
Ähm.
Ja.
V53RC1.
Was ist hier die Mission?
Heute ist die Mission, an einen ESP32 einen HTTP Post Request zu schicken.
Allerdings asynchron.
Weil ich habe gesehen, dass die im neuen ESP-IDF einen asynchronen Web-Server drin haben.
Das wollte ich mal ausprobieren.
Web-Server habe ich damit schon gemacht, aber noch nie asynchrones Request-Handling benutzt.
Also sprich, dass man mehrere, sodass der Web-Server auf dem Microcontroller nicht mehr hängt beim Bearbeiten eines Requests,
sondern man theoretisch auch zwei, drei Sachen gleichzeitig schickt.
Warum man das unbedingt auf dem Microcontroller braucht, kann man sich darüber streiten, aber ist auf jeden Fall nice.
Dann nenne ich das mal so wie den Ordner hier.
Clone.
Max, hast du schon mal einen Fuß vor die Tür gesetzt?
Nein, noch nie.
Never.
Punktiert das auch agentless oder ohne in seiner Anwendung aktiv was ändern zu müssen?
Also, lassen wir mal Grafana außen vor.
Ja.
Wenn du Metriken sammeln willst, gibt es ja immer...
Das Problem ist, wie bekommst du deine Metriken und ganz ohne Agents, beziehungsweise ganz ohne, dass deine Anwendung irgendwas macht, geht das nicht.
Wie willst du da an irgendwas drankommen, ja?
Also, klassische Art und Weise Monitoring war, so man fragt von außen.
Man hat irgendeinen zentralen Server, sowas wie Zappix oder Nagios oder so und die fragen von außen die Systeme ab.
So, pink das Ding.
Ist der SSH-Port offen?
Gibt es eine Web-Response auf Port 443 und sowas in der Richtung?
Irgendwie über HTTPS.
Funktioniert der Handshake?
So, das war so ganz klassisches Monitoring, wie man das früher gemacht hat.
So von außen, so ein bisschen Blackbox-mäßig, ja?
Also, man hat sich von außen angeguckt, ist die Domain erreichbar, ist der Port offen, solche Geschichten.
Das funktioniert natürlich auch nach wie vor und das funktioniert auch agentless in dem Sinn, weil das macht zentral deinen Server aus.
Ob du jetzt den Server als Agent siehst oder nicht.
Also, du musst zumindest nichts installieren.
Sobald du aber ein bisschen mehr Details haben willst, hast du damals auch schon einen Agent gebraucht.
Nämlich, wenn du beispielsweise wissen wolltest, wie ist die RAM-Auslastung auf meinen Servern, wie ist die Festplatten-Auslastung, wie viele Prozesse laufen, wie ist der Load.
Dann musstest du auch in Zeiten von Nagios oder Zappix oder was auch immer, musstest du einen Agent installieren.
Der Unterschied war, dass der Agent meistens die Sachen zurück an den Server geschickt hat.
Oder der Server den Agent alle paar Minuten abgefragt hat.
Also, du hast damals auch schon einen Agent gebraucht.
Heute gibt es zwei Varianten.
Also, bleiben wir mal bei einer, die relativ verbreitet ist.
Und zwar, wenn du die Sachen über Prometheus einsammelst.
Prometheus ist ein Pull-basiertes Verfahren.
Das heißt, der Prometheus-Server fragt Metriken ab.
Du brauchst keinen Agent, der Metriken an Prometheus schickt.
Du brauchst keinen Agent, der Metriken an Prometheus schickt.
Du brauchst keinen Agent, der Metriken an Prometheus schickt.
Du brauchst keinen Agent, der Metriken an Prometheus schickt.
Sondern Prometheus fragt die ab.
Aber trotzdem braucht Prometheus was, wo es die Metriken abfragt.
Das kann ein Exporter sein, wie das Prometheus nennt.
Das ist quasi ein Agent, nur nicht wirklich ein Agent, wie man es kennt von früher.
Sondern halt irgendwas mit einem Web-Endpunkt, den Prometheus crawlen kann.
Das gibt es.
Oder aber deine Anwendung.
Brauch aktiv.
Wenn deine Anwendung einen Matrix-Endpoint hat, wo es Prometheus-kompatible Werte zurückliefert,
dann kannst du die auch abfragen ohne Agent auf dem Server.
Aber das muss dann deine Anwendung unterstützen.
Also wenn es dir nicht reicht, dass du einfach Blackbox-mäßig von außen drauf guckst auf deinen Server,
sondern wissen willst, was auf deinem Server passiert oder Metriken von deiner Anwendung einsammeln willst,
dann brauchst du entweder einen Agent auf dem Server.
Oder deine Anwendung muss aktiv Metriken an irgendeinem Endpunkt bereitstellen, dass das funktioniert.
Anders kann es ja auch gar nicht funktionieren.
Ja.
Ja gut, das stimmt.
Das kannst du natürlich auch machen.
Du kannst dich auch bei SSH darauf einloggen und dann was abfragen.
Das geht auch.
Das ist dann die Extended-Variante von Server fragt alle 5 Minuten ab.
Server führt alle 5 Minuten den SSH-Check aus oder so.
Mit SNMP kriegst du aber auch nicht raus, ob das funktioniert.
Das heißt, wenn du deine Anwendung jetzt 3 Garbage-Collect-Runs hatte in den letzten 2 Minuten oder sowas.
Also, letztendlich, es ist vielfältig, was du machen kannst.
Du musst wissen, und das ist das, was irgendwie oftmals nicht richtig gemacht wird,
du musst wissen, was du eigentlich haben willst.
Ich habe das schon so oft erlebt, dass irgendwie 30 Milliarden Metriken eingesammelt werden.
Davon ist eigentlich nur 2 relevant und der Rest ist Rauschen.
Tracing und Profiling, da brauchst du einen Agent.
Ne, da brauchst du keinen Agent für.
Deine Anwendung muss das können.
Und da gibt es eigentlich so ein bisschen eine Art, dass du da so eine Anwendung hast,
dass du da so eine Anwendung hast, dass du da so eine Anwendung hast, dass du da so eine Anwendung hast,
dass du da so eine Anwendung hast, dass du da so eine Anwendung hast, dass du da so eine Anwendung hast,
Stichwort wurde nachgucken kannst Open Telemetry.
Das gibt's für nahezu alle Programmiersprachen gibt's Implementierung von Open Telemetry.
Open Telemetry hat 3 Dinger hat Traces, Logs und Metrix.
Du musst Open Telemetry in deine Anwendung einbauen,
und die kannst du dann collecten, wie du willst.
Wahrscheinlich am ehesten über den Open Telemetry Agent,
geht auch anders aber wenn du tracing machen willst das muss auf jeden fall
deine anwendung unterstützen da musste ich mit dem thema open telemetry
beschäftigen das ist so das stichwort was du googeln kannst und dir tutorials
zu angucken ja ja ja tritt ich weiß es ja open telemetry heißt das da musst du
danach suchen auch immer das klonen hat funktioniert
v 5.3 rc1 wunderbar und jetzt install esp 32 s3 und dann stellen wir das ganze
schon mal um auf die neueste esp version wobei ha moment wir können erst mal
arduino rausschmeißen button rausschmeißen arduino jason
rausschmeißen das brauchen wir jetzt alles nett required edf version juckt
mich nett aber das alte mal ein bisschen
schlecht
schlanker ich habe ich eher das geschriebenen titel weil ich den eindruck
habe c++ generell fühlt sich an wie auf wish bestellt so und jetzt switchen wir
mal auf die neueste also esp welchem ordner habe ich das jetzt gemacht hier
v3 export export punkt sh voll clean wird ob das jetzt noch bildet ob das
funktioniert oder nicht und dann schau mal ob das jetzt noch bildet ob das von
funktioniert okay wir benutzen die 53 rc1 scheint noch zu funktionieren flash
es ist jetzt neu dass das hier in einer zeit okay es kompiliert noch auch mit
53 das schon mal gut ich meine man kann es jetzt fragen es gibt nicht viel was
nicht kompilieren könnte aber bei ssc plus plus man weiß nie doch da lasst uns
mal schauen wie wir uns jetzt ins wlan verbinden da kann ich ein bisschen spicken
da kann ich ein bisschen spicken da kann ich ein bisschen spicken da kann ich ein bisschen spicken
muss ich auch und zwar da kann ich ein bisschen abgucken weil das habe ich
gestern schon gemacht also wlan sich zu verbinden auf diesem controller ist mit
dem standard arduino package mega easy da sagt man einfach wifi punkt beginn
ssd passwort fertig mehr muss man nicht machen so einfach ist das mit esp edf
natürlich nicht ob wir es lieben
natürlich nicht ob wir es lieben
das wäre das wäre zu einfach deswegen muss man da ein bisschen mehr machen aber
das wäre das wäre zu einfach deswegen muss man da ein bisschen mehr machen aber
ich finde es auch nicht schlecht gelöst ich mal kurz gucken
ich finde es auch nicht schlecht gelöst ich mal kurz gucken
ok also wifi connect excellent ok ich dann gucken wir das jetzt mal ab wie
ok also wifi connect excellent ok ich dann gucken wir das jetzt mal ab wie
ok also wifi connect excellent ok ich dann gucken wir das jetzt mal ab wie bugfrei das funktioniert weiß ich nicht das habe
bugfrei das funktioniert weiß ich nicht das habe
bugfrei das funktioniert weiß ich nicht das habe ich gestern auf die schnelle
ich gestern auf die schnelle
ich gestern auf die schnelle zusammen gewurschtelt und das hat
zusammen gewurschtelt und das hat
zusammen gewurschtelt und das hat funktioniert also ich kann das eigentlich
funktioniert also ich kann das eigentlich
copy-pasten, dann halten wir uns nicht so lange
damit auf. Das hier braucht
man, um sich mit dem WLAN zu verbinden.
Warum da solche ekligen Sachen
notwendig sind? Weil
C++, keine Ahnung.
Ich weiß, ich weiß
grob, was es macht,
aber warum?
Ey, keine Ahnung.
By the way, warum?
Ich halte mal eine ernst gemeinte Frage,
vielleicht auch an die C++-Kenner.
Warum gibt es in C++
so viele Varianten
irgendwas zu casten?
Was ist denn nur mit casten los?
Was ist denn so schlimm dran,
zu sagen,
wir casten das zu einem Character-Array?
Das ist
sogar noch schöner lesbar.
Ja, wahrscheinlich überspringt
man damit irgendwelche
Compile-Time-Checks,
aber nachdem C++
eh unmöglich ist,
ohne Zweideutigkeiten zu programmieren,
ist das doch das kleinste Problem, was man hat.
Also kann man doch einfach sagen,
so, bäm, fertig.
Crowdstrike.
Wir haben bestimmt auch ein paar Nullpointer dann.
Wobei, ich habe heute auf Twitter gelesen,
es war wahrscheinlich gar kein Nullpointer auf Crowdstrike.
Das haben bloß alle wieder nachgeplabbert.
Also, was hier passiert,
ist folgendes. Ich versuche das mal kurz zu erklären.
Achso, übrigens,
WLAN-SSID, ne, passt.
Alles klar.
Also, was hier passiert, ist folgendes.
Also, das hier ist Main, bla,
also, dann müssen wir das hier
aufrufen, Wifi-Connect.
Dass er das auch macht.
So, was jetzt passiert, ist folgendes.
Der legt irgendeine Standard-Config
an für das
Wifi-Interface.
STA ist Station-Mode.
Station-Mode ist das, was man normalerweise
so kennt von einem Wifi-Interface,
nämlich man verbindet sich zu einem
Access-Point. Es gibt auch noch die Möglichkeit
AP zu machen, ja, oder
Mesh oder was, whatever.
Aber Station-Mode, also sprich,
was euer Handy macht, ist auch Station-Mode.
Warum das Station-Mode heißt, keine Ahnung,
müsst ihr die Leute fragen, die die
Wifi-Standards machen.
Wir wollen unser Netzwerk-Interface als Station
betreiben, also sprich, uns ganz normal zum
Access-Point connecten.
Wir lassen uns eine Default-Wifi-Config
geben und da setzen wir jetzt noch ein paar Sachen
drin, nämlich, dass der alle Wifi-Channels
benutzen soll,
dass der
Sort-Methods, achso,
ah, dass der den Access-Point nimmt,
der den stärksten,
der stärkste Signal hat,
alle Access-Points, die schlechteren Empfang
haben als minus 127,
connectet er sich gar nicht hin,
er kann sich auch zu offenen
Wifis verbinden,
dann kopiert er meine
WLAN-SSID und mein WLAN-Passwort
in dieses Struct rein,
an die Stelle, wo es hingehört.
Ey, fragt mich nicht,
warum so kompliziert?
Ich hab das auch geklaut
aus einem GitHub-Projekt,
weil, wenn ich,
man würde ja eigentlich vermuten, man könnte,
man könnte einfach sagen,
Wifi-Config
STA
SSID
gleich WLAN-SSID, also würde man jetzt vermuten,
aber das geht nicht, weil
SSID ein
Uint28-Array
mit 32 Stellen ist.
Da kann man nur Sachen reinkopieren, da darf man nicht direkt was zuweisen.
Weil
C-Dinger.
Und deswegen
kopieren wir das da rein, anstatt es zuzuweisen.
Okay?
Das sieht so eklig aus, aber es funktioniert, es funktioniert.
Dann sagen wir noch mal explizit, dass wir Station-Mode betreiben wollen,
das Interface.
Dann sagen wir dem Interface, benutzt diese Config von hier oben
und dann sagen wir Wifi-Start.
Fertig.
Und wenn wir das jetzt flashen,
dann geht Wifi.
Wir bekommen noch keine IP, wohlgemerkt, aber Wifi geht schon mal.
Was wir auch an ein bisschen Debug-Ausgabe sehen dürften.
C++ sieht nicht nur eklig aus, C++ ist, glaube ich, die beschissenste Sprache, die es gibt.
C++ ist, glaube ich, die beschissenste Sprache, die es gibt.
C++ ist, glaube ich, die beschissenste Sprache, die es gibt.
Guck hier, Wifi-Gedöns kommt hier.
Wifi, bla, blub, Initialisierungskrempel.
UDP, M-Box 6, TCP, M-Box 6, Dings, blub, keine Ahnung.
Muss man DHCP extra enablen?
Nicht, nicht so ganz.
Das macht er, wenn man es richtig macht, für einen.
Aber wir sehen schon, unsere Event-Loop funktioniert.
Wir bekommen Wifi-Events, nämlich das Wifi-Event,
und das Wifi-Event 2.
Obviously, alles klar, oder?
Chat, was meint ihr?
Was ist das gute und was ist das schlechte Event?
Was ist schlecht und was ist gut?
Ist 41, ist das Event 41 gut oder schlecht?
Ist das Event 2 gut oder schlecht?
2 ist gut, okay?
Und 41 nicht.
Okay, Chat, ich muss sagen, ihr seid nicht schlecht, ihr habt recht.
Okay, Chat, ich muss sagen, ihr seid nicht schlecht, ihr habt recht.
Ich kann nämlich hier nachgucken, Wifi-Event.
Guckt mal hier, hier stehen die ganzen Events drin.
Und wir sehen, dass 2 tatsächlich bedeutet, das Wifi-Interface ist gestartet.
Und was war das andere?
41, 41 bedeutet Wifi-Event Home-Channel-Change.
Okay, das ist eigentlich gar nichts Schlechtes.
Das ist auch okay.
Aber das interessiert mich nicht, dass der Home-Channel gechanged ist.
So, was man jetzt nämlich sagen kann ist, ey, wir müssen, also, man muss ja warten, bis das Interface oben ist, damit man sagen kann, ich will jetzt eine IP haben.
Das heißt, wir müssen jetzt gucken, if Event Base Wifi-Event, also, ist das ein Wifi-Event, was gerade passiert ist?
Und?
Ist die Event-ID gleich, gleich, Wifi, wie heißt das, hab ich's vergessen, äh, wie heißt dieser Krempel hier nochmal?
Ist das gleich, äh, Start, dann will ich sagen, Wifi, ne, ESP-Wifi-Start will ich dann machen.
Also, sprich, der konfiguriert das Interface, das Interface fährt hoch und dann kann ich mein WLAN starten.
Alles klar?
Ist das das Tool für die Access-Point-Passwörter?
Das Tool für die Access-Point-Passwörter?
Ich hab keine Ahnung, was du meinst.
So, und wenn man das jetzt so macht, und wenn ich jetzt alles richtig gemacht hab, richtig gemacht hab, jetzt sollten wir eigentlich eine IP-Adresse bekommen, auf unserem, für unsere Wifi-Netzwerkkarte.
Oder für unser Wifi-Interface auf dem Controller.
Gucken wir mal.
So, der Flash-Vorgang ist erstmal richtig langsam.
Warum zweimal?
Wifi-Start?
Wir haben nicht zweimal Wifi-Start gemacht.
Oder?
Haben wir gemacht?
Falls wir das gemacht haben, ist das falsch.
Oh, das ist falsch, was wir gemacht haben.
Guter Cut-Chat.
Äh, wir wollen nicht Wifi-Start, wir wollen, äh, ESP-Wifi, ist das Connect?
Connect!
Obviously.
Logisch.
Wer hätte da auch nicht drauf kommen können?
Ja, die Dinger sind ein bisschen...
Nicht gerade so intuitiv benannt, wie man das gerne hätte.
Genau.
Er macht was?
IP!
Bam!
Wir haben eine IP.
Ich kann nicht klicken.
Alter.
Hier, guck.
Ping.
Mein Controller antwortet.
Zwar ziemlich langsam, aber er antwortet, okay?
Wir haben eine IP, Leute.
Also, so funzt das.
Schön ist das Ganze übrigens nicht gelöst, weil, wenn das hier nicht funktioniert, aus irgendwelchen Gründen,
dann müsste man das ja mehrfach durch, mehrfach, äh, durchführen.
Ja.
Also, man müsste, man müsste hier eigentlich noch so eine, noch so eine Art, äh, Retry einbauen.
Also, so nach dem Motto, ey, wenn, wenn hier, guck mal, hier steht ja auch, was es für, für Return Codes geben kann.
Ja, also, wenn das nicht funktioniert, dann Restarten.
Deswegen machen wir jetzt einfach mal eine Sache, um mir das Leben erleichtert zu machen.
Wir brechen einfach, wir starten einfach die Kiste neu, wenn Wifi-Connect nicht klappt.
Sollte aus irgendwelchen Gründen das beim ersten Mal nicht funktionieren,
dann startet ihr einfach den Controller neu, bis Wifi-Connect funktioniert.
Meine, das, wo man in ein, ach so, ja, das ist unter anderem dafür, ja.
Ja.
Wobei ich da schon viel, viel weiter dran gebaut hab.
Ähm, ja.
Man setzt, man setzt den, man setzt das Passwort und die SSID für den Controller, dass der sich zu einem Access Point verbinden kann.
Ja, genau.
Ähm, ich hab überlegt, wir könnten jetzt ja noch ein, äh, einbauen, dass man,
ähm, Firmware-Updates flashen kann über, über, übers WLAN.
Müssen wir mal schauen.
Ähm, und ich hab mir gedacht, Firmware-Updates über WebSocket, das geht zwar,
und das hab ich auch schon programmiert, das ist eigentlich kein Problem,
aber so ein Post-Request ist einfach schöner für so kontinuierliche Upload-Sachen,
wie das über WebSocket zu machen.
Ja, gerade was ist, wenn das abbricht und sonst wie.
Deswegen, ups.
Ein Stack-Overflow?
Dadurch, dass ich das logge?
Durch das, durch das pure Loggen?
Wie, wie, wie viel RAM darf denn diese Event-Loop verwenden?
Sieht man das irgendwo?
Create default Event-Loop.
Stack-Size.
What the fuck, Alter.
Was ist es denn?
Event-Stack-Size.
Ey, Alter.
C++-Shit, sag mir halt einfach, wie groß das ist.
Okay.
Ich hab keine Ahnung, wie groß das ist.
Man weiß es nicht.
Unbekannt.
Wäre natürlich ganz sinnvoll zu wissen, ja.
Weil es könnte, es könnte wirklich sein, wenn es gar so knapp bemessen ist,
dass das Ding einfach nicht genug RAM hat.
Und aus irgendwelchen Gründen nicht mal genug RAM hat zum Loggen.
Wobei, hier kann's eigentlich.
Naja.
Aber das funktioniert.
Ja, dann machen wir das doch anders.
If, wenn das da ungleich ESP-okay ist,
dann, äh, ESP-restart?
Moment.
Geht das so?
Vermutlich.
Okay.
Dann loggen wir das Ganze halt nicht.
Schauen wir mal, ob das wenigstens funzt jetzt.
Also ich meine, es sollte zumindest keinen Stack-Overflow mehr geben.
Okay, ne, funzt noch.
Alles klar.
Ja, dann lassen wir, dann lassen wir es erstmal so.
Scheiß drauf.
Aber ich hätte eigentlich gedacht, man kann hier die, die Stacks da jetzt ein bisschen hochschrauben von der Event-Loop irgendwie.
Event-Loop Default Create.
Ne, ja.
Man kann da keine Optionen mitgeben, ne.
Ich meine, höchstens, wo kommt ein Event-Händler her überhaupt?
Ah, ne, Event-Händler.
Wir könnten selbst ne, wir könnten selbst ne Event-Loop anlegen, die, aber, scheiß drauf.
Das passt so schon jetzt.
Also, so, wir haben ne IP, wunderbar.
Dann, können wir jetzt weitermachen.
Jetzt brauchen wir einen Web-Server.
Chat, wir fangen erstmal an, ohne HTTPS.
Mein Ziel ist natürlich HTTPS.
Ja, das ist klar.
Hatten wir, hatten ja, wir haben ja hier schon einen Web-Server mal gebaut, wo über HTTPS, über Web-Sockets mit dem Microcontroller kommuniziert werden konnte.
Das heißt, wir klauen uns das hier einfach jetzt.
Davon.
Und wir starten dann den Web-Server.
Jetzt ist natürlich die große Preisfrage, wie kann ich hier warten, bis WiFi connected ist?
Weil das ist ja alles asynchron.
Also, sprich, ne, ne, ne, ne, ne, das, das machen wir gar nicht.
Wir brauchen ein Event, wenn wir ne IP bekommen haben.
Guck mal, es gibt doch ein Event, wenn wir ne IP kriegen, oder?
IP-Event.
IP-Event 0.
Genau.
Das machen wir.
IP-Event.
So, und was war das hier?
Gott-IP wollen wir haben.
Und jetzt sagen wir hier.
Start Web-Server.
Was es noch nicht gibt, ja?
Ich finde das ein bisschen eklig, das jetzt davor.
Start Web-Server.
By the way, wir können das auch einfach inline hier drin haben.
Ah, wobei, ne, aber nicht.
Lass uns das mal.
So, Start Web-Server.
Das ist übrigens auch was, was ich einfach nur dumm finde an C++.
Und zwar, wenn man das hier hinschreibt.
Und.
Und die Methode hier unten definiert, dann sieht das erstmal so aus, als würde es funktionieren.
Aber, wenn ich das jetzt versuche zu kompilieren, dann geht das nicht.
Warum geht das nicht?
Weil das hier deklariert wird, nachdem es benutzt wird.
Also hier will ich es benutzen und hier unten wird das erst angelegt.
Jede, auch nur ansatzweise, halbwegs moderne Programmiersprache kommt mit sowas klar.
C++ nicht.
Was man in C++ machen muss dafür ist.
Zu sagen, by the way, es gibt, es gibt da was, das nennt sich so.
Und jetzt funktioniert es.
Was aber einfach nur saumäßig dämlich ist, oder?
Sagt doch mal ernsthaft.
Also, das ist glaube ich so die dümmste, die dümmste Lösung für dieses Problem ever.
Dass man einfach das quasi deklarieren muss vorher und die Implementierung.
Das ist so, das ist so dumm.
Ich verstehe gar nicht, warum das noch ein Ding ist.
Im Jahr 2024.
Dass das historisch mal so gewesen ist, das lasse ich mir ja alles noch gefallen, ja.
Header Files ist das nächste.
Fangen wir nicht von Header Files an im Jahr 2024, ja.
Aber es ist einfach richtig dumm, dass es dieses Problem immer noch gibt.
Und was es hier geht, C++ schlecht reden.
Was wird eigentlich prokriminiert?
Ich habe hier einen ESP32 S3.
Auf dem lassen wir einen Webserver laufen mit HTTPS.
So.
Webserver, WLAN und dann will ich darüber asynchron ein Post-Request schicken.
Das ist der Task für heute.
Weil das ist ganz neu.
Das gibt es erst seit ein paar Tagen, dass der Webserver, der quasi vom Hersteller in ihrem hauseigenen Framework mitgeliefert wird,
auch asynchrone Requests kann.
Und will ich einfach mal ausprobieren, ob das funktioniert.
Das ist also super bleeding edge.
Das ist noch nicht released.
Und ich weiß nicht, ob es funktioniert.
Aber wenn es geht, wäre echt nice.
So, Start Webserver.
Das können wir uns abgucken von hier.
Im Prinzip ist das ja kein großer Unterschied.
Der einzige Unterschied ist, was wir jetzt machen.
Wir legen keinen...
Was macht der hier unten eigentlich die ganze Zeit?
Also das brauchen wir...
Sag mal, was macht der eigentlich?
Alter!
Visual Studio Code...
What the fuck?
Wir woll...
C U.
Ähm, ja.
Den Webserver, den muss ich natürlich includen, dass das funktioniert.
Irgendwelchen Gründen nicht.
Funktioniert?
Was jetzt...
Doch funktioniert?
Ich glaub man will...
Kann das sein, dass mein Visual Studio Code C++ Plugin gecrashed ist?
Ich vermute es fast.
Das macht es gerne.
Das ist richtiger Schrott.
Ja, es ist gecrashed.
Jetzt funktioniert es wieder.
Nice.
GG Microsoft.
Good Job.
So, was wir jetzt machen ist, wir fangen nicht mit einem SSL, mit einem HTTPS-Webserver an,
sondern mit einem ganz normalen Webserver.
So.
Dann...
Brauchen wir...
Ja, CLion hat andere Probleme gehabt in der Zusammenarbeit.
Ich hab das...
Ich hab sogar CLion glaub ich noch installiert.
Ne, hab ich nicht.
Hatte ich aber.
Ich hab ja das JetBrains Desktop Package.
All Desktop Package.
CLion hatte andere Probleme.
Deswegen bin ich wieder bei Visual Studio Code gelandet dafür.
Ich krieg's aber aus dem Kopf nicht mehr zusammen, was das war.
Haben wir auch im Stream probiert.
Und...
Das hat...
Das hat mich übelst abgefuckt wegen...
Weiß nicht mehr was.
So.
Also, Start Webserver.
Hier runter.
Wo hab ich denn das Ganze?
So.
Wir lassen diesen ganzen Campbell weg mit Zertifikaten und sowas.
Und wir starten einfach den Web...
Ist das alles, was wir machen müssen?
Ernsthaft?
Ach ne, wir brauchen noch einen Webserver-Handle.
Okay.
Irgendwo.
Da.
Hier.
Das brauchen wir noch.
Und ich glaube jetzt...
Ja.
Und das...
Ich glaube das ist alles, was wir brauchen.
Um den Webserver zu starten.
Gucken wir mal.
Server starten.
Das ist CMake...
Ja!
Das war mir das Problem.
Genau.
Das ist CMake-based.
Das ist standardmäßig schon CMake-based.
Man denkt, das wäre ein richtig gutes Match für CLion.
Ist es aber nicht.
Weil die irgendwelche komischen, expressive eigenen Sachen da mit CMake machen, womit
CLion nicht klarkommt.
Guck mal.
Server-Event 1.
Webserver ist gestartet vermutlich mal.
Ich gehe mal davon aus, dass Event 1 bedeutet Server startet.
Okay.
Alles klar.
So, unser Webserver ist gestartet, wie man hier sieht.
Da.
Webserver startet.
Probieren wir mal aus, ob der Webserver gestartet ist.
Wir machen mal einen Curl.
Und wir bekommen eine Antwort.
Also.
Wir haben unseren ESP32 im Wifi und am Webserver laufen.
Das heißt, wir können uns jetzt der eigentlichen Sachen widmen.
Wie macht man asynchrone Webrequests dagegen?
Was für ein Application Launcher.
Du meinst das Ding?
Das ist RoFi.
RoFi.
RoFi, Alter.
Und das allerwichtigste ist natürlich das Emoji Autocomplete Menü.
Also ich habe da drinnen meine ganzen Apps.
Das hier benutze ich nie.
Keine Ahnung, warum ich das da überhaupt drinnen habe.
Das sind quasi alle.
Das hier sind quasi nur alle Apps mit Desktop Entry.
Das sind alle.
Was eigentlich überflüssig ist.
Man kann Windows, man kann Fenster suchen und dann da hinspringen.
Ja, wenn ich sage, ich will zum Firefox.
Bam.
Könnte ich sagen.
Mache ich aber auch nie.
Weil ich weiß eigentlich, auf welchem Desktop meine Sachen sind.
Deswegen mag ich ja auch E3 und Tiling Window Manager.
Beziehungsweise Tastatur, mit guter Tastaturbedienung.
Ich habe immer auf dem ersten Desktop meinen Browser.
Auf dem zweiten meinen Terminal.
Auf dem dritten meinen Editor.
Oder aber halt auf dem dritten und vierten meinen Editor.
Und auf sieben habe ich immer Animes laufen.
So habe ich das auf dem Desktop eingestellt.
Deswegen brauche ich nie, deswegen brauche ich nie überlegen.
Ja, aber nur auf Desktop 7, bitteschön.
Ich kenne die Anleitung.
Aber C-Line, ich habe es ausprobiert.
Hat, hatte, ich kriege es nicht mal zusammen, was das war.
Wir haben es im Stream ausprobiert.
Es gab irgendwelche Probleme mit diesem Custom Zeug, was Espressif da und CMake bastelt.
Ja, ja, das sieht auch erstmal so aus.
Funktioniert hat es.
Das sieht auch erstmal so aus, als würde es funktionieren.
Aber es gab ein paar Details, die haben nicht funktioniert.
Die haben mich nach der Zeit so aufgeregt, dass ich keinen Bock mehr hatte.
Und gesagt habe, ich mache jetzt wieder Whistle Studio Corner.
Ich glaube, ich glaube, Autocompletion hatte Probleme, manche Sachen aufzulösen.
Ich bin auch gedacht, warum?
Es ist noch gar nicht so lange her, wo wir das ausprobiert haben.
Also, Asynchrone Request.
Wie funktioniert das jetzt?
Wir machen das hier zu.
Und wir machen das hier zu.
Wobei, das brauchen wir ja alles nicht.
Wie macht man Asynchrone Request?
Wir gucken uns das Beispiel von denen an.
Async Handlers.
Also, WiFi Connection Gedöns haben wir gemacht.
Das haben wir auch gemacht.
Unser Webserver haben wir hier am Start.
Connect Handler, Start Webserver.
Haben wir auch gemacht.
Ja, wenn du NeoVim verwendest, die benutzen alle immer...
Da gibt es so ein Language Server Plugin für NeoVim, was das für dich handelt.
Ich habe aber keine Ahnung.
Ich habe, ehrlich gesagt, lange aufgehört, mein Vim, schon lange, jahre schon aufgehört, mein Vim aufzumodzen.
Mit IDE Features.
Ich benutze Vim täglich mehrere Stunden für Command Line Geschichten.
Aber sobald ich ein bisschen was Advancedes brauche, mache ich Whistle Studio Corner.
Oder die Jetbrains Sachen auf.
TS Fuchs, danke für den Sub.
Deswegen keine Ahnung, wie man Vim heutzutage cool konfiguriert.
Ich weiß nur, dass ich, wenn ich es machen würde, würde ich NeoVim nehmen.
Und dann mit irgendwelchen Lua Plugins oder was sie da alles am Start haben.
So.
Also, wir brauchen jetzt erstmal, das können wir uns hier auch ausgucken.
Abgucken.
Wir brauchen erstmal einen, einen URL-Händler.
Und zwar einen für HTTP.
So.
Also, wenn wir unseren Web-Server gestartet haben, dann brauchen wir einen Händler für, also sprich, was dann die Request verarbeitet.
Witzig, da hatten wir es heute Morgen noch von.
Für mal Slash, wir machen Slash Post einfach mal.
Wir wollen kein HTTP oder nennen wir es Slash Update.
So, wir wollen einen Post Request.
Jetzt brauchen wir einen Händler.
So.
Und da hatte ich es ja heute Morgen von.
Das ist ja auch wieder absolut zackt in C++.
Dass man sowas hier nicht mit einer anonymen Funktion gescheit machen kann.
Weil das halt richtig funktioniert.
Also, wir brauchen einen Händler für diesen Request.
Da muss ich jetzt einfach mal gucken, wie das hier funktioniert.
Also, lasst uns mal das Beispiel angucken.
Start Web-Server.
Warum ist eigentlich der neue GitHub-Editor so abfuck?
Und nervt immer, anstatt einfach nicht aufzugehen?
Benutzt dieses komische Feature hier ernsthaft jemand?
Ja doch, ich benutze es tatsächlich manchmal.
Aber in der Regel will ich das nicht.
In der Regel will ich hier drinnen was anklicken.
Und das Ding soll mich in Ruhe lassen hier neben.
So, Start Web-Server.
Die konfigurieren LRU Purge Enable.
Wenn die das machen, dann machen wir das auch.
Ich weiß zwar nicht, was das macht.
Purge Least Recently Used Connections.
Also, sprich.
Wenn ihm die Sockets ausgehen, dann wirft er alte Verbindungen weg.
So würde ich das mal vermuten.
Da bin ich mir nicht wirklich sicher, ob ich das haben will.
Oder ob ich lieber will, dass meine Connections weiter bestehen bleiben und keinen neuen mehr annimmt.
Weiß ich noch nicht genau.
Du hast nur 2 Stunden Verspätung und schon 60% der Strecke geschafft.
Okay, wenn du Glück hast, bleibt es bei 2 Stunden.
Ansonsten, es wird immer nur mehr, nicht weniger.
Ich weiß, es macht dir jetzt sehr viel Mut, aber so ist es.
Max Open Sockets.
Ja, da reicht das Default, das müssen wir nicht setzen.
Dann startet er den Web-Server.
Okay.
Das heißt, wir müssen jetzt hier noch checken.
If.
Muss ich das einfach so ausführen?
Ja, ungleich.
Dann, wenn das nicht okay ist.
Dann mache ich das gleiche.
ESP Restart.
Ja.
Mein Scheiß drauf.
Wenn mein Web-Server nicht startet, kann ich nicht weitermachen.
Also, wenn das aus irgendwelchen Gründen nicht funktioniert.
Komm, wir sind mal vor.
Okay.
So, und jetzt handeln wir den Post-Request.
Das sieht hier noch alles relativ normal aus.
Async-Handler.
Kann man das Ding hier irgendwie...
Gab es hier nicht immer so einen Minimieren-Knopf?
Ah, noch hier.
Okay, das ist übersichtlich.
Das ist das, wie wir es auch haben.
Also, was interessant wird, ist...
Wie hieß das Ding?
Oh.
Das ist Beispiel, Mann.
Alter.
Long Async-Handler.
Okay.
This handler is first invoked on the HTTP-Thread.
Okay, das macht Sinn.
Wenn das Initial reinkommt.
Dann checkt er, ob er nicht schon asynchron läuft.
Und dann startet er sich selber nochmal.
Boah, das ist ja mal voll durch die Brust ins Auge.
Also, soweit ich das verstehe, passiert hier folgendes in dem Beispiel.
Sobald ein Request reinkommt.
Für diesen Händler wird er aufgerufen.
Dann guckt er, ob er schon asynchron läuft.
Was er ja beim ersten Request nicht macht.
Wenn er nicht asynchron läuft, dann startet er sich selbst neu in einem Background-Thread.
Und das nächste Mal, wenn das hier aufgerufen wird, ist das hier dann true.
Und das wird übersprungen.
Wenn man hier nicht aufpasst, hat man übrigens eine Endlosschleife gebaut.
Und der ruft sich immer wieder auf, bis es crasht.
Das haben die gemacht, dass wenn der Threadpool keinen Platz mehr hat vermutlich.
Ich bin mir da nicht so ganz sicher, was sie da gebaut haben.
Ja, und danach macht er irgendwelche Sachen.
Heißt im Endeffekt...
Alter, wat?
Submit Async Request.
Also, das ruft er auf, um sich asynchron zu machen.
Das ist er selbst.
Das ist in dem Fall die Funktion hier.
Okay, das ist wahrscheinlich das, auf was es ankommt.
Ich glaube, den Rest können wir schon mal knicken hier.
httpd Request Async Handler Begin.
Das müssen wir machen.
Wisst ihr was?
Ich lasse dieses ganze super-advanced Zeug von denen mal hier weg.
Was macht der da?
Guckt, ob er schon im Essen...
Da haben sie eine Queue für die Sachen.
Und hier erzeugt er den Background-Thread.
Er ist free, Erthos.
Okay, ich glaube, ich habe es gecheckt, was passiert.
Also...
Gucken, ob das stimmt.
Ja, hier, okay.
Ich glaube, ich habe es verstanden.
Und zwar...
Der ruft als erstes das hier auf.
Noch nach dem Start.
Was das hier macht, ist...
Dieses ganze Ding ist im Prinzip nur dafür da, um zu checken,
ob es neue Requests gibt, die asynchron bearbeitet werden müssen.
Und zwar scheint es hier eine Message-Queue zu geben.
Irgendwie hier eine Message-Queue.
Eine Message-Queue.
Und...
Dort werden quasi asynchrone Requests reingepusht, wenn man so will.
In diese Message-Queue.
Er startet...
Ja...
Eine vordefinierte Anzahl von Threads.
Von Tasks.
Aber es sind im Prinzip quasi Threads.
Und...
Diese Threads startet er...
Mit...
Ja...
Das ist der Einstieg quasi für den jeweiligen Thread.
Und das ist eine Endlosschleife, die nachguckt in dieser Message-Queue,
ob es neue Requests gibt, die zu bearbeiten sind.
Und...
Wenn ja, dann geht er hier rein.
Bearbeitet die Methode, definiert es für den jeweiligen Request.
Und wenn er fertig ist, räumt er auf.
Ich glaube, das ist so die Essenz des Ganzen, was passiert.
Wir werden uns diese ganze Message-Queue glauben.
Komplett schenken.
Zum Ausprobieren ist das komplett Overkill.
Wir starten einfach für jeden Request einen neuen Thread.
Und hoffen, dass es funktioniert.
Aber das hier brauchen wir.
Wir brauchen Async-Händler Complete.
Wir brauchen...
Wie heißt das andere?
Async-Händler Begin.
Das hier brauchen wir.
Und dann Complete danach.
Okay.
Dann machen wir das doch mal.
Wir haben hier eine neue Funktion.
Static Void Handle Post.
Oder so.
Handle Post.
Da weiß ich zufällig aus dem Kopf, was das Ding für Parameter braucht.
HTTP Requests.
Braucht das.
Und zurück gibt das ein ESP-Error.
So, jetzt sollte es zumindest noch mal kompilieren.
Gut.
Und jetzt müssen wir das Ganze hier mit diesem Asynchronen-Krempel machen.
Also.
httpd Request Copy.
Ich vermute mal, was an der Stelle passiert ist.
Der
kopiert sich quasi alles,
was zu diesem Request gehört, raus.
Dass der...
Also bis...
Hier ist es ja noch synchron.
Der Request kommt rein.
Und die Methode wird hier aufgerufen.
Das ist alles noch synchron.
Und dann kann der Webserver genau diesen einen Request verarbeiten.
Und keinen zweiten Request gleichzeitig.
Jetzt kopiert er sich alles,
was zu diesem Request gehört.
Sodass das quasi den Request überlebt.
Diesen synchronen Request.
Und jetzt muss ich mich drum kümmern,
dass das asynchron weiterläuft.
Sodass quasi der synchrone Request
oder der Webserver
einmal synchron durchlaufen kann,
aber im Hintergrund die Bearbeitung weiterläuft.
Ist das...
Klingt ein bisschen...
Ne, das könnte Sonic oder Mario Kart sein.
Das ist Mario Kart.
Mario Kart.
Das kommt mir irgendwie bekannt vor.
Okay, und jetzt?
Und jetzt führen sie das einfach wieder aus, oder?
Okay, wir...
Leute, wir werden dieses
Example jetzt einfach mal zusammendampfen
auf...
drei Zeilen.
Ähm...
Wir starten hier jetzt einen neuen Thread.
Glücklicherweise
habe ich mir da schon mal irgendwann
einen Rapper für gebaut.
Also wir machen jetzt...
Wir machen im Prinzip das hier.
Nur gerappt.
Wir starten einen neuen Thread.
Und zwar...
machen wir das da drinnen.
Und das Ding heißt
Runtask.
Das Ding heißt, äh, ja...
HandlePost.
So.
Ja, ich hab mir das...
Ich kann euch das auch zeigen.
Hier.
Ich weiß, das ist bestimmt ein sehr hässliches
C++, aber es funktioniert.
Äh, der macht im Prinzip
unter der Haube
das, was dort auch drinnen steht.
Der macht, äh...
XtasCreate.
Nur, dass ich mich um den ganzen anderen Kempel
nicht mehr kümmern muss.
Und es ist
möglich, hier den Lambda zu übergeben,
was er machen soll.
Deswegen ist das zum Benutzen
dann angenehmer.
Wir starten einen eigenen Thread.
In diesem Thread machen wir jetzt folgendes.
Was macht er denn jetzt hier drinnen eigentlich?
Im Prinzip startet er jetzt ja diesen long...
Wie hieß das Ding?
LongAsync?
Ja, das da startet er jetzt nochmal.
Diesen ganzen
Krempel haben wir geskippt.
Und hier drinnen macht er
ganz normales HTTP Zeug.
Er sendet auch eine Antwort.
Okay.
Dann lasst uns doch erstmal testen,
ob ein GetRequest richtig funktioniert.
Ich weiß, es ist vielleicht ein bisschen dumm,
dass der GetRequest
jetzt kurz mal temporär
HandlePost heißt, aber...
Wir handeln jetzt mal einen GetRequest...
Oh ne, das Formatieren
von den Dingern ist wieder voll am
abkacken.
Oh man.
Warum ist das teilweise...
Man fühlt sich übelst sabotiert manchmal.
Ich mein, wer hat gedacht,
dass das eine gute Formatierung ist dafür?
The fuck?
Ah, what the...
Alter!
Keine Ahnung.
Okay, also was führen wir jetzt hier drinnen aus?
Im Prinzip
responden wir einfach.
Wir testen einfach mal, ob es funktioniert.
Hier, ähm...
Response, ne, hier, send 400.
Send, das machen wir.
Wir senden jetzt einfach eine Antwort hier drinnen.
Allerdings...
senden wir jetzt keine...
Ach, jetzt sieht es ja ganz brauchbar
vom... Alter!
Visual Studio Code mal entscheiden.
Allerdings dürfen wir jetzt nicht den Request
verwenden, sondern müssen diese Copy
von diesem Request verwenden.
So, das heißt wir...
jetzt die Copy...
So, nicht gzip,
html ist okay.
Und wir antworten auch nur...
äh, ja...
keckel antworten wir.
Das muss reichen.
So.
Ich weiß nicht, was Visual Studio da
gerade rumformatiert, aber...
So.
Und jetzt... Ha!
Und jetzt... Ha, das hätte ich sonst vergessen, sonst Memory
leakts. Und jetzt müssen wir sagen
asynch handler complete.
Was im Endeffekt quasi
eine Art free ist, vermutlich.
Ja, so.
Also wenn ich
Glück habe, funzt es jetzt.
Curl...
äh, wie habe ich es genannt? Update?
Ganz normaler Get-Request.
...
...
...
Okay, schauen wir mal, ob es funzt. Bam!
Easy!
Keckel!
So, jetzt müssen wir mal gucken, ob das ordentlich
asynchron funktioniert. Wir bauen da jetzt mal
einen Delay ein.
Delay...
1000. Und jetzt führen wir einfach
zwei Curls aus.
Gleichzeitig und gucken, ob das asynchron ist.
Wobei, nee, nee, nee, nee, nee.
Wir machen das noch viel besser.
Send.
Chunk können wir noch machen,
oder?
Das sieht man ja auch so.
Delay 1000.
So, wir machen jetzt zwei Curls.
Und die sollten jetzt beide
hängen, aber
...
dann eine Antwort bekommen nach jeweils einer Sekunde.
Sie hängen jetzt parallel
gleich. Habe ich eine IP?
Ja.
Okay. Ich würde sagen, das funzt.
Guck mal. Wir können mehrere
Curl-Befehle parallel ausführen.
Na, ob das so richtig
parallel ist, weiß ich nicht. Wir machen mal
Send. Chunk.
Ja, Send. Chunk.
Null?
Wir machen das mal.
Wir senden da wirklich mal was zurück.
Mal eine Vorschleife.
Ja.
Zehn Stück.
Zehn Mal senden wir da
was zurück. Oder keine Ahnung. Wir können auch 100 Mal
was zurück senden. Ist auch egal.
Okay, und dann warten wir jeweils 50 Millisekunden
dazwischen.
Format ist übrigens kaputt.
Visual Studio formatiert nicht
mehr. Hat's gedacht.
Nope. Kein Bock mehr zu formatieren.
Jetzt. Ach, jetzt geht's.
Alter, das ist so schlecht,
Mann.
Wie kann es so schlecht sein, Alter?
So, und jetzt sagen wir
Leon, danke schön für den Sub.
Chunk.
Send, String, Chunk.
Ja.
Okay, wir senden jetzt
Kekkel. Ne, wir senden
ja, wir senden Kekkel.
Kekkel 1 senden wir jetzt. Okay, wir senden
jetzt, ne, wir senden die jeweilige Zahl
von der, ja, Kekkel plus
FMT
Format I.
Okay.
Senden wir da jetzt.
Weil's sonst zu hübsch wird wahrscheinlich.
Okay, also wir
sind komplett.
Und dann muss man am Ende
was machen?
Request 0.
Okay.
Das so quasi, jetzt ist Schluss, oder wie?
Ah, 0 to finish response packet.
Obviously.
Weiß jeder.
Alles klar. So. Schauen wir mal.
Ich hatte bis jetzt noch keinen
großartig kryptischen Error.
Auch sehr ungewohnt.
Welches Betriebssystem ist das? Hier?
Das ist Arch, by the way.
Ich use Arch.
Das ist Arch Deluxe mit
I3.
Inner4M, wohlgemerkt.
Okay, update.
Äh.
Also, das läuft
asynchron, aber mein...
Wow, wow, wow, wow, wow.
Chat, das funktioniert
nicht, was ich hier gebaut hab.
Ah, siehste mal, ich kack noob.
Es muss Copy sein.
Oder?
Und nicht Request.
Ich hoffe, ich verwende hier nirgends
so Request. Ist das CMake?
Ja, ja.
Das ist aber nicht, was ich selbst
konfiguriert hab. Das ist, wenn du das
ESP-IDF-Beispielprojekt klonst,
ist das alles schon vorkonfiguriert.
Ich nehm immer das Beispiel und
copy-paste den Rest so hin, wie ich's haben will.
Ähm. Was macht die
Sunshine-Kiste, wenn ich
weitergebaut? Äh.
So wirklich? Ey, es
funzt, Leute! Also,
der macht asynchron was.
Aber warum zeigt mir Curl nix an?
Warte mal, wie ist das
bei... Moment, Moment, Moment.
Muss man da nicht, bei Chunk,
muss man da nicht Newline, Newline
irgendwie reinmachen?
Dass das, dass das
HTTP das checkt? Oder, oder
war das, oder ist das SMTP?
Ich kann mir das immer nicht merken.
Oder ist es
Carriage-Return-Newline? Was muss man
bei HTTP reinmachen, dass der, dass der,
dass der irgendwie...
Warte mal, HTTP
Chunk, Newline...
Ah, jetzt funzt! Guck!
So, und jetzt, und jetzt sollte ich
in der Lage sein, das zweimal
parallel zu machen.
Geht! Das beweist der,
der Request, der Get-Request ist asynchron.
Ich kann
zwei, das ging früher nicht. Früher
konnte der Webserver immer genau ein
Request parallel bearbeiten.
Das ist asynchron. Nice.
Ähm, jetzt ist die Frage,
lasst uns mal ausprobieren,
wie viele Requests,
da müssen wir das auch ein bisschen,
machen wir ein bisschen länger, okay.
Wie, wie viele Requests,
kann ich denn,
was meint ihr, wie viele gehen?
Wir machen mal acht.
Machen einfach unter, hinter.
Okay. Eins, zwei,
drei, vier, fünf, sechs,
sieben, acht.
Man sieht es jetzt halt nicht richtig.
Also acht Requests scheinen zu
funktionieren. Oh!
Das war jetzt vielleicht ein bisschen viel auf einmal.
Äh, acht Requests macht
ihn schon ein bisschen fertig.
Aber er crasht noch nicht, er crasht noch nicht.
Ach bloß, er ist ein bisschen zu ausgelastet.
Okay, ich gebe jetzt auf zehntausend
hoch, das ist vielleicht ein bisschen viel.
Ich brech mal ab.
Kill, all, curl, bam.
Ist vielleicht ein bisschen viel, ja.
Was meint ihr, wie viele, wie viele
Requests gehen da maximal? Acht?
Neun, zehn, elf?
Gucken wir mal, ich starte einfach jetzt.
Bis er crasht, irgendwann wird er ja crashen.
Okay.
Zwei, drei, vier, fünf, sechs,
sieben, acht, neun, zehn,
elf, zwölf, dreizehn,
vierzehn, fünfzehn, sechzehn, siebzehn,
achtzehn, neunzehn, zwanzig.
Ich habe jetzt zwanzig Requests laufen.
Also wenn zwanzig Parallele, wenn
dieser, wenn der zwanzig Parallele
Requests abkann, dann ist das Pog.
Der ist nicht gecrashed, das sieht nur so aus.
Der crasht aber nicht.
Der ist aber kurz vorm
crashen, würde ich sagen.
Solange die Zahl hier vorne noch hoch
läuft, ist er nicht gecrashed. Das ist die
Uptime. Die Uptime in Millisekunden
hier vorne.
Ja, könnte man machen.
Aber das ist ein Microcontroller,
der maximal keine 20 Requests abkann
oder so. Ich überlege gerade,
wie hieß dieses Ding? Oh, er ist fertig.
Er ist fertig.
Die ersten Requests sind fertig.
Ah, guck mal, der kann doch nicht so viele
Parallel bearbeiten. Guckt mal.
Jetzt macht er nämlich die nächsten
Requests erst. Die anderen hingen so lang.
Aha. Ja, okay.
Das klappt doch nicht so ganz.
Ja, der ist, das ist ein bisschen
viel. Aber ich mache
das. Nein, das ist ein Microcontroller,
der muss keine 20 Parallelrequests.
Wie hieß denn dieses Ding, was ich mal
letztens, so gar nicht so lange her, im Stream
verwendet habe? Es war, es war nicht
Locust, das habe ich noch nicht verwendet.
Äh, HTTP
Load, oder?
Ich habe es vergessen.
Aber wir wollen ja auch, also HTTP
Load Test Tools sind gar nicht
so gut dafür in dem Fall, weil
ich habe lange Requests.
Ich will nicht viele Requests machen,
ich habe lange Requests.
Mit GDB. Ja, aber nur sehr rudimentär.
Äh, Core Dumps
mir angeguckt.
Okay, das ist, das
Ding ist voll am eskalieren, weil ich ein paar
Requests gemacht habe. Ich reset das mal kurz.
Ich will mal kurz gucken, wie viel packt
das hier. Okay, also ein Request packt
es auf jeden Fall. Zwei packt es auch
ohne Probleme. Drei packt es auch
ohne Probleme. Vier
packt es auch ohne Probleme.
Fünf auch, hä?
Sechs auch.
Sieben auch.
Acht
auch.
Ne, sieben Requests.
Ab sieben Requests ist er auch am meckern,
dass der Thread, dass er
nichts mehr, keine neuen Sachen starten
kann. Okay, also sieben
Requests.
Dann ist Schluss.
Dann ist er am Abspacken schon.
Okay.
Das würde ich sagen, ist mehr als genug für so einen
kleinen Controller.
Man könnte wahrscheinlich, man könnte wahrscheinlich
noch mehr machen.
Ja, ESP mit Display. Man könnte
noch mehr machen. Aber heute was sehr
übersichtliches. Man könnte wahrscheinlich noch
mehr machen, indem man irgendwie sagt, es
gab noch irgendwie Conf
Max Open Sockets. Da haben wir irgendwie zwölf
oder so. Oh, keine Ahnung.
Zwanzig. Bam.
Wobei, was ist denn Max Anzahl
eigentlich? Ja, Max Socket.
Aha. Hier.
Max Sockets ist zehn.
Aber wir konnten trotzdem zwanzig
reinschreiben.
Oh. Ah.
Max Allowed sieben. Okay.
Sieben.
Na, wie das passt.
Wie wir es schon wieder rausgekriegt haben.
Dass sieben das Maximum ist.
Alles klar. Nice.
Easy. Gut.
Nächste.
Nächste
Stufe. Es soll ein
Post Request sein.
Es soll ein Post Request sein. Also können wir uns
diesen ganzen Krempel hier schon mal sparen.
Und ich glaube, wir machen das
anders. Wir benutzen
das Ding hier oben.
Wir starten den Task hier unten
drin. Und rufen dann
Handle Post
auf.
Also.
Dass wir sowas hier machen.
Dann. Es dürfte
ein bisschen übersichtlicher sein.
So. Das kommt
nämlich eh alles raus hier.
Alter Wishel Studio. Kannst du
diesmal ordentlich formatieren, ey?
Was ist das für ein Schrott? Warum sackt das so?
Äh. Und jetzt hier.
Return ESP. Okay.
Ja. Das ist deutlich
übersichtlicher jetzt.
Jetzt können die hier unten ihr
Gedöns drinnen machen.
Ja. Jetzt können die hier unten. Und hier oben können wir
jetzt uns auf unseren Post Request
konzentraten. Gucken wir ob noch
alles kompiliert.
Okay. Also. Post Request.
Wir loggen
einmal. Um zu checken ob das
mit dem Post Request überhaupt funktioniert.
Äh.
Wir loggen einmal die
Länge von dem Request.
Content. Also. Beziehungsweise wie
groß der Content ist den wir posten wollen.
Nur um zu checken ob prinzipiell ein Post
Request funktioniert. Also.
Curl minus X
Post. Och. Und wie
geht das jetzt? Minus minus Data
oder so. Ja. Data. Binary.
Data.
Und dann musste man Add
Mail oder so meint. Curl
Post File.
How to Post File Content sind
Curl. Data Binary
Add Part. Genau. Das suche
ich. Okay.
Post funktioniert. Länge 0. Ja.
Klar. Okay.
Path to File. Ey.
Wir laden einfach die Firmware hoch.
Die irgendwie unter
Bild
bin. Wie groß ist denn die? Ups.
Die ist. Ja. Das ist
eine gute Testdatei.
So.
Wir laden die Firmware hoch.
Wow.
Oh. Oh. Oh. Oh. Oh. Oh.
So war das nicht gedacht.
Warum ist Länge 0? Länge sollte
nicht 0 sein.
Ah. Ne. Hier. Länge 300
365138.
Und. Moment.
Gucken wir mal.
865138. Ja.
Passt. Okay. Also.
Das laden wir jetzt hoch.
Okay. Wie lesen wir das Ding noch?
Mal. Was für ein Vorteil
das hat? Also das größte
Vorteil ist schon mal. Also generell
die Frage ist nicht ob Arduino IDE
oder Arduino. Die Frage ist
ob ESP EDF oder Arduino.
Die Arduino IDE selbst würde ich nie
verwenden. Die Arduino IDE ist abfuck.
Ich bin mir nicht mal sicher ob die Arduino
IDE überhaupt bis heute Autocomplete
hat. Hat die Autocomplete mittlerweile?
Das letzte Mal als ich geguckt habe war
das ein Unstable Feature was die IDE immer
zum Crashen gebracht hat.
Also Arduino IDE würde ich eh nicht verwenden.
Du kannst aber ohne Probleme
Arduino
verwenden.
Leute. Modgis.
Keine Modgis da. Was ist da los?
Weg.
Bin ich denn gerade stehen geblieben?
Ja. Du kannst ohne Probleme Arduino
verwenden.
Damit. Das geht auch.
Wenn du es einfacher haben willst
verwendest du Plattform IO. Also
der ESP32 unterstützt.
Zwei beziehungsweise drei Sachen.
Von Haus aus.
Wo du dir auch einfach das runterladen
kannst von der Homepage von denen.
Die unterstützen einmal
nackiges Arduino.
Sie unterstützen ESP EDF.
Das ist das Framework vom Hersteller.
Und sie unterstützen
Arduino als
ESP EDF Komponente.
Das ist eine Sache die ich sonst
immer mache. Dann du kannst
Arduino quasi installieren.
Hier in ESP EDF als Komponente.
Und dann verwenden so als wäre es
quasi Arduino.
Plus das du aber noch alle Sachen zusätzlich
hast die ESP EDF so
anbietet. Was sehr nice ist.
Weil normalerweise
normalerweise
ist es so das das Hardcoded ist.
Also vieles was in Arduino drin ist
kannst du die Werte nicht ändern.
Und wenn du
ESP EDF mit Arduino als
Komponente benutzt kannst du beispielsweise
auch die Nummern
der Serienschnittstellen ändern. Oder
wie groß irgendwelche Buffer sind oder
sonst was. Was normalerweise zur
Compiletime vom Arduino Core
festgelegt wird. Also für mich ist
das die beste Kombination.
Ich verwende es jetzt ohne Arduino.
Weil
also auch ohne die Arduino Library.
Ich habe die gar nicht installiert.
Weil ich das neueste ESP EDF verwende.
Und das neueste ESP EDF
wird noch nicht supported von der Arduino
Implementierung für den ESP32.
Das ist ein Nachteil von
Arduino würde ich sagen. Du kannst
nie das neueste Framework benutzen.
Also Arduino ESP
also das ESP EDF also das da.
Die ESP32
Arduino Implementierung
von Espressif
die basiert auf
ESP EDF.
Also du kannst Arduino auf dem ESP32
nie ohne ESP EDF benutzen.
Nur das wenn du
den fertigen Arduino Core benutzt
bist du drauf festgelegt, dass
die Werte die die zur Compile Zeit
von dem Arduino Core hatten
die Werte sind die du haben willst.
Was du beispielsweise mit dem Arduino Core
nicht machen kannst ist
Menüconfig aufrufen und Settings
an deinem Controller vornehmen.
Du hast exakt die Settings zur
Compile Zeit als Espressif das letzte
Release vom Arduino Core rausgebracht hat.
Und allein schon deswegen würde ich
reines pures Arduino nicht auf
dem ESP32 machen.
Ich würde wenn überhaupt Arduino
nur als ESP EDF
Komponente verwenden.
Das funktioniert auch relativ gut im Prinzip
ist das einzige was du machen musst
ist include
Arduino wenn du es installiert hast.
Ja das musst du
machen und du musst einmal anfangen
init Arduino
machen das war es. Dann kannst du alle Arduino
Sachen verwenden in ESP EDF.
Also die Frage ist nicht entweder
oder sondern
eigentlich die beste
Variante ist Arduino mit
als Komponente
in ESP EDF verwenden.
Wird der Copy Pointer noch gelöscht?
Ja der wird hier gelöscht.
Das ist zumindest meine Vermutung.
Das steht da nicht explizit dabei.
This will free the request memory.
Ok steht doch dabei.
Also das
scheint quasi
ein Free zu sein.
Ja man hätte es auch
Request Async Handler
Free nennen können oder so aber
und es passiert immer
der führt den Händler aus
und wenn der Händler irgendwelche Probleme hat
danach wird gefreed.
Das einzige was jetzt noch sein könnte
ist eventuell
wenn das hier nicht richtig funktioniert
Geh einfach mal davon aus das es funktionieren wird.
Ok so und jetzt ist die Frage
wie man das mit einem Post Request machen.
Ich weiß das du den Content
von einem Post Request so lesen kannst.
http
request
receive
dann übergibst du den
das Request Objekt
dann brauchst du ein Buffer ohne Länge
also hier Cha Buffer
ah keine Ahnung
128 das ist viel zu klein
richtig lahm dann
size
so liest man Sachen
von dem Request ein
oder auch nicht
achso
so liest man Sachen
von dem Request ein und man muss jetzt
eine Schleife machen
man muss ein bisschen komisches Zeug basteln
man muss eine Schleife machen
man muss quasi
solange einlesen
bis man
Content
man muss quasi solange einlesen
bis man die Content Länge erreicht hat
beziehungsweise ist es wahrscheinlich besser
ok
das hier liefert zurück wie viele Bytes
das eingelesen hat
also sagen wir mal sowas wie irgendwie
Bites
der Buffer kommt da oben hin
so
jetzt muss ich da irgendwie ne Schleife drum herum bauen
ok sagen wir mal while
ok wir machen noch Content Length
wir machen nochmal sowas
das habe ich glaube ich auch mal in dem Beispiel gesehen
Remaining
das schreiben die auch in ihrem Beispiel
so
ab jetzt weiß ich auch nicht mehr wie die ist
also solange
noch Bytes übrig sind
also solange Remaining größer mit
0 ist
wollen wir Sachen
einlesen
das ist jetzt ohne
jegliches Error Handling oder sonst was
Log Info
Received Bytes
ne
wir geben Remaining aus
und jetzt sagen wir
Remaining
nicht Reminder
Remaining
Received Bytes
also wir ziehen das was wir jetzt einmalig empfangen haben
die Gesamtmenge ab
und dann geht es automatisch raus sobald
es nicht mehr größer 0 ist
soweit von der Idee her
so Bäm Flash
bin ich mal gespannt
ich gehe nicht davon aus
dass ich das richtig gemacht habe
irgendwas wird hier nicht stimmen
aber wir sollten zumindest jetzt durchratternd
sehen Bites
dass die Bytes runter gehen
wir machen auch nur mal ein
wir machen auch erstmal nur ein Request
wait a minute
ähm
das ist ich sehe nichts
das hört nicht mehr auf
ah ok ich habe keine Abbruch
ich habe keine sonstige Abbruchbedingungen drinnen
ok das ist nicht
sonderlich Pfeifett was ich da gebaut habe
ich gebe es zu
das ist nicht
sonderlich schlau ähm
ich würde sagen wir sollten gucken
if
also erstens
müssen wir mal das hier rausnehmen
aus dem Event Händler
dass ich mir jedes Event ausgeben lasse
weil das spammt mir mein Log as fuck zu
ja so
wenn Received Bites
kleiner gleich 0 ist
dann
break
das ist sicherlich kein gutes Error Handling
das ist gar kein Error Handling
also entweder
kleiner 0 nicht kleiner gleich 0
so wenn das kleiner 0 ist
ist ein Fehler aufgetreten
dann loggen wir
also Warning
ja keine Ahnung
äh Read Error
echte Hacker können das mitlesen
ja die haben Krepp im Auge
habt ihr auch Krepp im Auge
nicht Dreck
Krepp
wobei ich habe eher AWK im Auge
wie kann man negative Bites bekommen
man bekommt negative Bites
weil es ein Read Fehler ist
guck da steht auch hier
Return
es Return quasi
alles was negativ ist
ist ein Fehler
das heißt dann nicht wirklich dass er minus Bites gelesen hat
was ja minus Bites würde ja bedeuten
er hat etwas zurückgeschrieben an den Client
sondern es ist ein Fehler
so gucken wir mal
äh
was ist jetzt für ein Problem
warum bricht das ab
äh was ist das
warum ist das kaputt
ok Leute wisst ihr was
wir lassen ihn einfach weiter auslesen
egal ob Error oder nicht
wobei das kann eigentlich nicht funktionieren
oder
das kann eigentlich nicht sein
Leute wir geben uns den Error Code aus
ich bin
ich bin richtig pepega
wir geben uns den Error Code aus
Remaining
kann man richtig schreiben
äh und das hier ist
ähm
Received
guter Code wirft keinen Error richtig
und vor allem funktioniert er
und braucht deswegen weder Kommentare
noch Dokumentation noch Tests
so sieht es aus
sag ich auch
Error List Driven Programming
hätte CrowdStrike auch gebraucht
ich finde CrowdStrike
sollte bei uns sich mal einen Kurs mieten
wie man ordentliches C++
programmiert
war dieser Shit nicht sogar auch in C++
oder
man weiß es ja nicht wirklich was es ist
aber man vermutet es
fuck
ok gar kein Error Handling ist auch nicht gut oder
haha
das crasht es einfach
das ist aber doof
by the way warum crasht es jetzt
ich hatte vorher auch keinerlei Error Handling
drinne
und da ist es nicht gecrasht
sah das anders aus
ne oder verstehe ich nicht
so hatte ich es vorher dann lief es noch
ne was heißt es lief auch nicht
es hing dann irgendwie
ok wir lassen uns jetzt mal die
das ausgeben
jetzt hängts wieder guckt
seht ihr wow
guck mal
es wird wieder mehr weil er immer minus 2 hat
ok
ne das funktioniert so nicht
minus 2 hat er ok
was ist minus 2
was ist minus 2
das ist übrigens Blödsinn was
mit diesem Null Pointer
ich weiß nicht was dieser Dude da erzählt
aber
also wenn der Typ in dem Video erzählt
dass es ein Null Pointer Exception war
dann stimmt das höchstwahrscheinlich nicht
ich hab nämlich heute ne Analyse auf Twitter gelesen
dass das überhaupt nicht stimmt
dass die alle nur das nachgeplappert haben
was der erste Typ erzählt hat
ok minus 2
was bedeutet minus 2
was wirft das denn für
für Fehler
hier
minus 2
was bedeutet minus 2
ok das ist schlecht
ok also ohne Fehlerbehebung
lesen ist auch keine gute Idee
was
aber was ist denn jetzt falsch da dran
Leute ich muss mal kurz was essen nebenbei
ich halt hab hier ne gute Empfehlung
was wir kurz auf Youtube gucken können
weil ich 5 Minuten was vorhau
warum kackt das ab
Moment
minus 1
ok
ok
ok
1
gibt es auch noch
was ist denn jetzt wiederum minus 1
für nen Error
das stand doch hier irgendwo drinne
timeout bestimmt
ne das ist minus 3
socket fail
fuck ok
egal was ist wir sind gearscht
nice
ok irgendwie funktioniert das nicht
Asynchron Post Request
das kackt immer ab
und ich weiß nicht warum
ne das gucken wir nicht
ich muss jetzt erst mal was essen
ich hab übelst Hunger
was ist das
oh ne das ist Simplicissimus
das kann ich mir jetzt nicht geben
das klingt immer so
so bedeutungsvoll
alles wie er das ausspricht
ist mir zu anstrengend jetzt
Zwischenbilanz
der 4 Tage Woche
ja auf gehts
4 Tage Woche beste
Artstellungsexperience
Februar Homelab
aha
ein Rackstelz
Rackstelz ist immer gut zum angucken
während man am futtern ist
ist das da oben ein CRT Monitor
ne ne ne ne
ich hab das hier unten
das hier
hab ich irgendwie im Kopf
mit dem Gehäuse vom Monitor verbunden
das ist kein CRT
das ist ein oller
alter TFT
wie die da wiederum rumstehen
äh
heute noch mal Stellenanzeigen
ne heute ist es C++ Stelz
ah guck mal
gute alte schöne
HP
ne Dell
HP
DL380
ist das HP oder ist das Dell
HP HP
die Amis stehen total auf diese Unify
Dinger
in the den of my house
we are moving soon
so the setup is likely to change
oftmals ja
warum hat er da 4 NUCs stehen
I'll do a quick little video showing
what's in it
how everything works
before that all might change
ups
bis sie vorspulen
switches are 100 meg
so they're kinda useless
and they suck a lot of power
aber bei den Amis ist das glücklicherweise billig
ich würde mir die alten
Cisco Switche genauso wie diese alten
was ist auch immer sehr beliebt auf Ebay
die alten
welcher Hersteller
ist das nicht Cisco
Prodcom ne
HP
ne
was ist es noch so ein typischer
HP ja HP könnte sein aus recht
HP ja diese alten HP Switche
die sind ja auch teilweise super lahm
laut
brauchen Strom und macht überhaupt
keinen Sinn
aber Hauptsache haben
übrigens sehr ordentlich hier auch wieder
schön mit beschriftet mit Labels
und so
HP meine ich
I plan on
getting
another 2U Server
at some point probably
so these are just sort of
here rather than just having a gap
or any blanking panels
so
whatever future
changes I make I'll probably
whenever I get a new server
I'll probably
I glaube das Video ist langweilig
some spare parts that I had
das meiste davon ist auch aus
I had like an extra shell
haben wir sonst noch
Katzenvideo
this question comes from Thomas
and many other people
who all
what if everyone jumped at once
ok das wollte ich schon immer mal wissen
this question comes from Thomas
and many other people
who all asked what would happen if everyone on earth
stood as close to each other as they could
wer hat sich's noch nicht gefragt
jumped and landed on the ground
also ich predikte mal
es passiert wahrscheinlich gar nichts
das dürfte der Erde ziemlich egal sein
this is one of the most popular questions submitted to what if
it's been examined before including by a
science blogs post and a straight dope article
they cover the physics pretty well
however they don't tell the whole story
at the start of the scenario the entirety of
the earth's population has been magically transported
together into one place this crowd
takes up an area the size of Rhode Island
in fact let's assume they I mean
we are actually in Rhode Island
at the stroke of noon everyone jumps
natürlich selbstverständlich
wo sollte
auf der Welt das
stattfinden wenn nicht in den USA
oder logisch
sind wir uns einig sowas würde
selbstverständlich und ein Zauberer
würde natürlich auch die Leute wenn überhaupt
nur in die USA teleportieren
das ist etwas anderes
dieser Baufang betrifft nicht wirklich den Planeten
die Erde ist über 10 Milliarden
auf der Anzahl von Menschen kann man
vielleicht einen halben Meter biegen
und das ist wenn wir nicht schulter-zu-schulter
in der Mitte einer Gruppe sind
selbst wenn alle so hoch gestiegen sind
und die Erde ständig rückgängig war
würde die Erde nur von weniger als einem Atom
nach oben gedrückt werden
alle fallen zurück auf die Erde
das gibt technisch viel Energie
aber es wird über eine große Menge
der Erde ausgesprochen werden
die Erde wird von der Kontinentenkrust
und verschwindet mit wenig Effekt
außer wenn man die Nadel
von einigen lokalen Seismometern bewegt
das Geräusch von 12 Milliarden Füßen
schlägt auf den Boden auf
und schlägt viele Sekunden auf
und dann wird die Erde ruhig
Sekunden passen
alle schauen herum
es gibt viele ungewöhnliche Blickwünsche
jemand kackt
ein Telefon kommt aus einem Koffer
in Sekunden folgen die 7 Milliarden Telefone
der Welt
alle Netzwerke sind unter ungewöhnlicher Lüge
außerhalb von Rhode Island
beginnt abgestürzte Maschine
Flugzeuge fliegen durch die Höhe
auf Autopiloten
Essen startet auf abgestürzten Küchenstöfen zu brennen
Fußballballen verfolgen ihre Projekte
und haben nun unabhängige Ziele
Moment
das ist ja bei der Frage
normalerweise auch nicht mit gemeint
natürlich müssen
alle Leute wieder
zurück teleportiert werden
und die Zeit muss still stehen in der Zwischenzeit
und nicht springen in diesem einen Ding
ansonsten ist es natürlich ziemlich blöd
wenn auf einmal alle Leute dort weg sind
wo sie eben waren
um dann irgendwo kurz in Rhode Island zu springen
Back in Rhode Island
People, many people
begin to wonder
How do we get everyone home?
The TF Green Airport in Warwick, Rhode Island
handles a few thousand passengers a day
I just flew out of there
They have the nicest bathrooms of any airport I've ever seen
This is not part of the recording
Assuming they got things organized
including sending out scouting missions to retrieve fuel
they could run at 500% capacity for a hundred years
without making a dent in the crowd
The addition of all the nearby airports
doesn't change the equation much
nor does the region's light rail system
Crowds climb on board container ships
in the deepwater port of Providence
but stocking sufficient food and water for a long sea voyage proves a challenge
Rhode Island's million cars are commandeered
Moments later, I-95, I-195 and I-295
become the sites of the largest traffic jams
in the history of the planet
The roads are blocked by the crowds
but a lucky few get out and begin wandering
wandering the abandoned road network
Some make it past New York or Boston
before running out of fuel
Since the electricity is probably not on at this point
rather than finding a working gas pump
it's easier to just abandon the car and get in a new one
After all, who can stop you? All the cops are in Rhode Island
The edge of the crowd spreads outward
Southern Massachusetts and Connecticut
Any two people who meet are unlikely to have a language in common
and almost nobody knows the area
Even if people cooperate, everyone is hungry and thirsty
Grocery stores are immediately emptied
and woefully insufficient
Fresh water is hard to come by
and there's no efficient system for distributing it
Sanitation is a disaster
and healthcare infrastructure non-existent
Within weeks, Rhode Island is a graveyard of billions
including most of the people who submitted this question
Du hast ja kein Zelt dabei
Du wurdest ja instant weg teleportiert
Du und ich auch
Gut, dass wir das jetzt wissen
Man sagt wenn man einen Frosch
Gut, dass wir das wissen
Hätte ich das nicht gewusst, hätte mir was gefehlt
Don't make Rest Abis
Was kommt jetzt? CraftQL oder
TAPC oder
Ich brauch ne Runde Katzenvideosekunde
Fertig mein Toastbrotfutter
Ich bin gleich fertig
Ein Toastbrot hab ich noch
Ja
Das ist in Japan, guck mal wie ordentlich da drum herum ist
In Frankfurt hätte schon irgendjemand
auf den Tisch gepinkelt
Und ich meine, nicht die Katzen
Oh, es moved
Bam
Ganz ehrlich, Leute
Ich hab ne Modelleisenbahn
Nix am Hut, aber auch gar nix
Da würde ich aber trotzdem
denen einen Besuch abstatten
wenn ich in Japan bin
Oder wenn ich in der Ecke bin
Ihr habt aber nicht Billy auf den Gleisen stehen, oder?
Das Restaurant ist eine Stunde von dir weg
Ach, das ist ein Restaurant?
Okay
Ich dachte
Ich dachte, es ist so ein Modelleisenbahnladen
Jumbo hat verpasst?
Fertig
Jetzt hab ich noch super gesund
Ein Brot mit Nutella
Bam
Mit oder ohne?
Ohne
Ich find das total eklig mit Butter drunter
Das war so ne Glaubensfrage fast schon
Das war doch grad ein Kurzgesagt-Video, oder?
Losing weight is hard
and unfortunately your body is sabotaging you every step
Alle 12 Minuten ist zu lang
Ich bin jetzt einschaufelt, fertig futtern
Nutella ausstellt, jetzt kann ich futtern
So
Jetzt geht's weiter
Chat, warum geht denn das net?
Jetzt geht's
Chat, warum geht das jetzt auf einmal?
Die ganze Zeit ging's net
Aber das ist viel zu langsam, Leute
Das ist super lahm
Da stimmt irgendwas net
Das ist viel zu langsam
Also aus irgendwelchen Gründen funktioniert das
Aber das ist viel, viel, viel zu langsam
Hier, receive bytes
32, what the fuck
32
Da passiert irgendwas zwischendurch
was nicht richtig ist
Gucken wir mal ob das da am Reset immer noch funktioniert
Ich vermute auch, dass da irgendwas falsch ist
Ja
Ich weiß nicht, ob es bei mir falsch ist
Oder auf ESP Seite
Ich vermute fast auf ESP Seite
Weil das ist noch so ein neues Feature ist
Hat bestimmt nicht angreifen
Guck jetzt hängt's wieder
Ich vermute mal, das hat wahrscheinlich noch keiner mit Postrequest ausprobiert richtig
Ich vermute mal, das hat wahrscheinlich noch keiner mit Postrequest ausprobiert richtig
Weil ich wüsste echt nicht, was hier wirklich
Ne?
das ist sehr minimalistisch was da schief gehen kann manchmal geht's manchmal nicht
aber wenn es geht dann super langsam machen wir mal okay mein buffer von 128 ist auch
ziemlich pk 1024 okay das ist noch eine halbwegs sinnvolle größe und jetzt machte einfach gar nichts
mehr da stimmt doch was nicht leute wenn ich sowas in der ausgabe schon drin sehe da ist
auch irgendwas richtig leute hier guckt euch das mal der crash by the way nicht ja er macht
aber auch nichts mehr also da stimmt irgendwas nicht da ist irgendwas kaputt wir machen das
jetzt noch mal 128 irgendwas im arsch und mama github issues er ist ein kendler file upload
reading data das ist return any das kann man nicht sagen bei mir gibt es schon data
aber das kann man nicht sagen bei mir gibt es schon data aber das kann man nicht sagen
aber das kann man nicht sagen bei mir gibt es schon data aber es fand dann nicht es gibt data
aber dann crash 6 ist 4096 das sollte dafür eigentlich reichen aber er war in receive 11
er war in receive 128 genau das habe ich auch ist es etwa ein bug gibt ein patch oder andere
welcher patch ist doch was ganz anderes aber hier gibt es ein hier gibt es ein pull request dafür
um das problem zu fixen prevent konkurrent access to socket use denn er ist ja aha dann lasst uns
doch mal angucken was da eigentlich kaputt ist der fix ist relativ easy so wie es aussieht ok also für
mich sieht das so aus als checken die nicht ob das ein asynchroner request ist und die greifen auf den
gleichen request von ihrem http management thread zu
während der asynchronen läuft und sachen upload deswegen würde ich sagen leute wir
erfreuen einfach mal den patch oder und gucken ob so funktioniert patch eightypower şeyler so kann
ich den patch platte kommen wir müssen wir müssen uns das nochmal klonen master oder haben jetzt den
patch rein dann schauen wir mal funktioniert dasasa ich jetzt relativ easy ausprobieren so welcher ist
das plays played while rendering
von dem branch hat auch nur ein comet drin okay das dürfte easy sein
schauen wir mal ob das ganze funktioniert mit mit diesem patch
applied wie viele esp installation habe ich jetzt hier eigentlich fünf
könnte das auch einfach ins 553 apply oder muss das nicht wirklich neu klonen
abiklons war neu dann wurstel dann wurschtel ich nicht einem stand rum der
eigentlich dem release tag von denen entspricht nicht dann irgendwann fängt
das vergesse und ich frage warum sich funktioniert weil ich vor habe ist ein
web server auf dem sp 32 und also wifi web server und auf dem web server dann
was hochladen allerdings asynchron so dass man mehrere sachen gleichzeitig
hochladen kann das ist ein ganz neues feature das gibt es seit zwei wochen in
esp df das wollte ich mal ausprobieren und wir haben schon festgestellt es
gibt wohl noch einen kleinen bug
den man wohl fixen kann mit dem patch aus diesem pull request und das
probier jetzt mal aus ob das funktioniert drei stunden später
upa masteristen wie pr pr
idir smart update herr als mal geht es pode
auf welcher branche hat er das
nicht auf master okay wir kopieren uns einfach den kommentar jetzt cherry pick
in patch okay wir möchten nichts schmeißen dann wieder weg ich hätte
auch das jemand das ist wurscht wir haben jetzt im prinzip nicht lockt
das im prinzip den patch pleite von dem du noch mal oben drauf ja okay dann
probiere das doch mal aus jetzt haben wir unsere spdf mit den zusätzlichen
patches schauen wir mal master export export etwas gucken da so export flash
der es war clean flash so wir haben esp ok wir haben sogar schon version 5.4
weiß ich ob es gerade gesehen habt aber wahrscheinlich
nicht so gut ist aber ich weiß nicht ob ihr das gesehen habt aber wahrscheinlich
nicht so gut ist aber ich weiß nicht ob ihr das gesehen habt aber wahrscheinlich
hat master immer die version nach dem nach dem letzten tag da haben die
bestimmte magic drin so haben auf jeden fall den richtigen stand es scheint auch
noch alles zu kompilieren jetzt bin ich mal gespannt leute chat
predictions meine das funktioniert mit dem patch jetzt oder es ist ein fehler
bei mir und ich habe irgendwas verkackt ich bin da unschlüssig schau mal chat
meines funktioniert nicht okay naja gucken wir mal zack
das sieht gut aus das sieht gut aus
also einfach random patches von github auf geht's okay jetzt nachdem das jetzt
funktioniert können wir die buffer sei es auch um alle busy größer machen würde ich sagen also 1024
also 1024
also 1024 buffer sei es ist glaube ich echt ganz in
buffer sei es ist glaube ich echt ganz in
buffer sei es ist glaube ich echt ganz in ordnung oder wir können sogar 2048 buffer
ordnung oder wir können sogar 2048 buffer
ordnung oder wir können sogar 2048 buffer sei es machen aber dann müssen wir auf
sei es machen aber dann müssen wir auf
sei es machen aber dann müssen wir auf jeden fall die stack sei es von unserem
jeden fall die stack sei es von unserem
jeden fall die stack sei es von unserem task etwas vergrößern
task etwas vergrößern
task etwas vergrößern naja wir haben 4096 text als das könnte
naja wir haben 4096 text als das könnte
naja wir haben 4096 text als das könnte gerade noch so hinhauen
gerade noch so hinhauen
gerade noch so hinhauen probieren wir mal aus flächen war auch
probieren wir mal aus flächen war auch
schon mal schneller so ist es gecrasht gerade der körper flohach mist ok sex heißt es reicht
doch nicht also stacks es kommen wir machen der kriegt er kriegt jetzt mal mal 3 12.000
er ist das ist im prinzip wie viel ich weiß dass es nicht wirklich stimmt ja aber wie viel ram so
ein thread verwenden darf stimmt nicht wirklich weil heap memory kann er immer allokieren wieder
will es egal wie groß sich die groß die stacks als es aber ganz grob gesagt ist das wie viel
ram so ein einzelner thread verwenden darf jetzt sind es 12 km sie kommen und jetzt geht das auch
viel schneller seht ihr das jetzt ist es schon fertig gleich fertig jetzt auf
wir schicken übrigens keine antwort dass wir fertig sind sollten wir vielleicht noch mal
machen send was habe ich hier content wie html oder so das sollte man noch machen jetzt ist
nicht geht's wir wir antworten mit angeblich mit html ok und jetzt senden wir ja omega keckel als
antwort man sollte kölner nicht mehr hängen ich habe scheint zu funktionieren und übrigens
diesen krempel mama raus das wird sonst so schlecht lesbar aber ich würde sagen der patch hat das
gefixt jetzt müssen wir nur noch hoffen wir könnten jetzt mal in den merch request gehen und reinschreiben
fix mal ich bin ja nicht eingeloggt bin ich auf dem zweiten rechner eingeloggt weil ich würde ich
würde ist so ob das richtige haben jetzt bin ich eingeloggt na gut weil ich finde es immer ganz sinnvoll
wenn man ein bisschen feedback auf die pull request schreibt selbst wenn man nichts mit der
entwicklung zu tun hat weil oftmals wissen nicht so genau tut es jetzt tut es nur bei dem einen würde
das eigentlich reinschreiben dass das auch bei mir den fehler fix sagt boom kommentiert wie schnell
es jetzt geht asynchron easy so und wisst ihr was das jetzt omega keckel passt wisst ihr was das
heißt ist jetzt kann ich mehrere dateien parallel hochladen nicht dass ich das bräuchte aber um zu
beweisen dass das asynchron funktioniert sagt
seht ihr paralleler asynchroner asynchrones handling von post requests das ist mega nice das gefällt mir
dass das so in anführungsstrichen so einfach jetzt funktioniert wenn es denn funktionieren würde also
wenn es funktioniert ist es einfach leider ist das aktuelle noch verbuggt und man braucht noch
ein custom patch chat ist das mission accomplished nee das ist nicht mission accomplished mission
accomplished ist erst wenn es über https geht also http wir brauchen wir wollen das ganze jahr als
mit tls machen also machen wir das ganze jetzt mal mit https das brauchen wir nicht das brauchen wir
das brauchen wir das brauchen wir das brauchen wir ja müssen wir die zertifikate inkluden das verstehe
ich muss okay nice und jetzt wollen wir sagen ssl start okay und jetzt sollte der webserver mit https hochkommen
und ich sollte das ganze auch über https machen können https trauma wenn das funktioniert dann
mission accomplished wir haben natürlich aber wir verzeihen dass den espresso china chinesen war dass
es nicht funktioniert weil das ist noch ein ganz neues feature und es ist noch nicht released es
ist noch in einem erz ist quasi rc 15 53 rc 1 drin das ist okay dass es gerade kaputt ist
also ich habe ja selbst sein zertifikate es geht es ist eine ganze ecke langsamer über ssl das wundert
mich persönlich okay über ssl hat so ein paar kleine probleme wie es aussieht wenn er out of
memory wer würde wieder crashen aber wir können wir können immer trotzdem hier oben nochmal 512
bei das wird es eigentlich nicht sein aber irgendwas verpeilt
ich meine viel mehr kannst du nicht machen um den server umzustellen auf https als genug stacks
wüsste ich jetzt nicht was da kaputt ist aber nochmal vielleicht doch ein bisschen wenig speicher
gehabt kunst kein ding geht laden wir mal laden wir mal zwei sachen parallel hoch kunst dann sieht
du an den zahlen dass die unterschiedlich sind funktionieren auch über https easy easy easy
sehr nice mission accomplished würde ich sagen kein crash nix asynchrone datei uploads parallel
auf dem microcontroller finde haben die schön gemacht ist easy zu handhaben sofern es funktioniert
ja also das ist wirklich sehr übersichtlich im prinzip brauchst du eigentlich das hier ist das
hier ist zeug dass das überhaupt wifi sich verbindet im prinzip brauchst du nur den brauchst du nur dann web
starten den händler registrieren einmal am anfang sagen hier einmal am anfang anfangen sagen es
und start essen beginn dann machst du hier wie als wäre es ein synchroner request dein krempe
am ende sagst du komplett das ist wirklich easy also da kannst du nichts sagen das haben die gut
gemacht es ist zwar noch verpackt in der aktuellen version aber ich gehe stark davon aus dass bis zum
release von 53 das gefixt ist
easy nice chat das war's mission mission complete für heute kann ich firmware update bauen über http
für den controller chat gibt es noch irgendwas wichtiges irgendwas was ihr wissen wollt zu dem
was wir gemacht haben oder allgemein weil wir nicht neue folge dr bauer ich muss dir ehrlich
sagen ich finde das nicht lustig ich habe das ein paar mal als shorts empfohlen bekommen keine ahnung ich teile da den
humor nicht unbedingt also auf der einen seite ist das was wo ich mir denke das ist was was ich eigentlich
potenziell lustig finden müsste aber ich finde es nicht lustig ist genauso wie ich anscheinend auch
der einzige bin der die office nicht lustig findet mit welcher lib hast du den web server erstellt ja
das ist ja das beste das ist eingebaut in esp edf muss hier du musst den passenden händler inkluden
von denen das liefern die mit
und dann kannst du deinen web server erstellen mit wo ist er hier im prinzip ist dass ich das ist alles was ich
gemacht habe start web server und dann hier den händler für den upload das liefert esp edf mit also
eine sache musst du machen wenn du https verwenden willst du musst in die config von einem projekt
gehen und sagen https hier enable https server component das musste einschalten nginx ja klar
auf msp 32 nginx embedded nginx fork ja growth strike habe ich mich schon morgen drüber ausgelassen
also gao stmo das ist mittlerweile ist das standardmäßig dabei also ein http web server
haben die schon ganz lange schon jahre mit dabei ein tls fähigen web server auch schon lange und
jetzt seit neuestem seit dieser version und die ist noch nicht raus weil wir mussten sogar noch
dass es funktioniert einen patch von github einspielen dass das vorgesehen ist
quasi hotfix patchen dass es funktioniert jetzt kann man sogar http post requests asynchro
handeln lassen von dem web server auf dem micro controller also sprich wie du hier siehst ich kann
zwei post requests parallel laufen lassen ich bin ein bisschen blöd weil ich habe die ausgabe schon
ausgemacht hier oben du kannst zwei wenn er sich war jetzt hat er sich gerade nicht zum wlan verbunden
mir guckt du kannst zwei oder bis zu sieben parallele request bearbeiten lassen von dem
von dem web server und das finde ich es für ein bild bild in stadt quasi nennen wir es mal standard
library web server echt ganz nice der micro controller ist nicht der schwachbrüstigste das
ist das würde aber auch nur in normalen esp 32 funktionieren sieben auch noch bei https da bin
ich mir nicht so ganz sicher warum wir mal gucken
wir können nicht gucken nicht gescheit gucken aber es müssten sieben seien auch bei https ja die sache
ist ich weiß nicht ob der ram reicht's den hat glaube ich ja nur 160 kilobyte ram ja doch doch
müsste reichen können ja das kann man tatsächlich noch ausprobieren wir können ja mal hier dieses
status update rausschmeißen dass uns das nicht so viel nicht so voll spannt ja hier dass das
remaining machen wir mal raus und in main lassen wir uns jetzt mal unsere
hieb sei es ausgeben vom spp get free hipster ist er will hieb sei es in
beiz ob mama guck mal wie viel viel viel haben wir noch frei haben dynamisch ok
ohne alles haben wir ok so irgendwas um 167 kilobyte frei so in dem dreh machen
wir mal ein paar requests wie schnell er ist der ist viel zu schnell jetzt so
schnell so schnell bin ich ja gar nicht ja das ok so ein request ist schon leute
habe ich ein memory league naja bin ich also ein request frist schon
drei
30 30 30 kilobyte so ungefähr schwer zu sagen
so initial beim beim verbindungs aufbaut frist ist mal kurz 30 kilobyte danach
weniger wir müssen das wir müssen das langsamer
machen das ist das geht zu schnell das geht sicher wir müssen irgendwie das
lieb hier rein machen hier 100 millisekunden delay das sollte es lahm
genug machen dass wir ein paar curls starten können gucken wie viele curls
wird zum laufenden
laufen bekommen und wie viel haben wir dann ab wann der ram quasi ausgeht ok
wifi verbunden hier fünf ok da geht bloß fünf requests da gehen nur fünf
requests mehr geht nicht also da kriegen wir da kriegen wir da gehen wir
noch fünf request durch und dann hat er noch ein bisschen rahmen übrig hat er
irgendwas memory liegt guck mal an die request karten gerade ab und jetzt wird
freigegeben ok
mit ssl kriegen wir bloß fünf request parallel was aber auch vollkommen
ausreichend ist für so einen kleinen micro controller und noch noch mal will
ich hatte keinen bock super alter das braucht 50 das braucht 15 also ungefähr
man weiß nicht so genau und zwischen 550 und 30 kilobyte o request er als geno
4 also vier parallele request weil es vorbei was ist denn hier da ist ein
es geht nur vier also vier parallele request dann ist vorbei
es ist nur eine Frage für die die es gibt wie viele request an die wir haben
Was ist denn da so groß? Ich würde mal sagen, der ganze SSL-Kontext-Zeug wird wahrscheinlich einiges an RAM brauchen.
Also wir reden ja hier von Kilobyte, das sind ja Bytes, was mir hier angezeigt werden.
30 Kilobyte kann doch sein.
Und das ganze Encryption-Zeug und alles mögliche, was da im RAM gehalten werden muss, kann ich mir schon vorstellen.
Es ist auf jeden Fall eine ganze Ecke ressourcenintensiver als plain HTTP.
Aber ich würde es trotzdem immer über HTTPS machen, weil das Ding hat ja letztendlich genug RAM.
Das ist jetzt ja nicht gerade wenig, was das Ding für so einen kleinen Microcontroller hat.
Und gerade wenn du darüber dein WLAN-Passwort setzt, über dein Accesspoint, dann ist es halt immer nice, wenn es über HTTPS ist.
Da kann es halt niemand abgreifen.
Auch wenn es eher was Theoretisches ist, aber es ist dann halt ausgeschlossen.
Nahezu ausgeschlossen.
Aber Leute, ich bin happy. Das funktioniert gut.
Hätte ich nicht gedacht, dass es so easy ist.
Da haben die sich echt schöne API überlegt, wie man das machen kann.
Dass man dann Custom-Patch einspielen muss.
Ja, so what.
Alles klar.
Chat.
Schön, dass ihr dabei gewesen seid.
Ich gehe jetzt auf.
Mal runter aufs Klo und wir hören uns.
Bis dann. Macht's gut.
See you.
