Pok, Pok.
Pok, Pok, Pog, Pog, Pok.
Pok, Pok, Pog, Pog.
Pok, Pok, Pog, Pog.
Pok, Pok, Pog, Pog, Pog.
Pok, Pok, Pog, Pog, Pog.
Ich muss gerade mal warten,
bis mein Browser geupdatet ist
auf der anderen Seite.
radiant Bass.
Kag Wait.
Keg Waiting,
dass mein Browser geupdatet ist.
ich gebe zu, Freitag
12.16 Uhr ist vielleicht nicht so der
normalste Zeitpunkt zum Streamsauen
für mich. Aber warum
nicht, ne?
Ja, ich hab Urlaub,
richtig. Ich hab
Urlaub seit...
Ich mein, letzter Arbeitstag
war
am 24.
Wobei, also
streng genommen letzter Arbeitstag
war am 24.
Aber ich hatte ja quasi hier
nochmal Bereitschaft
und hier hatte
ich nochmal Teambuilding-Workshop.
Also insofern... Oh Leute,
das war wieder was, ey. Ich sag's euch.
Kann ich euch dann erzählen.
Kann ich euch erzählen.
Wobei, es ging.
Es war bisher...
Es war nervig wie alle Teambuilding-Workshops,
aber insgesamt muss ich sagen,
war das tatsächlich noch der beste Teambuilding-Workshop.
Marabuna
518. Moin.
Düdü.
Düdüt. Düdü. Düdüt.
So. Und...
Deswegen, also so, sag mal so,
Soft-Urlaub
hab ich quasi schon seit 24.
Aber so richtig hart Urlaub, also wo dann auch
wirklich gar nichts mehr ist,
hab ich quasi seit
gestern.
Was war so toll bei dem Teambuilding?
Naja, wie gesagt... Wartet mal kurz.
Hä?
Monk HS.
Was so toll beim Teambuilding war?
Naja, es war nix toll.
Es war nur weniger nervig.
Also toll hab ich's trotzdem nicht gefunden.
Ich mag solche Sachen einfach nicht.
Aber insgesamt
war's tatsächlich ganz, ganz, ganz
okay. Ja, wir haben natürlich
wieder irgendwelche komischen Spielchen gemacht.
Also wir haben... Passt mal auf, passt mal auf.
Ähm...
Typisches, typisches Teambuilding-Spiel,
was wir gemacht haben.
Wir hatten zwei Teams. Also, ne?
Wir waren als ein Team da, aber wir wurden aufgeteilt
in zwei Teams.
Und beide Teams mussten
einen Atomreaktor
fixen.
Natürlich war das logischerweise
kein echter Atomreaktor
und hatte mit Vorfällen in einem Atomreaktor
auch gar nichts zu tun.
Aber das ist so eine typische Story, die gerne bei solchen
Spielchen auf
auf Teambuildings gemacht wird.
Also, das ging voll in der Maßen.
Das ging voll in der Maßen. Also, guckt mal.
Beide Teams...
Beide Teams hatten
einen roten Kreis auf der Erde.
So. Äh, einen orangen Kreis
auf der Erde. Das war der
Atomreaktor.
Und in der Mitte...
In der Mitte...
Was ist das hier? Warum macht es so komische Dinger?
So, und in der Mitte...
In der Mitte stand eine Flasche.
Ich mach jetzt... Das wird kein
Bubar, Leute. Es wird kein Bubar-Bild.
Sieht doch vielleicht ein bisschen so aus. Okay, kein Bubar.
Ja? So.
Also, in der Mitte stand eine Flasche
und da drauf...
Da drauf
lag ein Ei.
Okay?
Okay? So. Und dann hast du
einen Rucksack bekommen. Das zweite machen wir einfach
wieder weg. Und dann hast du...
Alter, Paint. Mein Gott, Paint ist...
Ich bin nicht wirklich traurig,
dass Paint weg ist. Naja, zumindest
hat man dann einen Rucksack bekommen mit Teilen
drin.
Und man musste quasi
mit den Teilen aus dem Rucksack
musste man was bauen
im Team zusammen.
Wie man das Ei
ohne dass es kaputt geht
von der Flasche bekommt aus dem Kreis
raus
und danach die Flasche rausbekommt
ohne dass es kaputt geht.
So. Und da
hatte man dann so Sachen drinnen
wie
ein bisschen... Also, eine Schnur war drinnen.
Es war
ein Kleiderbügel drinnen.
Eine Mausefalle. Ein paar Kabelbinder.
Was es mit dem
Atomreaktor zu tun hat. Also,
es hat insofern was...
Du darfst nicht in diesen Kreis
reingehen, weil verstrahlt so
nach dem Motto. Du musstest das alles
von außen machen. Und wir haben das
ohne Scheiß... Ich glaube, wir haben das mit
am schnellsten von allen Teams, die es jemals
gegeben hat, gepackt, weil
wir haben einfach alle Teile links liegen lassen
und haben uns die...
Die...
Wie ist das? Da war so eine aufgewickelte
Schnur drinnen. Wir haben
die Schnur einfach abgewickelt.
Einer ist hierhin.
Einer hat es hierhin gestellt.
Einer hat es hierhin gestellt.
Mit der Schnur drüber gespannt. Wir haben erst
dann mit der Schnur langsam das Ei runter
gekickt. Das ging,
weil das war auf dem Gras.
Es ist nicht viel passiert mit dem Ei.
So. Dann haben wir an die Schnur
ein bisschen Metall dran gemacht, das quasi
hier immer weiter raus
gedingst, das Ei.
Und danach sind wir mit der Schnur einfach
ein paar Mal im Kreis gelaufen,
bis sie sich um die Flasche gewickelt hat. Dann haben wir die Flasche
rausgehoben. Also, das hat
wie, keine Ahnung, acht Minuten gedauert
oder so. Dann war das fertig, obwohl 30
angesetzt waren.
Naja, das
ist ein typisches Teambuilding-Spielchen, ja?
Typisches Teambuilding-Spielchen.
Jemand Oracle
pfeifert euch, hoffe ja nicht.
Ich habe keine Ahnung.
Und ich fasse Datenbanken auch nicht an, weil ich weiß,
dass ich davon keine Ahnung habe.
Ihr wisst, wie das ist. Es ist wichtig zu wissen, wenn man
keinen Plan hat.
Und von Datenbanken, also
insbesondere natürlich auch Oracle,
weil da kommst du ja nur dran, wenn du
viel Geld hast. Aber
so alles, was es da gibt,
ja, ich meine, von Postgres habe ich zumindest aus
Anwendungsentwicklungssicht noch ein bisschen Ahnung.
Aber von Oracle gar nicht.
Deswegen halte ich da echt die Finger von weg.
Ja, SAP HANA ist auch ganz, ganz
grausam, Alter.
Bei uns auf der Arbeit gab es eine Diskussion,
was man nehmen sollte. Pass mal auf, müssen wir uns mal vorstellen.
Gab es die Diskussion,
was man nehmen sollte für irgendeine Anwendung?
Ich glaube, es war keine neue Anwendung, aber sollte umgebaut
werden. Gab es die Diskussion,
Oracle, SAP HANA,
Sybase
oder Postgres?
Und da haben wir uns
alle angeguckt und haben gesagt, naja,
obviously Postgres, weil
macht alles, kann
alles, funktioniert,
ist etabliert,
kostet nichts,
läuft auf Linux. Also im
Prinzip so, warum?
Warum denkt ihr überhaupt über die anderen
Optionen nach, wenn ihr einfach Postgres
nehmen könnt?
Am Ende hattest du dann da wirklich Leute drin,
die, die ultrakrasse
SAP HANA-Fans waren. Ich kann das nicht
verstehen. Ich habe damit noch nie was gemacht.
Ich will damit auch nichts machen.
Allein schon, weil es SAP ist und wahrscheinlich wieder
30 Trilliarden kostet.
Und Oracle will man
sich auch nicht mehr ans Bein binden, als notwendig
ist. Und irgendeine uralte Sybase-Version
von 1995, erst recht.
Warum nicht, also warum nicht einfach
stinknormales Postgres, wenn es doch schon
zur Auswahl steht?
Aber war's nicht, war's nicht. Ey, ist echt,
ist echt. Böses Enterprise-Keckel
teilweise.
Am Morgen wird MMO gecrindet.
Ich weiß nicht, ob ich MMO im Stream ein bisschen
crinden soll, weil das ist ultra langweilig
zum Zugucken, kann ich euch sagen. Das ist das
langweiligste, was es gibt, ey.
Leute beim MMO-Kreise-Crinden zu gucken.
Zuzugucken.
Postgres macht keine Werbung. Naja, gut.
Postgres hat keine Lobby-Arbeitsleute,
die vorbeikommen und, also
Postgres hat keine so, so, so
Lobby-Abteilung, Sales-Abteilung, die ankommt
und dir das schmackhaft macht. Ja, da
stimmt, das stimmt schon, ja.
Aber in dem Fall mussten es ja nicht mal
irgendwelche CEOs entscheiden, sondern wirklich
Leute aus der Technik. Und wie man da
ernsthaft auf die Idee kommen kann,
SAP oder Oracle versus
Postgres, also, verstehe ich nicht.
Das ist überhaupt eine Frage, dass es überhaupt
die Frage gibt, verstehe ich nicht.
Wenn du Postgres nehmen kannst, sollst du
immer Postgres nehmen.
Raspberry Pi 5 sind es verfügbar, ich weiß, ich hab's gesehen.
Da habe ich trotzdem noch keinen gekauft.
Was sagt denn, was sagt denn Barry Base?
What the
Pi 6?
Warum habe ich am Raspberry Pi 6
gesucht?
Okay.
Die sind nicht
verfügbar.
Ja, die
Sortierbarkeit war hier auch schon mal
besser. Ja, ja,
wir machen gleich, wir machen gleich weiter.
Ich muss den ganzen, ich muss erstmal Betriebssystem
OS-Update machen.
OS-Update.
Eggman-Update.
Dings-Update.
Sonst noch irgendwas Update?
Ähm,
ich weiß nicht, was das ist, aber irgendwas, was wir nicht
mehr brauchen.
Weiß auch nicht, warum das installiert ist.
Wenn nicht, war das mal als irgendeine
Dieb...
Okay, wahrscheinlich,
wahrscheinlich wurde das
mal wegen irgendeiner
Dependency
mit installiert, hä?
Ach komm, ich lass, ich,
naja, ich aninstall das einfach.
Wird sich schon wieder installieren,
wenn man's braucht. So,
also, Packages sind geupdatet.
Wichtigster Check, ASCII-Quarium geht noch.
ASCII-Quarium nach LOLCAT gepiped,
geht auch noch gut. Nice, Reboot-Time.
Meinst du nicht?
Aber zeig mal, hier, wenn die lieferbar sind.
Ja, Starter-Kit braucht keiner.
Ja, doch.
Doch, Starter-Kit. Starters brauchen Starter.
Ja, wenn die noch ein Netzteil brauchen, vielleicht,
oder so, ja, dann. Ich mein, es bietet sich an,
für den aktuellen Raspberry Pi 5 auch ein Netzteil
zu kaufen, weil die
haben ja zum ersten Mal,
also, nicht zum ersten,
aber jetzt zum wiederholten Male
bisschen, bisschen mehr
Maximum Leistungsbedarf,
aber
das brauchen die ja meistens
trotzdem nicht. Also, ich würde
beim Raspberry Pi mit meinem alten Netzteil
ins Rennen gehen.
Das geht, glaube ich, immer noch
voll klar. Was kostet
das Starter-Kit?
Starter-Kit
kostet Raspberry Pi
ja, vier gigreichen Digge.
Äh, SD-Karten,
Power-Sub-Platen, Case. Das Case ist halt auch
kacke.
Ja, sowas geht vielleicht noch nicht.
Ich, ich,
ich würd mir ja sofort wieder das
Flir-Case kaufen.
17 Euro.
Also, ich würd mir ja wieder, das gibt's ja auch
schon für den Fünfer-Pi-5
Flir-Case.
Ja,
das da würd ich mir wieder kaufen.
Das geht voll klar. Gibt's auch
für Raspberry Pi 5.
Ah, nee, das ist für den Vierer.
Aber ich hab's letztens, ich hab's doch letztens
auch schon für den Fünfer gesehen.
Himba Pi Fall Gen 2.
Alles klar, genau, das brauchen wir.
Himba, Himba Pi
Fall Gen 2. Ah, das ist sogar
fürs, fürs Dreier.
Also,
ich hab das, ich hab das auf jeden Fall gesehen,
dass es auch fürs
für den Pi 5 schon gibt.
Eher Flir-Case.
Das ist für den Zero.
Aber guck, die haben auch, die haben auch
ein Pi 5 Case. Das ist, das ist
so mein To-Go,
äh, nee, To-Go ist das, also, falsches Wort.
Das ist so mein, mein
Default Raspberry Pi Case.
Ich find das Ding super. Das sieht gut aus.
Nicht, dass es so entscheidend wäre, aber es sieht
clean aus. Du kannst unten dran relativ
gut noch ne, ne SSD
pappen, SATA-SSD,
beziehungsweise auf USB
SSD pappen. Ist auch genug Platz.
Oder legst du oben drauf, nimmst da so ein bisschen
Klebeband, machst dran.
Und dadurch, dass das gesamte Gehäuse
Alu ist, Kek, Kek-Alu,
Ups, meine E-Mails sind vielleicht grad ein bisschen groß,
weil das Kek-Alu-Case
ist,
verteilt sich die ganze Wärme auch gut rüber.
Also, aber Leute, die ein Raspberry Pi
quasi
24-7 auf, ähm,
hoher CPU-Last laufen lassen wollen,
also mit 80% plus
CPU-Auslastung, dann ist das Case nix.
Das Case, dadurch, dass es so einen großen Metallkörper
hat, ne, verteilt die Wärme ganz
gut und hilft auch ein bisschen, die besser abzutransportieren.
Aber natürlich wird's auch
mit der Zeit zu heiß, wenn du's
volle Pulle 24-7 in einem schlecht
belüfteten Raum laufen lässt, das ist ja klar.
Aber das sind ja
die aller, aller, allermeisten Raspberry Pis
nicht. Du brauchst
dein neues Netzteil, weil der Raspberry Pi 5
einen USB-C-Anschluss hat. Ne, brauch ich nicht.
Weil ich ein ganz normales
China-Chinesen-USB-Netzteil
verwenden würde
und dann ein
USB-C-Kabel anschließe.
Also ich hab Berge,
ja, ich hab
Berge von denen hier,
ich hab aber auch welche mit Quick-Charge
und bis zu
was ist Quick-Charge?
Bis zu 20
20 Volt
5 Ampere oder sowas?
Irgendwie so? Ja, genau.
Ja.
Also sie können sogar Quick-Charge, also die sollten
da nicht auseinanderfallen,
wenn ich den
Raspberry Pi dran anschließe.
Zur Not habe ich noch meine Steckdosenleiste hier,
die hat auch USB-Anschlüsse.
Also insofern, ich denke, ich bin für den Raspberry Pi
gerüstet. Fünfer.
Aber dazu müsste ich mir erstmal einen Fünfer kaufen.
Ja, macht's auch.
Kennst du? Ja, kenn ich.
Kenn ich. Ja, ja.
Kenn ich.
Hab ich aber noch nicht mitgemacht.
So, jetzt,
jetzt geht's los. Jetzt hören wir mal. Rust.
Wobei, bevor wir, wir machen
vielleicht, vielleicht erstmal
die Docker-Geschichte. Bin mir gar nicht
sicher, wo wir stehen geblieben sind. Wie immer,
ihr müsst nicht wirklich bei den letzten
Streams dabei gewesen sein, weil das ja immer ein bisschen
unabhängig voneinander ist.
Schadet allerdings auch
nicht. Das heißt, wenn ihr öfters dabei sein wollt,
könnt ihr ein Follow dalassen.
Postchamp. So, also
ich muss erstmal den ganzen Krempel starten.
Repos. Campchamp.
Hier haben wir ein paar uncommittete Sachen
drinne. So, hier machen wir
Rider auf. Für unser
.NET Backend.
Hier machen wir Rust
auf. Für unser Low-Level-Web-RTC
Zeug.
Wie kommt's?
Ich zeig dir gleich, was Sache ist.
So, Rust. Und hier brauchen wir
Visual Studio Code für unser Frontend-Zeug.
Und zack, bumm, sind schon nochmal
80% RAM voll wahrscheinlich.
Haben wir hier einen Chrome. Oh, es
laggt. Es laggt.
Alter.
Die VM, man.
Was ist mit dem
1CPU-Core los hier?
VM? VM, was ist?
Kriegt ihr schon mal wieder ein?
Das da oben ist meine CPU-Auslastung. Also 8 Cores
und jeweilige CPU-Auslastung.
Was zum Teufel geht da im Hintergrund gerade ab?
Ah, Jetbrains.
Jetbrains macht's.
Jetbrains-Java-Dinger.
Mit Vim wäre es besser.
Ne.
Die CPU-Auslastung, ja.
Aber die Möglichkeiten,
angenehme Sachen zu benutzen, eher nicht.
Es sei denn, du fragst
die Hardcore-Vim-Fraktion
hier auf YouTube, die für alles,
was Vim-Only macht.
So.
Also.
Dann müssen wir noch unseren RTSP-Server starten.
Den haben wir, den hatte ich hier, glaube ich,
hatte ich ein neues Tab auf.
EMP.
Dann hatte ich da den RTSP-Server drin.
Ja, RTSP.
So.
Da liegt hoffentlich auch das Video drin.
RTSP-Server starten.
FFM-Pack.
Restream.
Plub 2. Ne, das TS-File
haben wir gestreamt, gell.
Okay, und jetzt schauen wir mal, ob alles funktioniert.
Local Host,
Port 80. Achso, ich muss
die Anwendung ja noch starten.
Tab. Das ist ein ganz schön
langes Setup hier, bis es funktioniert.
Okay.
Run. Jetzt schauen wir mal,
ob der Kram an sich noch funktioniert.
Dann erzähle ich mal kurz was zu.
Okay, Prage.
Okay, es funktioniert. Nice.
Also. Wir streamen das Video
in den Browser.
Alles gut. Schon frei.
Ja, seit letzter Woche Freitag eigentlich
die Arbeit vorbei. Aber ich hatte dann noch
eine Woche als Wochenende Bereitschaft und jetzt
noch zwei Tage Teambuilding. Also
so richtig
Hardcut so Urlaub. Erst seit
gestern. Ja, und seit
morgen
So ist es. Und
morgen muss ich da ein bisschen MMO-Kreisekund machen.
Es hat jemand gefragt vorhin, welches
MMO
irgendwo
hier
hier
der ältere Meier hat.
Gefragt. Bist du noch da? Welches
MMO kann ich dir sagen? Ich spiele
ab morgen wieder
Dark in
Dark Age of Camelot.
Das Spiel ist älter als
viele von euch im Chat. Das kam 2001
raus. Vor 22
Jahren, Alter.
Und ich hab's
zu EU-Release angefangen zu spielen
und spiele es eigentlich durchgehend immer wieder.
Bestes MMO ever.
Ever.
Nee, gab noch keine Diskussion
über die Azubi.
Über die FISI-Abschlussprüfung oder
Fachinformatik-Abschlussprüfung.
Nee, nichts. Ich war auch hier nicht
on seit
Montag.
Also gab's noch keine Diskussion
drüber. War noch keine Möglichkeit drüber
zu diskutieren. Und wie war die Abschlussprüfung?
War die
auch wieder unschaffbar wie die letzte?
Also unser Videostreaming läuft.
So, kurze Sache.
Ihr könnt euch gerne über die
Fachinformatik-Abschlussprüfung auslassen.
Da sag ich auch gleich was zu. Wenn ein paar Leute
First-Hands-Experience
da haben. Also, ich sag noch
ganz kurz was zur Anwendung. Wir werden das heute
verdockerisieren, dass ich das ordentlich testen kann
beziehungsweise ordentlich laufen lassen kann bei mir lokal.
Ganz, ganz kurz,
ganz simpel Übersicht, was es
gibt. Wir haben eine Anwendung am Start
mit etwas viel Debug-Output,
wie es aussieht. Wir haben
eine
ASP.NET-Webanwendung
für die, ja,
für das Frontend, also als API-Endpunkte
für das Frontend. Dann
haben wir eine Rust-Low-Level-Web-RTC-Geschichte
und wir haben ein bisschen JavaScript,
HTML, CSS. Was passiert,
ist folgendes in diesem Video nur
ganz kurz, also heute auch
nur ganz kurz.
Provider, ich kann
das nicht, ich kann das nicht. Keiner kann Provider
so gut aussprechen wie SemperVideo, äh.
Provider.
Ich kann's
nicht, das ist einfach original.
Ähm, also
im Prinzip, im Prinzip läuft's weiter.
Folgendermaßen,
Kamerastream läuft hier,
der Kamerastream, er hat, ich stellverdient,
gerade streamt er ein YouTube-Video von mir,
okay? Also, das hier, Kamerastream,
RTSP-Server, FFmpeg,
pumpt da ein Video rein.
Backend, das, äh,
.NET-Backend geht per FFmpeg
an den Stream dran
und liest den Stream
aus, dann baut es
mit dem Browser eine WebRTC-Verbindung
auf, mit Hilfe der Low-Level
WebRTC-Rust-Library.
Und dann streamt es das Video
in den Browser. Okay, so, so,
so funktioniert's gerade.
Das ist jetzt wirklich absolut High-Level-Overview.
So, nachdem ich das später ja
laufen lassen möchte,
in, in nem Container,
müssen wir das Ganze jetzt erstmal
vercontainerisieren.
Das heißt, wir brauchen jetzt
weder Rust, noch .NET, noch
JavaScript, noch
sonst irgendwas in der Richtung.
Deswegen stoppe ich die Anwendung mal wieder.
Und wir müssen uns jetzt mal ein Docker-File
aus den Fingern saugen,
das Sinn ergibt.
Ich glaube, dass das tatsächlich ein etwas komplizierteres
Docker-File wird,
weil,
.
.
.
Was ist denn jetzt los hier?
Das hört sich ja, hört sich ja fast schon hier
...mäßig an.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
Erlang, Fortran
Okay, das muss ich mal in Ruhe durchlesen
Ich schreibe mir das mal auf
Leute, ich schreibe mir das mal auf, vielleicht machen wir das
Vielleicht, vielleicht machen wir da echt mit
Ja
Warum nicht? Ist doch immer ganz nice
In was?
Was ist Vlang?
The V-Programming
The V-Programming Language
Ich sag V
Die V-Programmiersprache
Das sieht ein bisschen aus
Wie Go
Ehrlich gesagt
Das sieht Go doch
Also außer, dass es
FN ist und so, aber
Moment mal, ist Go oder Rust
FN? Ich bin gerade verwirrt
Moment
Rust ist FN, das sieht eine Mischung aus
Zwischen Go und Rust
Okay
Na, ich weiß ja nicht
Ja, aber
Das ist jetzt ja nur wirklich kein Aushängeschild
Von der Sprache
Wie groß der Compiler und wie lange es dauert
Den Compiler zu bauen, oder?
Ich meine GCC
Ich wollte gerade sagen
Alter, GCC ist halt auch wieder so ein Ding
Das dauert auch drei Stunden, bis das fertig ist
Was aber nicht heißt, dass wenn ich GCC benutze
Das schlecht sein muss dann
Wobei GCC checkt halt auch keiner mehr
Ist das so? Ich habe damit
Keine Ahnung, ich kann dazu nichts sagen
Okay, wir bauen jetzt ein Dogger-File
Auf geht's
Ich versuche mal
Ein bisschen was dabei zu erklären, okay?
Chatge, wer von euch
Hat
Viel Plan von Dogger? Also ich kriege das hin
Ich will bloß mal so grob wissen
Also machen wir es mal anders
Wer von euch würde sagen
Er ist der krasse Dogger-Container-Bau-Experte
Wobei man sagen muss
Streiche Dogger
Er setzt es einfach durch Container
Ja, weil Dogger hat ja
Außer als CLI-Tool
Mit den eigentlichen Containern und das
Wie das heute im Enterprise-Umfeld läuft
Eigentlich nur noch wenig zu tun
Also seid ihr die krassen Container-Bau-Profis?
Oder seid
Würdet ihr eher sagen
Würdet ihr eher sagen, naja
Ich habe schon mal ein Dogger-File
Erstellt, aber sonst nicht kompliziert war das nicht
Also war das nicht
War ein paar Zeilen und fertig ist
Okay, also, denn wir müssen jetzt
Ich versuche das mal zu erklären und dann hoffe ich
Dass es funktioniert
Also ich stelle mir das folgendermaßen vor
Wir brauchen ja
Moment
Muss ich mal gucken
Also, Ziel ist erstmal
Ich weiß nämlich nicht, wie lange ich Zeit habe
Vielleicht habe ich nur bis 15 Uhr oder 14.30 oder irgendwie so Zeit
Ziel ist erstmal, dass wir ein Dogger-File bauen
Was unsere Anwendung eben in ein Container-Image baut
Das bisschen
Unhandliche an dieser Anwendung ist
Ihr seht
Es gibt ein
Low-Level-Part in Rust
Das mit Go könnt ihr euch wegdenken
Das mit Go gibt es nicht mehr
Also das gibt es noch, aber das benutze ich
Benutze ich aktuell nicht
Das ist einfach nur da zum abgucken
Es gibt
Also es gibt eigentlich
Mehrere Parts
Wir brauchen einmal den Low-Level-Rust-Part
Und wir brauchen den .NET-Backend-Part
In Frontend ist noch nichts drin
Das habe ich mir mal angelegt
Falls ich ein bisschen mehr mache als eine HTML-Seite
Und in
Ja
Hier ist das Rust-Zeug drin
Und das Ding ist halt
Ihr seht schon
Die Dinger sind relativ gut
Die Dinger sind relativ groß
Also
Rust ist 2,2 GB
Erinnert mich ein bisschen an Node-Modules
Die installieren ja auch immer Gott in die Welt
Nicht ganz so schlimm wie Node-Modules
Node-Modules wäre das Ding wahrscheinlich
Eher 15G groß
Aber Rust haut auch schon mal richtig rein
So
Dann haben wir unser .NET-Backend
Und das war's
So und wir können jetzt halt nicht einfach hergehen
Und ein Docker-Image bauen
Die Anwendung drin bauen
Und das Docker-Image hochladen
Was heißt können wir nicht
Doch
Das können wir schon
Aber
Das machen wir jetzt auch
Dass ihr seht wo das Problem liegt
Das Docker-Image ist dann am Ende halt saumäßig groß
Weil der ganze Mist
Den wir hier drinnen brauchen um es zu bauen
Dann im Docker-Image landet
Das will man ja eigentlich nicht
Du willst ja eigentlich nur den Output haben
Kann man für Rust kein Docker-Ignore mitgeben
Doch kannst du
Aber du brauchst dieses ganze Zeug hier drinnen
Wenn du die Rust-Anwendung baust
Also das heißt du brauchst es dann auch
In den Build-Container
Und ein Build-Container gleicht
Der das
Als Basis für das Image verwendet wird
Sind die im Output-Image auch drinnen
Und dann hast du im Endeffekt dann Docker-Images
Die ja 3 GB groß sind
Das ist natürlich kacke
Das will man nicht haben
Deswegen wird es wahrscheinlich auf ein Multi-Stage-Build rauslaufen
Ich glaube so heißt das
Dass wir erst einmal Rust bauen
Dann .NET bauen
Dann die Sachen rüber kopieren
Und am Ende dann
Einen möglichst kleinen Container bauen
Doch doch doch
Ja ja
Also wir fangen jetzt erstmal an
Wie alle anfangen mit Docker-Files
Und zwar
Wir schreiben das mal untereinander
Und da werdet ihr auch gleich sehen
Wo das eigentliche Problem ist
Ich will ein Debian-Image
Nach Möglichkeit
Also wir fangen mal ganz unbedarft an
Wir nehmen ein Debian-Image
Installieren uns alle Abhängigkeiten
Kompilieren das und gucken mal wie groß das Image ist
Ich persönlich denke wir werden am Ende
Ein Multi-Stage-Build haben
Das offizielle Rust-Image
Für Rust zum Kompilieren verwenden
Das offizielle
ASP.NET-Image verwenden
Für das Output-Image
Und wahrscheinlich ein stinknormales Debian oder so
Um die .NET-Sache zu bauen
Oder ne Moment
Microsoft hat ja auch offizielle
SDK-Images zum Bauen
Wir machen das erstmal von Hand
Und dann verbessern wir das
Also from
Jetzt habe ich keine Ahnung
Debian-Docker-Hub
Wie da die Tags heißen
Bookworm
Bookworm klingt gut
Und das ist einfach Debian Bookworm oder?
Debian
Bookworm
Und mich einfach gleich an Rust damit füllen
Doch doch doch
Wie gesagt da wirds wahrscheinlich drauf rauslaufen
Da wirds wahrscheinlich drauf rauslaufen
Aber ich bin mir noch unschlüssig wie wir das überhaupt bauen
Also
From Debian Bookworm
Nenn ich mal ASP-Build oder sowas
Na es juckt
Wir bauen jetzt erstmal ganz
Simpel
So untereinander das was wir brauchen
Damit die Anwendung baut
Und dann machen wir es schön
Das es auch klein wird
Und das es nur das baut was es soll
Und rüber kopiert
Und das man dann auch sieht
Das es durchaus Sinn macht
Mal länger als 2 Minuten in seine Docker-Files zu stecken
Also ich würde sagen
Wir benutzen aktuelles Debian-Image
Weil Debian beste
Da haben wir sowas wie WorkDir
Kann man das eigentlich auch kleinschreiben?
Ich glaube man darf das kleinschreiben
Irgendwie habe ich mir das so angewöhnt
Das immer groß zu schreiben
Aber ich glaube man darf das auch kleinschreiben
Aber ich glaube man darf das auch kleinschreiben
Aber ich glaube man darf das auch kleinschreiben
Aber ich glaube man darf das auch kleinschreiben
Das kann man aber auch mittlerweile mittlerweile auch kleinschreiben
Die schreiben es auch groß
Guck hier in ihren
In ihren
Examples
Also wir fangen ohne MultiStage Build an
Wir fangen ganz simpel mit einem Debian-Image an
Und lassen es mal da drinnen bauen
Also
WorkDir
Machen wir mal sowas wie
Bild
WorkDir heißt
Alle Sachen
Anbefehle
Die jetzt hier
Hier
Da
Da
Hier
Da
Hier
Hier
Hier
Hier
Hier
Hier
Hier
Hier
Hier
hier kommen kannst du ausführen ohne dass du von cd reinschreiben muss ja
also wenn man jetzt zum beispiel so was hier macht wie copy oder sowas von a
nach b dann bezieht sich das automatisch auf bild was ganz ach so und es sorgt
dafür dass das verzeichnis glaubt sogar angelegt wird so als erstes weißen
debian image ist run up get update ok also docker bild punkt es ist noch
nicht viel passiert ab geht ab hat er jetzt wirklich geupdatet das erscheint
mir erschien mir ein bisschen bisschen schnell ok dann run up geht install was
brauche auf jeden fall wir brauchen bestimmt curl wie get curl und so und so
zeug
get bestimmt auch macht das jetzt was was y fehlt muss man machen wenn man das
ins krebs verwenden will ansonsten will ja nämlich dass man jetzt ein tippt und
man kann ich jetzt eintippen wenn es interaktive im skript läuft okay hat
funktioniert übrigens auch so ein ding doch verwendet ja seit ein paar version
bild kit also vielleicht kennt ihr noch docker bild von früher die waren ja dann
anders aus
auf jeden fall mittlerweile verwenden die ja glaube ich bild kit wenn es
verfügbar ist ich muss sagen mir hat der output früher besser gefallen als der
bild kit output der bild kit output sieht sehr fancy aus du hast recht das
ist sinnvoll falls irgendwelche rückfrage rückfragen wir abkommen ja ja
das stimmt das schenken wir uns jetzt mal weil ich wahrscheinlich das debian
image dann nicht verwenden wird ich weiß gar nicht ob man das zum alten output
wiederum formatieren kann
also wie geht es weiter wir installieren paar sachen ich bin mir nicht sicher was wir sonst
noch so brauchen so jetzt ich würde sagen wir bauen wir bilden erst mal rast okay wir bilden
erst mal rast damit man rast bilden kann im container also die die rast app wo sich quasi
alles was hier drin ist moment nicht alles was hierüber ist garantiert nicht alles was hierüber
ist weil dann kopiere ich auch zwei gigabyte alleine das will ich ja garantiert nicht haben
also ich will eigentlich nur aus web wie heißt das ding mein ordner aus web rtc rast will ich
eigentlich nur source und die cargo falls rüber kopieren cargo ist das npm von rast und in so aus
liegen halt fährt es gedacht so ausfalls also copy web rtc rast
machen wir mal irgendwie so was cargo sternchen dahin copy all docker ignore komme auch machen
aber es sind nur zwei sachen lieber kopieren müssen es sollte wahrscheinlich so auch gehen
so und dann so opieren wir über source ich glaube das muss man so nennen damit das funktioniert was
macht das denn es bezieht sich auf was was das rast programm rust was das macht das
sorgt dafür, wenn du ein Update machst und Rückfragen kommen in Debian, dass es die Rückfragen
halt einfach mit der Default-Antwort beantwortet, anstatt dass du eine Abfrage kriegst, weil
du kannst ja in einem interaktiven Skript, in einem Docker-Bild keine interaktive Abfrage
machen an den User, weil es gibt ja nichts zum Inputten. Also du hast zum Beispiel eine
Sache. Stell dir vor, du hast von Hand in deiner ssh-Config rumeditiert. Du machst
ein Upget oder ein Upgrade, was auch immer, eines der Update-Commands und dann sagt er
dir, hey User, du musst mir jetzt sagen, ob du die Default-Maintainer-Version der ssh-Config
installieren möchtest beim Package-Upgrade oder ob du deine Version behalten willst.
Ich glaube, die Default-Antwort ist, deine Version behalten. Wenn du das ausschaltest,
dann nimmt er immer die Default-Antwort und fragt dich nicht, weil er kann dich ja in
einem interaktiven Skript, was ohne dich läuft, nicht fragen. So, schauen wir mal, ob das
jetzt funktioniert, was ich hier gemacht habe. Bild. Ja, scheint funktioniert. Ist das nicht
durch den Parameter Y? Nur halb, das bezieht sich nur auf die Abfragen von Upt, beziehungsweise
von Upget. Wenn irgendwelche Packages, die Upt selbst upgradet, Abfragen haben, dann nicht.
Das bezieht sich nur darauf, dass du die Abfragen von Upt, die du selbst upgradest,
bezieht sich nur darauf, dass du nicht mehr Yes bei Upt eingeben musst. Okay, das hat funktioniert.
Dann ist jetzt die große Preisfrage, Chatge. Wie kriegen wir Rust in unserem Debian-Image
installiert? Ich würde sagen, Rust up. Perfekt, exzellent, das wollte ich haben. Gut, dass wir in
weißer Voraussicht schon mal Curl installiert haben. Was ist das? Run, Curl, Proto, HTTPS, TLS, V1.2,
SSF, X, genau das wollte ich haben. Das ist, genau so hätte ich es auch selbst geschrieben. So, Bild. Oh, was
jetzt? Unable to run interactively. Run with minus Y to accept. Ach so, ach so, ach so. Jetzt bin ich mir unschlüssig. So?
Nee. Moment, ich weiß, wo ich mir das abgucken kann. Warte mal. Dort, netz, hier, hier, exzellent. Minus Y. Ja, das stimmt.
DPKG ist ja eigentlich die Debian-Geschichte für Packages. Okay, Rust wird gedownloadet. Das brauchen wir wahrscheinlich nicht.
Wie gesagt, ich denke, ich werde dann auf das offizielle Rust-Image wechseln, was glaube ich auch auf Debian basiert, wenn ich das richtig im Kopf habe.
Gell?
Rust-Docker-Image basiert auch auf Debian. Debian, wie das die geilen Leute sagen. Ja, guckt hier. Buster. Gibt's Bookworm? Bullseye gibt's? Bookworm gibt's auch.
Und Alpine haben sie auch am Start. Aber Alpine, scheiß drauf. Kein Bock. Geh weg.
Müsste deine Variante mit minus, minus, minus Y auch gehen? Keine Ahnung. Nachdem ich mir da unschlüssig war, wir können es ja mal ausprobieren. Nachdem ich mir da unschlüssig war,
habe ich es mal sein gelassen.
Nee.
Funktioniert nicht.
Weil minus, minus heißt ja eigentlich, es kommen keine Options mehr. Keine Ahnung.
Ehrlich gesagt, checke ich auch gar nicht, was das macht. Aber ich weiß, dass es funktioniert.
Und deswegen...
Ach so.
Okay, Standard-In. Aber warum brauche ich Standard-In, wenn ich es doch schon reinpipe in Standard-In?
Wie dem auch sei, keine Ahnung. Ist mir auch wurscht. Es funktioniert.
Okay.
Debian Alpine sehe ich tatsächlich auch so. Ich kann jetzt zumindest aus meiner Sicht erklären, warum ich der Meinung bin, dass Debian größer Alpine ist.
Also, eines der riesen Vorteile von Alpine ist ja erstens, dass es minimalistisch ist.
Minimalistische Containerdistributionen finde ich aber gar nicht mal so relevant.
Weil, wenn du richtig dein Docker-File baust, kopierst du ja nicht quasi dein Bild-Image in dein Target-Image rein,
sondern nur das, was du gebaut hast.
Das heißt, also das Image, was du dann eigentlich startest.
Das heißt, es ist eh gar nicht so wichtig, dass das ein besonders minimalistisches System ist,
weil Debian ohne zusätzliche Sachen installiert ist auch relativ minimalistisch.
Dann ist es vielleicht 15 MB mehr als Alpine oder so, aber so what? Juckt ja nicht.
Dazu kommt, dass Alpine regelmäßig mal Problemchen hat.
Zum Beispiel mit DNS-Auflösung.
Ich weiß nicht, ob das mittlerweile gefixt ist, aber Debian...
Äh, Alpine...
Hat, glaube ich, mit DNS-Antworten größer...
Einem Kilobyte oder sowas Probleme.
Alpine DNS Error.
Ja, genau, ja.
DNS Resolution in Alpine.
Ach ja, und das liegt daran, dass Alpine, um besonders minimalistisch zu sein,
nicht die normale GLibc verwendet, sondern Musel-Libc.
Das ist quasi eine alternative...
Implementierung der C-Standard-Library.
Wobei man sagen muss, was in GLibc drin ist, ist nicht unbedingt alles rein Standard.
Es ist eine Neuimplementierung.
Und besonders minimalistisch und schön für Self-Content-Anwendungen und sowas.
Darauf basiert Alpine, aber die haben zum Beispiel Probleme aufgrund dessen mit größeren DNS-Antworten.
Ich bin mir gar nicht sicher, ob hier drin steht, was das eigentliche Problem ist.
Aber das Problem ist, wenn die DNS-Antworten zu groß sind,
dann gibt es einen Error in Alpine.
Zumindest war das mal ein größeres Problem vor einem halben Jahr oder so.
Und das habe ich mir gemerkt.
Das kann durchaus sein, dass es gefixt ist.
Ja, ja.
Das kann durchaus sein, dass es gefixt ist.
Das ist natürlich das, was mir als erstes...
Ich gehe auch mal stark von aus, dass es gefixt ist.
Aber Alpine hat öfters mal kleine Probleme.
Ja, das Debian-Image ist größer, das stimmt.
Aber so ein Riesenunterschied ist es am Ende nicht.
Und ich finde Debian einfach angenehmer.
Cargo-Chef.
Was es nicht alles gibt hier.
Cargo-Chef.
Das ist der Grund, warum ich Debian gerne verwende als Base-Image.
Wie gesagt, ich glaube auch gar nicht, dass wir hierbei bleiben werden, sondern das Rust-Base-Image verwenden.
Okay.
Jetgear, auf geht's.
Docker-Build am Start.
Und jetzt müssen wir Rust bilden.
Also, wir brauchen jetzt sowas wie Cargo-Build.
Release.
Wir testen erstmal, ob das so funktioniert.
Also, Run.
CD.
Ach so.
Moment.
Was muss man machen, nachdem man Rust abinstalliert hat?
Werden wir jetzt gleich sehen.
CD.
Web-RTC.
Rust.
Und da drin machen wir jetzt Cargo-Build.
Release.
Vermutlich wird das nicht funktionieren.
Bam.
Wer hätte das gedacht?
Can CD to Web-RTC Rust.
Warum nicht?
Was ist das Problem?
Ah, ich kack-Noob.
Ich muss gar nicht CD'en.
Ich hab doch alles hier richtig hinkopiert.
Lul.
Ich nehm wahrscheinlich einfach die offiziellen Microsoft-ASP.NET-Core-Images.
Oh, Build.
Geht nicht, weil...
Cargo-Not-Found.
Ja, wunderbar.
Alter, wo liegt denn bitte schon Cargo, nachdem man Rust abinstalliert hat?
Okay.
Okay.
Ähm...
Weiß ich...
Äh...
Moment.
Wir gucken mal nach, Leute.
Wir gucken mal nach.
Hier.
Wir machen uns mal einfach.
Wir taggen das Bild schon mal gleich.
Und zwar als CamChamp Version 0.1.
So.
Jetzt können wir sagen, Docker run.
Ja, ja.
Minus, minus, m.
Ist es minus it?
Oder ist es...
Ich kann mir...
Es gibt so ein paar Sachen, die mach ich prinzipiell immer falsch.
Falsch.
So, CamChamp.
Bash.
Hat's funktioniert?
Okay, hat funktioniert.
So, ähm...
Was wollte ich jetzt gucken?
Wo Cargo liegt, gell?
Also wir sind jetzt, nur mal zur Erklärung, falls man das so schnell nicht mitgekommen ist.
Ich zeig das nochmal.
Also ich hab das Container-Image gebaut.
Und da kommt ja so eine ID raus.
Oder man gibt dem Container-Image einen Namen, einen Tag.
Und ich hab das...
Ich hab das Image gebaut.
Ich hab das Image getaggt mit dem Name.
Und jetzt kann ich das Image starten.
So.
Und minus, minus, m heißt, nachdem ich das Image gestartet hab und quasi es wieder gestoppt wird,
soll es auch gleich gelöscht werden.
Minus i ist Interactive und t ist Konsolen-Allocation oder irgendwie sowas.
Das ist der Tag vom eben gebauten Image.
Und das ist das Programm, was er da drin starten soll.
Also im Prinzip startet er eine Shell im Container-Image.
Das heißt, wir können jetzt nachgucken, wo RustUp den Kram installiert hat.
Keine Ahnung.
Guck mal, es gibt da auch ein Cargo.
Cargo, Bin, Cargo.
Okay, vielleicht, soll ich das vielleicht direkt angeben?
Soll ich das vielleicht...
Wo ist eigentlich meine...
Wo ist eigentlich meine Cargo-Tommel und sowas?
Irgendwie...
Irgendwie ist die weg.
Bada-bum-dings-bums-dansch-fridens-ab.
Wo sind die hin?
Die hab ich doch rüber kopiert.
Die müsste doch eigentlich...
Die müsste auch da sein.
Aber war es das nicht?
So, Build, Cargo, Cargo...
Ne, Bin, Cargo.
Ja.
Äh, Build.
No Cargo-Tommel-Fawn.
Ja, ja, ist okay.
Ist gut.
Ist gut.
Also, nochmal bauen.
Run.
Und zwar Run Cargo Build Release.
Und wo ist das Problem?
Sorry for Bash.
Pog Subscription.
Subscription.
Wo ist das Problem, dass er meine Tommel-Config nicht rüber kopiert?
Da ist sie doch hier.
Guck, da ist noch Bestande.
Ach.
Guck mal, das ist klein geschrieben.
Muss das groß geschrieben sein vielleicht?
So.
Übrigens, jetzt sieht man eine Sache, worauf man unbedingt achten muss beim Docker.
Beim Docker-Image erstellen.
Was wird jetzt passieren, Leute, wenn ich das nochmal bilden lasse?
Also, ich zeige euch das mal.
So, ja.
Docker Run.
Nein, nicht Docker Run.
Build.
Ihr seht, zack, bumm, geht relativ schnell.
Und jetzt passt mal auf.
Wenn ich jetzt...
Was wird jetzt passieren, wenn ich das hier ändere an der Stelle?
Genau, Rebuild ab dem Step.
Der wird alles hier unten drunter neu ausführen.
Also, inklusive Download von Rust.
Das heißt, man sollte sich wirklich gut überlegen, wie man seine einzelnen Steps im Docker-File definiert.
Das heißt, es wäre deutlich sinnvoller, die Installation hier zu machen und das Kopieren...
...und das Installieren danach.
Weil das hier wird sich öfters ändern.
Download von der Rust-Runtime muss wahrscheinlich nicht öfters passieren.
Build.
Hey!
Ach nee, ich dachte, es kompiliert schon.
Es lädt gerade Rust runter.
Rust.
Du-du-du-du-du-du-du-du-du-du-du-du.
Au, au, au, au.
Ich weiß, woran es liegt.
Es ist Debian.
Dem fehlen seine ganzen Package-Devil-Library-Geschichten.
Und jetzt kommt wieder ein Problem, was ich habe, was ich mir bei Debian seit Jahren nicht merken kann.
Wie heißt dieses Package?
Heißt es BuildEssential oder heißt es BuildEssentials?
Upt, Install, BuildEssentials.
Essential?
Das heißt BuildEssential.
Nein, das heißt BuildEssentials.
Nein, das heißt BuildEssentials.
Ich bring das, ohne Scheiß, jedes Mal, ich schreib das jedes Mal falsch.
Jedes Mal.
Glücklicherweise hat mein Auto Komplett und meistens ist es kein Problem.
BuildEssential.
So, und jetzt seht ihr, was auch doof ist?
Ich passe diesen Step hier oben an.
Und jetzt wird alles nochmal neu ausgeführt.
Das heißt, man sollte schon seine Docker-Steps
careful wählen, dass das nicht ausartet in 500 neuen Installs und so.
Ah ja, und jedes Image ist lokal bei mir in der Registry noch drinne.
Und ich müsste jetzt erstmal Docker cleanen.
Ihr werdet sehen, guck mal, wir haben angefangen bei 100, wie viel haben wir, warte mal, Chat-Gate ist doch ganz einfach rauszufinden, bei wie viel Plattenplatz wir angefangen haben.
Also wir werden jetzt einige Gigabyte verschwinden, verschwenden.
Wir haben angefangen bei 100, guck mal, wir haben 3 Gig, 3 Gig haben wir schon verbraucht.
Oh, guck mal, es funzt.
Rust compiled.
Oh, Alter, Rust compiled, aber echt lange.
Rust.
Placingly fast.
Gut, ich mein, es dauert halt 20 Milliarden Dependencies zu...
Boah, Alter, guckt euch die CPU-Auslastung an, Mann.
Meine VM ist einfach komplett...
Alter!
Okay, er ist fertig, alles klar.
Die VM ist einfach komplett auslastet.
Aber es ist ja gut, es ist ja gut, unbenutzte CPU-Cores sind wasted CPU-Cores, ja?
Okay, es hat funktioniert, nice.
So, wenn ich jetzt nochmal bilde, geht's natürlich deutlich schneller, alles klar.
So, wenn das jetzt funktioniert hat...
Nicht exec, run.
Wenn das jetzt funktioniert hat, haben wir hier eine...
Target...
Release...
Haben wir die Library drinnen liegen, okay.
Excellent, hat funktioniert, nice.
Alles gut.
Alles gut.
So, Dogger-File.
Übrigens auch ein weiteres Problem, wo jetzt Multistage-Builds schon sehr sinnvoll wären.
Weil, wenn ich jetzt...
Was an meinem Rust-Source-Code ändere...
Macht er dir alle folgenden, ab hier, alle folgenden Steps...
Neu.
Das heißt, als nächstes kommt hier unser .NET-Build...
Und dann wird dann auch jedes Mal neu ausgeführt, also...
Das wird auf jeden Fall auf Multistage-Builds rauslaufen.
Dass das ordentlich funktioniert.
Okay.
Aber ich will...
Ich will es einmal zum Laufen bekommen, bevor wir es komplizierter machen.
Also, wir haben jetzt hier Cargo...
Cargo-Build...
Okay, das ist richtig.
Alles klar.
Wie war das übrigens nochmal?
Docker-Prune?
Ne.
Docker oder Docker-Prune?
Es gab doch so ein System-Prune.
Docker System Prune minus A.
Genau.
So, guck doch mal.
Jetzt haben wir 106...
106 Gig.
Ich sage Docker mal.
Alle...
Wo war ich jetzt irgendwie?
Ja.
Ich glaube, Ubuntu und Hello World und Traffic brauchen wir nicht mehr 7 Monate ago.
Jetzt sagen wir mal, Docker löscht einfach mal alles.
Oh, fuck.
Jetzt muss ich ein CamChamp neu bauen.
Egal.
Egal.
20, Leute.
20 Gig.
Einfach mal weg.
Ja.
Ja, ja.
Hast du recht.
Das geht jetzt aber nicht richtig.
Wobei, naja.
Es würde doch...
Doch, doch.
Es würde...
Es würde schon funktionieren.
Ich könnte jetzt...
Ich könnte jetzt die .NET Runtime installieren und sonst was.
Aber das Dumme ist halt, wenn man es...
Wenn man es einfach so logisch gruppieren will, so nach dem Motto, wir bauen erst Rust
und dann bauen wir .NET, dann würde ich ab diesem Step hier, sobald sich mein Rust-Source-Code
ändert, halt immer das ganze .NET-Zeug neu bauen.
Deswegen, das schreit eigentlich nach Multi-Stage-Build.
So, jetzt brauchen wir .NET als nächstes.
Gig.
Hört sich boomer an.
Echt, warum?
Was sagen die coolen Nichts...
Was sagen die coolen Nichts-Boomer zu Gigabyte?
GB?
Wobei es ja eigentlich Gibi...
Gibi...
Nee, Moment.
Gibi oder Gibi heißen müsste?
Gibi, gell?
Gibi?
Aber es ist Mebi und nicht Meebi.
Niemand...
Leute, ohne Scheiß.
Ich kenne niemand, der diese Einheiten verwendet.
In der Aussprache, ja?
Vielleicht zum Rechnen und so.
Aber in der Aussprache.
Niemand.
Niemand.
Okay, weiter.
Jetzt brauchen wir...
Jetzt brauchen wir unser .NET-Zeug.
Gibt es offizielle Node.js...
Äh...
Node.js...
Images.
Node.js Chiseled Images.
Es gibt auf jeden Fall offizielle Node-Images.
Relativ sicher.
Nachdem ich wenig Node-Anwendungen baue, weiß ich es nicht.
Aber es würde mich enorm wundern, wenn es die nicht gäbe.
So, also ich sehe schon, wir müssen trotzdem die Sachen in unterschiedlichen Verzeichnissen
machen.
Weil ich kann ja schlecht im gleichen Bild verzeichnen.
Ich kann ja schlecht im gleichen Bild verzeichnen.
Ich kann ja schlecht im gleichen Bild verzeichnen.
Ich kann ja schlecht im gleichen Bild verzeichnen.
Ich kann ja schlecht im gleichen Bild verzeichnen.
Ich kann ja schlecht im gleichen Bild verzeichnen.
Ich kann ja schlecht im gleichen Bild verzeichnen.
Ich kann ja schlecht im eigenen Bild verzeichnen.
So, den paragraf kann ich auch erst mal interpretation鹂nar.
Dann habe ich den operator Sci-Zak.
Verzeichnis.
Dotnet und Rust Build-ятся.
Wobei.
Warum eigentlich nicht!
Die kommen sich wirklich gar nicht so hinten Partikel in die Quere, oder?
Well, okay.
Das könnte durchaus ein bisschen verwirrend werden für den einen oder anderen Compiler,
wenn es mehrere...
Okay, schauen wir mal.
Also, als Erstes müssen wir jetzt Dotnet installieren.
Dotnet lässt sich relativ easy installieren, nämlich so.
Dotnet 8.
Ich schreibe jetzt mal was rein, bevor jetzt gleich...
Das hatten wir nämlich schon öfters im Chat.
dass ich 10 Minuten vorher was erzählt habe
und dann kam jemand rein,
beißt, danke schon für den Sub, Dennis, danke,
bock, Subscription, Leute.
Ich schreibe das jetzt oben als Kommentar rein, weil
viele im Chat
lacken critical information, wenn sie in den Stream
reinkommen. Und ich weiß nicht mehr, was
es für ein Thema war. Ich habe letztens,
glaube ich, 20 Minuten lang
fünfmal das Gleiche erklärt
und dann kamen immer Leute in den Stream
und sagen, Max, aber so macht man das doch gar nicht,
ich mach das doch so und so.
Ja, ich weiß, deswegen machen wir es erstmal
einfach und dann machen wir es ein bisschen komplizierter,
aber richtig. Fünf Minuten später kam wieder einer rein.
Max, aber das macht man doch gar nicht so.
Mach das doch mal anders. Wir schreiben das
da rein, deswegen schreibe ich das jetzt mal
da oben rein. Am Ende
machen wir Multistage,
heißt das Multistage oder Multistage-Build?
Soccer Multi, ups.
Soccer
Multistage-Build.
Das ist alles
an die
Five Hat
Community-Ges.
Lass das nicht wieder so ist, wie das letzte Mal.
H-Style
92
Pog-Subscription. Danke für die ganzen
Subs, Leute. Es ist sehr...
So, also jetzt installieren
wir erst einmal .NET.
Build.
Warum bildet er jetzt alles?
Ach so, weil ich gerade alle meine Images
weggeworfen habe.
Ja, das...
Das würde es erklären.
Wenn man alle Images löscht...
Alter, meine Nase läuft zu schlimm. Ich habe nichts zum Butzen.
Nicht, dass... Nicht, dass hier irgendwie...
Nochmal brauche ich das nicht.
Eine Sache
sieht man aber jetzt schon, was ein richtig
großer Vorteil von Docker ist.
Und es ist genau
eines der Dinger, wofür Docker ursprünglich
erfunden wurde. Für das ganze Zeug,
was daraus gewachsen ist
an Container-Ökosystemen und
wie teilweise Docker heute...
auch als Docker selbst, ja, für Sachen
verwendet wird, wofür es gar nicht
gedacht ist. Das war ja damals noch nicht
abzusehen, aber genau für sowas wurde
Docker ursprünglich entwickelt. Nämlich
um diese ganze Sache mit... Ich entwickle
was, auf meiner Kiste kompiliert es, auf
meiner Kiste läuft es, aber auf dem Server
läuft es nicht, auf der anderen
Entwicklerkiste läuft es nicht, zu vermeiden.
Hauptsächlich ursprüngliche Docker-Idee
war ja sogar, es funktioniert auf meiner
Entwicklerkiste, aber auf der anderen
Entwicklerkiste nicht. Das war eines der
ursprünglichen Ideen in der Docker. Und man
sieht auch schon, dass es genau hierfür
was bringt. Auch wenn wir das hier nicht
optimal machen und wenn das langsam ist
und wenn das nicht schön ist, es ist
nachvollziehbar. Das heißt, wenn es
funktioniert, das Bild jetzt, und ich das
Image lösche, dann funktioniert es das
nächste Mal wieder. Und wenn das Image weg
ist, ist der ganze Müll aus dem lokalen
System auch weg. Richtig, genau. So, jetzt
haben wir .NET installiert. Jetzt können wir
als nächstes...
Äh, Copy. Aus unserem Backend-Projekt können
wir die ganzen .cs-Files rüberkopieren.
Da muss ich jetzt aber mal nachgucken, was
wir noch so haben.
Wir brauchen ganzen .cs-Files und wir
brauchen das Projekt-File. Mehr brauchen
wir eigentlich nicht. Also alle .cs-Backend-
Files und das Sternchen.c... Wobei, Moment.
Nee, das... das...
Kopiert ihr hier nicht mit. So, die zwei
Files brauchen wir.
Danach können wir theoretisch schon mal
probieren,
wie ist mit .NET publish... warte mal, ich
glaube ich habe das um das Handy gekriegt...
Nix.
Da können wir gucken, wie es aussieht mit .NET
publish... wie geht das... iiih, die
.NET Bild oder, .NET publish-release?
Das habe ich. Ja und so, weil wir es ja
installieren mit Docker... äh, weil wir das ja
installieren mit
mit dem install skript ok.net publish minus series ob das funktioniert doch
haben wir das leben für meine bachelorarbeit leicht gemacht als
unterschied ja genau für sowas ist auch fast jetzt was er was hat er jetzt für
probleme please install lippi q machen wir ja das ist das ist eines der wenigen
dort netz die opfack opfack okay das ist das problem wenn ich das da oben
rein schreibe da muss ich den ganzen schiff noch mal durchlaufen lassen es
dauert wieder zwei minuten habe ich keinen bock drauf aber was lippi q gibt
es nicht ok exxon debian warum gibt es nein nein
debian warum gibt es das abt abt search
lippi q lippi q def muss ich jetzt sehen okay alles klar lippi q def high
iq library lippi iq das sieht doch schon besser aus so und jetzt haben wir
unser image am start mit gebauter anwendung drin das heißt nachdem die
anwendung jetzt fertig ist ach so moment eins brauchen wir noch eins brauchen wir
noch wir brauchen noch
kopie weil das kann man eigentlich dann nachmachen weil wenn sich das ändert
muss die anwendung noch mal kopie back end www root nach www also für unsere
webseite die muss ja auch noch mit reinkopiert werden bild ok jetzt können
wir gucken ob die anwendung funktioniert also unser unser container image würde
ich sagen jetzt erst mal fertig mal gucken ob es funktioniert was ich hier
gebaut habe
und jetzt muss man glaube ich angeben wo ist es denn bin release backend dll
und bämm es geht nicht weil unable to load shared library webrtc rust
ah so weil das im falschen ordner liegt das liegt nämlich unter target release
das liegt nämlich unter target release
release
libweb rtc rast
muss man auch noch gleich moven
jetzt gucken ob es jetzt läuft
ach
ne moment ne
vielleicht weil das nicht
im richtigen verzeichnis liegt
aber cp
libweb rtc rast kann sein ich bin mir nicht ganz sicher wo das hin muss release.net hier vielleicht
bin release
also wir müssen unser image auf jeden fall noch fixen
.net
run
backend dll
ey funzt
pog
warum funktioniert denn das ich hab doch gar kein ffm pack drauf sollte das jetzt nicht eigentlich
crashen
weil
ne das ist dumm was ich hier mache
wo sucht .net nach der library
im verzeichnis wo du startest
wenn du nichts spezielles angibst
ok also aber prinzipiell
das hier kommt von rast also prinzipiell funktioniert
das als erstes hat natürlich
kein www root
wir müssen das auf jeden fall noch ein bisschen umkopieren
das ist eklig so
ich will das image aber sowieso eh nicht
lassen insofern was mich wundert ist
dass der nicht meckert
dass ffm pack probleme hat
hier
ah ich weiß woran das liegt dass der nicht
meckert dass ffm pack probleme hat
das ist nämlich in nem thread drinne
und der thread der crasht einfach
und ich bekomm nix von mit
wir machen das jetzt mal anders
wir sagen jetzt mal ffm pack
loglevel oder sowas
konnte man doch hier setzen
das setzen wir jetzt hier auf quiet
oder sowas
wir setzen mal das loglevel
und dann sollten wir jetzt gleich
nen fehler bekommen
also was musste ich jetzt noch machen
ich musste es moven
kann man
bei .net publish nicht nen output
path angeben
das muss ich grad mal ausprobieren
konnte man nicht sagen
.net publish
minus o build doch konnte man
also .net minus o
kommt nach build rein
und dann
moven wir noch
dann moven wir noch
target
oh
vergessen wo es ist
target
release
libwebrtcrust.so
moven wir noch
nach
build
ok
so
und ich hoffe dass es jetzt ordentlich
crasht
weil wenn es ordentlich crasht
dann können wir nämlich
den container ordentlich bauen
so mal hier run
schauen wir mal ob das hier gut aussieht
jetzt haben wir nen ordner build
achso da haben wir www root
muss da auch noch rein
wieso lese ich immer webrc crust
passt doch
ganzen schalentiere
hier krustentiere
am start ok
.net
.net run ne nicht run
backend dll
jawoll
ffm pack crasht ok
das würde es natürlich erklären
und jetzt sagen wir mal apt install ffm pack
das brauchen wir nämlich
auch noch wir brauchen auch noch
ffm pack
oh da fällt mir grad was ein
leute es ist keine gute idee wie ich das gebaut hab
wir sollten vielleicht eine
statische feste ffm pack version
nehmen
weil ansonsten ist es immer davon abhängig
dass die betriebssystem version
also die betriebssystem ffm pack
version von dem
was ich benutze als base image
mit der von meiner entwicklerkiste übereinstimmt
weil ich will ja neues ffm pack benutzen
gucken wir mal ob das jetzt funktioniert
backend nope
der findet einfach mein ffm pack nicht
obwohl es installiert ist
das ist aber sehr
keck wait
gut der rest
funktioniert also container scheint schon mal
halbwegs brauchbar
zu sein
ld config lass mal kurz gucken wo ist denn
wo liegt meine library
what
alter was ist denn das für ein scheiß fad
lip x86
64 linux
knu
da hätte ich ja im leben nicht dran gedacht
dass das da liegt
ja da guckt meine anwendung natürlich auch nicht nach
ob das da liegt
außerdem ist es die falsche ffm pack version
ich entwickle mit ffm pack 6.1
glaube ich
und das hier ist ffm pack 5.9
sehe ich das richtig 5.1
ja das kann ja nicht funktionieren
ok
so dann fixen wir mal das docker image weiter
als nächstes mussten wir noch
ne das machen wir hier
wo ist die sache mit www root
hier www root
soll nicht dahin kopiert werden sondern nach
build
also das ist alles noch sehr
unoptimiert hier
wie ok
wo bekommen wir ne statische
also noch ne build step um ffm
pack zu bauen nee ich baue ffm
pack nicht es gibt ein projekt was
nightly builds von ffm pack macht
das werde ich verwenden ich bin
mir nur nicht mehr ganz sicher
wie das wie das es gibt ein paar
projekte die das machen das müssen wir uns gleich mal auf github
auf github raussuchen
ich will das aber erstmal
checken ob prinzipiell das
was ich hier gebaut habe funktioniert
also
.net
.net .net
backend
dll
ok gut funktioniert
alles www root ist auch
da ok es liegt echt nur an ffm pack
jetzt müssen wir uns ein ffm
pack build suchen
mit allen dependencies drinne
ffm pack build
für linux
und zwar nicht
ein binary ffm pack build
sondern mit
ja ich suche ja ein fertiges build sondern
ich suche ja nicht die binaries
das könnte sogar das richtige projekt sein was ich suche
lass mal gibt das denn nicht vielleicht sogar
ein offizielles docker image
mit ffm pack library
versioniert oder so
guck mal
aber das ist wahrscheinlich nur normales ffm
pack und nicht die ffm pack library oder
oder
oder
ne
das ist ja wobei man weiß es ja nicht
man weiß es nicht
probieren wir mal aus
holen wir das mal
cli
cli
haben die
auch ein nicht cli image
wobei bezieht sich
auf was bezieht sich denn cli
auf ffm pack
oder auf
dass es
shells und so dabei hat
cli ls
was sind denn die unterschiede
zwischen den einzelnen
sachen überhaupt
ja das
so schlau war ich auch
ich vermute da ist die
das sind
wahrscheinlich einfach nur binaries und da ist
die
da sind die ganzen ähm
äh die library
parts von ffm pack die ich brauche gar nicht
dabei ok gucken wir
gucken wir uns das mal an also
wir machen
jetzt mal wir starten einfach mal einen docker container
mit
mit dem image und zwar
ffm pack nehmen wir mal
amd 64 latest
bam
gucken wir mal rein
was es da so gibt
ob da ffm pack tatsächlich auch als
library drinne liegt weil da können wir nämlich
die images gleich verwenden
oh
ah
ok der versucht gerade ffm
pack direkt zu starten mit einer datei
die bash heißt das ist natürlich blöd
da müssen wir jetzt entry point
überschreiben
minus minus entry point
bash
kopf nicht gebacken jawoll doch gut
passt
hier ffm pack ist am
start
a v
ja
die bringen die libraries gar nicht
mit vermutlich
lip
äh
die bringen glaube ich die ganzen libraries
nicht mit
suchen wir mal irgendwie nach
die haben nur
ne na geil
die bringen nur ffm pack
die binaries mit das bringt mir ja gar nix
und
was ist das das ist das da
ne das ist natürlich
blöde
dann bringen mir die images
nicht wirklich was
weil
weil die ffm pack
binaries
die brauche ich ja gar nicht
gucken wir nochmal
was da jetzt drinne ist ob das irgendwie anders
ist
wer sich fragt was das ist das hier listet
alle libraries auf auf dem system hier guckt
und ähm
v format nennt sich eben
ein teil von ffm pack
das gibt es immer
wenn es ffm pack gibt
ja ok die images bringen mir nix weil in den images ist bloß
ffm pack als binary drin
aber immerhin
als halbwegs
aktuelle als als genau die version
die ich brauche ok
das heißt wir müssen das selbst machen
ffm pack einbauen
oder was haben wir sonst noch so für images auf docker hub
jellyfin
ne
I
ne
ich glaube ich verzichte auf ein 4 jahre altes
ffm pack
kannst du nicht einfach ein fertiges bild runterladen
doch doch machen wir jetzt
ich dachte nur vielleicht gibt es ein fertiges
fertiges image container image
was wir verwenden können
updated 8 years ago
und was zum teufel ist
open coconut
na gut brauchen wir nicht
gucken wir mal hier
ich glaube das sind die richtigen bilds das sind auch die die ich sonst immer
verwendet verwendet habe
weil man ein statisches
ffm pack gebraucht hat
ja
ffm pack
n1128
git commit hash linux gpl
linux gpl
shared
das klingt gut
kann es sein dass die libraries von ffm pack sich lib av
nennen
da gibt es mehrere
es gibt av format
gibt es auch
aber es kommt
also die dinger nennen sie immer lib av
und dann kommt dann der rest hinten dran
aber es ist ja egal ich habe nach av format
gesucht und das hätte er finden müssen
also sind
wir haben es ja auch gesehen da lagen keine rum
aber was haben die hier alles zur auswahl
die haben linux 64
haben die vielleicht auch
irgendeine tag version
anstatt master
so 661 oder so
ja
601
was für eine ffm pack version habe ich denn bei mir lokal
61
gibt es hier 61
ne gibt es nicht
ach das liegt daran
weil 61 wahrscheinlich gerade master ist
und 601
das letzte release
kann das sein
vermutlich
dann nehmen wir mal 601
601 müsste auch klar gehen
also 601
linux
601 linux
64 gpl
shared das brauchen wir
was damit gemeint ist folgendes
also rate ich jetzt einfach mal
gpl
gpl enthält nur die open source codex
gpl enthält nur die open source codex
und minus shared
bedeutet das ist nur die library komponente
und das hier ist library
plus oder eventuell nur
binaries
da gibt es aber keine oder
das ist das source code oder das ist kein
das ist doch nur das source code
das ist doch bestimmt kein
fertig gebautes
ich glaube nicht das ich glaube das das nur das source code ist
guck mal mal
ok ta xfz
moment das heißt ja anders
ta z muss weg
ja guck das ist nur das source code
das bringt mir nix
da müsste ich ffm pack
auch noch selbst kompilieren
da halten sich da halten sich
mein bock hält sich da in grenzen den ich da drauf habe
ffm pack kommt weg
ok docker file
wir benutzen das hier
linux 64
gpl shared
gehen wir mal in unseren docker container
rein den wir eben hatten
und probieren das da mal aus
wie das da aussieht
wget
zack genau
so
ta x
fz
ne z nicht
ja das sind das ist
ne fertig kompilierte library ok
das ist gut
hier haben wir es
binaries sind auch am start die wir nicht
brauchen die können wir theoretisch löschen
noch gleich aus dem image da es ein bisschen kleiner wird
lip
da ist alles drin was wir brauchen
genau
exzellent
ok wir bauen unsere anwendung kurz ein kleines
bisschen um
nämlich
ich lade das hier auch mal runter
und dann packen wir
das ganze
in unser docker ignore file
weil ich will garantiert nicht
aber docker file ist auch nicht
also weil ich will ja nicht
ffm pack da irgendwie drinnen liegen haben
also machen wir
in unser git ignore
in unser git ignore file
alles was ffm pack sternchen hast soll
weg ok
weil ich will nicht aus versehen
irgendwie 500 mb oder
wie groß ist das jetzt entpackt
ne
ach ne
aber ich habs noch gar nicht entpackt
kack noob alter
ich wundere mich schon die ganze zeit wo ist es
was
äh
ich bin verwirrt
achso f
steht ja sogar da lul
so ffm pack taucht hier nicht drinnen auf
ja ich hab keinen bock das
157 mb
bei mir im git landen
muss nicht sein
deswegen kommt das in das git ignore rein
so und jetzt müssen wir gucken
dass ich als library
fad nicht slash lib verwende
sondern
wir benennen das sogar noch um
komm wir benennen das um
den namen kann sich doch keiner merken
wir benennen das einfach in ffm pack um
und die library löschen wir
und das runtergeladene ta-archiv löschen wir wieder
das heißt mein ffm pack suche ich jetzt unterhalb von
ffm pack slash lib
ups
so mal gucken ob das jetzt startet
run
run
und funzt nice
ohne fehler
ja ja und es liest auch die sachen von der kamera
also alles gut
so ffm pack slash
also genau ffm pack slash lib
das heißt im endeffekt müssen wir jetzt
nur das gleiche noch für den docker container machen
und dann bauen wir den docker container
noch ordentlich
so jetzt haben wir das hier hin kopiert
ffm pack machen wir mal hier als letzten step
wget
ffm pack
wie
wie sagt man wget
dass er direkt entpacken soll
also ta kann man das einfach so rein
pipen
hx
vielleicht hat x nur z kein
pipe oder so hin
ne
unexpected end of file
ähm
ne moment
muss wget noch sagen
minus o glaub ich
für output
wget pipe ta
so wir fragen stackoverflow
wget
groß o minus
gepiped
ne moment das muss ich jetzt hier erstmal testen
wget
minus groß o minus
das ist wahrscheinlich der standard out
gepiped nach ta xzf
alles klar
okay nice stackoverflow gg
stackoverflow lügt
ah moment das ist kein z
ja das ist richtig
wat
archive is compressed
use minus j option
moment
ey warum ist
warum ist chat
äh nicht chat warum ist stackoverflow
falsch
okay minus xv so
irgendwie
hey das funktioniert
nice kaum macht mans richtig
okay so und jetzt ist die
große preisfrage ich lösch den ganzen kreml
grad nochmal jaja
jetzt ist die große preisfrage
wie kann man ta den output
ordnernamen angeben war das
minus c
ta output directory
name
how to choose directory
name
during untarring
genau das wollen wir haben
minus c pretty name strip
components one achso
das ist weil die m kardieren davor
anscheinend geht das nicht
what
jetzt okay jetzt wirds aber advanced
was
minus minus transform
und dann regex
für den dateinamen oder was
ja komm komm
mal nicht
wir wollen es mal nicht übertreiben
ich würde vorschlagen wir machen einfach nen move danach
und gut ist ja
es muss ja nicht
wir müssen es ja nicht komplett übertreiben
also ein move ffm pack
nach ffm pack okay alles gut
und schon ist es so wie wir es haben wollen
wunderbar
man kann es ja mit shell
hacks auch übertreiben
so
und als nächstes jetzt noch nen move
von ffm pack sternchen
nach ffm pack
so
und dann
nach build ffm pack
so und wenn ich jetzt alles
gemacht habe dann sollte
dann sollte
mein docker
dann sollte mein docker container
funktionieren
ich bin gespannt
dann löschen wir den container nochmal
wir könnten auch quiet
machen beim wget
ich glaub minus
minus q ist es bei wget
und ähm
minus minus s
ist es bei also bei wget
ist es minus q für quiet
und bei curl ist es glaube ich minus s für
silent wenn man nicht will
dass der unnötige
terminal outputs macht
okay run
jetzt bin ich ja mal
gespannt ob das funktioniert was ich hier gebaut habe
hier sind wir
also dotnet
dotnet
backend dln
falsche ffm pack version
fragezeichen
okay das ist ausgesprochen
doof jetzt
das ist wirklich doof
was hat er denn für schmerzen man
dotnet run okay
unable to load
ja ich weiß okay ich kopier das mal
kopier das mal wieder hoch
ja okay okay ffm pack
nicht gefunden habe ich
habe ich kapiert habe ich kapiert
oh
what alter der crasht einfach
was ist denn das jetzt
crash champ
einfach einfach
der crash champ am start
weil ich gerade versuche
rockercontainer zu bauen
für meine anwendung dafür brauche ich ffm pack
aber ffm pack zeigt sich
nicht
kooperativ
achso ich habe auch die falsche version
guck mal
meint ihr es könnte daran liegen
dass ich hier lokal
ffm pack
6 1 habe
und im container ffm pack
6 0 1
was meint ihr könnte das
das problem sein
ich mein es deutet schon ein bisschen drauf hin
ja wenn ich hier so sachen
sehe wie
einfach instant crash
warum crasht er denn
was ist das problem man
hm
okay was hat er denn
für schmerzen ffm pack lib
ist das überhaupt richtig
ffm pack lib
die sollten abwärts kompatibel sein
das hätte ich auch gedacht
aber
vielleicht doch nicht
was ist denn wenn ich hier irgendeinen mist angebe
und dann ausführe
run
dann sagt er method not supported
habe ich das richtige
runtergeladen
habe ich irgendeinen mist runtergeladen
ffm pack
der findet es offensichtlich ja auch
okay wir machen mal kurz hier einen return rein
um zu gucken ob es daran liegt
hier haben wir mal irgendwie console
aber irgendwas dass ich das nicht
jetzt schreiben wir console
console rightliner perfekt
was
das artet schon wieder aus
warum muss das alles warum kann das einfach nicht funktionieren
pack w
wieso der max von youtube erwischt
jetzt kann ich mich nicht mehr
raus reden
warum geht das
okay also bis hierhin funzt alles
aber dann crasht das hier
aus irgendwelchen gründen
das könnte aber auch woanders ran liegen
fuck it alter
der crash
okay der crasht
ach ich weiß warum der crasht
oh ich kack noob
alter es funktioniert alles
guck mal hier
fällt euch hier was auf
entdeckt ihr hier irgendwas
was im container so garantiert nicht funktionieren kann
der liest einfach hardcoded
von meinem lokalen rtsp server
was das kann ja so nicht funktionieren
das gibt es ja da gar nicht
mein error handling ist absolut erste sahne
der handelt einfach gar keine errors
und
und sagen wir mal so
so sollte man das ja auch nicht machen
das sollte normalerweise ein ordentlicher background service sein
der sich auch bei fehlern neu startet
und sowas
das machen wir dann noch
okay ich lasse es jetzt erstmal so wie es ist
mein docker container funktioniert auf jeden fall
jetzt
jetzt funktioniert er
also funktionieren bedeutet er crasht
okay ja aber aber
aber es funktioniert
also der docker container ist korrekt
ich kann euch das auch beweisen
dass der funktioniert
wir machen hier einfach mal ein
kann man hier eigentlich return machen direkt
ne ein return rein
und ihr seht
zack es läuft
bam
ah wir brauchen noch was
wir müssen die interfaces
überschreiben wo er dran bindet
und zwar
und zwar
asp.net core environment variables
für den port
das da will ich haben
minus minus urls
command line argument
okay das ist auch gut
minus minus urls
also da wollen wir dann haben
soll listen an http
doppelt punkt doppelt sternchen
punkt und jetzt brauchen wir mal irgendeine
port hier keine ahnung 80
44
funst nice
okay da muss das noch
als command in unseren docker container
rein
jetzt sind wir mal
so frei
und kommentieren den ganzen media
krempel aus
gehen wir mal in das docker
file rein und sagen am ende
cmd
ja also das würde
würde höchst wahrscheinlich
das ist das docker container
ok
ok
ok
ok
ok
ok
ok
ok
ok
ok
ok
ok
ok
ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok
Das sackt halt, ne?
Okay, probieren wir mal aus.
Docker, Run, CamChamp.
Schauen wir mal, ob es geht.
Zack, Funst.
Docker-Image tut.
So, ein weiterer Punkt, warum es eine blöde Idee ist, so ein Docker-Image zu bauen.
Euch fällt hier vielleicht was auf.
Das Docker-Image ist 3,6 Gigabyte.
Ich meine, das heißt nicht, dass es nicht funktioniert.
Aber ein bisschen groß ist es wahrscheinlich, ja?
Du kannst dein Zeug auch in einer Pipeline bauen und die Artefakte nur in den Container kopieren.
Ich wusste, dass gleich irgendjemand kommt und sowas in der Richtung erzählt.
Wobei, da warst du doch sogar da, wo ich das gesagt habe.
Lass mir das nicht so lassen.
Also, man sieht, es ist ein bisschen doof.
Ach so, du meinst, dass du irgendwie GitHub-Actions machst und dann den Output...
Ja, okay, das wäre nochmal.
Das wäre nochmal eine Nummer-Advancer.
Das machen wir vielleicht das nächste Mal.
Müssen wir mal gucken.
Also, das funktioniert.
Das ist allerdings, wie man sieht hier, echt sehr doof.
Ja, so ein 8,6 Gigabyte Container-Image sackt ein bisschen.
Ich schmeiße nochmal alle meine Container-Images weg.
Das wird man gleich sehen.
Da haben wir wieder 5 Gigabyte freigegeben.
Und jetzt machen wir das Ganze nochmal in hübsch.
Also, was ist denn...
Ach ja.
Was ist denn die Essenz aus dem Ganzen, was wir hier machen?
Wir installieren Rust.
Kompilieren die Rust-App.
Wir installieren .NET.
Kompilieren die .NET-App.
Installieren die Abhängigkeiten für .NET.
Kompilieren die .NET-App.
Kopieren die Rust-Library, die wir hier oben gebaut haben, in den Output-Folder, wo dann die Anwendung drin läuft.
Kopieren die Webseite in den Web-Server-Folder.
Wir downloaden den FFM-Pack.
Und kopieren es an die richtige Stelle.
Und am Ende sagen wir, wie man das Ganze starten kann.
So.
Also.
Das Ganze jetzt noch in schön.
Und es gibt sowas.
Also, ihr habt jetzt gesehen.
Chat, ich möchte, dass ihr das alle zur Kenntnis...
Ach so, fuck, das Image ist weg.
Okay.
Dass ihr das alle zur Kenntnis genommen habt, dass das Image, wenn man das so baut, 3,6 Gigabyte groß ist.
Chat, noted.
Das wird nachher abgefragt.
Da gibt es doch so ein nice noted Emote.
Ja.
Habt ihr das noted alle, ja?
Dass es 3,6 Gigabyte ist.
Dass es keine so gute Idee ist.
Die .NET-App ist wahrscheinlich recht groß.
Nee, die ist...
Das ist ja sogar eine Framework-dependent-App.
Die ist nicht groß.
Die ist, keine Ahnung, 10 MB oder sowas.
Okay.
Der Chat hat genoted.
Alles klar.
So, und das ist natürlich doof, weil die Images fressen halt...
Das ist deutlich zu groß.
Die Images fressen halt Speicher in der Registry.
Wenn das auch etwas optimierter da drinnen gespeichert wird.
Aber auch die Bildzeiten sind relativ...
relativ groß, weil ab jedem Step, wenn sich hier etwas ändert, muss das ganze Ding neu
durchlaufen werden.
Und dementsprechend sind natürlich auch die Updates zu den Images, die Diffs, relativ
groß.
Selbst wenn ihr nicht jedes Mal ein komplett neues Image speichert, der cached sich ja
nur die Stages.
Das heißt, eure Image-Registry wird über kurz oder lang echt viel Geld kosten, wenn
ihr nur solche Images reinhaut oder wenn ihr die selbst hostet, dann...
Na gut, ihr könnt es auch bei GitHub hosten, da weiß ich nicht, ab wann die was berechnen.
Haha.
Ist auf jeden Fall keine gute Idee, weil es dauert alles länger und suckt.
Deswegen gibt es bei Docker sowas, das nennt sich Multistage-Build.
Die Idee dahinter ist folgendes.
Man macht nicht nur ein Image, sondern man macht für jeden Build-Step, der ein bisschen
komplexer ist und Caching braucht, einen eigenen...
Ja, Build-Step mit eigenem Image draus und ganz am Ende macht man dann ein Image, wo
man die Sachen aus den vorherigen Build-Steps reinkopiert und das wird dann das Image, was
am Ende rausfällt und von Docker gestartet wird oder von Kubernetes oder von irgendeiner
Container-Runtime.
Hat den Vorteil, diesen ganzen Mist hier von...
Wir müssen Rust runterladen, wir brauchen hier komplettes Ding, wir brauchen Rust-Abhängigkeiten
von 1,2 Gigabyte, fällt weg, die fallen nur im Build-Prozess an, im eigentlichen Output-Image
sind die dann nicht mehr drinne.
Was wir im Output-Image brauchen und warum unsere Output-Image nicht mehr drin ist, ist,
dass...
Was wir brauchen und warum unsere Output-Image doch immer noch ein bisschen größer ist...
Ja gut, ist das hier, FFmpeg.
Aber auch FFmpeg kann gecached werden, weil FFmpeg-Updaten wir ja nicht laufen, sondern
immer nur dann, wenn es notwendig ist.
Also, würde ich sagen, legen wir mal los und bauen da mal ein Multistage-Build draus.
Ich würde vorschlagen, das erste, was wir machen ist, wir benennen das mal um, dass
wir abgucken können.
Docker-File-Old.
Docker-File-New.
Alles klar.
So, das erste, was wir machen ist, wir gucken mal nach dem offiziellen Rust-Image, weil
dieser Step hier gefällt mir beispielsweise überhaupt nicht, dass wir unser eigenes Rust
installieren müssen.
Und wenn wir eh schon mehrere Images verwenden und unser Image beim Bauen nicht gleich dem
Output-Image ist, können wir einfach auch das offizielle Rust-Image verwenden.
Und wir wollen...
Rust-174-Build.
Okay.
Gut.
Bookworm.
Wollen wir haben.
Das ist gut.
174.
Also.
Wir benutzen jetzt nicht Debian, sondern wir benutzen Rust 1.74 Bookworm.
Das ist zufälligerweise auch ein Debian, aber das ist echt nur Zufall.
Müsste nicht sein.
So, und wir müssen jetzt auch kein Slim-Image oder sonst was verwenden, weil wir kopieren
ja den Output rüber und wir verwenden das Image-Guide.
Also, wir könnten ein super fettes Image haben zum Bauen, wovon wir eigentlich am Ende
in dem Target-Image gar nichts verwenden.
So, Work-Dir-Build ist glaube ich okay.
Ähm.
Update.
Updaten.
Können wir uns schenken.
Ha.
Wer braucht geupdatetes Image?
Install.
WGAT werden wir weiterhin brauchen, weil wir ja noch FFM-Pack irgendwo runterladen müssen.
Das Curl können wir uns schenken.
Output kopieren.
Das müssen wir in der Tat machen.
Und...
Wir können uns aber...
Ne, wobei, ist eigentlich gut.
Wir können Cargo-Build machen nur noch, weil wir jetzt das offizielle Image benutzen.
Da ist Cargo im Path.
Kann er ohne Update überhaupt die Pakete finden?
Wir installieren...
Achso, ja, du hast recht.
Das könnte sein, dass das ein Problem macht.
Er würde eigentlich von ausgehen, dass das geht, aber...
Ja.
Ja, du hast recht.
Ja, wir lassen es drin.
Ja, ihr habt...
Ihr habt recht.
Wir lassen es.
Wir lassen es.
Wir lassen es.
Wir lassen es.
Wir lassen es.
Wir lassen es.
Wir lassen es.
Wir lassen es.
Wir lassen es.
Wir lassen es.
Wir lassen es.
Wir lassen es.
Ja, wir lassen es drin.
Ja, ihr habt...
Ihr habt recht.
Wir lassen es drin.
So, das können wir uns erstmal schenken hier.
Wir machen das mal weg hier.
Bam.
So, wir haben es ja da drüben noch stehen.
So, Cargo-Build-Release.
Bis zu dem Step sollte das jetzt eigentlich schon durchlaufen.
Probieren wir mal aus.
Ob das jetzt funzt.
Docker-Build.
Ah.
Sieht eigentlich schon mal ganz gut aus.
Okay, das ist nur Update aktuell.
Und warum macht der jetzt so Pause-Champ?
Warum pausiert Champ das gerade so?
Upget?
Ach ne, das war doch das Docker-Image-Pull.
Ach so.
Aber guck mal, Cargo-Build funktioniert jetzt.
Direkt out of the box.
Ohne dass man irgendwie einen Handstand machen muss, dass es funktioniert.
Alter, meine Kiste.
Guckt euch das mal an.
Die Feuerwehr ist jetzt...
Die Feuerwehr ist jetzt...
Die Feuerwehr ist jetzt...
Die Feuerwehr ist jetzt einfach mal komplett ausgelastet, wenn Rust baut.
Blazingly fast compile stellst.
Blazingly fast, aber CPU intensive.
Ja, das stimmt schon.
Sobald es jetzt in Docker läuft, wir könnten es ja theoretisch auch irgendwie limitieren.
Aber wozu?
Aber wozu?
Exporting Layers.
Okay, das ist noch kein...
Es hat jetzt bis jetzt noch nicht viel gebracht.
Weil wir haben ja noch kein Target-Image.
Wir haben jetzt so...
Okay, das ist der...
Das ist der Build-Step für...
Ja.
für für rast ich würde sagen wir machen in dem gleichen step die die ffm pack geschichte weil
sonst muss ich ja jede bei jeder änderung die machen wir übrigens auch davor uns müsste sich
ja bei jeder änderung quasi in rust jetzt wieder neu ffm pack runterladen das ist natürlich auch
nicht nicht irgendwie sinn und zweck der sache aber mal hier ran bewegt ffm pack wir können das
auch in einem in eigenem step aus also wie er wehrt ffm pack und dann wird ffm pack umbenannt
in vielleicht sollte ich das nicht einfach nur ffm pack nennen sondern ffm pack wie heißt der kram
ffm pack minus n sehr schön so das können wir machen gut so das ist der erste bild step
also ffm pack runterladen ffm pack entpacken rast zeug kompilieren und jetzt kommt der trick
beim multistage bild für den dotnet part machen wir ein neues bild image also wieder from jetzt
muss ich mal gucken dotnet docker images sdk brauchen wir jetzt genau
sdk from mcr das ist die microsoft docker sdk 8.0 muss dahinter als versions tag wenn ich jetzt
wüsste welche versions tag es gebe wäre schon sehr nice sieht man das wenn man hier drauf geht
nein das wäre auch deutlich zu einfach microsoft wenn das funktionieren würde feature tags wird
trotzdem ganz nice zu wissen was es ist
sonst noch gibt die haben garantiert noch mehr tags naja gut scheiß drauf wir machen es wir machen so
das ding nennen wir jetzt okay dass das heißt nicht bild sondern das heißt rast und das hier
heißt dotnet weil das dienst die namen brauche später weil man die dateien von den einzelnen
steps raus kopieren wollen aber immer hier kommen sie immer so was okay bild rast nächster step
bild dotnet so microsoft image wird gepublikiert und jetzt wir machen wieder wird wird dir bild
weil warum nicht so und jetzt können wir diesen kram hierüber kopieren said noiss Asko diesen
kram hierüber kopieren copy und jetzt kommt sich die dinge auch nicht mehr in die quere
dass hier ist ein eigener container mal bilden und das hier ist ein ein eigener container munter
okay, jetzt wird das Ganze wieder
.NET run, .NET
haben wir es noch hier, publish
okay, da ist, zack
das können wir uns
auch sparen, weil
.NET garantiert im .NET Container
verfügbar sein wird
werden die ganzen Stages nacheinander gleichzeitig
abgearbeitet, gleichzeitig
es sei denn, die eine hat Abhängigkeit
auf die andere, das ist relativ
schlau, mittlerweile
die ganze Buildkit, Docker
Buildgeschichte, du wirst
du wirst gleich sehen, der macht das parallel
es sei denn, es hängt voneinander ab
oh ja, gut, und wenn sie unterschiedlich schnell sind
dann sieht es halt auch nicht parallel
aus, aber sie sind parallel, okay
.NET publish, .NET release
Output, eigentlich
kann ich mir das komplett schenken, den
Output, das kann ruhig das Default Verzeichnis
sein, das ist okay
okay, und jetzt
kommt der eigentliche Trick
jetzt kann man unten nochmal sagen
hier, wieso
App oder so, nennen wir es einfach mal
App
so, und jetzt sagen wir
From, jetzt brauchen wir das Microsoft Image
für
ASP.NET Core
hier, das da, brauchen wir
wahrscheinlich einfach nur das, Moment, ach nicht Runtime
ASP.NET, da ist doch
genau, From, so, S
GachiBus
also Runtime oder sowas
keine Ahnung, ich glaube Microsoft
nennt das Zeug immer Runtime
so, WorkDir
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
so
ist schon was dran ich meine es sei denn es macht sinn dass man die einzelne cash für sich genommen
aber du hast du hast recht ja ok also docker bild jetzt werdet ihr sehen als sei das kackt ab es
sei es kackt ab wir müssen jetzt mehrere bilds parallel sehen nämlich einmal den rast konnte
einmal den dotnet container und den output container am ende ok er pullt erst mal dass
er pullt erst mal das image zack und schon ist er fertig das ging ach so doch er ist zu schlau
leute doch er ist zu schlau der erkennt dass der das von diesem image nichts benutzt werden
deswegen baut das nicht vermutlich ok also muss ich jetzt muss ich jetzt doch so tun als will ich
was davon haben und zwar man kann jetzt also wir haben ja hier oben die dort net app die dort net
app gebildet gebildet und hier die rast app und das ist mein mein ziel image das heißt
im endeffekt muss ich jetzt so was machen hier wie copy und jetzt from wobei ich glaube das
können wir uns sparen copy from hier den name von dem image zur bild zeit wo die dateien liegen also
copy from rast slash bild weil werkt ihr splash bild und da drin gibt es jetzt ein ffm pack folder
Als nächstes brauchen wir
from Rust noch
ja,
build target release libweb
rtc rust.so
Soll im Prinzip hier exakt
genauso heißen.
Und dann brauchen wir
als letzten Step noch, ich bin mir nicht
sicher, ob die Reihenfolge gerade die beste
ist. Und dann brauchen wir
als letzten Step noch
die .NET App. Und zwar
jetzt ist es from .NET
from .NET
und jetzt
kann ich mir immer nicht merken, wo dieser ganze Mist
liegt. Auf jeden Fall schon mal in build.
Habe ich das hier irgendwo stehen?
Ne.
Minus O. Ja, auch
in release, aber diesen...
Liegt FFmpeg nicht unter
slash build slash... Ne.
FFmpeg kommt hier...
Achso, Moment. Wait a minute.
Du hast recht.
Das hätte übrigens gar nicht funktioniert an der Stelle,
weil es Verzeichnis nicht gegeben hätte.
So ist richtig. So ist richtig.
Siehste? Chatge... HiIQ wieder.
So, from build.
Ich kann es mir einfach immer nicht
merken, wo die .NET... .NET
publish minus c release.
Alles klar, gib ihm.
Was?
Achso, ha. Ja.
Ja, ist ja gut. Nicht Docker.
Okay.
Bin release
net 8.
Publish.
Bin release...
net 8. Publish.
All right.
Bin release publish.
Okay.
Auch hier. Gleicher, gleicher.
Soll die ganzen Crampli einfach
in das Verzeichnis schmeißen.
Einfach eigenen Output setzen.
Ja, das wäre auch eine Möglichkeit.
So, und als letztes kopieren
wir noch von
backend www...
Das da machen wir
im Endeffekt. Moment, das machen wir nicht. www root
nach www root.
Alles klar.
So.
Das cmd sparen wir uns jetzt mal.
Ich hoffe, das funzt jetzt. Docker build. Bam.
Guck, man sieht,
er macht die Sachen auch parallel. Hier oben
ist er am .NET Image. Hier unten ist er am Rust Image.
.
.
Guck, hier oben lädt er noch das .NET Image runter.
Hier unten baut er schon Rust. Also es geht bis zu dem Punkt
parallel. Das letzte, das Output
Image kann er natürlich nicht parallel bauen, weil
das Abhängigkeiten zu diesen beiden Images hat.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ich meine vielleicht geht es ja doch okay es geht doch easy ich habe nichts
gesagt scheint doch zu funktionieren ja dann da können wir das ja auch wieder
rückgängig machen ffm per clip so also ich habe jetzt den source code geändert
von meiner net anwendung von der idee her sollte er dort net nur dort net
bilden und neues image bauen da stimmt was nicht leute warum ist das warum ist
das cash ich habe doch eindeutig hier geändert oder habe ich moment habe ich
vorher einfach nicht gespeichert kann das auch sein moment moment das muss ich
jetzt mal ausprobieren ich kopiere sie einfach noch ein paar
mal ja okay ich habe freundlich gespeichert
alles gut sehr gut gut alles klar also das sollte
jetzt funktionieren ja von uns und habe gesehen wie viel schneller das jetzt
bildet das image im vergleich zu vorher und wie viel kleiner das ist können
wir uns mal gucken was passiert wenn ich in der also wenn ich ihn wenn ich auf
der dort netz seite was ändere das jetzt relativ easy zu zeigen noch mal bumm
sagt okay cash weil er hat es schon mal gebildet mit diesen drei zeilen drin
so gehen wir mal in den rust path gehen wir man den rust path und ändern hier
irgendwas keine ahnung ihr active connections soll jetzt unbedingt haben
noch ausrufezeichen habe bild cook cargo run bild jetzt muss er nur den rust path
neu bilden das dauert natürlich lang weil ras lange braucht zum kombiniert
irgendjemand hat auch vorhin cargo chef angesprochen
du du du du Leute ich habe eine Idee
Leute ich habe eine Idee
die. Gibt es so was
wie Cargo
Pull oder so was?
Das könnte man tatsächlich noch
ausbrühen. Weil man könnte
jetzt ja an der Stelle
Machen wir das mal wieder weg.
Was macht ihr? Wir haben einen Multistage
Docker-File gebaut. Also
was ich mir überlegt habe ist folgendes. Guckt mal.
Hier kopiere ich den Source-Code Cargo
hin und mache ein Bild. Wenn ich so was
machen könnte, ich weiß nicht, ob es so was gibt,
ja, dann
würde ich
auch beim Ändern an der Go
äh, was labere ich mit Go? An der Rust
an einem
Rust-Source-Code
wenn sich nichts an den Dependencies
ändert, wäre das hier
gecached an der Stelle. Gibt es so was
wie Docker-Pull oder so was?
Oder Cargo-Pull, nicht Docker-Pull.
Cargo-Pull?
Was soll das tun?
Alle Dependencies runterladen,
die
man braucht, die in der
Cargo-Tommel stehen.
Weiß ich, ob es so was gibt.
Also bei .net heißt es Restore.
Cargo-Pull? Gibt es so was?
Was haben wir denn?
Build. Check.
Clean. New.
Init. Add. Remove.
Run. Bench. Update.
Bench. Update.
Ne.
Ne, gibt es nicht.
Cargo-Fetch. Ne, so was gibt es anscheinend nicht.
Oh we...
Hä? Das steht da nicht drüben.
da steht aber gar nicht hier dabei windows macht ein cargo patch minus list
werden alle okay weil das wäre natürlich gut da muss da nicht jedes mal diesen
ganzen krempel elb es gibt ja nicht alles bild c check clean klippi config
patch ok das ist schon mal gut install okay was auch immer miri ist
owner package remove reports ok patch ist glaube ich echt nicht verkehrt dass
an der stelle das probieren wir jetzt doch klart mal aus cargo patch so dann
hat er zumindest die dependencies gecached an der stelle das sollte doch
eigentlich ganz brauchbar sein aber er muss den kram trotzdem
kompilen ich glaube da ich glaube da kommen wir
jetzt nicht
ich glaube da kommen wir jetzt nicht
drumherum
fail to pass manifest warum ach so ja okay es funktioniert nicht dass das
funktioniert so nicht wie ich mir das gedacht habe ich glaube den compile step
den kann man nicht kann man nicht beschleunigt ich habe mir könnten dass
wenn wir also bei github actions könnte man den bild output vom letzten mal
cachen dann irgendwie wieder herstellen so dass er an der stelle dann nicht alles
hier hin und da da ist er nicht geschrieben ich habe das hier von dem
wurde ich kann das noch immer ich kann damit leben ja ich kann mir leben es
okay ich würde sagen passt soweit mission erfüllt ja mein schnelles relativ
kleines rocker image das ist gut hat funktioniert okay chat ich hoffe ich kotze
jetzt ein bisschen bei der arbeit noch abgabel im streamontag heim ist weiß ich
Ich weiß nicht, ob man das als Fortbildung verbuchen kann, wenn man nicht viel mit Docker gemacht hat, bestimmt.
Das Problem ist, glaube ich, nicht das Base-Image, dass Debian so groß wäre, sondern eben, weil halt die komplette .NET-Runtime drauf ist.
Sieht man ja auch. Und die .NET-Runtime, die ist halt unter Ubuntu auch nicht kleiner als mit Debian.
Echt? Ist das so? Ist das kleiner?
Okay, das probieren wir uns mal kurz aus.
Also, wir haben aktuell von unserem Image, der App, lassen wir mal außen vor, da werden wir nichts dran machen können.
Erstmal User. So, in User ist Lib, ist IQ, das Braumer, und Perl, was auch immer.
Und 100 MB davon sind .NET. Ja, probieren wir das mal aus.
Okay.
Also, was brauchen wir?
Jammy.
Sch-Schisselt.
Für ASP.
ASP.
So.
Äh.
Ja, nix Preview. Die gibt's wahrscheinlich schon komplett.
Äh, die gibt's... Okay, das... Da bin ich, da bin ich jetzt ja mal gespannt.
Also, im Prinzip brauchen wir jetzt nur ASP, ne?
Jammy.
Schiss.
Elite.
Isolet.
Bild.
Sehr nice.
Stalker-Image.
Ja!
Damit kann ich leben, oder?
260 MB.
Äh, Bash ist da natürlich, ist da SH drauf, irgendwas. Da ist nichts drauf.
Da ist einfach gar nichts drauf.
Ach so, funktioniert's noch? Das ist eine gute Frage, ja.
Ne.
Ne.
Ne.
Funktioniert nicht mehr.
Ah, ich glaube, ich weiß, warum.
Ich weiß, warum. Wir müssen es so schreiben.
Ne, ne, wir müssen es so schreiben, Leute.
Passt mal auf, ich weiß, woran das liegt.
Wenn das was... Wenn das... Wenn das jetzt geht, erkläre ich euch, woran das lag.
Wenn's nicht geht, dann nicht.
Ja, fuck.
The application.net does not exist.
Äh.
Ist das vielleicht nur für self-contained apps?
Bin ich denn zu viel geschisselt?
Hahaha.
Äh, da brauch ich...
Ich bräuchte mal ein Example.
Ein Example-Docker-File.
Publish.net, nicht auch eine Binary.
Die ist aber standardmäßig abhängig von der Runtime.
Und wenn die Runtime nicht da... Also, es ist ja nichts da.
Dann geht das nicht.
Die müsste ich als self-contained application raushauen.
Dann würde es funktionieren.
Das ist geschisselt im Entry-Point.
Also quasi so, oder wie?
Ne, also.
Ich brauch mal ein Example.
Ich brauch mal ein Example-Docker-File.
Gibt's hier irgendwie ein Example-Docker-File?
Ja.
Entry-Point.
Ach, tatsächlich, guck mal.
Man gibt da wirklich nur...
Gibt man da vielleicht so wirklich nur...
Das hinten gar nicht mit an?
Das braucht man wahrscheinlich gar nicht, ne?
Geht.
Nice.
Aha.
.net weggeschisselt, anscheinend.
Gut zu wissen.
Gut zu wissen.
Easy, easy.
Guck mal, und jetzt haben wir nur noch 260 MB.
Und jetzt abschließend mal den Test.
Wie lange würde so ein komplettes Bild jetzt brauchen?
Wahrscheinlich so eineinhalb Minuten.
So, Bild.
Weil ich hab jetzt alle meine Caches und sonst wie weggeschmissen.
Okay, also.
Gucken wir mal drauf, wie lange so ein komplettes Bild jetzt braucht.
Jetzt wird richtig drauf losgeschisselt, ey.
Das heißt, glaube ich, schmeißeln, gell?
Auf Deutsch.
Schisseln oder so.
Ich glaube, es heißt meißeln.
Da haben die...
Ja, ist das ein Image von Microsoft?
Oder ist das ein Image, was die Canonical-Leute schisseln?
Vielleicht finden wir nochmal.
Ich hab noch eine Idee.
Docker-File-Rust.
Vielleicht gibt's da noch...
Bald neu der Schissel-Champ.
Vielleicht gibt's ja da ein Exempel für...
Äh.
Nee, ich überlege gerade, ob es nicht vielleicht was gibt,
dass man irgendwie diesen Cargo-Bild...
Äh, dieses Cargo-Library-Gedöns...
Cachen könnte.
Habt ihr auch ein bisschen gemeißelt heute an euren Containern?
Sehr nice.
Cache Rust-Dependent.
You need a dummy AS and your Cargo-Yammel first.
Then build it to cache the dependencies and then copy your...
Ach so!
Hi-I-Q.
Hi...
Ach, guck mal.
Die legen so eine Fake-Lib-AS an.
Und danach in einem Build-Step die richtige.
Okay, das Bild, das probiere ich jetzt noch aus.
Jetzt wird Rust geschisselt, Leute.
Okay, Image hat gebildet jetzt...
Wie lang?
280 Sekunden.
Alles klar.
Pass auf.
Wir schisseln jetzt das Rust.
So.
Also, so.
Cargo.
So, an der Stelle.
Wenn man jetzt hier sagt Cargo-Bild...
Dann meckert er garantiert, weil...
Keine...
Äh...
Lib-AS da ist.
So, wenn ich jetzt sage run...
Touch...
Lib...
Ne, Moment, was?
Source...
Lib-AS...
Geht das jetzt?
No, such file or directory.
Äh...
Moment, kann das sein, dass es Touch einfach nicht gibt?
Das ist zu...
Hyper...
Touchy?
Ne.
What?
Jetzt.
Ist es nicht irgendein Base-Tool, was immer dabei ist?
Ach, der Source-Ordner wird...
Okay, okay.
MKDir...
Source.
Äh...
Ich dachte eigentlich, dass Touch Bash Build-In ist.
Okay, ne, passt, passt, passt, passt.
Ich glaub, Leute, das Funst...
Ist...
Better Twitch TV Schissel...
Ja, so oft werden wir das nicht brauchen, vermute ich.
Aber, Leute, ich glaub, das Funst, was ich hier vorhab.
Ich glaub, das Funst...
Guck mal.
Der hat jetzt die Datei angelegt, die leere Lib-Datei.
Jetzt kompiliert er.
Und jetzt, für den nächsten Step, sollten die Dependencies eigentlich gecached sein.
Ja, ich glaub, das Funst, Leute.
Ich glaub, ich glaub, das Funst.
Cargo-Bild...
So, probieren wir jetzt aus.
Wir ändern jetzt...
Also, eben hat's ja noch lange gedauert.
So, wir machen jetzt einfach hier doppelten Output.
So, ist ja eh egal.
Seven TV Emotes...
Rust.
Das ist ein gutes Emote.
Das find ich gut, das mach ich mal.
Use Emote.
Ich mein, das bezieht sich ja...
Das bezieht sich ja auf das Game, ja?
Aber es passt in dem Fall ja auch.
So, schau mal mal, wie schnell...
So, schau mal mal, wie schnell...
Wie schnell das jetzt geht.
Nice!
Es funktioniert!
Guck mal!
Die Dependencies sind gecached.
Jetzt.
Das ist richtig high IQ gewesen.
Guck mal, wie viel schneller das jetzt fertig ist.
Es funktioniert!
Okay, das ist nice.
Guck mal.
Dadurch, dass der hier eine leere Lib...
Also, hier holt er sich die neuesten Cargo...
Das neueste Cargo-Dependency-File.
Dann legt er eine Fake-Lib-RS an, sodass Cargo-Bild funktioniert.
Ab der Stelle ist es gecached.
Bis zu dem Zeitpunkt, wo sich an meinen Dependencies was ändert.
Und da ändert sich ja selten was dran.
Und nur dann, wenn sich die Dependencies ändern, dann bildet er Dependency und Anwendung neu.
Sonst bildet er nur die Anwendung neu.
Eigentlich sehr nice, oder?
Excellent!
Die Standard.net Docker-File-Templates machen das by the way auch.
Was? Die schisseln?
Ne, was machen die?
Ich committe das mal.
Ja.
Packweight.
Hier ist das Docker-File drin.
Der Urlaub wird ausgenutzt, ja.
Erst Restore, dann Source kopieren.
Ach das!
Ja.
Deswegen bin ich drauf gekommen mit dem Restore, weil ich bilde mir ein, weil ich das da mal gesehen hab.
Deswegen wollte ich gucken, ob Cargo auch sowas hat.
Aber muss ein bisschen tricksen.
Aber ist schon okay.
Geht eigentlich ziemlich gut.
Ähm...
Okay.
Ja, das ist noch die Sachen vom letzten Mal.
Die pushe ich jetzt einfach...
...mal ins...
...ins ChemChamp-Shit.
Git push origin master.
Bam.
Schau mal, was der ChemChamp macht auf GitHub.
Der hat jetzt ein Comet.
Und er hat mit Abstand die allerbesten Comet-Messages.
Das gefällt mir.
Nice.
Excellent, würde ich dazu sagen.
Excellent.
Guck mal, die machen hier super kompliziertes Zeug.
Das...
...müssen wir gar nicht machen.
Excellent.
Okay.
Ich würde sagen, wir waren heute highly effective.
Nee, effective ist das Fall.
Und highly...
...productive, nicht effective.
Image unter 200 MB.
Da muss so ein bisschen was weggeschisselt werden.
Also unter 200 MB ist enorm schwierig.
Wenn FFmpeg schon 140 MB groß ist.
Und dementsprechend das OS...
Ich glaube nicht, dass das funzt, ey.
Könnte man das Programm auch als Dienst programmieren?
Wie jetzt?
Du meinst Windows-Service oder was?
Ja, bestimmt.
Bestimmt.
Damit will ich mich nicht beschäftigen.
Also wir müssen...
Okay, wir könnten FFmpeg selbst programmieren.
Wir könnten FFmpeg selbst kompilieren.
Und wirklich nur das einbauen, was wir bräuchten.
Das wäre eine Möglichkeit.
Ey, Leute.
Das machen wir.
Leute, das machen wir.
Das machen wir.
Nicht jetzt.
Nicht jetzt.
Das machen wir.
Da habe ich schon lange Bock drauf, mal FFmpeg selbst zu bauen.
Mit genau den Options, die man braucht.
Weil wir brauchen nicht viel.
Wir brauchen RTSP-Support.
H264.
Nee, noch nicht mal H264-Support.
Wir decoden ja nix.
Wir brauchen eigentlich nur FFmpeg.
Nur mit RTSP-Support.
Da wird FFmpeg eine ganze Ecke kleiner.
Wir brauchen keine Filter.
Wir brauchen nix.
Netzwerk.
Wir brauchen Netzwerk.
RTSP-Support.
Das machen wir mal.
Ja, ja.
Und dann können wir...
Das ist...
Okay, Leute.
Unsere Mission wird sein.
Für den nächsten Stream.
Image...
Image kleiner...
Kleiner...
200 MB.
Das machen wir im nächsten Stream.
Image kleiner 200 MB.
Es kann sein, dass wir OpenSSL brauchen für RTSP.
Das ist möglich.
Was macht FFmpeg?
FFmpeg verbindet sich hier zu Webcams.
Also ich kann es ja mal starten.
Dann siehst du es.
Also Webcam ist jetzt ein bisschen das falsche Wort.
Webcam ist stellvertretend von einem lokalen RTSP-Server.
Aber im Prinzip Webcam...
Oh shit.
Jetzt habe ich irgendwas kaputt gemacht.
Warum?
Warum?
Da ist es doch.
Ach ich kack knub.
Wie jetzt?
Na ja.
Angular.
MonkaS.
No.
I'm no Angular...
Expert.
No Frontend Expert.
And especially no Angular Expert.
Okay.
Mv...
FFmpeg.
Zu FFmpeg.
So, jetzt sollte es eigentlich funktionieren.
Ja.
Funst.
Also was das macht ist folgendes.
Das verbindet sich zum...
Ach so.
Jetzt habe ich den Kram hier noch auskommentiert.
Kann ich ja gar nicht zeigen.
So, es verbindet sich lokal zu einer Webcam.
Und dann streamt es den Webcam-Output in den Browser.
Und der Trick dabei ist, wenn es denn jetzt funktioniert, wenn ich es nicht irgendwie
kaputt gemacht habe, habe ich nicht...
Also stellvertretend für Webcam-Output gibt es halt ein YouTube-Video von mir.
So.
Und ohne zu re-encoden.
Das ist halt das Ding.
Also, der nimmt einfach...
Der connectet sich per RTSP.
FFmpeg RTSP connectet er sich zum...
Zur Webcam.
Liest die einzelnen Frames oder ja, Packages aus.
Aus diesem H.264 encodeten Stream.
Und schickst die 1 zu 1 weiter per WebRTC in den Browser.
Und der Browser decodet dann.
Also das heißt, es ist...
Braucht nahezu keine CPU-Last auf Server-Seite.
Bloß ein bisschen zum decoden im Browser.
Und wie performant ist das jetzt im Vergleich zu Go?
Ich habe keine Ahnung, ob es in der Praxis überhaupt einen nennenswerten Unterschied macht.
Höchstwahrscheinlich nicht.
Höchstwahrscheinlich nicht.
Weil...
Der große Unterschied zwischen Rust und Go in dem Fall ist.
Also wo es wirklich richtig krass Performance gut machen könnte.
Ist an der Stelle, wo man oft callen muss nach Go von .NET aus.
Und so oft call ich nicht.
Ich meine, es sieht zwar hier viel aus.
Ihr seht es hier durchrattern.
Aber das sind halt auch nur alle 16 Millisekunden.
Alle 16 Millisekunden ist halt gar nichts.
Im Browser kann man das nicht siegen.
Korrekt.
Das geht um Live-Webcams.
Du kannst nicht siegen.
Wieso nicht Rust-Cam?
Weil CamChamp...
Weil meine Dinger immer Champ heißen.
Außerdem ist es nichts, was ich will, dass irgendjemand verwendet.
Sondern das ist gebastelt für mich.
Und ich werde es wahrscheinlich bei mir benutzen.
So, wo wir gerade dabei sind.
Lass mal gucken.
Ich glaube, der 4er-Champ hat immer noch keine Bugs.
Nee.
Obviously keine neuen Bugs.
Ist ja auch komplett bugfrei.
Der 4M-Champ hat natürlich auch keine neuen Bugs.
Okay.
Alles klar.
Weil Bugs produzieren wir hier ja nicht.
Bei uns ist alles immer first try.
5Head-Community-ge-fehlerfrei.
So, Chat.
Sehr schön.
Das hat heute wunderbar funktioniert.
Nächster Stream.
Ahead of Time Compilation.
FFmpeg selbst kompilieren.
Und gucken, dass wir das Image unter 200 MB kriegen.
Also mit AOT sollte es easy funktionieren.
Weil dann ist auch .NET kleiner.
Und FFmpeg, wenn das geht.
Also, nee.
AOT sollte easy funktionieren.
Da ist auch die ganze .NET-Anwendung kleiner.
Wir bräuchten theoretisch auch gar kein .NET-Image mehr.
Und FFmpeg, wenn das geht, kommen wir easy unter 200 MB.
Wenn das Custom sich kompiliert.
Was jetzt gemacht wird Offstream.
Ich bin heute noch nicht mal eine Runde gelaufen.
Das werde ich jetzt machen.
Vielleicht so in dem Dreh, ja.
Wobei man halt sagen muss.
Teile von der .NET Runtime müssen ja trotzdem rein.
Beziehungsweise nicht von der Runtime.
Aber von der Standard-Library trotzdem rein.
Weil sonst läuft das Zeug ja nicht.
Also, wir sehen uns, Leute.
Bis dann, macht's gut.
Ich hoffe, euch hat das Stream gefallen.
Wenn euch das Stream gefallen hat.
Dann könnt ihr mir jetzt followen.
Dass ihr beim nächsten Broadcast-Stream.
Oder bei was auch immer wir machen.
Wieder mit am Start seid.
Würde mich freuen.
Und schön, dass ihr da gewesen seid.
Wir sehen uns im nächsten Stream.
Bis dann.
Macht's gut.
See you.
Die ersten.
So, so muss das sein.
Bis dann.
Macht's gut.
See you.
