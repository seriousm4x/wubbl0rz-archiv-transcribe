Bis zum nächsten Mal.
Bis zum nächsten Mal.
So, da bin ich.
Gucken, ob das Mikro funktioniert.
Battlefield 6.
Dazu müsste ich Battlefield 6 erstmal spielen.
Ich weiß immer noch nicht,
ob ich das machen soll.
Lest ja da viel Widersprüchliches.
Und viele meinen auch irgendwie schon,
dass man nach zwei Monaten die Luft raus und
ach, keine Ahnung.
Irgendwie haben die mich verbrannt mit Battlefield 2042.
Ich habe gar nicht richtig Bock.
Obwohl ich extra meinen Rechner neu aufgesetzt habe.
Ich musste ja Windows neu installieren wegen Secure Boot.
Und Anti-Cheat.
Dass das funktioniert, habe ich ja gemacht.
Also ich könnte jetzt spielen, aber ich habe nicht gespielt.
Bis jetzt.
Overlay, danke schön für den Sub.
Massive Subscription.
Ich habe mir gedacht, wir haben das letzte Mal
haben wir so viel Java gemacht.
Und
ich habe ja gesagt, wir machen dann was
in Kotlin. Aber ich habe mir jetzt gedacht,
komm, genug Java-Krempel erstmal.
Wir machen jetzt zwischenzeitlich mal was
in Rust.
Ich lerne ein bisschen Rust und
ich nenne den Titel einfach mal
Rust lernen.
Die Krabben sind unterwegs.
So.
Ja, ich mach mal kurz das Java-Zeug weg hier,
was wir da noch haben.
Und jetzt kann ich euch nochmal das Schöne zeigen,
wie nice das ist, wenn man hier diese Container-Entwicklungs-Stells
macht. Guckt mal hier.
Und jetzt, zack.
Alle Rückstände wieder weg.
Bist du krank?
Nee. Ich hab ein bisschen
ich hab ein bisschen
so raubtrocknen hals aber ich bin nicht krank ich hoffe ich hoffe auch nicht dass ich krank werde
blazingly fast nase job keine ahnung ist mal so mal so ich glaube ich habe nicht genug getrunken
so und jetzt blazingly fast written in rust wir gucken uns heute wir machen
in der das ist denn hier warum ist das rgb sekunde rgb beleuchtung von
meiner tastatur ist falsch jetzt also richtig rein raus gestöpselt
Wollte ich jetzt gerade sagen.
Genau, wir gucken uns mal Rust Web Framework an.
Und zwar Rust Axum.
Das scheint der neueste Shit zu sein bei Rust.
Im Rust Ökosystem blickt man ja nicht durch.
Rust Projekte bestehen aus fast so vielen Dependencies wie Node.js Projekte.
Und alle zwei Jahre, ach Quatsch, zwei Jahre, alle paar Monate ist irgendein Framework dann wieder unmaintained und irgendwas Neues.
Also das Rust-Ökosystem, da kann eh auch niemand Schritt halten.
Fast so schlimm wie JavaScript, nicht ganz so schlimm.
Ja.
Deswegen gucken wir uns heute mal Axum an, beziehungsweise so Sachen, die drumherum gehören.
Wie macht man einen Background-Job? Wie macht man Structured Logging?
Wie macht man irgendwie so eine globale App-Config?
Ich weiß, globale Variablen in Rust sind ja super, super verpönt, aber manchmal kommt man nicht drumherum.
Wie macht man Command-Line-Parsing?
Ja, irgendwie sowas.
Mal gucken.
Ich glaube nicht, dass da jetzt eine richtig tolle Anwendung bei rauskommt am Ende.
Aber man hat wieder was gelernt.
Und die nächsten Tage, ich würde sagen, ich finde es immer ganz gut.
Das hat mir auch so die letzten Streams gezeigt.
Es ist immer ganz gut, wenn man ein Thema so zwei, drei Streams macht.
weil ansonsten wird es unübersichtlich und man kommt schlecht rein wenn man die streams davor
nicht dabei war und in 12 streams ist meistens nicht so viel passiert wenn man kurz drüber
scrollt blickt man schnell durch und dann kann man noch kann man drei streams machen
zu dem thema das reicht auch meistens erst einmal sonst wird es zu zu abgedreht meistens
Doch, doch, das machen wir auch noch.
Das machen wir auf jeden Fall noch den Dezember.
Ja, und dann
macht man drei Streams
zu einem Thema. Das ist immer ganz gut.
Kriegt man dann alles auch ganz gut durch.
Dann
machen wir was anderes. Dann machen wir
Set-Servers. Mit echt mal Zeit.
Die haben mittlerweile 70
oder weiß nicht wie viele.
Warte, lass mich mal kurz gucken.
Die haben mittlerweile
Szenarios. 70 Szenarios.
75 Szenarios oder sowas hier.
Moment, Moment. Nee, die haben mehr.
Guck mal. Die haben 25
Easy.
56.
Boah.
Die haben ja richtig viele
mittlerweile. Allein schon
Easy und Hard zusammen sind 40.
Die haben
96 Szenarien mittlerweile.
Boah, das ist aber richtig...
Wo wir das gemacht haben vor ein paar Jahren,
da hatten die, keine Ahnung,
25 oder so.
Ob ich noch weiß,
welche ich gemacht habe?
Ich weiß nur, dass ich das hier auf jeden Fall gemacht habe.
Da kann ich mich noch dran erinnern.
Das ist nämlich einmal gucken,
welcher Prozess läuft und dann killen.
So, das...
Da kann ich mich noch dran erinnern.
An die anderen kann ich mich nicht versuchten.
Den habe ich auch schon ein paar Mal zum Beispiel gemacht.
Bei den anderen muss ich dann mal gucken.
Das haben wir auch schon gemacht.
Das kommt mir auch bekannt vor.
Das haben wir glaube ich auch schon gemacht.
Das auch.
Ich weiß es nicht.
Wir haben damals die alle gemacht, die es schon gab.
Und ich blick da nicht mehr durch.
Wollen die dafür Geld?
Ja, es gibt jetzt eine Pro-Subscription.
Die finde ich ist auch ganz okay gepriced.
Kannst du für 50 Euro für ein Jahr oder sowas.
Ja genau, 50 Dollar für ein Jahr kannst du dir holen.
Und da kriegst du nicht nur die Pro-Szenarios,
sondern du kriegst auch so ein bisschen auswertung falls du das andere leute
machen lässt das ist eher dafür gedacht
wenn du beispielsweise ein admin einstellen willst und willst checken ob
da auch wirklich bisserl ahnung von linux hat hast und sagt hier mach doch mal
aufgabe 5 und 15 da kannst du nämlich im nachhinein auch
noch die aufzeichnung angucken was der gemacht hat und so was
Ansonsten kann man sich ein...
Also man kann ja auch schon relativ viele Szenarien machen for free.
Oder man muss halt 5 Dollar ausgeben, um die zu machen.
Das finde ich ist fair.
Letztendlich steckt hinter jedem Szenario eine AWS-VM.
Das kostet ja auch Geld, also irgendwie müssen die den Kram ja bezahlen.
ja das wird das wird bestimmt was kosten ja mal stark von aus sind zwar kleine vms aber
sind vms und mittlerweile ist der service ja auch relativ bekannt das heißt da sind auch
tagtäglich sich vms ab also es wird auf jeden fall was kostet und aws vms sind nicht billig
also hier aws pricing instance pricing
anfälle wenn ich auf der aws zeit was man das general purpose keine ahnung mal zwei cpus
Kann man den Kram irgendwie umstellen auf monatlich?
Ich bin nicht so der große AWS Checker, haben die eine Möglichkeit monatlich hier anzuzeigen?
Oder muss man das selbst ausrechnen?
Weil die nicht wollen, weil die nicht wollen, dass man sieht wie teuer es denn ist.
zumindest sind vms bei allen großen cloud anbietern also jetzt egal ob das microsoft
ist in asia oder google oder aws oder sonst wie vms sind relativ teuer wenn man wenn man
einfach nur eine nackige linux vm braucht fährt man mit so was wie hetzner viel besser als mit
den üblichen cloud anbietern dafür haben die halt auch ein größeres ökosystem ja du hast ja
wenn du dich bei...
Fuck.
Wenn du dich bei Google einloggst,
wenn du hier diese Übersicht...
Ich bin jetzt nicht eingeloggt,
aber ich glaube, wir haben ein Bild davon.
Wir haben ja hier links...
Ja, okay.
Da kein Bild davon irgendwie.
Genau, hier.
Hierneben, in dieser Leiste,
wo man die Services anzeigt,
Da haben die ja mittlerweile 150 Stinger oder so drin.
Also das Ökosystem bei den etablierten größeren Hyperscalern, wie man das ja so schön nennt, weil es irgendwie geil klingt.
Weil ich finde es klingt ein bisschen cringe, wenn ich ehrlich bin.
Aber die haben so viele Angebote und Services mittlerweile, da blickst du nicht mehr durch.
Das heißt, wenn man einfach eine Nackische VM braucht, ohne dieses große Ökosystem drunter, Hetzner Kiste kaufen, das ist deutlich billiger.
oder irgendwas anderes.
Digital Ocean ist ein ganz guter Kompromiss.
Die haben noch ein bisschen mehr als VMs,
die haben auch Managed Datenbank, Kubernetes Cluster,
aber nicht ganz so teuer,
wie beispielsweise bei Azure die VMs.
Aber wenn man wirklich nur eine nackige VM braucht,
ist Hetzner echt super.
Ich kann sogar sagen,
man verzichtet auf eine Public IPv4-Adresse,
dann ist es sogar noch mal ein bisschen billiger.
Noch mal 50 Cent billiger.
Hast du noch einen Rabattcode von Hetzner?
Nee, keinen mehr, der funktioniert.
Ich habe mit dem auch schon eine Weile nichts mehr gemacht.
Also, dementsprechend werde ich wahrscheinlich in nächster Zeit auch keinen Rabattcode haben.
Man könnte natürlich mal wieder Hallo sagen und gucken, ob man was machen will.
Aber ich habe gerade wenig Bock auf Sponsor-Streams und Videos ja auch nicht.
Also, ne.
Das lassen wir.
Ja, also meine Lieblingskiste bei Hetzner ist ja...
Bin ich jetzt blöd? Wo ist die denn?
Hier? Ne.
Hä?
Gibt's die nicht mehr?
Sag mal, Chat, bin ich dumm?
Wo ist denn die Triple Core Kiste?
Gibt's die nicht mehr?
Und seit wann gibt es in Germany nur noch eine Location?
Und warum gibt es keine Location mehr in den USA?
Bin ich jetzt verwirrt?
Haben die Probleme?
Oder was ist?
Die haben umstrukturiert.
Aha.
Also es gibt kein Rechenzentrum mehr in den USA.
Und nur noch eins in Deutschland.
Sehe ich das richtig?
Ach nee.
Ah.
Regular Performance gibt es noch.
Da gibt es auch welche in USA und Singapur.
But it's not a triple core.
But it's not a triple core.
Aber es gibt keine Triple Core Kiste mehr.
Ja, das ist aber doof.
Das war meine Lieblingskiste, die Triple Core Kiste.
Die hat ordentlich CPU Leistung gehabt.
Genug RAM, genug Speicherplatz für alles.
Und hat auch irgendwie so nicht viel mehr gekostet.
Die war mir lieber.
Naja gut.
Ist aber, ich mein, kannst dich immer noch nicht beschweren.
Ja, 5,49 Euro oder 4,99, wenn du auf deine IPv4-Adresse verzichtest.
Das ist immer noch in Ordnung.
Da kannst du nix sagen, ja.
Das ist vollkommen okay.
Ja, da fährt man auf jeden Fall am besten mit.
Nicht unbedingt jetzt rein mit Hetzner, aber mit...
mit ein bisschen oldschooligen Hosting-Anbietern
und nicht die kompletten All-in-One-Cloud-Lösungen, die es gibt.
Das lassen sie sich halt auch gut bezahlen.
Ich habe übrigens gehört, bei mir auf der Arbeit,
da wird jetzt ein Versuchsaufbau gestartet
für Cloud,
für eine Cloud-Lösung in Deutschland.
Da bin ich mal
gespannt,
also welcher Anbieter es dann da wird,
ob es Lidl wird oder
Telekom oder keine Ahnung.
Die wollen wohl irgendwie gucken, ob es Alternativen
zu Azure und
AWS und GCP
gibt, die man auch sinnvoll
verwenden kann.
Ich habe ja das Gefühl, sie wird rauskommen.
Ist nicht so das.
Aber mal gucken.
Mal gucken.
Rast Pogu.
Wer guckt deine Firma?
Was?
Was meinst du?
Nee, nicht meine.
Da, wo ich arbeite.
Nee, nicht meine Ein-Mann-Firma.
25 commits, 250 files touched.
Ja, ordentlich.
Eine eigene Programmiersprache.
Ist ja auch nur just for fun, oder?
Weil es dich interessiert, wie man sowas baut.
Oder hast du große Ambitionen?
Achso, T-Lang.
OKS.
Ne, das ist die von Garmin.
Garmin benutzt Monkey C
um ihre
Navigationsgeräte, Fahrradcomputer, Uhren
und so, wenn man dafür was programmieren will.
Ach ne.
Ach so. Das heißt wirklich so bei dir.
Achso.
Ich dachte, du meinst...
Jetzt hab ich durcheinander gebracht, Chat.
Ich dachte, ihr meint das von Garmin.
Let.
Na?
Geht schon los in die Richtung, wie wir uns heute mit Rust beschäftigen.
Damit auch lettet die ganzen Variablen.
Lettmut gibt's in Rust.
Lettmut.
Aha.
Ja, es gibt keine...
Wie wär's mit Syntax-Highlighting?
Ich weiß, es gibt keinen fertigen Syntax-Highlighter, der das kann.
Aber du kannst ja von Hand Syntax highlighten.
Dann sieht das Beispiel einfach nicer aus.
Was seid ihr alles für High-IQ-Leute, die sich hier eigene Programmiersprachen erstellen?
Massive.
Aber immerhin schöne Emojis drin.
Ist die Readme-AI zusammengeschustert?
Wird's cool.
Was ich glaube, ich glaube, die ist AI-mäßig zusammengewurschtelt.
Das sieht irgendwie nach AI aus.
Ich weiß nicht.
Das ist so viel, so viel, so viel Worte, so viel Text.
Das sieht nach AI aus.
Sarix, moin.
Exzellent, Leute.
So, wir müssen erst einmal, bevor wir überhaupt anfangen können mit Rust, ne.
müssen wir uns erstmal eine VM erstellen.
Quatsch, was laber ich denn für einen Scheiß?
Keine VM erstellen.
Container erstellen, in dem wir entwickeln können.
Weil ich bin ja dazu übergegangen,
nur noch in Containern zu entwickeln.
Mit DevPod.
Da bin ich fast immun gegen Supply Chain Angriffe.
Der VM Champ, der geht nicht mehr.
Aber wir brauchen eh keine VM, wir brauchen einen Container.
Container Champ.
Ich kopiere mir das mal kurz.
Den Quarkus Champ.
Den kopiere ich mir mal rüber.
nach Rust.
Guck mal, hier hatten wir den Sigmetric-Champ.
Da waren wir den Rust...
Nee, einfach nur den Rust-Champ.
Und jetzt löschen wir mal alles, was mit Java zu tun hat.
Zack.
Zack.
Um. Weg damit.
Excellent.
So, dann gehen wir nach Dev-Container rein
und schauen uns das Ganze mal an.
Wir müssen Container bauen für Rust.
Bin mir gar nicht sicher,
was die beste Variante ist.
Kennst du den Clipchamp von Windows? Ja, den kenn ich. Den hab ich aber nicht installiert.
Das ist optional. Oh doch, den hab ich installiert. Dann kommt der Clipchamp, kommt jetzt weg.
Bam, uninstall Clipchamp.
Es ist übrigens auch geil, ne, dass, ähm, da sieht man mal wie schlecht das eigentlich
programmiert ist in windows dass man denkt dass das wenn du was an installs tier im startmenü
sich das nicht automatisch wie flash wenn die anwender an install durch ist ich bin der meinung
dass man das windows es gibt keinen windows killer der windows gilt windows kann nur bzw microsoft nur
sich selbst killen was windows angeht und das haben sie die letzten paar jahre echt ganz gut
hingekriegt und ich denke man kann jetzt zu recht sagen 2026 waren wir noch nie so nah am
jahr des linux desktops dran wie 2026 es wird auch 2026 nicht wirklich das jahr des linux desktops
aber wir waren noch nie so nah dran ja ja ja ja da wäre ich da war ich auch am start wenn anti
die Cheat auf Linux laufen würde. Da wäre ich auch am Start.
Ja.
Deswegen. Ich sag ja, nur Microsoft
kann Windows killen und da arbeiten sie ja hart
dran.
Übrigens, der Microsoft-Chef,
ich weiß nicht, ob ihr das gelesen habt,
der Microsoft-Chef,
der hat jetzt gesagt,
alle Mitarbeiter
sollen gefälligst
wie verrückt nur noch AI
machen und wer das nicht will,
soll abhauen, so sinngemäß.
Also,
das deckt sich
auch mit der Erfahrung,
was ich so gehört habe von Microsoft.
Es gab ja bei uns so ein paar Verkaufsveranstaltungen.
Offiziell waren das ja
keine Verkaufsveranstaltungen, das waren
so, wir, ja doch,
schon Verkaufsveranstaltungen.
Also, es gibt
öfter so Veranstaltungen, da werden
Leute, die in größeren
Unternehmen Entscheidungen treffen, eingeladen,
dass man denen erzählen kann, was es so Neues gibt.
Es sind nicht direkt Verkaufsveranstaltungen,
aber es sind irgendwie auch Verkaufsveranstaltungen.
Und unser Chef hat erzählt,
also nicht der Chef, der Abteilungsleiter hat erzählt,
die waren eigentlich alle ganz gut von Microsoft,
die waren, Schwachsinn, von Google,
die waren ganz gut die Leute, die neue Cloud-Sachen gezeigt haben.
Von AWS, die waren ganz gut die neue Cloud-Sachen gezeigt haben.
Die haben sich auch der Thematik angenommen,
sind drauf eingegangen mit, wie ist das mit Daten,
dass die nur in Europa bleiben und sowas, außer Microsoft.
Microsoft hat prinzipiell nichts beantwortet, gescheit, nichts gescheit gezeigt,
außer wir haben AI und ihr müsst AI kaufen, AI-Beste.
Das muss man sich wirklich so vorgestellt haben, wie, ja, hallo Herr Microsoft,
hallo Herr Azure, sagen Sie mal, wie ist es, wie sieht es denn mit Datenschutz aus
und Daten in der Cloud, dass die in Europa bleiben?
Da müssen die sinngemäß dann sowas drauf geantwortet haben.
Aha, das ist eine sehr gute Frage, die man auch toll mit AI lösen kann.
Also, die kannst du voll knicken, gell.
Cliffy schreibt, bin fiesi. Einmal im Monat zum Patch-Test, sagt dann ein Kollege im Morgen.
Ach ja, das neue Update hat das und das kaputt gemacht. Hier, das war lustig.
Ich sag dann immer, wo gearbeitet wird
Fallen, äh, ne, nein, nein, nicht wo gearbeitet wird
Wo gehobelt wird, fallen Späne
Ne, wie geht das? Wo gehobelt wird, fallen Späne?
So rum, gell?
Kann ich mal richtig reden
Wie findest du denn MacOS?
Das bisschen, was ich bisher von MacOS
gesehen habe
Also das ganz kleine bisschen
Was ich selbst bisher von MacOS gesehen habe
fand ich ganz okay.
Und was ich bei Videos sehe,
finde ich auch ganz okay. Hauptsächlich.
Nicht wegen dem GUI oder sonst was.
Sondern weil es, sagen wir mal,
Unix-artig genug ist, um nicht abzufacken.
Den Rest kannst du ignorieren.
Also
ist ganz brauchbar.
Ja, also
für Technik
Sachen zu machen, für Sachen zu entwickeln,
für Bastelkram oder so,
ist alles besser als
windows also ist egal ob es ein ordentlich eingerichtetes linux ist oder mac os oder
ein fix und fertig ist ubuntu einfach nur drauf ist alles besser als windows windows hat nur noch
so ein paar feiler das ist einmal gaming hauptsächlich auch wegen anti cheat gaming
selbst an sich ist ja mittlerweile linux gar nicht so übel aber hauptsächlich anti cheat
und ein paar professionelle Anwendungsgebiete.
Also die Leute, die unbedingt Photoshop mit Grafikbeschleunigung benutzen müssen
und keine Ahnung, was gibt es da sonst noch?
Irgendwelche Videoschnittdinger, wobei es da mit DaVinci Resolve ja mittlerweile auch,
habe ich noch nicht probiert, aber auch ein ganz gutes Cross-Plattform-Ding gibt.
Oder irgendwelche Business-Anwendungen, wo das nur zertifiziert ist für Windows 11
und irgendwelche CAD-Geschichten oder so.
So paar Dinger.
Aber ansonsten ist Windows eigentlich für alles andere
der größte Rotz.
Was? Windows killt Intel-Chips?
Davon habe ich noch nichts mitgekriegt.
Erinnert sich noch einer an Silverlight,
Wo wir gerade bei toten Microsoft-Technologien sind
Das war auch so ein Ding
Silverlight, wer das nicht kennt, das war Microsoft Flash
Das war Flash, quasi
Der Flash-Konkurrent von Microsoft war Silverlight
Und
Das ist aber, nach ganz kurzer Zeit haben die es schon wieder sterben lassen
Hast du das GitHub-Drama mitbekommen?
Ja, das ist aber schon ein paar Tage alt
Gab es da mittlerweile was Neues?
Also du meinst das Drama, dass GitHub Runner, GitHub Action Runner, die man selbst hostet, jetzt irgendwie mit 0,02 Cent die Minute, nee, keine Ahnung, wie auch immer, zu Buche schlagen.
Ja, und das habe ich auch gehört. Ich habe auch gehört, das ist das Letzte, was ich davon gehört habe, dass die einen Rückzieher gemacht haben, ja.
Moonlight, ja, kenne ich. Das war die Mono-Implementierung von Silverlight. Moonlight ist ja mittlerweile was anderes. Moonlight ist mittlerweile eine Implementierung vom Nvidia Streaming Service.
Doppelt benannt, belegter Name.
Nvidia-Dreiber sind immer noch nicht so geil unter Linux.
Das mit Sleep ist auch geil
Habt ihr das mitgekriegt?
Save Sleep auf GitHub
Ich weiß, wir sind jetzt ein bisschen sidetracked, aber
Save Sleep
Auf GitHub
Guck, sowas läuft hier auf GitHub, Runnern
Save Sleep
Hahaha
Also, ich muss, also zwei Sachen sind daran extrem beschissen.
Erstens ist das idle, oder wie nennt man das, busy, busy waiting, heißt das so?
Ja, also die haben im Endeffekt, ist das eine Endlosschleife, die brutal CPU zieht,
weil die die sleep nicht oder so die rödel und macht nichts also so eine
busy waiting endlos schleife da hast du wenn du wenn ich das wenn man das
ausführt hast du einen cpu kern komplett voll oder mit mehrere teilweise weil es
ja gescheduled wird so und jetzt ist das zweite problem also das ist ungefähr so
wie wenn ich es koki weil weil true was und jetzt nichts machen ich wusste gar nicht dass das geht
ehrlich gesagt also du ok cook endlos schleife ein cpu kern ist voll das passiert damit so das
nächste problem ist die gucken hier das ist eine magic variable in bash die hoch zählt so das
nächste problem ist die busy waiten hier bis die sekunden also solange die sekunden ungleich dem
ersten argument sind also wenn das jetzt beispielsweise eine aufruft sie ist selbst
Sleep 10, dann steht hier 10
drinne und sobald das hier gleich
wird, also sprich sobald 10 Sekunden
rum sind, bricht die Schleife
ab. Das Problem ist jetzt
allerdings, die checken
ungleich. Was ist denn
jetzt, wenn es kurz ruckelt
und die Sekunden
auf 11 gehen?
Die gehen von 9 auf
11. Dann ist
es auch ungleich. Und dann
haben wir eine Endlosschleife, die wirklich endlos
läuft.
Also, der hätte mal schon so was wie
kleiner gleich oder so machen müssen.
Aber nee, unklar. Also, das ist wirklich
hardcore-Pepega,
dieses Ding.
Ja, dann 07, ja.
Dann ist LOL angesagt.
So.
So sieht's aus. Das war das mit
Safe Sleep, ja.
So, irgendwas
Was soll wohl hier noch gefragt?
Was? Sau blöde Frage.
Weiß das jemand?
Die physikalische Grenze beim Protokoll-
Was? Protokoll-Overhead.
Bezieht die sich auf den Port oder auch auf das Kabel?
Äh, was?
Die physikalische Grenze
beim Protokoll-Overhead?
Das verstehe ich nicht.
Keine Ahnung, was damit gemeint sein soll
Eine blöde Frage
Gerade standen Telekom-Mitarbeiter
Oh, das waren doch bestimmt irgendwelche Leute
Die Glasfaser verkaufen wollten, oder?
Ja, ja
Ja, ja
Jaja.
Ne, ne, blablabla.
Das sind irgendwelche, wie heißen die?
Ranger-Marketing oder sowas, gell?
Das sind irgendwelche Sales-Leute von einem Drittanbieter, die für die Telekom unterwegs sind.
Ignorier die einfach.
Ich hatte die auch schon vor der Tür.
Und die wollten auch erzählen, ja, sie wissen doch, dass bald Glasfaser ausgebaut wird.
Da habe ich zu ihnen gesagt, ja, ich gucke mal im Internet, wie es mit dem Ausbau aussieht.
Dann waren sie wieder weg.
Und dann habe ich im Internet geguckt.
Da war noch nicht mal was geplant.
Ja, das habe ich auch gelesen.
Der Typ, der jegliche C und C++ aus der Microsoft Codebase eliminieren will.
Aber ich finde, da hat Reddit, hat das gut erkannt,
dass es ein typisches Projekt von einem, der befördert werden will.
Und sobald er die Beförderung hat, hat er keinen Bock mehr drauf.
Sprix, danke schön für den Sub.
Irgendwo gab es vorhin noch eine Frage.
Aber die finde ich jetzt nicht mehr.
Oh.
Na gut.
Jetzt aber Rust. Genau.
Rust.
Ja gut, Vodafone-Kabel ist aber shared.
Also, potenziell ist so ein eigener Glasfaseranschluss schon nicer.
Aber du kriegst trotzdem ordentlich Bandbreite bei Vodafone für wenig Geld.
Für weniger Geld.
Ich habe ja selbst Vodafone.
Aber auch nur, weil es bei mir noch keinen Glasfaseranschluss gibt.
So, Rust.
Also, wir müssen erstmal einen Container bauen.
Wie installiert man am besten Rust mittlerweile?
Also ihr wisst, ich entwickle ja nur noch in Containern.
Das heißt, bevor wir anfangen können zu basteln, müssen wir uns erstmal einen Container bauen, in dem wir dann entwickeln können.
Da können wir uns dann direkt mit der IDE auch reinkonnekten und sowas.
So, also, JDK brauchen wir auf jeden Fall nicht für Rust.
Nix brauchen wir auch.
Wobei, können wir...
Ne, wir installieren das nicht über Nix. Scheiß drauf.
wir installieren noch geht weiß gar nicht warum ich das da oben nicht drin
habe ja und jetzt rast ab
doch wird die idee wird auf dem host und im container installiert das funktioniert
folgendermaßen du hast wobei ich kann es ja ich kann es ja gleich zeigen aber du
hast eine idee auf deinem host system das ist halt da auch wo das gui und
alles läuft, aber du hast quasi
so eine Client
Package von der IDE,
den hast du im Container laufen, weil du
willst ja gucken, was dort für
Environment Variablen gesetzt sind,
welche Toolchains installiert sind
und sowas in der Richtung. Also in zwei Sachen.
Es gibt im Container, das macht
aber DevPod auch alles automatisch, deswegen
verwende ich das mittlerweile echt gern
und das installiert
es für dich schon drauf und dann musst du
nur noch einmal die Connection einrichten
und dann geht das.
So, äh, Rust Up.
Rust.
Gab's da nicht, gab's da nicht
ein, äh, ein Buch für Rust Up?
The Rust Up Book.
Also ich hab ja schon mal
ein bisschen was in Rust gemacht, so ist es nicht.
Bin nicht komplett 100%iger Noob, aber
ziemlicher Rust Noob.
Wird aber dann in die
Files gemountet.
Das Projektverzeichnis wird
in den Container gemountet, ja.
das unter slash workspaces wird das verzeichnis reingemaut indem die dev container jason liegt
du wirst also durch das gleich sehen du wirst das gleich sehen das ist eigentlich relativ
easy so wir installieren jetzt installation chapter also wie von stars install nightly
Dann machen wir das doch.
Curl müssen wir auch noch installieren.
Und dann sagen wir
Curl
Default Toolchain None
J, okay, ja, machen wir so.
Beste.
Ne, Moment.
Das muss ich hier machen.
Rust up.
Ich will das ja nicht als Root installieren.
Oder?
Moment, Moment, Chat, ich muss denken.
Quatsch, das ist ja gar kein Root hier.
Ich mach Blödsinn. Da.
Okay.
Nicht Knightly?
Warum nicht Knightly?
Pleading Edge?
Rust.
So.
Docker, Build.
Wir gucken mal, ob das funktioniert, was ich hier gebaut hab.
Wobei, nee.
RustUp alleine installieren reicht ja noch gar nicht
RustUp alleine ist ja gar nicht genug
Wir müssen ja dann auch hier den Kram da machen
RustUp
Toolchain install nightly
Allow .profil minimal
Komponent Clippy
Können wir nicht einfach sagen
RustUp Toolchain install
Was mache ich denn anstatt nightly dann?
Stable?
War ich dann stable?
Okay, das scheint
funktioniert zu haben.
Docker-File.
Rust up.
Toolchain install nightly.
Clippy ist empfehlenswert.
Okay.
Clippy.
Clippy.
Das hat aber nichts mit der
Büroklammer von Office zu tun, oder?
Sorry, Microsoft 365.
Office heißt es ja nicht mehr.
Heißt es eigentlich noch Microsoft 365?
Die sind doch immer wild am Umbenennen.
So, und jetzt?
Okay.
Okay.
Wir müssen dann wahrscheinlich noch eine andere
C-Library installieren, dass wir Static Builds
machen können, aber das muss ich mal ausprobieren, wenn ich es dann
wenn ich es dann am
Dacht habe okay locker bild
Jawohl wird alles installt
Ist nach dem büro klammern wirklich aber warum
Ich muss ja sagen ich hatte bei früher in office hatte ich nie klippi ich hatte immer den zauberer
kennt ihr noch jemand da gab es ein zauberer anstelle von anstelle von klammer gab es
und zauberer aber ich glaube das findet man nicht mehr hier den da oder die katze genau
Die Katze hatte ich auch oft. Katze oder
Zauberer.
Cache der eigentlich jetzt den Download?
Ähm...
Ja, und also, das funktioniert
so. Moment, Docker-File.
Das funktioniert so.
Docker cached jede Zeile.
Und wenn sich in dieser Zeile was
ändert, oder davor,
dann wird ab hier, also quasi
ab danach
wird komplett weiter
gebildet. Also wenn ich jetzt hier hingehen würde
und schreib hier oben drüber
Run, Cackle, dann würde
alles ab hier neu gebaut.
Also das ist ein relativ doofes Caching.
Es gibt noch
andere Varianten, ja, also es gibt noch
aber das macht es dann komplizierter.
Es gibt noch die Möglichkeit, wenn du so Sachen
hast wie Node-Modules und so
und die cachen willst, gibt es noch irgendwie
was mit Storage-Provider oder so
was, dass du das cachen kannst. Das ist aber ein bisschen
komplizierter. Zu 900% reicht
das so.
So,
jetzt haben wir hier unseren Container.
Und wir wollen
nicht IntelliJ, wir wollen
Rust Rover haben.
Und dann können wir
loslegen.
Vielleicht noch nicht ganz.
Ups, warum starte ich das denn jetzt? Das ist falsch.
Ich will das gar nicht starten.
Ich gucke aber mal
In der Toolbox
Ob es neue Updates gibt
Oh je
Oh ne Leute
Shit
Ich update nur Rust Rover
Weil ansonsten dauert es wieder 3 Stunden
Bis alles geupdatet ist
rast chef aha schon hier sind die rastkenner am start
wir machen jetzt kein update wir machen nur rastro wird geupdatet da habe ich
keinen bock drauf jetzt alles aber ab was wird das projekt
hauptsächlich zu rast lernen das wird irgendeine web in den web server
beziehungsweise ein backend was bisschen start ist html ausliefert aber wir gucken uns halt
auch mal die sachen drumherum an sowie kriegt man gescheit gelockt wie kriegt man konfiguration
verwaltet über config falls über ein wein und variablen wie passt man sie alle argumente so
zeug wir handeln uns da mal so ein bisschen ein bisschen dran rum so dann können wir uns verbinden
sag so guck ich weiß nicht mehr wer es wissen wollte du startest du startest jetzt einfach
dieses connect skript und der lädt also der baut den container wenn er nicht gebaut ist der lädt
die idee schon runter diese kleinen idee schon in den container rein und danach startet er die
chatpoint idee direkt mit dem connection string wie du zum container kommst du musst also dann
eigentlich gar nichts mehr großartig machen und wirst direkt
in den Container connected. Das ist
sehr nice. Und eine SSH-Verbindung geht
auf.
Das musste ich auch nur einmal machen.
Und das Gute ist,
wenn ich fertig bin,
dann kann ich einfach deleten
und gut ist.
Okay, jetzt habe ich hier ein Terminal im Container.
Jetzt geht hier gleich meine...
Ich gehe schon mal auf den dritten Desktop.
Dev-Container sind richtig, ne?
Ich habe das total lang ignoriert, weil ich mir gedacht habe, wozu braucht man sowas?
Ich bin jetzt erst drauf gekommen, vor ein paar Wochen erst,
wegen diesen ganzen Scheihulut.
Das hört sich immer an, als sei es einer erkältet.
Supply-Chain-Angriffe auf NPM.
Da habe ich mir gedacht, was kann man denn machen,
dass wenn man sich selbst mal was einfangen sollte,
das nicht so
gefährlich ist.
Und da bin ich zum Schluss gekommen,
ja, ist ja auch ganz sinnvoll, einfach in Containern zu entwickeln.
Da fängst du dir dann höchstens
was im Container ein.
So, da haben wir unsere EDE offen.
Projekt gestartet.
Wir haben noch kein Rust-Projekt angelegt.
Das heißt,
wir brauchen ein...
Boah, mal gucken, ob ich das noch aus dem Kopf...
Ich glaube, es ist Cargo New, ne?
Cargo New und dann Lulwe zum Beispiel.
Oder habe ich es falsch gemacht?
Ne.
Ja, genau.
Okay, wir nennen es nicht Lulwe, wir nennen es Rust Champ.
Cargo, New,
Rust. Ich glaube, da macht man Snake Case.
Rust Champ.
Okay. Und dann?
Hier ist der Rust Champ.
Dann öffnen wir den mal.
Als Projekt.
Gucken wir mal.
Hier wird automatisch in den Container
das aktuelle Verzeichnis reingemount
oder Workspaces.
Es ist fast wie wenn ich es lokal habe.
Also nicht im Container.
Es ist wirklich nice.
Okay, hier gibt es kaum Platz für Text. Das brauchen wir nicht, oder? Hier Cargo-Stells,
das machen wir auf der Command Line. C Sharp machen wir bestimmt auch demnächst mal wieder.
Main-RS. So, boah, ja, mach's noch kleiner. Font-Size. Change Font-Size in all Editors.
Oh, kann man wenigstens was erkennen.
Musst du Rust Rover dann sagen, wo der Rust Compiler liegt?
Nee, anscheinend checkt das Rust Rover von alleine.
Guck.
Er checkt das.
Der ist wahrscheinlich so schlau und guckt schon in einem Standardverzeichnis.
So, Hello World.
Das heißt, jetzt können wir sagen, Cargo Run, wenn ich das richtig im Kopf habe.
Ah, Build Essentials fehlen, oder?
Build Essentials.
Okay, wo wir gerade dabei sind, das schreiben wir gleich in unser Docker-File,
dass wir das nächste mal nicht vergessen das ist jetzt muss ich den kompletten container neu bauen
weil ich hier oben was hinzufügen wild ist so cargo run bm hello world so next ich will statische
binaries produzieren da muss man musel installieren für guck mal das habe ich doch immer das habe ich
noch so im Kopf.
Ich glaube Release macht man hier auch.
Genau. So und jetzt können wir gucken.
Target
Release
Rust-Champ.
Wenn man da mal schauen,
wie das gebildet ist, sieht man, es ist
gelinkt gegen libgcc, libc,
linux, bla bla bla.
Jetzt kommt das nächste.
Wie baue ich statische Libraries?
Static,
Binary,
Rust mit Musel.
Also das ist so.
Ich versuche das mal halbwegs zu erklären,
weil ich habe mich damit vor einer Weile schon mal beschäftigt.
Standardmäßig
verwendet Linux, zumindest die meisten,
mal außer Alpine und so außen vor,
verwendet GLibc.
Und wenn man ein
Binary baut,
ein ausführbares
Binary baut,
dann
und man verwendet Funktionen aus der C-Standard-Library,
was oftmals passiert,
dann linkt der standardmäßig dynamisch gegen GLibc.
Das Problem dabei ist,
wenn man jetzt das Binary auf eine andere Linux-Kiste kopiert,
die eine ältere GLibc-Version hat,
als gegen die, wo man gelinkt hat,
dann geht es nicht, dann kackt es ab.
Und das ist ziemlich doof.
Die...
Äh, was macht...
Was hat denn hier so viele Auslastung?
Okay.
Rust macht Dinger.
Auf Ubuntu bilden und auf Alpine geht's nicht?
Ja, es geht sogar auf einem älteren Ubuntu ja schon nicht.
So und das ist doof. Die Oldschool Variante, also sagen wir mal so, die Variante bei allen Programmiersprachen außer bei Go ist es, dann die C-Library statisch zu linken. Das Problem ist, dass man GLibc nicht richtig statisch linken kann.
Der Unterschied zwischen Dynamisch und Statisch gelinken ist einfach der, beim Statisch linken wird beim Kompilieren quasi alles, was man als Abhängigkeiten hat, in das Binary mit reingepackt.
Beim Dynamisch linken wird einfach nur reingeschrieben, ich will jetzt diese Funktion aufrufen aus der Library, die schon da ist.
Es gibt eine ganz gute C-Library für Statisches linken und das ist Musel.libc.
Und das unterstützt Rust auch standardmäßig zum Bilden von statischen Binaries.
Ich hoffe, man hat jetzt verstanden, was ich euch sagen wollte.
Konnte man mir folgen, ja?
Deswegen muss ich jetzt mal gucken, wie man das nochmal genau gemacht hat.
Das war ein bisschen komplizierter.
Rust up.
Weil jetzt ist es so, ich kann es euch ja mal zeigen.
Immer besser als zu labern.
Ich zeige es jetzt einfach mal.
So, also auf der Kiste, ich gucke mir jetzt an, was hat mein Binary für Abhängigkeiten.
Ich habe dynamische Abhängigkeiten zu libgcc, zu libc und zu linuxvdso, was auch immer das ist.
Was ist linuxvdso?
Virtual Dynamic Shared Object, aha.
so auf dem gleichen system wo ich das kompiliert habe kann ich es ausführen das geht machen wir
jetzt mal was anderes gehen wir mal hier rein rust champ target release jetzt versuchen wir
es mal auszuführen auf meinem host system geht auch liegt daran weil ich gelebt zehn installiert
habe und sogar noch eine neuere
GLEPC-Version als hier im Container.
Aber jetzt, passt mal auf,
jetzt sagen wir,
jetzt nehmen wir einfach mal ein älteres Ubuntu.
Ubuntu, na komm.
Nehmen wir 20, 2004.
Wobei, das könnte noch
aktuell genug sein. Egal.
Kann man eigentlich sowas machen hier?
Ah, geht. Guck hier. Rust Champ.
Geht nicht mehr.
Auf Ubuntu 20.04 läuft das Binary nicht,
weil ich das kompiliert habe gegen eine neuere GLEP-C-Version.
Dann sagt er hier, bla bla bla, gibt's nicht, kann ich, tut nicht.
So.
Jetzt machen wir das Gleiche nochmal.
und kompilieren das allerdings nicht dynamisch gegen GLibc,
sondern machen ein Static-Build mit MuselLibc.
Wenn ich jetzt noch weiß, wie man den Kram installiert...
Äh...
Äh...
Wie ging das nochmal?
Ach, guck mal hier!
Rust-Target-Add...
Genau.
Das schreiben wir auch in unser Dockerfile rein.
Ups.
So, hat er installiert.
Dockerfile, dass das nächste Mal alles auch noch da ist.
Run.
Rust target at.
Ja, gut.
Wobei, komm.
Das machen wir davor.
Ne, das können wir nicht davor machen.
Das müssen wir natürlich schon hier danach machen.
So.
Und nun bauen wir das Ganze nochmal.
Jetzt bauen wir das Ganze nochmal.
Cargo.
Cargo.
Bild.
Ach ne.
Ich muss angeben.
Wie mache ich das denn?
Steht das vielleicht hier drin?
Cargo.
Bild.
Das muss man irgendwo angeben.
das cargo bild ja hier das stand doch target cargo bild das genau so und jetzt gehen wir da rein
ich lösche vorher noch mal mein target verzeichnis das clean ist und jetzt sagen wir noch mal docker
Run.
Hä?
Mag er nicht mehr?
Ah, ich bin im...
Ich hab's verzeichnet, ist eben gelöscht.
Jetzt...
Okay. So, und jetzt gehen wir hier hin.
Nach da rein.
Release.
Release.
Rust Champ. Und zack, es läuft.
Und wenn ich jetzt hier gucke...
Ups, wenn mich das hier...
Statically linked, das heißt das Ding kann ich jetzt auf jedes x-beliebige Linux kopieren und es läuft.
Machen wir mal, ich zeige euch mal was.
Ubuntu 12.04, okay.
Das ist schon ein bisschen älter.
Rust.
x86, Release.
Rust Champ, bam, läuft.
Das ist jetzt genauso statisch wie beispielsweise eine Go-Anwendung.
Was? Leider, leider, Chat, leider gibt es nichts Älteres.
Guck.
Gibt's nicht.
1204 ist das älteste Ubuntu, wobei 11 habe ich noch nicht ausprobiert.
Das älteste Ubuntu, für wo es Container gibt.
11.11.10 gibt es vielleicht noch, wenn wir Glück haben.
Nee.
Also 12.04 ist tatsächlich das älteste, was es gibt.
Gut, so.
Deswegen will ich die Sachen statisch bilden, weil ich ein Fan von self-contained statischen Binarys bin.
Spätestens seit Go.
Wie ist die Binary Größe?
Ah gut, die ist natürlich ein bisschen größer.
Dürften so 5, 6 MB oder so sein.
Ja, das stimmt.
Das sollte man noch erwähnen.
Dementsprechend.
Ach ne, geht doch voll klar.
548K für ein Hello World.
Ich meine, zu DOS Zeiten war das viel.
Da wäre fast eine Diskette voll gewesen mit.
Aber heutzutage ist das vollkommen in Ordnung.
No more Quarkus today, but I think next week we will do Quarkus again, but this time with
Kotlin instead of Java.
Today we learn Rust and web applications in Rust.
Stimmt, du hast recht, das können wir auch mal
Wir schmeißen die Debug-Symbole raus
Dann ist die Anwendung nur 441k groß
Aber der Fairness halber sollte man jetzt tatsächlich nochmal sagen
Wenn ich jetzt Cargo
Wenn ich das jetzt nochmal bilde
mit dem statisch gelingt.
Und ich gehe jetzt hier nach CD Release
und gucke mir an, wie groß das ist.
Dann sehe ich, die Anwendung ist fast genauso groß,
obwohl sie statisch gelingt ist.
Also gut, dann nicht.
Gut, aber jetzt fangen wir mal an.
Das ist nur so ein kleiner Exkurs
zu statischen und dynamischen Binarys.
Rust.
Also.
Axum.
Wollen wir benutzen.
Brauchen wir eine Hello World
Anwendung für Axum. Guck mal, hier gibt es doch schon
sogar eine.
Ne, das ist vielleicht
mal Overkill. Es gibt doch bestimmt hier
ein Exempel.
Exempel.
Gibt es da nicht irgendwie ein simples
Hello World oder so?
Ah doch, doch hier.
Okay.
Source, Main.
Okay, das ist übersichtlich.
Dann machen wir das doch mal jetzt.
Da bin ich ja mal gespannt.
das kopieren wir einfach mal komplett
und dann passen wir es ein bisschen an und gucken,
wie das
funzt.
Okay, auf geht's.
Also, Tokyo Main.
Tokyo ist diese
Async-Geschichte, ne?
Ich erinnere mich dunkel dran,
dass man
Async-Away machen kann in Rust.
die pen ach guck mal wie schlau die idee ist
ich war über command line ich will nicht ich will nicht über über die idee
guck mal hier das ist ja richtig nice wieder wieder das erkannt hat dass ich
Tokio und Axum
als Dependencies hab,
die IDE und gleich meine Cargo-Config
reingehauen hat.
Das finde ich nice.
Excellent.
Gut.
Okay, es geht nicht.
Warum nicht?
default runtime flavor ist multithread, but the RTMultithread feature is not...
... ist disabled.
Aha, okay, dann gehen wir mal
pokio, gehen wir mal crates.io, da gibt es ja dieses, das ist ja der
package manager von rust.
Okio.
Und gucken wir uns mal an, was wir verkehrt gemacht haben.
In unserer Tommel.
Ah, ja.
Okay.
So muss man machen.
Aber es geht immer noch nicht.
Tja.
Moment, Moment.
Ne, shit.
Kackt immer noch ab.
Die Fault Flay, das kopieren wir uns jetzt mal in irgendeine...
jetzt ist weg der einfach nur ein bisschen reloaded so funks das jetzt ich
starte das mal testweise wir haben einfach schon 70 pakete leute 70 pakete
alles die pendels ich sagte aber das ist fast so schlimm wie bei not ist nicht
ganz so schlimm aber da hast du wirklich 30 milliarden die pendels immer so wir
haben jetzt hier eine web anwendung die irgendwas auf port 3000 macht guck mal curl local host port
3000 bäum hellu world okay funzt nice das erste was wir ändern ist den port den port gehen wir
auf 8080.
Da können wir nämlich auch von hier curlen.
Ja, nice.
Watch, minus N,
0,1.
Okay, das fand ich ja schon mal
erstaunlich easy.
Aber ich weiß, Rust wird richtig eklig.
Teilweise.
Gerade wenn man so ein Kack-Noob ist wie ich.
Wie groß ist das Binary jetzt? Sehr gute Frage. Jetzt können wir es nochmal vergleichen. Cargo,
Build, Release. Wir gucken uns mal das Dynamische an und das Statische.
Also Target, Release, 1,9 MB. Ich vermute mal das Statische ist jetzt tatsächlich ein bisschen
größer.
Argo
Build.
Oh, was hab ich verkehrt gemacht?
Vergleichen wir mal die Binary Größe. Ich denke mal,
das müsste jetzt größer als 1,9 MB sein.
Target
X86
ich unknown Linux musel.
Äh.
Chat.
Da stimmt was nicht.
Ach so. Ha. Ich hab Release vergessen.
Ich hab Release vergessen.
Das war ein Debug-Bild.
1,9.
Es ist genauso groß.
Ja gut, dann können wir doch erst recht statisch linken.
Perfekt.
Also es ist kaum größer,
das statisch gelinkte.
Und das statisch gelinkte...
Komm, jetzt einfach hier starten.
Da läuft's.
so wisst ihr was mich interessieren würde früher ich kann mich daran erinnern
es gab so was wie cargo watch run
das war's gibt's seit heute und die nächsten zwei drei streams noch bis ich
bis ich der meinung bin ich habe genug durchblick oder vielleicht auch
vielleicht auch die nächsten zwei streams mal gucken wenn es euch gefällt
Leute, wenn ihr dabei sein wollt, könnt ihr mir jetzt
ein Follow am Start... Äh, ein Follow am
Start lassen? Was auch immer. Ihr wisst, was ich
sagen wollte. Könnt ihr mir
ein Follow dalassen.
Ich hab mich die letzten Streams sehr gefreut,
dass es so viele Follows gab.
Bacon.
Ist das jetzt
das neue Cargo Watch?
Bacon.
Bacon.
Aber das ist ein Testrunner, oder?
Sehe ich das falsch?
Ist kein...
Kein...
Kein so
Ich starte die Anwendung neu
Ne, ne, ne, ne
Ich will
Sobald sich mein Source Code ändert
Automatisch neu startet
Okay, lass mal gucken
Vielleicht kann das ja Bacon auch
Cargo install locked Bacon
Die Namen von den Projekten
immer das machen wir hier auch in unsere unser docker file weil ansonsten weiß
jetzt schon dass ich das wieder vergesse
316 dependencies jetzt nicht bei meinem projekt sondern bei bacon das nimmt ja
schon fast noch es aus maße an post
champ
bacon
Was?
Entry?
Hört ja gar nicht mehr auf hier.
Re-Entry?
Moment.
Was?
Ach hier.
Run arbitrary commands when files change.
Ne.
Wir benutzen noch kein C-Programm, um unser Rust-Zeug zu bilden.
Da sind wir nicht blazingly fast written in Rust.
Doch, das ist was, was ich suche.
Aber wenn das Reddit mitbekommt...
Das geht nicht.
Wir können nicht unsafe code benutzen, um unser safe Rust zu run.
Da gibt's...
Da drehen sie durch.
Ich könnte ja um die Leute zu triggern
Aber eine Runde Unsafe
Rust machen
Da gab es doch
Da war so vor der Weile irgendein
Drama in der Rust Community
Weil irgendjemand aus Performance
Kunden Unsafe Rust drin hatte
Und da haben die den so sehr
Abgefuckt in GitHub Issues
Dass er das Projekt archivt hat
So, Bacon
Okay, wie geht das jetzt? Bacon
Check
Ne, das wollen wir nicht
Kann man Bacon Run machen?
Ah
Ja, nice
Das wäre, das wäre es ja
Okay, Hello World
Jetzt ändern wir mal was hier drin
blub blub blub und hat nicht reloadet warum nicht hat mich wie lautet
wiederholt mich bacon reload server ich habe gespeichert ja
nochmal restart vielleicht server rast rast gehen wir noch dazu ein cookbook
bacon dies treu und change strategy kill den restart ich brauche dafür den config file
kein konflikt
kein konflikt da habe ich keinen bock drauf bacon hält schicke schicke terminal ausgabe
Minus, minus, config.
Ach, man kann das direkt ins Command schreiben.
Also minus, minus.
Und hier bake and run. Minus, minus.
Config. Tommel.
Gleich.
Moment, Moment.
So.
Aha.
Moment.
1, 2, 3.
Ah.
Dazu kann ich nur sagen, easy, easy.
So, jetzt startet er den Krempel neu. Ist doch nice.
Ja, das gefällt mir.
Guck mal, wie schnell das geht.
Oh, oh.
kannst einkaufen twitch twitch hat jetzt ein neues feature du kannst jetzt auf pause drücken
und ach das geht gar nicht muss man das einschalten irgendwie dass man pause drücken
kann ich habe nämlich gesehen manche streamer haben jetzt eine pause funktion nur wenn man
subscribed ist ach so aber ich darf das bei mir selbst nicht machen ich dachte
ich bin wenigstens bei mir selbst subscribed im eigenen stream darf man
nicht dann musste dann musste höchstens das wort nachher gucken ich will dich
jetzt nicht vom einkaufen abhalten gibt nicht mal lange heute was
So, also, jetzt mal hier in mich gehen.
Wie punzt das jetzt eigentlich?
Wie ist das denn mit Error-Handling eigentlich in Rust?
Guck mal, weil hier wird ja immer Unwrap verwendet.
Bei Unwrap crasht das Ganze direkt.
Aber wenn ich jetzt den Fehler printen will, anstatt irgendwie eine ordentliche Ausgabe machen will.
Gibt es da irgendwie so eine automatische...
Ah, guck mal hier.
Replace unwrapped with dry.
Oder match.
Aha.
Aha.
Oh, das ist ja eklig
Ähm, by the way
Ich will Format haben
Format und Save
Ich hab
Format und Save
Unbedingt
Hm
Jetzt geht's hier um
Rust-Geschichten. Also erst einmal
App kommt nicht da oben hin, App kommt
hier unten hin, weil ansonsten
Listener, Mensch, also
Ja, ja, das
prinzipiell weiß ich das, aber
würde ich jetzt
dann beispielsweise, aber ich will ja
kann ich
okay, kann ich sowas hier machen?
Return?
Ach, das geht da
drinne. Okay. Und jetzt könnte ich hier sagen
Print line.
Genau. Super. So.
AI Champ.
AI hat's kaputt gemacht.
Unexpected token
return.
Hä?
Warum?
Hä?
Moment, erholt sich vielleicht?
Erholt sich Bacon nicht, wenn es mal einen Compile-Fehler gab?
Ja, das ist ja doof.
Wenn es mal einen Compile-Fehler gab, checkt es Bacon nicht.
Das ist immer so halbherziges Zeug
Oder ich bin zu dumm für
Das kann natürlich auch sein
Muss man eben abbrechen danach nochmal
Da gibt es vielleicht auch eine Option für
Um das zu setzen
Print R
Ne, gibt es nicht
Das ist
E-Print
gibt es auch noch was da jetzt der unterschied okay wir machen cargo run ist mir zu doof mit
bacon so fail to buy also wir haben jetzt mal was rein was es garantiert nicht gibt
er brennt auf standard auf standard error ja okay fällt zu beiden tue blablup sowieso ja das ist okay
das kann man so lassen aber dann bricht er auch ab danach ja das finde ich schon mal ganz brauchbar
dass er abbricht das heißt sobald das funzt geht es weiter und er startet den server ja
auch ganz nice gut da kommen wir schon zum ersten problem wie macht man command line
parsing in rust gibt es garantiert fertige libraries für weil man möchte ja vielleicht
den port und die adresse irgendwie überschreiben
das machen wir doch mal
doch ich kann cargo watch verwenden aber cargo watch ist wohl deprecated
Crates.io.
Wir gucken mal, was man bei CLI so findet.
Updated 10 years ago.
Ja, genau.
Das brauchen wir.
Hackweight.
Clap.
Easy Clap.
So.
Das habe ich schon mal benutzt, Leute.
Jetzt, wo ich das sehe, kommt mir das bekannt vor.
Das kenne ich.
Das habe ich schon mal benutzt.
Gucken wir mal kurz hier.
Examples.
Oh, gibt es da vielleicht noch was
Einfaches?
Monka
Es, Alter, wie kompliziert will ich es machen?
Gibt es da vielleicht auch ein Easy-Beispiel?
Was ich checke?
Demo, Demo-RS.
Okay, das sieht übersichtlich aus.
simple program to greet a person
command version about
struktur
Achso, Moment, ich muss Clap erst noch installieren.
Das ist ja nice.
Das finde ich richtig nice, dass die IDE das checkt und für mich einfügen kann.
Das ist mega praktisch.
Guck mal, das ist gut.
Guck mal, genau. Und die hat sogar gecheckt, dass ich Parser verwende.
excellent xxx so dann machen wir jetzt mal hier so was wie address ort 16 aber oft heimste auch
keine hilfe text was short long was was bedeutet das die fall value check ich
ja noch die fortwählen 80 80 die kann ich so was sagen wie die ford well you
Punkt 1.
Ah, ne.
Default Value.
Warum ist da ein T hintendran?
Hä?
Was?
Warum Default Value T?
Was soll denn T überhaupt bedeuten?
und kein short so version about wie geht es jetzt weiter
einfach hier sagen pass
ok
args pass ok run
ach so na gut ich sollte ja vielleicht noch was ausgeben das wäre noch ganz sinnvoll gibt es denn
jetzt so was wie help zum beispiel das ist nice guck mal und sogar ein version dings hat da hinzu
Waschschirm 0.1.
Der generiert automatisch Hilfe.
Auch nice. Das finde ich gut.
Das machen die meisten so Command Line
Frameworks, aber das finde ich gut, dass das die
Rust Variante auch macht.
Oh, gut.
Was sind diese anderen Dinger
hier? About und
Version About gibt es doch gar nicht.
Minus, Minus, About.
Nö, gibt's nicht.
Ach so, mit den drei Slashes taucht's in der Hilfe auf.
Aber das checkt man so auch.
Bout gibt's nicht und lange Bout an.
Weg, weg damit.
Dann können wir das doch hier AppConfig nennen.
Ah, AppConfig.
Und jetzt printen wir davon mal was.
Ah, nächstes Problem.
Wie mache ich Structured
Structured JSON Logging
Also wenn ich das Ding
Jetzt hier zum Beispiel
Printen will, gescheit
Ja gut
Ne, ist ja schon fast
Ne, ist es nicht
Das ist jetzt diese Representation
Intern von Rust
Nee, ich will Structured
JSON Logging machen, also dass dann sowas rauskommt
wie Message
bla bla bla
Da braucht man bestimmt
irgendeine Library für
Da, checken wir, Moment, Moment
Wir fragen mal LM Studio
Mal ein bisschen meine Grafikkarte verwenden
für was
So, fragen wir mal.
Wie mache ich
Structured Logging
Hallo?
In JSON, in Rust.
Mit Serde und Lock empfohlen.
Lock.
Ist das Default?
Endflogger.
Init.
Lock.
Kontext.
Aha.
Level.
Message.
Serde.
Das ist irgendwie so ein Serialisierungsding.
To String.
Kontext.
Unwrap.
Boah, das ist aber umständlich AF
Mit Tracing, modernes Logging Framework
Ja, und Custom Sachen gibt's
Ach, hier oben ist das der Logging-Content
Oh ne, das ist ja umständlich
Ich will zum Beispiel auch einfach sagen können
Print mir mal eine Map oder sowas
tracing und tracing subscriber
wie von das jetzt moment ich bin bin verwirrt tracing info war er aus band subscriber
Was macht das hier für Dinger?
Info, Message, Anwendung gestartet, Version.
Aha, das gefällt mir schon viel besser.
Von der Syntax her.
Aber die Frage ist jetzt, wie kann ich nestet?
Okay, oder Slog.
Wir schauen mal kurz paar Crates.
Slog.
Ordentlich.
Einfach mal 4 Millionen Downloads.
Racing.
Alter!
62 Millionen Downloads.
WTF?
Okay, dann verwenden wir Tracing.
Mal gucken, was mir besser gefällt
von der Syntax her.
Was, Train?
Was?
Okay, die Syntax finde ich schon mal abartig
Wenn ich das schon sehe
Was ist das denn, Train?
Was trainet er denn?
Slot hat ganz oben in der Readme auch geschrieben, you might consider using tracing instead.
Okay, dann.
Benutzer definierten Spannungen.
Ich glaube nicht, ich glaube die meinen Span, oder? Nicht Spannung.
User Context
Okay, dann benutzen wir Tracing
Ach, hier kann man auch Wasser
Nee, ich will immer in Jason Dongen.
Okay, Tracing.
Und Tracing.
Tracing und Tracing.
Brauchen wir jetzt.
Okay, dann schauen wir mal.
Tracing.
Gucken wir mal in die Examples rein.
Das finde ich bei Rust-Projekten auch immer gut.
Hier haben wir so einen Examples-Ordner.
Examples.
Gibt es da auch wieder ein Hello World oder sowas?
Hello? Hello World?
Nee, gibt's nicht. Ja, geil.
Was haben wir denn hier?
Valuable.
What?
Tower, Tokyo, Threat Info, Panic, Lock.
Lock klingt gut.
Format, Custom.
Format, Jason.
Das klingt gut.
Format, Jason.
Das ist gut.
Okay.
Das ist minimalistisch hier
Was ist?
Tracing Subscriber
FNT with max level in it
Ja, das ist ja nur wirklich überschaubar
Vom Boilerplate
Und Zeremonie drumherum
Das finde ich okay
Das hat was
Ähm
War ne Frage
Woher kommt Lock?
Ich kopier mir das mal kurz hier rein
Der würde das hinzufügen
No
Lock will ich nicht
kann man jetzt hier at tracing subscriber to dependencies und jetzt
ach so jetzt macht das einzel ja ok und jetzt at tracing to dependencies
das model ist doch ist doch so war doch so schnell schon ich hab's ich habe so
settings für offloading ist hier irgendwo guckt das ist schon eigentlich fast auf max maximum
ist es auch so schnell so tracing das ist ein max level standard max level
jetzt ran
Achso, Debug ist standardmäßig gar nicht aktiviert wahrscheinlich. Gibt es sowas wie Info?
Guck mal hier, Info, this is the tracing. Moment, Moment, Moment, Moment, Moment. Ich will ja Jason,
ich will ja einen Jason Output haben. Gibt es sowas wie hier, ah, Jason. Ne, gibt es nicht.
war moment die idee ist richtig nice das muss ich mal sagen chat brains pock guck mal hier alles
was ich jetzt manuell mir irgendwie zusammensuchen müsste über google check das ding schon von sich
aus das kannst du kannst du wirklich sagen das ist top und schon haben wir jason logs
timestamp level info fields message das ist ein tracing line target rust champ das brauchen wir
nicht was haben wir sonst noch hier für sachen zur auswahl in den fmt compact
less verbose formatter was passiert da
glaube das hat kaputt gemacht
macht.
Pretty with ansie? Ach, dann macht er das farbig.
Ja gut, aber halt jasonlocks kannst du halt farbig machen.
mit file, ne
level
was ist denn
eine span in dem
in dem Zusammenhang
with file, with level
with line number
Max Level Span Event.
Target.
Ne, Target.
Target, aber False, dass das weg ist.
Also was
eine Span ist, musst du es mir noch
erklären.
Span.
Ah geil, gibt es nichts dazu.
Info-Span?
Instrument?
Was zum...
Okay, hier wird irgendwelches Zeug...
Ich hab kein Plassen.
Was da passiert gerade?
Tracing?
Info-Span?
Was passiert jetzt?
Nix.
Das wird nicht ausgegeben.
Ja, toll.
Ne, das muss ich hier irgendwie machen.
Okay, aber das scheint ja mit Logging
schon mal ganz gut zu funktionieren.
Jetzt ist nur die Preisfrage, wie kriege ich hier
gescheit Sachen rein?
Also wie kriege ich jetzt hier rein
meine App-Config
zum Beispiel? Machen wir das doch mal
hier.
da stand doch irgendwas
von, man konnte
irgendwie mit Equals dazwischen
also irgendwie Config gleich
das da, geht nicht
Named
Argument never used
vielleicht weil der String
vorne drin ist
öh
darf ich den String dahinter machen dann
auch nicht
doof
Config args trade
Tracing value is not
certified. Ach, muss ich...
Wie geht denn das?
Debug?
Kann man so irgendwie
machen?
Nee.
Ich brauche ein Beispiel.
fragezeichen links und rechts dahinter vorne in das kannst du das glaube ich nicht ach guck mal hier
ein prozent vor
geht auch nicht. display is not implemented. ah ich hab nur debug
also was soll ich fragen? hä das geht was ist das für eine syntax wieder alter. rust man.
okay so und was passiert jetzt
es geht nicht das sieht kacke aus moment der macht das ist falsch was der macht ich will
das als jason objekt log nicht als nicht als komischer string mit es also ich will das als
nested
nested
objects loggen. Also ich will loggen
config, Klammer auf,
address, das da,
das da. Ich will nicht irgendwie
so ein
Rust-Object im...
Da muss ich mein Model mal fragen,
wie das funzt.
Ups.
Wir machen mal ein Beispiel, wie das das checkt.
Let map gleich new, ach Quatsch, Moment.
Hash map.
Das darf man doch weglassen, ne?
War das nicht so?
Doch.
Jetzt kann man sagen map.
Map insert.
Tackle.
Was ist das Problem?
Cannot borrow Mut-Tipp.
Ah, jetzt kommt die Rust-Geschichte.
Ach so, ah, man muss
da vorschreiben, dass es Mut ist.
Chat, was ist denn der Unterschied
zwischen so und
und so?
Oh.
Hä, das ist genau...
Hä?
So, ich bin wieder da.
Ähm.
So.
Ich schreibt mal, ich will die Map als nested Object finden.
Okay, jetzt mal gespannt.
Also man muss auch mal sagen, dieses Gwencoder ist gar nicht so übel für ein lokales Model.
Mal gucken, ob das stimmt, was es da jetzt raushaut.
in was kann man herbst nicht direkt als strukturierte daten in tracing log zu
werden aber es gibt mehrere möglichkeiten das zu erreichen wie viele gigabyte verbraucht die
das hat auf jeden fall in die grafikkarte gepasst wo sieht man das
18,63 gig
Was hat meine Grafikkarte für
Wie viel Speicher? 24 Gig
Hat die glaube ich
also erstmal kurz gucken was das hier sagt in rast kann man herbst nicht
direkt als strukturelle daten in tracing los gibt mehr das zu erreichen mit sehr
der jason nee das ist falsch das habe ich ja schon gemacht
das habe ich ja schon gemacht das ist blödsinn
dann macht er das ist das ist verkehrt das kann nicht funktionieren hier kommt
eine jason string raus denen dann wiederum embedded in den jason string
dass das also ich glaube das ist blödsinn was das hier anzeigt mit sehr
der attributen direkt direkte jason formatierung ja ist klar
also da sage ich mal das funktioniert alles nicht was da ihr anzeigt
vollständiges beispiel mit tracing das ist mist okay wir geben google mal eine
chance leute google hat doch jetzt diesen komischen ki modus die fragen wir jetzt mal
frage jetzt den Google KI Modus.
Google nervt nicht rum.
AI Modus.
So, also.
Ich will
ähm
in Rust
die Map als Nested
Object
finden.
nicht als Jason String in Jason Strings added.
So, gucken wir mal, ob das versteht überhaupt, was ich von ihm will.
In Rust Tracing für ein komplexes Wert stellen wir über ihr Debug-Trade als flacher String gelockt,
um eine Hashmap in der Jason-Ausgabe als echtes Verschachtel statt Stringer zu geben.
das 2 die experimentelle experimentelle value able unterstützung empfohlen für
echte objekte das klingt doch gut oder was ist das zweite rapper mit serde wenn
du kein anstieg benutzen möchte kannst du ein hilfstück verwenden dass der
implement und die selbe trance
Das Value Able Ökosystem.
Aha.
Aha.
Okay, wie funktioniert das?
Die Pendancies.
Value able.
Okay, Moment, Moment, Moment.
Das muss ich jetzt erst mal checken, was das von mir will.
Value able hinzufügen.
Wir vertrauen dem Model jetzt einfach mal.
Es könnte auch sein, dass es übelst ein Bullshit anzeigt.
Valuable.
So.
Tracing.
Ja, Moment.
Da schreiben wir doch gleich mal hier rein.
1.44.
Ja.
Und hier machen wir auch 1.11.
Und zwar Hardcoded Version reinschreiben.
Und dann brauchen wir Tracing Subscriber.
Tracing Subscriber soll auch noch Valuable kriegen.
Und das kriegt hier Derive.
Dann haben wir das drinnen stehen.
Kompilieren mit den Flex.
Rust Flex minus minus CFG.
Wir benutzen Unstable Features.
So mag ich das.
Beste.
Und jetzt kann ich sagen, Config Map S Value.
Aha.
Das ist richtig blazingly fast.
Guck mal hier, wie fast ich bin beim Programme erstellen schon.
In .NET hätte ich wahrscheinlich eine komplette Anwendung schon fertig,
aber in Rust bin ich noch, wie konfiguriere ich Logging?
Aber wenn es läuft, ist es blazingly fast.
Was muss ich jetzt machen?
S-Value.
Geht nicht.
Unresolved Reference.
Ach so, das geht jetzt nicht, weil ich noch nicht Unstable hinzugefügt habe.
Ne? Jetzt muss ich das hier sagen.
Cargo run.
Fuck.
Method not found. Ah, ich hab bestimmt
irgendwas nicht eingebunden.
Import.
Value able hab ich nicht
geused. Guck mal mal, ob es ohne
unstable funktioniert.
Ne? Mit unstable?
Ah.
Guck mal, es funzt.
Ich habe ein JSON-Objekt jetzt ordentlich als Objekt und nicht als Embedded in einen JSON,
in einen anderen JSON-String-Embed.
Genauso will ich das haben.
So mag ich das.
Kann das jetzt, die nächste Frage, kann das Ding auch meine App-Config serialisieren?
S-Value.
Ne.
Das war doch einfach...
Ich fand es ein bisschen durch die Brust ins Auge.
So, Moment.
Und wie mache ich das jetzt?
Ich will dieses Struct hier
als Jason ausgeben.
Wie mache ich das?
Wobei, das habe ich blöd gefragt jetzt.
Ja, ja, hier.
Ich meine, ich will das Struct ausgeben mit Tracing.
Ist das hier schon Vibe-Coden?
So, Valuable Clap.
Struct mit Value Able ausstatten.
Value Able ist hier entscheidend.
Okay, ja dann, nice.
Value Able.
Okay.
Wisst ihr, für sowas ist AI gut.
ich finde es nicht sinnvoll zu sagen ich stelle mir eine webseite das ist für demos gut aber
dafür so dinger ist das halt richtig praktisch sofern die eiwass tag chat gpt frage ich dafür
erst gar nicht ich wette mit euch chat gpt hat den größten bullshit raus von sich gegeben
address port funzt ja irgendwie finde ich es nice muss ich sagen also das hat was
jetzt nur die frage wie kann ich wie kann ich das hier als default machen
Füge folgenden Inhalt in die Cargo-Tommel ein.
Moment, in welche Datei?
Cargo-Config-Tommel erstellen.
Hä?
Warte mal.
Ich habe hier eine Cargo-Tommel und jetzt eine Cargo-Config-Tommel.
What the f...
Moment.
Also was soll ich erstellen?
Sollen Ordner erstellen.
Argo.
Und da drinnen jetzt eine
Konfig-Tommel.
Was wie? Kein Wim.
Keck, wait.
Äh, Abt ist richtig schnell geworden
seit den letzten Debian-Versionen.
Frost Flags.
Ohne Wim, ohne mich sehe ich genauso.
Cargo.
Cargo run.
Nee, Funst.
Das ist richtig hier, was Google...
Was für ein Model ist das?
Gemini?
Was das sagt.
Ist auf jeden Fall besser als...
Was ChatGPT da fabriziert.
Mein lokales Model war ein bisschen überfordert damit.
Aber das geht klar.
Ja Chat GPT ist ziemlich dumm geworden in letzter Zeit.
So guck mal, da haben wir es doch schon.
Jetzt können wir unsere App-Config loggen.
So, also dann machen wir mal weiter im Text.
Das können wir wieder wegmachen.
Wir loggen jetzt unser, nennen wir das hier mal init.
Loggen wir hier einfach unsere Config.
Unsere Config steht aktuell nur in Port und String drin, das ist kein Problem.
Es reicht erstmal.
Jetzt kümmern wir uns mal um das Thema Error-Handling.
Ich kann mich noch dran erinnern, man konnte in Rust, das hier lasse ich jetzt mal weg, man konnte in Rust das mit so einem Fragezeichen irgendwie machen, so Async-Geschichten.
Nee, Onkers.
konnte irgendwie sagen
so, guck mal, so ging
so konnte man irgendwie sagen
hier so ein Fragezeichen hinten dran machen
und dann hat das quasi
das Result genommen
geguckt, ob da was drin ist
und
also ob das hier fehlgeschlagen ist
wenn das fehlgeschlagen ist
hat es den Error gelockt
Und ansonsten hat es das hier in die Variable geschrieben.
Das geht aber nicht, weil
Cannot use ?operator in function that returns ?zu
Ist about the function in which the expression appears, not the expression in which...
Ja, das dachte ich mir.
Aha.
Ein Result muss man zurückgeben.
Kann man vielleicht sagen Standard-Error?
So, so, so, so, so.
Geht aber immer noch nicht.
The Question Markable can only be used in an async block that returns result...
Oh.
Äh.
Was will es von mir jetzt?
Hier, wir stackoverflowen uns hier durch.
Die Botschaft ist etwas komisch, weil die Transformation, die Sie verfolgen, Sie vielleicht...
Man muss okay am Ende machen.
Ok.
Ok, ok.
So, Unwrap kann ich jetzt wegmachen,
weil ich das alles mit Fragezeichen
handeln kann.
Die große Preisfrage, die ich mir jetzt stelle,
wenn meine Main-Methode
einen Return-Type hat,
es gibt nichts mehr, was höher ist als Main
oder niedriger, je nachdem, wie man es sieht.
Also das ist der Einstieg.
Was passiert denn jetzt bei einem Fehler?
main kann ja kein error return in dem sinn schreiben wir hier etwas rein guck mal was
passiert wenn ich jetzt cargo runne bämm es knallt einfach mit einem print okay dann machen wir jetzt
noch mal was anderes ich will es ja alles ordentlich als jason formatiert ausgeben
dann können wir ja doch jetzt sagen okay ich habe eine idee ich habe ich habe eine idee
Leute. Pass mal auf, wir machen das jetzt so. Wir nennen das hier Run. Das hier Main, ohne dass es
was zurück gibt hier drinnen rufen wir ran auf und ich will gucken
was was was was was macht expect returns to contain it contain it
returns to contain okay value wie kostet
okay das ist
Okay, also, ähm, ich muss, ich will jetzt ein If machen, ob da, ob, ob da ein Error zurückgekommen ist.
Ne, das nicht, wie mach ich das jetzt gescheit?
Ähm, irgendwie If?
Ja.
Wie war da die Syntax für nochmal?
War das
Irgendwie so?
Ne
Shit
Rust, Syntax, MonkaS
Rust
Rust
das ist das auto kommt macht an der stelle anscheinend nichts match
if
RUST
if error
Handling errors.
Geil. Super.
Beispiel.
Let. Okay. Ja, Moment.
Im Okay-Fall will ich ja nichts machen.
Gibt es da nicht die Möglichkeit
ein If zu machen?
Ne, die machen überall hier immer Matches.
Aha.
Hier.
Let.
Let Error.
Wollen wir dann.
Also quasi.
Let.
Error.
oder R ist es, ne?
Let Error
Error
Und jetzt kann ich sagen, wenn das ein Error ist,
jetzt sagen wir Tracing
Error
E
Okay, schauen wir mal. Cargo Run.
Bam
Wollen wir wieder kaputt machen?
Guck mal, Funst!
Jetzt wird automatisch alle Errors,
die reinkommen,
werden so raufpropagated.
Und
werden dann am Ende hier in der Main
gelockt.
Ja gut, nice.
Exzellent sozusagen.
Huge.
Hash Map kann wieder raus.
So, das gefällt mir jetzt schon mal ganz gut.
So, Print.
Printeln kommt raus.
Jetzt reicht immer das hier ausgeben.
Config S-Value.
So.
Jetzt.
gibt es
in Rust
äh,
Build-Infos, also sowas
wie letzter Git-Commit-Hash
und sowas.
Das würde mich noch interessieren.
Also was ich ganz gerne mache, ist
am Anfang von solchen Anwendungen
ausgeben,
mit welcher
Version die gebaut wurden und
wann die gebaut wurden und sowas.
Weil aktuell gibt es ja nur die Config aus.
Ich würde jetzt gerne ausgeben noch Git-Commit-Hash, Git oder Build-Time und ob das Verzeichnis dirty war, irgendwas nicht committed war und die letzten Tag die Version ausgeben und sowas.
Das wäre jetzt noch die Frage, wie man das macht.
Okay, ChatGPT hat jetzt einmal Chance, hier sich wieder zu redeemen.
Gucken wir mal.
Ich will in einem Rust-Programm Build-Infos ausgeben, wie zum Beispiel git commit hash 30 oder tag oder build time.
Mal gucken, was ChatGPT dazu sagt.
Das geht in Rust sehr gut.
Üblich ist eine Kombination
Build.js plus Env.
Option Env.
Ohne ein fertiges Projekt.
Ich zeige dir beide Wege.
Zuerst den klassischen manuellen Weg.
Okay, zeig mal her.
Build.js anlegen im Projekt Root.
Git hash.
Roman new.
Oh, das sieht aber umständlich aus.
Das sieht umständlich aus, aber das ergibt Sinn.
Aber es macht Sinn, was es hier schreibt.
So übel ist das gar nicht, was ChatGPT hier zusammengezimmert hat, oder?
Habe ich Git hier drauf überhaupt installiert?
So schlecht ist das gar nicht, was ChatGPT da zusammengewurscht hat.
wofür brauche ich krono
ach so hier gut genau was so
und wenn es gibt in der standard library keine möglichkeit die aktuelle date heim
doch bestimmt rast standard date heim
ist doch also das finde ich nicht verkehrt ehrlich gesagt was was chat gpt hier zusammen
gezimmert hat ich werde es nicht eins zu eins zu übernehmen aber von der idee finde ich das
nicht verkehrt was haben wir sonst noch hier als nächstes fertige crates empfohlen werken
sehr beliebt bild die pendels werken version 8 werken mit bilder geht
kommentiert geht dort jedes kreisbild timestamp im mit
chat was meint ihr wo was selbst machen oder wollen wir werden verwenden wir testen zwar
selbst ein nummer um zu sehen wie es funktioniert ja wir probieren das mal
also wir brauchen jetzt hier hat er gesagt eine bild bild punkt rs so
das machen wir weg wir machen auch immer nur
wir machen hier nur das describe
Describe
Ups, muss vielleicht die Klammer zumachen
So, und jetzt
Wie verwende ich das jetzt?
Also, das
Das sieht auch echt super umständlich aus
Also der führten Kommando aus Git.
Describe minus minus Tags.
Okay, machen wir das mal von Hand.
Git describe.
No names found.
Cannot describe anything, weil ich noch kein Tag gesetzt habe.
Man stand hier nicht auch noch Version drin?
Version 0.10.
Okay, dann machen wir, dann taggen wir das jetzt mal.
Okay.
Git.
Git add.
Git add.
commit in it das kleid macht nichts und jetzt geht tag minus a 0.1.0 1.0 was richtig macht so
und jetzt ist clive jetzt zeigt er mir auch was an an der stelle okay zeigte mir den tag an die
frage ist jetzt wenn ich jetzt was er die tiere hier drin dann ist das jetzt ja dort weil was
nicht kommentiert ist aber das zeigt es greift nicht an aber man kann bei describe glaube ich
sowas hier angeben.
Genau.
Dann schreibt der Dirty
hinten dran, wenn noch uncommittete Sachen drin sind.
Und was hat er hier
sonst noch für Optionen drin? Minus, minus
Tags.
Macht er doch standardmäßig.
Und Abriff,
was ist Abriff gleich 0?
Weiß nicht.
Und was ist, wenn ich jetzt,
Okay, was ist, wenn ich jetzt nochmal
committe?
Blub.
Dann müsste jetzt der Comet-Hash angezeigt werden.
Genau.
So.
Wenn ich jetzt hier nochmal
was editiere, dann
genau. Letzter
Tag, den er findet.
Ein Comet, es kommt oben drauf.
Dieses Comet hat diese Hash
und es waren noch uncommittete Sachen drin.
Das ist im Prinzip genau die Ausgabe, die ich haben will.
genau die ausgabe die ich habe dann gucken wir mal jetzt describe minus minus dirty
kann man das darf man das so machen
Darf man das so machen?
Geht das?
Ne oder?
Der spackt doch irgendwie rum jetzt
Was hat er für Schmerzen?
Eben ging es doch noch
Eben ging es doch noch.
R-Hash für einen Raw-String, in dem du Anführungszeichen benutzen kannst.
Moment, was?
So?
Aber hier kann ich jetzt Anführungszeichen drin benutzen, oder wie?
Ach, und hinten...
Ach so.
Ich verstehe.
Okay, das ist aber Overkill für, weil es geht mit Single Quads genauso.
So, das kommt weg.
Sonst habe ich ja hier nichts drin, das ich stehen habe.
Output, Result,
okay.
Was macht das denn hier für so
super
Output?
Kann ich einfach sagen Unwrap?
Ne.
Und meiner.
Was bin ich hier überhaupt sehend gerade?
Output.
Und dann?
Ah.
Boah, ist das kompliziert.
Unwrap?
Weil es soll ja knallen, wenn es nicht geht.
Punkt.
Stand it out.
Into?
Ne.
Wie mache ich denn das jetzt?
Wie wandle ich das jetzt ordentlich in einen String um?
Standard Out
Jetzt habe ich hier einen Weck U8
String
To
Wie wandle ich das jetzt ordentlich in einen String um?
He doesn't know
Richtig
hier, lacks critical information
also irgendwie sowas
machen die hier
so hat JetKPT gemacht
aber das
ich mein ich kann so sagen hier
String
ROM
UTF-8
Aber das sieht ja mal
Hardcore abartig aus, oder?
Das geht doch bestimmt
Das geht doch bestimmt
Das sieht doch mal richtig eklig aus
Moment, ich kann einfach sagen
End
End
Ja, ich weiß, es macht fast dasselbe,
aber es sieht hässlich aus.
Calls
Gibt es nicht sowas wie Machwas mit dem
Ja doch Unwrap
Unwrap? Das ist doch schon das Richtige, was ich haben will.
So ganz check ich es immer noch nicht.
And then?
Äh, warum?
Warum formatiert er das so dumm?
Frage.
Was macht das da?
Ach so, weil hier drumherum, das wollen wir ja nicht.
ich check's net.
And then?
Und was ist das?
Wie
fandst du das jetzt?
Das ist Ruby Syntax hier.
Output?
Output?
Und jetzt?
Und jetzt so oder wie?
Ne.
Unwrap.
Alter, ich bin zu unfähig für Rust, Mann!
Hier sagen sie, okay.
Ich bin zu dumm dafür.
Expected result.
Poundstring.
Ah ja.
Expected Result String
Alter, ich bin
da zu dämlich für.
Okay, dann machen wir das so,
also das gefällt mir nicht.
Wir können es so machen, wie ich es vorher
String
from UTF-18
UTF-18, neues Format
created
So
Äh
Äh
Hatte ich das nicht eben so und es das ging
Warum geht das jetzt so
Vor allem an Emma
Ah ne ah weil ich hier
Standard Out machen muss
Aber das sieht so hässlich aus
Das sieht so hässlich aus. Warum gibt es nicht so was wie Map oder so? Gibt es vielleicht Map? Map!
lull ja okay moment moment moment mal gucken
standard out und jetzt kann ich hier sagen string rom utf 8
Unwrap.
Unwrap.
So viel Unwrappe.
Ungerappe.
Ja gut.
Das ist doch schon schöner.
Das gefällt mir. So ist das gut. So lassen wir das.
Das hier ist ein String.
Und ich bekomme hier einen Describe.
Sehr gut.
So. Jetzt bin ich mal gespannt,
ob das funst, was ich hier gebaut habe.
Also.
ich habe eine bild script schau mal cargo run kackt jetzt bestimmt direkt ab beim bilden
macht es nicht so wie greife ich denn jetzt auf diese variablen zu weiß hat im code verwenden
Enf. Enf.
Okay.
Main.
Machen wir hier mal noch hier.
Git.
Enf.
Git describe.
Jawoll. Und jetzt run.
Und Daumen drücken, dass es funzt.
Es funzt, Leute.
Es funzt.
Was ich nicht ganz verstehe, wo kommt denn hier der...
Ah, Moment.
Die...
Die Quotes braucht man gar nicht.
Die Quotes braucht man nicht.
Es funzt.
Sehr schön.
Pogge.
Ja, das ist doch übersichtlich.
Jetzt ist nur die Preisfrage.
Jetzt mal ganz blöd.
Mal ganz blöd.
Wir sind jetzt hier auf diesem Comet.
So, hier, guck.
G09 irgendwas.
wir sind nicht auf g 09 wir sind auf 09 bekommen das g her
dass die die short variante
bekommen das g her
Kefelgit
Vergönnen, ja, das glaube ich auch
Okay
Wir fragen mal
Was steht G für?
G steht für Git?
Okay.
Na gut, okay.
Wieder was gelernt.
War mir neu.
Ja, aber was ich mit Flayer frage, ist jetzt,
wenn ich jetzt committe,
also wir haben jetzt hier
Cargo run.
So, wir haben jetzt hier 0,97.
Jetzt machen wir hier mal ein Comet.
Und jetzt sagt mein Describe,
wir sind nicht mehr dirty und haben dieses Comet.
Kriegt er das denn jetzt überhaupt mit
mein Cargo run? Nö.
Mein Cargo run kriegt das nicht mit.
wie kann ich das jetzt mit meinem cargo mitteilen dass der reloaden soll
bei einem bild ich weiß was ich machen kann ist ich kann immer meinen target löschen und
komplett neu bilden das müsste wahrscheinlich funktion aber das kann ja nicht sinn und zweck
der sache sein
ja genau er guckt weil jetzt hat es gecheckt
kannst es in deine cargo tommel hinzufügen
Ja, aber was?
Was soll ich in die Cargo-Tommel hinzufügen?
Ähm, Cargo...
Build-RS on Git-Change.
Buildscripts.
Rerun if changed.
How to force Build-RS run after a comet.
Aha.
rerun if changed
git head
5 head time, Leute.
Also.
rerun if changed
git
.git head
Und das soll jetzt funktionieren.
Kommt mal.
Kommt mit.
Wir sollten jetzt 4 E8 bekommen.
Geht nicht. Geht nicht.
Geht nicht.
Hat er nicht gecheckt?
Eran have changed.
Funst nicht.
Ja, aber das ist doch die ganze Zeit schon immer.
Die Datei changed doch gar nicht.
das ist blödsinn
in den edelst guck mal dass die tat ja auch gar nicht geändert
und das steht ja immer nur master drin
Was spricht denn die Version Runtime?
Na, weil die
zur Runtime nicht zur Verfügung steht
Da kommt ein Binary raus
Das Binary wird irgendwo hin kopiert, gestartet
Das ist ja dann nicht mehr in dem Git-Repo drin
Das Verhalten ist erwartet, reicht nicht, weil es sich meist nicht die Datei hat ändert.
erhält nur einen point der jacke chat gpt ist heute frei fett sonst kackt sie
immer ab bei einem neuen die datei ändert sich oder bei viel korrekte
lösung minimal robust und empfohlen hat index packt raps und raps alter
Okay.
Ja, dann reicht's doch,
dann reicht's doch,
wenn ich...
Okay.
Egal. Wir machen das jetzt einfach mal,
was ChatGPT da sagt.
Cargo.
Run.
Okay, passt, passt.
Commit.
Describe. Also wir sollten jetzt
eine 985 bekommen.
Ups.
Oh, wenn ich ja richtig tippen könnte.
985.
Es geht.
Sehr gut.
Guck mal, wir haben es selbst gebaut.
Wir brauchen gar keine externe
Dependencies dafür.
Wir führen einfach einen Git Describe aus
und ja, das gefällt mir.
Das ist sehr nice.
Das ist schick.
Also das gefällt mir.
Also, jetzt ist die Frage, wie kriegen wir das jetzt noch beispielsweise unsere App-Config rein?
Also, sagen wir mal.
Ne, nicht wirklich AI.
sagen wir mal ich will so was haben wie jetzt version ja string sehr gut geht version string
will ich haben wenn ich das jetzt ausführen gibt es also was wie ignore vielleicht ja
ich noch
clap ignore rust clap ignore field how to make clap ignore a specify field
ins truck genau das wollen wir es gibt es gibt nicht so es gibt es klappt war das mal für arg
skip ok weiß und so und jetzt brauche jetzt will ich jetzt jetzt die frage wie geht das in rast
jetzt will ich hier draus eine globale config machen in der gesamten anwendung zur verfügung
steht also ich will quasi was haben wie static oder app config app config das
wird das wird so in rastl fünften ich muss ich muss ja ich muss jetzt zur
Laufzeit der Sachen rein. Gibt es Static
Mut?
Static, Constant,
Upconfig, Must have a value.
Ja, aber ich bekomme das ja erst, wenn ich es parse.
Ja, das ist irgendwie blöd.
Sowas wie 0 gibt es in Rust ja nicht.
Also es gibt None, aber das passt ja an der Stelle nicht.
Ich meine, ich könnte da irgendeinen Mist reinschreiben.
Aber das ist...
Gibt es...
Weiß nicht, das ist irgendwie...
Das ist irgendwie blöd.
Aber selbst jetzt mal angenommen, ne?
Selbst
String
One cell
Was ist hier?
Cannot call in static
Ach so, ich
Äh
Okay
das funzt so schon mal nicht wie ich das haben will won cell von wegen ich höre
nicht auf den chat was jeder immer unterstellt hier chat ist jetzt guckt
Ist der Beweis.
Ich höre gerade in diesem Moment auf den Chat.
Sell.
One sell new.
One sell get or init.
Ja, sowas.
Das ist sowas, was ich haben will.
Genau.
Genau.
Also würde ich jetzt quasi sagen.
Gleich.
One sell.
Standard Cell, One Cell.
Warum findet er hier
vor nichts?
One Cell.
Gibt es nicht.
Overrated, she baited.
Jetzt findet er es angeblich doch.
Wie mache ich das?
Ich mache nochmal rückgängig.
On sell.
Gleich.
Ich muss so machen, hä?
App-Config.
Aha.
Warum darf ich denn new aufrufen?
Das ist erlaubt, oder was?
One cell.
App-Config. Und dann muss ich hier sagen
get or init.
Das ist aber auch
kacke. Das ist so eklig.
Was wird gebaut? Ich gucke mir ein Web Framework an in Rust.
Und lerne nebenbei ein bisschen Rust und wie man so Sachen macht wie Structured Logging oder Command Line Argumente parsen.
Jetzt quasi App Config.
Get on
What?
Was? Unsafe?
Moment, muss das überhaupt
MUT sein? Das muss nicht MUT sein, oder?
Und jetzt sage ich hier
AppConfig
Ne
Pass
So, jetzt geht's, pass auf
Shit, geht nicht
Warum nicht?
Warte mal, String?
Wie kommen die auf String?
Witzig
Och, was ist denn jetzt schon wieder?
Cannot be shared between threads safely
Ich will das nicht, ich will das gar nicht zwischen Threads sharen
Ich habe überhaupt nicht vor, das zwischen Threads zu sharen
Rust
Wie kommst du auf die Idee, dass ich das sharen will zwischen
Wie kommt Rust da drauf, dass das
Rust
Wie kommst du drauf, dass ich das
dass ich das sharen will zwischen Threads
Threads.
Ach so.
Ach, weil ich...
Aber guck mal, guck mal.
Selbst wenn ich das auskommentiere, hier.
So dass Rust gar keine Ahnung davon hat.
Dann sagt er
Cannot be shared.
ja das ist doch abfakt das ist doch so das kann man dazu oder 200 machen das können wir so nicht
machen wieder da weiß ich habe eine idee ich habe mir die leute ich weiß ich weiß was wir machen ich
weiß was man passt auf jetzt sechs hat heim wir machen eine function die nicht eisung ist die
nennen wir appconfig.
So.
Dann machen wir das da rein.
Da kann es gar nicht rummeckern.
Vielleicht wollen wir auch
wirklich oneslog haben.
Oneslog.
War halt once lock auch gut aber dann brauche ich die funktion ja nicht mehr wenn ich schon
Was das eklige so static once once lock
Once lock
Okay das funst und jetzt kommt man sagen app konfiguriert oder in it aha
Und jetzt sagen wir hier
App-Config.
As-Value.
Ach, nee.
Nee, jetzt muss ich hier immer Get machen oder sowas.
Get und dann noch eine Option.
Das ist doch hässlich, AF.
Boah, ist das hässlich.
Meine Güte, ist das hässlich.
welche lipp ich für die config verwende das ist klepp command line ein command line pass
so
das funst aber das ist das ist echt echt da man kann klepp wo wir gerade dabei
sind klepp rast kann klepp environment variablen wollen wir musikwechsel wollen wir
zwischen war auf die hier mein browser abgekackt leute doch nicht
Warum die Config überhaupt global ablegen, das weiß ich noch nicht genau.
Wahrscheinlich weil ich die unterschiedlichen Teilen brauche.
kann das okay das heißt man kann sowas sagen wie
meine idee das ach guck mal da die können sogar features auto kompleten
auto kompleten von den ja das ist ja nice
turns on user environment variablen
ein wein und variables vor allem
also schreibe einfach einfach dabei
environment variables
so und nun gibt es jetzt hier irgendwie sowas wie ein wein und ich habe da was gesehen
und da gibt man jetzt an wie die environment variable heißt also sowas wie champ underscore
address so zum beispiel und und hier
Enf Champ Port. Gucken ob das funzt. Also noch haben wir hier Port 8080,
Export, wobei wir können es auch hier davor schreiben. Champ gleich, ne,
Champ Port gleich 1234. Port 1234, sehr schön, sehr schön. Das gefällt mir. Das war einfacher
als gedacht aber das mit das wird der config datei fakt und immer noch ein
bisschen ab es ist das ist ja mal richtig hässlich so aber wenn ich das
überall durch reich ist doch irgendwie auch blöd ich mache ich mache dann
irgendwann ein background job auf wo ich nach gucke wie oft da irgendwas
aktualisiert werden soll und überall soll ich das übergeben als parameter
ich weiß nicht so ein globales ding für diese sachen ist doch gar nicht verkehrt
auf der anderen seite guckt in dotnet oder in spring boot oder
ein go weniger da wird es da geht es alles über die pendency injection dann
sagt man auch beim erstellen hier ich will meine app config haben also was haben wir hier nicht
ach so hat die pendel sie in checken
mal eine blöde frage warum muss man eigentlich eine globale variablen locken wenn sie von
mehreren threats zugegriffen wird das problem ist doch nicht das zugreifen
von mehreren threats sondern schreiben von mehreren threats
also eigentlich ist es mal ist das mal komplett safe
extraktor in axel
So einfach ist es doch ist es eigentlich schon
mehr mehrere reader sind nie ein problem
Achso, das GetOrInit.
Ja gut, einmal muss ja was reingeschrieben werden.
Die globale Variable ist im Cache.
Ja, das ist ja auch okay.
Die ändert sich ja auch nicht.
Stimmt, ich muss ja einmal was reinschreiben.
Und das könnte ich von mehreren Threads aus machen.
Ja, ich muss
einmal muss ich was reinschreiben.
Das stimmt. Ja, streng
genommen ist das tatsächlich dann ein Problem. Das könnte
ich ja aus mehreren Threads irgendwie parallel machen.
Okay, gette ich.
Macht Sinn. Hat Rust recht.
Allgemein auf Threading bezogen
ist Lesen nicht safe.
Wo soll denn mehrere Reader
Ohne Writer
Wo soll das denn nicht safe sein
Mehrere Reader sind immer safe
Also ich wüsste jetzt nicht
Wo mehrere Reader nicht safe sein können
Probleme sind immer nur
Wenn geschrieben wird
Sobald geschrieben wird
Mehrere Reader
Eigentlich kein Problem
Das gefällt mir so nicht.
Das hier checke ich auch nicht so genau.
Axum Extract Extension.
Ich versuche gerade zu checken, was hier passiert.
Warum ist das so ein langes, ewig langes Beispiel?
Warum ist das so ein krass langes Beispiel, Alter?
Da blickt doch kein Sau durch.
Axum Extractors.
Ja, das da.
For example.
Händlerfunction ist ein Essig von der...
Ne, das ist doch nicht das, was ich haben will.
Ja Moment, das ist nur für Routes.
Aber ich will das ja auch hier in Run benutzen und so.
Nee, das geht ja dann nicht gescheit.
Nee, das ist irgendwie nicht so das.
und ich will auch einen Background Thread starten
und da drinnen
dann drauf zugreifen. Ne, ne, ne, ne.
Das ist nicht so das...
Okay.
Ich hab ne Idee.
Ich hab ne Idee, was wir machen.
Nachdem ich das hier so eklig finde,
wir probieren das hier nochmal. Also wir sagen jetzt
Function
AppConfig
Zack.
So. Dann packen wir das
da rein.
Das da packen wir auch da rein.
Und jetzt returnen wir
App-Config.
So.
Funktioniert.
Warum?
Ah, weil ich
und App-Config returnen muss?
Ne, ähm.
Was hat der jetzt für Schmerzen?
wäre ja auch deutlich zu einfach.
Wir machen mal hier
letconfig.
Moment, warum ist das...
Moment, Moment, Moment.
Wartet mal, wartet mal.
Ich bin...
Ich bin gerade...
verwirrt
ach so ok ok ok moment moment das ist doch richtig das ist doch richtig ich brauche jetzt
und moment moment rast und static und static das brauche ich aber wenn ich das hier weg
mache checkt das dann immer noch okay so jetzt habe ich eine globale app konfekt kann ich hier
einfach nur sagen appconfig zack svalue doch das doch schon viel besser ja das
finde ich schon schicker noch schicker wäre es wenn ich es value nicht brauchen
würde aber das geht anscheinend nicht anders
Das ist doch so ganz gut.
Ja, das gefällt mir.
Das kann man so lassen.
Ja.
Okay.
Jetzt nächste Preisfrage.
Wie starte ich einen Background Thread?
Dein Rust Herz schmerzt.
Ja, wie würdest du es machen? Rein mit der Dependency Ejection von Axum komme ich ja nicht hin.
Das kann man ja nur in Händlern dann anscheinend verwenden.
Wenn ich jetzt ein Background Thread hab, da ging das dann schon wieder nicht.
Der Background Thread soll einmal in der Sekunde Blub ausgeben erstmal nur.
Long Running Task ohne Ende.
Okay also wir seralalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalalal
Mit Tokio geht das doch auch, oder?
Genau, Tokio spawn.
Tokio.
Spawn.
Genau, Tokio spawn.
Tokio spawn. Jetzt muss man auch wieder so machen, gell?
Oder nicht?
Okay.
Pokyo spawn.
Zeige mal her.
spawn.
Ah, Async Move.
Äh.
Nee, nee.
Move war nicht. Async.
Dieses komische
Ding brauch ich nicht mehr. Aha.
Okay. Okay. Tokio Spawn
Async. So. Und jetzt haben wir hier Loop.
Für immer.
So. Und jetzt
gibt es sowas wie Tokio Sleep?
Sleep? Delay?
Delay? Ne.
Sleep?
Tokio Sleep Rust.
Sinux, danke schön für den Sub.
Tokio Time Sleep.
Tokio Time Sleep.
Durations from the seconds.
Genau, so ist gut.
So.
Und jetzt sagen wir, Tracing.
Info.
Ja, keine Ahnung.
Blub.
So.
Gucken wir mal, ob das jetzt funzt.
Achso, ja, vielleicht soll ich den Fehler wieder rausnehmen.
Easy, geht.
Sehr gut.
Dazu könnte man ja fast schon sagen, easy.
oder nein das war das falsche
so und da will ich jetzt auf meine config zugreifen nur mal so zu gucken wie es geht
konfig gleich app config s value eigentlich wirklich die ei macht komische dinger
Ja, geht.
Geht.
So, das hier ist übrigens verkehrt.
Das muss hier weg.
Und das soll...
Moment.
Let.
Config.
Moment, ne, da muss ja Klammern drumherum, ne?
Aber irgendwas stimmt hier nicht.
Ah ja.
config und jetzt config get version gleich
to string
was hast du für schmerzen rast
das sei eine new value to field immutable bei den das muss mutt mutt muss das sein mut und
jetzt kann ich sagen tust ringen so jetzt haben wir das da drin jetzt jetzt müsste nämlich auch
ausgeben können.
Git-Version. Ja, sehr schick.
Sehr gut. Das gefällt mir.
Und einmal... So.
Und jetzt machen wir mal...
Jetzt gucken wir mal, ob das aus der...
Jetzt sagen wir mal, das kommt aus der Config.
Arc.
Champ.
Champ.
Interval.
Default ist 1.

Interval.
Und nun gucken wir mal.
Config.
From seconds.
App-Config.
Intervall.
Okay, das funzt nicht. Warum?
Moment, er will einen U64.
Ich will aber einen U60.
Wie jetzt?
Ein U16 passt doch in einen U64 rein.
Hol dir doch die Version direkt über Clap in die App-Config.
Aber ich hab die Version nicht.
Klepp macht es ja zur
zur Runtime
das da ist
das da ist ja Compile Time
Add Safecast
Oh
Okay, was ist besser?
Das da oder was der Chat
geschrieben hat? U64 from
App-Config.
Das hier sieht irgendwie
angenehmer aus.
So.
Schauen wir mal. Cargo Run.
Kann nicht failen.
Und wenn es failt, was passiert dann?
Kackts ab.
So. Intervall 1.
Jetzt gucken wir mal, wenn ich jetzt hier sage, Champ Intervall gleich 5.
Guck, dann updaten wir auch nur noch alle 5 Sekunden.
Das ist Funst.
Kunst.
Eis.
So.
Und jetzt.
Was?
Statt U64 lieber Into nehmen, setzt sich weniger fest auf einen Typen.
Also sowas hier.
Into.
Äh.
Moment, warum geht das jetzt?
Moment.
ist ist was jetzt so schlau zu checken was will das hier als parameter haben
und dann kaste das in tue schon für mich
das aber ziemlich pock
das ist eigentlich ganz nice
Yep, Clock.
So, jetzt haben wir unseren Background-Thread.
Okay, Leute.
Drei Stunden kommt genau hin.
Heute ist der Streamtitel ja...
Moment.
Das da, passt mal auf, Google, two hours, sind genau drei Stunden.
Und drei Stunden sind gleich um.
Ich muss nochmal an die frische Luft, Leute.
Aber heute
einiges gelernt über Rust.
Ich habe verstanden,
dass die Rust-Fans
das hier nicht so mögen
mit meiner globalen Config.
Wirklich gute Alternative
habe ich jetzt aber noch nicht gelesen.
Außer überall alles zu übergeben.
Sich zu übergeben.
Welche Tastatur hast du?
Ich habe eine Logitech, sage ich dir.
G 512
Carbon
I
G X
Ja, steht da unten drauf.
Wenn es euch gefallen hat, Leute,
oder wenn ihr Bock auf solche Streams habt,
dann könnt ihr mir jetzt ein Follow dalassen.
Gucken, morgen geht es, glaube ich, weiter mit Rust.
Noch für 1, 2, 3 eventuell Streams,
bis wir unsere Anwendung hier am Start haben.
Und bis wir uns halbwegs sicher fühlen, was Rust angeht.
Wobei Rust ist nichts, was man in 3 Tagen lernt.
Das habe ich schon gecheckt.
Also die Basics kann man dann ganz gut.
Kein Aufwachen-Stream?
Na doch, doch, doch, vielleicht schon Aufwachen-Stream.
Was willst du eigentlich servern?
Nichts Spezielles, eine Web-Anwendung.
Wir machen im Endeffekt die gleiche Anwendung, würde ich sagen, nochmal, die wir letztens in Quarkus gebaut haben.
Da weiß ich nämlich schon, was wir alles einbauen.
Wobei wir das ja eigentlich schon, eine Sache ja schon eingebaut haben, die es in der anderen Anwendung noch nicht gab.
Nämlich diese Versionsnummer beim Startup.
ja für den ersten tag also es ist nicht das allererste mal dass ich was mache muss gleich
dazu sagen ja also ein bisschen was mit was habe ich schon gemacht aber auch noch was gelernt
unterschiedliche cargo crates rust crates und bild skript klepp zum passen wenn übrigens sehr
angenehm im handling hier klepp als command line passen kann man sich nicht beschweren macht alles
was man will.
Wenn ich jetzt noch frage, ist,
wie man verschiedene
Commands da unterbringt.
Also wenn ich jetzt zum Beispiel Command Run
oder so haben will.
Naja.
Das gucken wir uns dann aber das nächste Mal an.
Ich würde sagen, Leute,
wir sehen uns.
Bis zum nächsten Stream.
Dann wieder 1,08.
Was auch immer.
Hoch 7 Millisekunden.
Bis dann.
Macht's gut.
See you.
