So, Leute, wir sind am Start.
Habe ich heute Qualitätsoptionen?
Ja, ich habe Qualitätsoptionen.
PogChamp, Pogos, Qualitätsoptionen heute.
Unglaublich, man kann auch die Qualität vom Stream einstellen.
Und es ist auch unglaublich wichtig, dass wenn ich mein Desktop und meine 4M streame,
dass ich dann 1080p at 60fps habe.
Wichtig.
Leute, guckt mal, guckt mal, wie flüssig mein Mauszeiger ist.
Seht ihr das?
Und wie flüssig ich Fenster bewegen kann.
Craig Gerson.
Das ist wie live dabei.
In echt.
60fps Fenster.
Jetzt muss ich mir das Ganze mal im Vollbild angucken, in der Vorschau.
Moment, ich stelle es mal auf 1080.
Oh, das ist gestochen scharf, Leute.
Stimmt's?
Gestochen scharf.
So scharf war das noch nie, das Stream.
Sehe ich das richtig?
Also meine Vorschau sieht wirklich super aus.
Kann man nicht meckern.
Kann man echt nicht meckern.
So.
Ja, das 4M Workstation.
Die habe ich mal, ähm, irgendwann, die hatten, die hatten vor, ich glaube vor zwei Jahren oder vor,
oder war, nee, müsste vor zwei Jahren gewesen, oder?
Keine Ahnung.
Die hatten mal so einen Weihnachts-Sale, da hat es glaube ich, wie viel kostet es denn normalerweise?
Also es hat glaube ich nur 90 oder so gekostet.
4M Workstation 14 ist das, ist das 14, äh, was kostet denn das normal?
250, genau, das, das habe ich auch, das hat, das hat bei denen auf der Seite glaube ich plus 90 oder so gekostet,
da habe ich mir gedacht, hey, ich, äh, verwende es schon, verwende es schon so lange,
4M, wir kaufen mal eine neue Version.
Lull, Alter, Lull.
Software kaufen in 2K17, Lull.
Wer macht denn sowas?
Ah.
Ja, was machen wir denn heute?
Dazu muss ich erstmal ein kleines Intro erzählen, was wir heute machen.
Und gleich dazu sagen, es ist eine Sache, mit der ich mich selbst nicht großartig auskenne.
Wir brauchen heute zumindest, und es ist sehr gut, dass wir die installiert haben,
wir brauchen die Linux 4M, die wir uns eingerichtet haben, die Manjaro Linux 4M,
die wir uns eingerichtet haben von ein paar Livestreams, ist schon eine Weile her,
weil wir heute quasi bis auf zum Testen von unserem Programm,
was wir auch mal unter Windows testen müssen,
werden wir das hauptsächlich unter Linux machen.
Und ich muss auch noch ein paar Vorbereitungen treffen.
Also wie gesagt, ich habe selbst nicht so eine großartige Ahnung,
was, wie das, wie das funktioniert heute.
Und zwar, ihr wisst ja, ich bin sehr großer JavaScript-Fan,
also um nicht zu sagen, ich bin quasi der größte JavaScript-Fan, den es so überhaupt gibt,
aber ich bin ein sehr großer JavaScript-Fan, den es so überhaupt gibt,
und dementsprechend programmiere ich auch nie in JavaScript.
Oder selten, wenn es sich irgendwie verweilen lässt.
JavaScript hat schon ein paar ganz merkwürdige Eigenheiten.
Aber heute müssen wir wahrscheinlich ein bisschen JavaScript,
wobei eigentlich, ich kann den, ich ändere den Titel nochmal,
eigentlich programmieren wir wahrscheinlich, denke ich mal zumindest,
TypeScript und nicht JavaScript, ja.
TypeScript, das muss ich gerade mal ändern, weil eigentlich geht es ja heute,
Titel mal ändern, TypeScript.
Heute, weil, weil, Mensch, also, wenn ich die Wahl habe,
wenn ich schon was in JavaScript machen muss, ja,
dann kann ich mir die Arbeit ein bisschen einfacher machen
und das Ganze wenigstens in TypeScript machen.
Ich werde euch auch gleich erzählen, was wir machen.
Sobald sich der Titel aktualisiert hat,
weil Twitch ist so eine kleine Indie-Streaming-Seite,
da kann man nicht erwarten, dass sich der Titel innerhalb der ersten drei,
zwei Minuten aktualisiert, aber ich, ich, ich halte jetzt die,
ich habe ja wenigstens Qualitätsoptionen heute.
Hat sich der Titel letztendlich aktualisierend?
Eigentlich, Leute, eigentlich sollte der Titel des Streams jetzt sein,
labern über JavaScript-Typescript kotzen.
Ist es, ist das bei euch angepasst?
Ist das bei euch richtig?
Ja, der Titel ist richtig.
Nice-u.
Okay, also, was wir heute machen wollen,
ist,
ist,
so,
doch, ich habe gerade F5 gedrückt, ist da, guckt, Leute, ich zeige es euch,
weil,
Titel ist aktualisiert, yeah.
Moment, ich bin hier nicht in Twitch eingeloggt und Twitch hat trotzdem neues Loot.
Aha.
Na, wenn das, wenn Twitch das meint, beziehungsweise Amazon.
Können wir nicht in einer anständigen Sprache was machen?
Ich, ich, ich würde gerne, ich, ich, ich, ohne Scheiß, Leute, ich würde das, was ich heute machen will,
ich würde es gerne in,
keine Ahnung, in C-Sharp, in, äh, C++, in, in, in, in Ruby, in, äh, in irgendwas, außer halt unbedingt JavaScript machen.
Aber,
ich glaube, wir kommen nicht drum herum.
Und zwar, was ich machen will,
ähm,
ist mir heute auf der Arbeit aufgefallen.
Und zwar,
ich habe auf der Arbeit mal vor einer Weile was programmiert,
das nennt sich das Lull-Tool.
Und das ist jetzt kein Witz.
Das heißt wirklich so.
Es führen einige Leute regelmäßig auf der Arbeit
in ihrer Shell den Befehl Lull aus,
ohne dass sie wissen, was Lull heißt,
weil sie das Tool von mir verwenden.
Das Lull-Tool.
So.
Und was das Lull-Tool macht,
ähm, kann ich auch ganz kurz erklären.
Das macht ein paar Abfragen gegenüber,
das macht ein paar HTTP-Abfragen gegenüber ein paar Services.
Und, äh, sucht sich ein paar Informationen von allen möglichen
Seiten, Quellen zusammen
und zeigt dann daraus in der Shell was an.
Unter Linux.
Das ist ein Tool, das funktioniert nur unter Linux.
Und es ist in Rust programmiert.
Weil ich der Meinung war, als ich das, äh,
programmiert habe,
also, ja, schon ein bisschen her,
also so lange ist es nicht ewig her, keine Ahnung,
wie alt, das wird so eineinhalb Jahre alt sein oder so.
Und damals habe ich mir gedacht,
ich wollte schon immer mal was in Rust machen.
Rust ist das Ding.
Nein, also nicht, nicht das Rust hier.
Also nicht, äh, nicht Unity und nicht Rust,
sondern Rust, äh, Programmiersprache.
Rust.
RS.
Äh.
So, wo haben die von der Seite?
So, in der, in,
das Tool findet man nirgendwo.
Das gibt es nur bei mir auf der Arbeit.
Das habe ich für unseren internen Zweck geprogrammiert.
Deswegen kann ich jetzt auch nicht so viel genauer erzählen,
was es macht, aber es sucht sich eben von verschiedenen Seiten
Informationen zusammen
und
stellt die dann auf der Shell dar, ja.
Also zum Beispiel eine Sache, die man sagen kann,
da wurde überhaupt nichts, was, was,
ist ja nicht geheim oder so.
Äh, man kann damit zum Beispiel erkennen,
wo welcher Server steht.
Jetzt über die Shell, was ganz praktisch ist.
Man könnte das in irgendwelchen Webinterfaces
oder in irgendwelchen, äh, äh,
wie, wie nennt man das?
Inventardatenbanken oder so nachgucken, aber
dieses Tool verbindet sich zu ein paar Seiten,
zieht sich die Informationen raus und dann kannst du die relativ schnell
anzeigen lassen, hey, unser Live-System
sowieso, ähm,
keine Ahnung, äh,
welche Domain hat das zurzeit
und, und, wo steht das?
Und solche Dinger zeigt das an, ja.
Es ist eigentlich bloß, äh, zur Hilfe für, ähm,
Leute, die
öfters mal auf die Kiste drauf müssen,
dass sie das auch von der Shell machen können und nicht,
und jetzt nicht irgendwie im Webinterface rumklicken müssen.
Eigentlich hab ich das hauptsächlich und
die meisten Tools, die ich so bastle, hab ich,
bastel ich erstmal hauptsächlich für mich.
Und damals hab ich mir gedacht, ich könnte das ja mal in Rust machen,
ja. Ich hab jetzt nen Source Code leider nicht da, aber, ja.
Weil ich mal
ausprobieren wollte, wie dann
Rust so ist. Rust ist von
Mozilla, die
Programmiersprache, die sie sich ausgedacht haben, extra
für Firefox, um dort
die Sachen schneller und gleichzeitig
sicher zu machen.
Ähm, Servo
ist, ähm, so diese,
die,
die neue Browser-Engine, die irgendwann mal in
Mozilla reinkommen soll, die ist in Rust programmiert und
ist halt viel schneller paralysiert und
bla, was auch immer Mozilla da so macht.
Und ich glaub, die neue CSS
Layout-Engine
in Firefox ist mittlerweile
auch in Rust programmiert.
So, und Rust ist wirklich super.
Ich kann gegen Rust nichts Schlechtes sagen, aber
Rust macht keinen Spaß zu programmieren.
Zum Beispiel, wir gucken uns mal hier ein paar,
gucken, ob wir hier ein paar schöne, typische
Rust-Beispiele haben.
Ich hoffe, jetzt kommt die, äh,
berühmt-berüchtigte Rust, äh,
Rust-Taskforce von Hacker News
mich und flamed mich.
Ähm, aber Rust finde ich nicht angenehm
zu programmieren. Haben wir hier irgendwie ein paar, paar
schöne Beispiele hier? Oh,
beste Seite.
Machen wir hier. Ugly Rust.
Suchen wir mal danach. Ne, das ist, das ist
über das Spiel. So, und zumindest
ist Rust ziemlich eklig.
Das macht keinen Spaß da drin, irgendwas
bisschen komplizierteres zu programmieren. Ähm,
wenn man, wenn man, wenn man sowas wie eine Browser-Engine
machen will, okay, hey, das ist, das muss schnell
sein, das muss sicher sein, das muss parallelisierbar sein,
aber, hier, guck mal,
allein schon, wenn die, die Fragen angehören,
why does Rust have such a ugly syntax?
Guck, jetzt gucken wir uns mal das Beispiel
aus dem, aus den
Beispielarten, die haben ja gar kein Beispiel drinnen.
Sie haben, ach man, ich
muss, ich, ja,
sowas, oh, wenn ich sowas schon sehe,
das ist,
ich finde Rust ist in der Handhabung nicht schön.
Die benutzen schon Rust, ja, ja,
Flickscroller, äh,
Mozilla
Quantum Rust.
Ich glaub CSS ist
schon, die CSS
Engine, ja, genau,
Stylo, genau, das ist Rust.
Das ist
jetzt mit dem letzten Mozilla gekommen.
Guck mal, wenn du schon solche Titel liest,
warum macht es Rust einem so schwer?
Wir brauchen mal
ein richtig, ich brauch mal ein richtig schönes, richtig
eklig
Example, richtig schönes
ekliges Rust-Beispiel.
Oh, Beautiful Rust, oh, da bin ich
mal gespannt, da gibt's immer Leute, die irgendwas posten.
So,
und ich finde, ich finde allein schon,
also wenn, das hier ist jetzt Beautiful Rust,
ne, das ist Beautiful Rust,
so, ich mach das mal ein bisschen größer,
ich finde sogar, Beautiful Rust sieht schon
abartig hässlich aus.
Und Rust, Rust kürzt
gerne Sachen ab, die unsinnig sind, meiner
Meinung nach, abzukürzen, vielleicht stehen da die ganzen
Mathematikers drauf, und,
ähm, dann haben sie so komische Pfeile drin,
für Return-Wert, anstatt
das hinzuschreiben, und dann gibt's hier noch so
zwischendrin irgendwelche,
kleiner, größer Dinger, zum,
ich weiß an der Stelle,
ich glaub, das ist der Typ vom Result,
und da kannst du quasi direkt Funktionen angeben,
und du musst jede Variable
angeben, ob du sie Read-Only
machen willst, oder schreibbar, und,
Rust!
Also, Rust ist schön,
und ein
großer Vorteil von Rust, warum ich dieses Tool
auch damals in Rust programmiert hab, ist,
die, die Tools bei Rust dabei,
du merkst, dass die Programmiersprache
von Leuten entwickelt wurde,
die Wert drauf legen, dass die Werkzeuge
gut sind. Bei Rust
gibt es Cargo,
das ist der Package-Manager für Rust,
also sprich, damit kann ich Rust-Sachen installieren,
Rust-Libraries installieren,
zusätzlich, wenn ich da grad am Basteln
bin,
und man kann damit auch
seine
Rust-Programme, kompiliert man auch mit,
mit Cargo, also Cargo ist quasi
Compiler-Frontend,
und,
ja, Package-Manager für, für
Library in einem.
So, und,
man kann,
man kann mit Cargo sagen,
ich muss es euch jetzt nicht näher zeigen,
aber man kann mit Cargo sagen, hey,
kompiliere mir mal
mein Rust-Programm,
sofern es keine großartigen
Super-Abhängigkeiten hat, mit denen das nicht geht,
aber mein Programm muss ja plus ein paar
HTTP-Gets machen, und dann
ein bisschen aufbereiten, man kann, man kann dann
sagen, hier, kompiliere mir das mal,
so ähnlich wie mit C++ statisch,
allerdings nicht alles statisch, sondern
eben auch nicht gegen die,
gegen die Libc-Version vom Betriebssystem,
sondern gegen so eine Special-Libc-Version,
und das heißt, man kriegt dann mit Rust
ein Programm raus, das ist, nachdem man
alle Debug-Symbole oder sonst was entfernt hat,
ist das Rust-Programm am Ende
von mir, also,
aus dem Compiler raus, kommt's mit 4,5 MB,
und man muss sagen, das ist komplett
Self-Content, ist alles drin, 4,5 MB,
und wenn man, wenn man die ganzen Debug-Symbole
und ganzes Gedöns entfernt, ist das
Programm, glaube ich, am Ende
um den MB groß, und das ist natürlich
eine krasse Geschichte, und das Beste
ist, nachdem man das gegen eine
alternative C-Library linken kann,
und, und statisch
linken kann, ist
das komplett alles in einem,
das funktioniert auf jedem Linux,
seit Kernel 2.6
irgendwas, das ist natürlich richtig geil,
das kann man sich, das kann sich dann jemand das
Blutzen mit kopieren und auf jedem x-beliebigen
Linux verwenden. So, und jetzt
ist mir aufgefallen,
dass mein Lull-Tool
kaputt ist.
Das ist mir heute aufgefallen.
Und zwar,
macht mein Lull-Tool
Fehler,
also sprich, dass, ähm,
nein, das zeigt im Prinzip schon
das Richtige an, allerdings
nicht unbedingt immer von der richtigen
Seite, also sprich, ich hab mich da,
ich hab da teilweise falsch, oder
ults verwendet, damals aktuell, weil es
nicht mehr aktuell sind,
und an sich,
ist der Source-Code auch
nicht sonderlich schön, ich hab keinen Bock mehr da drin
was zu machen, und ich müsste jetzt
eigentlich mein Tool umbauen,
dass es die Leute wieder ordentlich verwenden können.
So.
Und da hatte ich jetzt die Auswahl,
entweder, also hab ich
mir so überlegt, entweder,
weil ich will ja das, ich hab's ja, ich hab's ja
programmiert, dass man das verwendet,
ähm, und das haben sich jetzt auch viele schon dran gewöhnt,
ich find's halt lustig, wenn die Leute in ihrer Konsole
auf der Arbeit eintippen, so nach dem Motto Lull,
wegen deiner Ausgabe,
ja, und ich
hab jetzt die Auswahl gehabt,
ich mach's entweder in Rust, nochmal,
oder
ich mach's in einer anderen Programmiersprache,
und jetzt kommen wir zu dem eigentlichen Thema
heute, ich will es allerdings wieder
so haben, ich mach mal mein Linux hier an,
ich will es allerdings wieder so haben,
dass man sich einfach
ne Datei
kopiert, einfach ne ausführbare Datei
kopiert, und das einfach
tut, ja, dass ich
keiner, dass ich keiner irgendwie Demian-Pakete
bauen muss, irgendwelche Sachen installieren muss,
einfach, einfach rüberziehen, ausführen
und das Tool macht, die eine Sache, die es machen können,
können soll,
auf so vielen Betriebssystemen,
wie es irgendwie geht, ohne dass man zusätzlich Sachen installieren
muss, äh, Abhängigkeiten installieren
muss oder sonst was, das will ich beibehalten.
So, jetzt hab ich mal geguckt, was es für Möglichkeiten
gibt. Erste Idee,
die ich hatte, ist,
machen wir das einfach, äh, C++,
statisch linken, alles und sonst was,
das ist nicht so einfach, wie ich mir das vorgestellt
hab, oder vielleicht bin ich einfach nur so blöd,
du kannst zwar Sachen statisch linken,
allerdings ist das alles nicht so
simpel, dass da so
ein komplett self-contained Ding
am Ende rauskommt, was vor allem
halt auch, ähm,
auf Linux Systemen
läuft, die alle möglichen Systeme
sein können, ja, Hauptsache das sind Linux.
Dann hab ich mir gedacht, komm, warum machst
du es nicht so, wie das auch,
wie das auch Discord macht,
oder was gibt's denn da noch,
ich geh mal davon aus, Skype wird intern wahrscheinlich
mittlerweile auch JavaScript sein, äh, wie das,
wie das Steam macht, wie das Discord
macht, wie das,
wie das Origin, Uplay und so, wie die
das machen, äh, warum machst du es nicht auch
so, ich mein, es ist auch
eine Anwendung, die funktioniert
auf nahezu allen Betriebssystemen
mit dem gleichen Code.
Und, ihr wisst,
ich hab eine unglaubliche Abneigung
gegen Elektronen-Anwendungen,
also quasi das, worauf
hier der ganze Krempel meistens
basiert, zumindest Discord,
weil es halt nen Chrome,
nen Node.js und alles
bundelt und am Ende ist das Programm
140 MB groß und braucht
800 MB RAM für ein Fenster. Außerdem ist
ja meins ne Konsolen-Anwendung, da fällt so ein GUI-Ding
wie Elektron eh schon raus.
So, dann hab ich überlegt, was können
wir dann machen? Ich will das in irgendeiner ordentlichen
Programmiersprache machen. Hab ich mir gedacht, hey,
guck mal mal, wie ist
es denn mit .NET Core? Hab ich
mir da mal angeguckt, .NET Core. So,
.NET Core hat die Möglichkeit
self-contained Applications zu
bauen, allerdings kommt da nen Ordner
raus und keine einzelne Datei. Also sprich,
da müssten die Leute wieder nen Ordner kopieren, irgendein
Start-Script basteln. Ah, ist auch nicht
so schön. .NET Core
Anwendungen haben auch ein paar Abhängigkeiten zu
irgendwelchen SSL-Libraries und sonst was,
die man nicht wegbekommt. Die müssen da sein,
dass es läuft. Also so wirklich self-contained ist
self-contained auch nicht bei .NET Core.
Und
.NET Core Anwendungen wieder irgendwo
einpacken geht auch nicht so einfach.
Weil die standardmäßig
erstmal nur als Build-Targets anbieten.
Ich glaub, äh,
Fedora, Ubuntu,
äh, Suse
und sowas. Also es wär
meine bevorzugte Variante gewesen, ja.
Irgend so ne .NET Core Anwendung, eine
ausführbare Datei zusammengepackt, gut ist.
Geht auch nicht.
So, äh, ähm, äh,
FlixCorder, das kann ich dir jetzt grad gar nicht so genau
beantworten, aber ich hab mir damals, ich weiß,
das ist jetzt ne bescheuerte Begründung, ja, ist mir schon
klar, ähm,
ich hatte, es hatte
irgendeinen Grund, warum ich wirklich will,
dass das komplett alles in einem ist.
Ähm,
ach, keine Ahnung, ich weiß es nicht mehr.
Ich, ich krieg's, ich krieg's nicht mehr zusammen.
Es hat unter irgendwelchen Umständen
nicht ordentlich funktioniert. Ah, du konntest es
auf unseren Servern teilweise nicht ausführen.
Äh, Ausrufezeichen tun nicht,
ich mach am Tool heute nix, wir machen was anderes.
Zumindest wie dem auch sei.
Also vielleicht könnte man's auch einfach mit C++ machen,
das Ganze nicht statisch linken.
So, und zumindest hab ich geguckt, was gibt's denn da noch
zur Auswahl.
Also was, was könnte man da machen?
Und ich hab zwei Sachen
gefunden. Das erste ist,
ich hätt's auch gern in Ruby gemacht, es gibt sowas
nennt sich Ruby Packer.
Das da.
Damit kann man, das ist genau
das, was ich haben will eigentlich, sowas.
Äh, ach so, ja, Achidoro,
weil du grad Python schreibst,
vielleicht kennst du sowas für Python, dann können wir das vielleicht auch nochmal
ausprobieren, das wär auch nochmal ne Alternative.
Ähm,
ich hab sowas für Ruby gefunden,
damit kann man, das ist wohl auch relativ
beliebt hier, man hat 582, relativ
aktuell, damit kann man quasi,
wenn man ne Ruby-Anwendung hat, das ist das erste, was
ich gefunden hab, weil ich geguckt hab, hey, kann man das nicht
irgendwas mit Ruby machen, Ruby ist,
sagen wir mal nach C Sharp, eigentlich so meine zweite
Lieblingssprache,
und damit kann man relativ simpel
nen
so nen self-contained executable
bauen, wo ne
Ruby-Runtime drinne ist und halt,
im Endeffekt kommt da eine Datei raus. Läuft unter
jedem Linux, sollte man
denken, allerdings
ist jedes Linux, doch nicht so wirklich
jedes Linux, weil, ich hab's auf
ein paar Systeme ausprobiert,
es klappt nicht auf allen.
Also, bei manchen ist die glibc-Version
zu alt, und ansonsten, es klappt nicht.
Okay, das ist natürlich doof. Und,
man kann es nicht cross-compilen zu Windows, das heißt,
ich bräuchte ein Windows-System zum entwickeln.
Auch kein Bock, ja.
Hab ich mir gedacht, okay, komm, scheiß drauf,
guckst du mal, was es für Node.js
gibt. Ihr wisst ja, ich bin
großer JavaScript-Fan, also hab ich gesagt,
komm, scheiß drauf, guckst du mal, was es für Node.js
gibt. Und hab
dann das hier gefunden. Node.js
pgk
package, oder wie auch immer
das heißt. Package your Node.js
project into an executable. Und das ist genau
das, was ich will. Das hab ich
mit ner mini-mini-Testversion mal
ausprobiert.
Und das funktioniert.
Das läuft unter Windows.
Du kannst es unter, das Gute ist,
du kannst die Anwendung unter Linux
erstellen, du kannst
komplett
executables raushauen für
Linux, nahezu jeder Version.
Ich hab's auf nem CentOS 6 getestet, ja.
Und wenn was auf nem CentOS 6
funktioniert, da funktioniert's überall.
Ich hab's auf meinem
Manjaro getestet, ich hab's auf
ne Fedora getestet,
ich hab's unter Windows 10 getestet.
Und das lief einfach. Das hat funktioniert.
Das find ich schon mal gut.
Der krasse Unterschied ist,
wie gesagt, mein Rust-Programm, was alles enthält,
was man so braucht,
ist am Ende
irgendwie 2 MB groß und
das hier ist halt 30 MB.
Aber auf der anderen Seite hab ich mir danach so
überlegt, hey komm,
wir sind im Jahr 2018,
ob jetzt 2 MB oder 30 MB
macht ja nicht so viel aus,
zumal das Programm nur kurz läuft und du
nicht so viel RAM brauchst, auch nicht, weil's
so ein paar Konsolenausgaben macht,
ein paar HTTP-Abfragen,
so. Und
das war's im Prinzip.
Deswegen hab ich
mir gedacht, ich muss mal
heute ausprobieren, wie man ordentlich
Sachen unter Linux mit
JavaScript entwickelt,
beziehungsweise mit TypeScript, weil wenn schon dann mit
TypeScript, sonst krieg ich Anfälle.
Und natürlich müssen wir das Programm auch unter
so den gängigen
Plattformen testen. Also sprich,
das erste, was wir jetzt machen ist,
das heißt, ich weiß gar nicht, ob wir großartig
zum Programmieren kommen, ich denke mal
ein bisschen schon.
Wir müssen
uns erstmal, ich mach jetzt mal mal
ein Linux-VM an.
Das ist übrigens die gleiche Linux-VM,
die wir uns installiert haben vor ein paar
Streams. Das ist schon, ist schon ein Monat
her oder so. Das ist
exakt die gleiche, die gleiche
Linux-VM,
die wir da schon hatten.
So. Und
wir müssen jetzt ein paar Sachen machen. Also ich will das, ich möchte
das Ding gerne testen unter,
unter Ubuntu. Ich will das testen
unter, unter einem relativ alten CentOS
und unter,
keine Ahnung, was nehmen wir denn da sonst noch?
Irgendwas anderes noch.
Würde ich gerne testen und zwar so simpel, wie es irgendwie
geht. Das heißt als erstes, und
jetzt machen wir mal ein paar Hype-Geschichten, weil die Leute,
die stehen ja da aktuell total drauf.
Ähm, die einfachste
Variante, um
mal zu testen, so grob, ja, das ersetzt
keinen richtigen, richtigen Test
auf einer ordentlichen Kiste oder auf einer ordentlichen
VM. Das erste ist, wir gucken jetzt, wie wir ein paar
Container installieren. Und zwar werden wir uns,
wir werden uns einen, einen CentOS 6
Container installieren. Wir installieren uns einen
Ubuntu-Container und wir installieren uns einen,
was weiß ich, einen aktuellen Fedora-Container oder sowas
in der Richtung. Das heißt als erstes muss ich
mir jetzt mal, und das habe ich unter Manjaro so noch nicht
gemacht, muss ich
mir mal einen
Containerfront installieren.
Und zwar bin ich, seit es bei Ubuntu
dabei ist, äh,
ein großer Fan von LXD.
Das ist jetzt nicht so bekannt wie
Docker oder sowas in der Richtung. Er hat auch ein bisschen
andere, anderes Konzept, bisschen andere Philosophie.
Das heißt als erstes installieren
wir jetzt uns ein paar Container, auf denen wir dann später
unser Programm testen können.
Ob das, ob das auf allen
Linux-Distributionen funktioniert.
Und danach kopieren wir es uns einfach auf unsere Windows-Maschine
und testen es da. Äh, das ist
Manjaro Linux. Ja, das machen wir.
Das, das habe ich vor. Ähm,
so. Und natürlich zwischendurch,
wir machen ja relativ
selten was in Linux. Das heißt, wenn wir schon mal dabei
sind, können wir uns das Ganze auch ein bisschen angucken.
Äh, wenn ihr irgendwie Fragen habt zu irgendwelchen,
wie macht man irgendwelche Sachen im Terminal
oder, äh, wie könnte man das jetzt eleganter
machen oder was mache ich da oder, oder
ein paar TMAX-Geschichten, wozu benutzt man das
Ganze. Irgendwas. Fragt einfach
und
wir können uns das angucken. Übrigens, hallo
zeitwächtig, der YouTube ist
neu hier, sagt Hallo. Das ist übrigens ein geiles Feature.
Das gefällt mir, gefällt mir. Ich muss sagen,
normalerweise ist es ja so,
irgendwie bin ich halt voll im Redefluss,
normalerweise ist es ja so, wenn
irgendwie
was von einer größeren Firma übernommen wird,
sowas wie Amazon kauft Twitch
auf. In der Regel denke ich würde erstmal, ach Gott, scheiße,
jetzt ist es soweit, ab jetzt wird Twitch scheiße. Aber ich muss
sagen, Amazon
hat Twitch besser gemacht. Es gibt
wenig Sachen, die ich kacke finde,
was sich getan hat seit der Übernahme,
ja. So Sachen wie, dass man das erste Mal Hallo
im Chat schreiben kann, sowas finde ich, das finde ich
super. Das ist absolut top, kann ich nichts sagen.
Ganz im Gegensatz zu
dem, was, äh, was Google mit YouTube über die Jahre
gemacht hat, wobei YouTube hat auch schon,
gehört auch schon eine Weile zu Google,
aber YouTube ist mittlerweile so zerrissen
in, in, in sich, ja.
Also was, was Settings angeht, du hast
fünf Dialoge, wo du rein musst. Du hast
deine Kanal-Settings, du hast deine
du hast deine Profil-Settings,
du hast deine Kanal-
du hast deine, deine Kanal-Oberflächen-Settings,
du hast deine Google-Plus-Settings, du hast deine Google-Settings,
dein Google-Profil, es ist so
wie, du weißt gar nicht, wo du was gucken musst.
Und, und ich glaube
sogar, dass es auf YouTube möglich ist, ich glaube,
ich weiß nicht, wie das funktioniert, ne.
Ich glaube sogar, dass es auch möglich ist, dass man Moderatoren
für Kommentare anlegt. Ich glaube, das
geht, aber ich habe es ums Verrecken nicht gefunden.
Und, und mittlerweile
ist es, ich habe mittlerweile so wenig Vertrauen
in die, in die Menüs,
und die, die, die Konfigurierbarkeit
von Google und YouTube, dass
ich, ich habe Schiss, ich habe Schiss,
irgendwas anzuklicken, von dem ich nicht genau weiß,
was es macht, weil ich Angst habe, es löscht meinen Kanal oder sowas.
Hey, sogar, sogar die,
die neue Twitch-Beta finde ich nicht schlecht.
Installiert man sich, äh, Franker
Faces Z oder Better Twitch TV oder ist
das fast, fast so gut wieder wie das alte.
Und ich habe euch ja schon mal die Geschichte erzählt,
wo ich die,
wo ich mal aus Versehen
auf Disconnect geklickt habe,
auf YouTube, also sprich, da gehst
du in deine Kanal-Settings und kannst auf Disconnect
klicken und da ist
dann, dann wurde auf einmal mein Google
Plus Account, äh, wurde er
von meinem YouTube Account getrennt. Das wollte ich gar nicht.
Und das Schlimme war, danach
konnte ich keine Kommentare mehr schreiben.
Ich konnte unter meinem eigenen Video keine Kommentare
mehr schreiben, weil ich aus Versehen auf Disconnect
gedrückt habe. So.
Und danach dachte ich mir, ey,
easy, ist doch überhaupt
kein Ding, connectest du das einfach
wieder, weil ich meine, es wurde dann,
es wurde dann der YouTube Account vom
Google Plus Account disconnected. Das heißt,
ich hatte noch eine Google Plus Seite, MaxFPS
und einen YouTube Channel MaxFPS.
Die, die waren ja da, die wurden damals beide zusammen
angelegt, also Google Plus dazu angelegt.
Dann habe ich mir gedacht, okay, connectest du es
einfach wieder. Dann habe ich auf connect gedrückt.
Ich, ich habe, ich habe, wie sagt
man das, Scheiße und Wasser geschwitzt? Keine Ahnung.
Ähm, das hat nämlich dann
15 Minuten gedauert, bis man was gesehen hat.
Und danach habe ich festgestellt, es funktioniert immer noch nicht.
Der hat
danach automatisch sich nicht mit MaxFPS
Google Plus connectet, sondern sich
mit eine neue, eine neue
ähm, Firmaseite
oder wie das hieß bei Google Plus angelegt
und die damit connectet. Dann konnte
ich immer noch nicht mehr unter meinen eigenen Videos
Kommentare als MaxFPS schreiben.
Und dann musste ich das nochmal disconnecten. Habe ich wieder
mir halt in die Hose geschissen
dabei. Und ich gedacht habe, wunderbar, was jetzt passiert.
Und ich weiß nicht mehr, wie ich es dann hingekriegt
habe. Ich glaube, danach habe ich von Hand eingegeben,
mit was er es connecten soll.
Und dann hat er zum Glück das Richtige
ausgewählt. Ey, ich war so fertig
den Tag danach, weil ich gedacht habe, mein YouTube
Channel ist jetzt im Arsch.
Und seitdem, ich klicke
nichts mehr an. Ich klicke nichts mehr an in YouTube.
Kannst du vergessen.
Gut, ähm, da haben wir uns ein paar Fische
angeguckt. Ich will jetzt erstmal, ich versuche
jetzt mal unter, unter Mancharo
LXD zu installieren. Sagt mir mal
bitte, ob die Schriftgröße,
ob das so passt. Oder ob ich noch ein bisschen
größer stellen soll.
Sagt mir mal, ob die Schriftgröße so passt.
Passt?
Okay. Das Schöne an Mancharo ist,
Mancharo ist ein Arch Linux
Abkömmling. Das ist eigentlich ein Arch Linux mit
ein bisschen schönerem Installer.
Und die haben ein super Wiki. Das heißt, wenn man,
nein, nein, nein, nichts, nicht LXDE, LXDE.
Nicht, nicht zu verwechseln. Die haben
eigentlich ein super Wiki. So mit dem
Gentoo-Wiki zusammen eigentlich das Beste.
Ach so, Chat verschieben. Ja klar kann ich Chat
verschieben. Habe ich vergessen.
Ähm, sieht man ja gar nichts.
Äh, soll ich,
soll ich das Chat, soll ich das Chat-Fan
da, soll ich das ausblenden
oder soll ich's
verschieben? Ja, ich verschieb's
nach rechts. Rechts sieht man im Terminal eh kaum
was. Rechts, rechts wird wahrscheinlich
kaum was sein. Probieren wir das mal so aus.
Ich verschieb's mal rechts. Äh, wenn's
nervt, sagt mir Bescheid, dann machen wir das Chat-Fenster weg.
So, und
wenn man, wenn man unter
Arch Linux was machen will, ist, das Arch-Wiki ist das
Beste. So, wir installieren uns jetzt mal
ein Container-Frontend.
So, ich guck mal kurz,
in den Chat, ob ich irgendwas übersehen hab.
Äh, FlixCoder, ich übrigens, ich hoffe,
ich hab die Frage nach, warum überhaupt
statisch linken irgendwie halbwegs ordentlich
beantwortet. Ich weiß es nicht mehr, ehrlich gesagt.
Keine Ahnung. Ich weiß nur noch, ich
ich wollte, ich hab mich damals,
das war einer der Gründe, warum ich es in Rust
machen wollte,
weil man dort
total easy statisch linken kann
und es überall auf jedem
nur erdenklichen Linux-System läuft.
Ich, ich weiß, ich krieg's leider nicht mal genau zusammen.
Wobei, wenn ich, wenn ich das dynamisch
linke, brauch ich da nicht irgendwie
eine gewisse Mindestversion oder so, wo ich
sag, hey, die brauch ich mindestens oder?
Keine Ahnung. Zumindest
ist es auch mal schön, mal was anderes auszuprobieren.
So, hab ich noch irgendwas
übersehen? Äh, es war ein Jaro-Linux, hab ich schon
gesagt. Sub-Button gibt's immer noch nicht, hab ich immer noch nicht.
Ich hab immer noch nicht Twitch angeschrieben.
Ähm,
Google+, wann wird das endlich geschlossen? Ja, das ist
ja quasi um absteigenden Ast.
Du musst es glauben, jetzt ist es richtig.
Ne, ich, ich ja auch, ja.
Ich weiß es ja selbst nicht mehr.
Ansonsten, ansonsten vielleicht
probier ich das auch noch mal ein bisschen in C++ aus. Das wäre nämlich
die zweite Variante gewesen.
Ja, ja, klar, äh, Franka
Faces Z und bei der Twitch-Team ist ein Riesenakt, das
anzupassen im Hintergrund. Ähm,
äh, übrigens,
ist, ist, ist, ist ein Mod
am Start?
Ist, haben, haben wir einen Mod, Mod da
gerade? Der Patrick
ist da, aber der ist afghan.
Ja, zumindest
das Ausrufezeichen Tool
stimmt nicht.
Äh, ich muss Ausrufezeichen
Tool mal deaktivieren.
Äh, das, das geht über den, äh,
ähm, Nightbot.
Ja, ja. Ich, ich deaktiviere
das jetzt mal, weil
ich programmiere ja gar nicht am Screenshot-Tool
heute. Egal, ich muss
das nicht deaktivieren, das passt schon.
Ja, Leute, denkt immer dran, ich habe einen zweiten Monitor
auf, wenn ich das Ganze sehr übertreibe, kann ich euch immer noch bannen.
Okay, gucken wir mal, wie man LXD installiert
unter,
unter Artstellung, das habe ich noch nie gemacht.
Achso, ja gut, das ist,
das ist nicht drauf, weil ich es nicht install...
Mein Stream hängt?
What? Telekom, please!
Ja, Stream geht. Okay.
Ähm, ja.
Install LXC and
LXD Package, then starts LXD
Service. Kein Ding, machen wir.
Wie viel Platz
haben wir denn eigentlich? Ja, passt.
LOL XD
Äh, nicht LXD,
XD wollen wir haben.
Oh, ich habe meine, meine
T-Mark Settings noch nicht hier drinnen, auf
dem Rechner. Grausam, da werde ich
mich jetzt wahrscheinlich laufend vertippen.
Wo ist es denn? Wie heißt denn das Ding überhaupt?
LXD
LXD,
da ist es doch.
Ja, 53.
Das wollen wir
installieren. Äh, wisst ihr was, vorher
machen wir mal einen Snapshot.
Das ist auch ein Riesenvorteil einfach von
4M, du machst einen Snapshot, easy, easy life.
Wenn ich
jetzt irgendwie verkacke, kann ich es einfach wieder rückgängig machen.
Äh, LXD 2.2.1
äh, ja, das scheint aktuell
zu sein.
Ich soll gucken, dass Go Pass nicht gesetzt ist.
Go Pass ist bestimmt nicht gesetzt, ich habe kein Go drauf.
Go wäre übrigens auch noch eine Variante
dieses Tool zu entwickeln, fällt mir gerade auf.
Aber, ich bin auch
kein großartiger Go-Fan.
So, installieren wir das jetzt mal.
351
So, mal gucken, ob das funktioniert.
Bäh, installiert Go.
Übrigens
hochsecures Passwort bei mir,
also falls einer meiner 4M-Hacks
hören will.
Snapshots, also wie die Windows
Wiederherstellungspunkte. Ja, fast.
Fast.
Nur, dass die ordentlich
funktioniert. Jetzt bin ich mal
gespannt, ob das funktioniert. Übrigens, ähm,
als Terminal, weil das ist das letzte Mal
wurde ich das ja gefragt,
das hier ist ein Gnome Terminal
mit dem Base 16
Tomorrow Night 256
das wollten das letzte Mal
laufende Leute wissen, deswegen zeige ich das gleich
von Anfang an. Und der
Font ist Hack.
Hack in der normalen Variante
Schriftgröße 15
und hier als
also quasi
im Terminal selbst habe ich auch TMAX
gestartet. Das ist diese Geschichte,
wo ich hier unten zwischen den Tabs wechseln kann
oder hier so Splits aufmachen kann und sowas
in der Richtung. Das ist auch immer sehr praktisch.
Oh, ich brauche
muss meine TMAX-Config kopieren.
Ich ahne Schlimmes.
Zumindest mal meine Shortcuts wieder.
Hexofont, ja.
So, ähm, und noch
eine Sache. Ich habe mir schon mal
angeguckt, äh,
TypeScript.
Anscheinend ist der beste Editor
für zum
TypeScript programmieren tatsächlich
Visual Studio Code.
Also sprich Microsoft sorgt zumindest
dafür, dass sie ihre eigenen Sachen ordentlich unterstützen.
Wie heißt die Terminal, wie heißt
sie im Terminal sonst zu splitten? Das ist
TMAX. Das da.
Das ist ein Terminal Multipl-
Wo schreiben sie es denn hier hin?
Multiplex Terminals,
genau. Das ist recht praktisch.
Stimmt. Stimmt, du hast recht,
Visual Studio Code selbst ist ja auch
in TypeScript.
Ja, deswegen müssen wir gleich noch Visual Studio
installieren. Also, jetzt mal zu den Shortcuts,
ne. Das kann am Anfang
ein bisschen verwirren. Also,
und ich habe hier leider meine
TMAX-Config auch nicht drauf. Zumindest nicht
alles. Das haben wir damals nicht
fertig eingerichtet.
Man kriegt, wenn man
wenn man STRG-B drückt,
STRG-B ist der
TMAX, standardmäßig der
TMAX-Command-Mode. Also, wenn ich
STRG-B drücke und danach
C für Create macht er mir ein neues Tab auf.
Ähm, wenn ich STRG-B
drücke und Anführungszeichen
macht er mir einen neuen Split und
sowas in der Richtung. Und
du kannst mit STRG-B, Pfeiltaste nach
oben, kannst du dann die Sachen durchwechseln.
Du kannst
beispielsweise, man hat sich jetzt hier
mehrere Splits aufgemacht
und möchte
jetzt den Split unten rechts
im Fullscreen haben, sage ich
STRG-B, also sprich TMAX
TMAX-Mode ansteuern.
Dann sage ich Z, dann geht das in Fullscreen.
Z kann ich wieder zurück.
Und was auch richtig
cool ist, wobei
ich jetzt aus dem Kopf gar nicht genau
weiß, wie man es genau aktiviert, weil man
keinen Shortcut dafür hat.
Ähm, Sync
Genau, Synchronize
Panes, da kann ich
jetzt, wenn ich, warte
muss man noch ON hinschreiben oder was?
Wirt
Okay, ähm
Jetzt kann ich es euch nicht zeigen.
Ich hab da nochmal
Aber guck mal, wenn, warum ist das
an on command? Der Auto vervollständigt
mir das doch sogar.
Ich will euch das jetzt mal zeigen, weil im Hintergrund
der ist ja eh noch am installieren hier nebenbei.
Äh
Ach off, aha.
Okay, okay, also muss man
Ups, also muss man
Z
Synchronize Panes
ON, muss man machen, genau. So und ihr seht
jetzt, jetzt schreibe ich das gleiche in
jedem dieser Splits.
Was halt sehr praktisch ist.
Man fragt sich jetzt vielleicht erstmal
Wozu brauche ich den Scheiß?
Ja, also sprich, warum sollte ich quasi in jedem
in jedem meiner Unterterminal Fensters
jetzt exakt das gleiche schreiben wollen?
Aber, stellt euch mal vor,
hier oben bin ich
auf, ähm
Hier bin ich auf Server 1, hier bin ich auf Server 2,
hier auf Server 3 und auf Server 4 eingeloggt
und ich möchte, und das sind alles Server, die gleich aufgebaut sind
und ich möchte mir jetzt irgendwelche Logs
anzeigen lassen, ja
Dann, oder machen wir es einfacher so
Dann kann ich mir das
Dann kann ich mir das quasi
auf jedem, auf jedem
Server anzeigen lassen, ohne
dass ich jetzt überall das gleiche
eintippen muss. Also, das ist wirklich
unglaublich praktisch.
So, das habe ich mir normalerweise
um einen Shortcut gelegt, weil
das hier, das hier zu tippen
das ist ja, kann sich ja keiner merken
So, und
das mache ich jetzt wieder aus, jetzt kann ich wieder nur
dem Einzelnen tippen. Also, das ist wirklich, wirklich
eine coole Geschichte. Und, achso
ja, nochmal, nochmal, nochmal was
Wollen wir ein bisschen abschweifen, aber
wie gesagt, wir machen so wenig mit Linux, können wir das mal machen
Mal angenommen, ich habe mir jetzt
hier auf meinen, auf meinen 4 Servern
die Logs angeguckt und gesagt, ah, guck mal
hier oben sieht irgendwas anders aus, ich will
mir das jetzt mal genauer angucken. Mal angenommen, ich will mir
hier oben jetzt, ähm, die
die Status Conf genauer angucken. Wenn ich jetzt natürlich
das hier eingebe, dann mache ich die
auf jedem Server auf, das will ich ja nicht.
Ja, oder zum Beispiel, ich gebe Reboot ein
das will ich garantiert nicht auf jedem Server machen
dann kann ich einfach sagen, Steuerung BZ
ups, Steuerung BZ
dann mache ich das in Fullscreen
was ich bearbeiten will
guck mir, guck mir die Datei hier an
denk mir so, ah, nice, super
Fehler gefunden, sag ich wieder Steuerung
BZ und, ähm
ich bin wieder auf allen Servern da
und das hat er nur auf dem einen gemacht
also, sehr praktisch
und, also, TMAX wäre ein bisschen
was auf der Linux Kommandozeile
macht und, ähm
für jeden, ja
also auch für, ich würde sogar sagen
selbst für Windows
Desktop Entwickler
die normalerweise da nicht so viel
mit zu tun haben, ist
eine ordentliche Shell, eine ordentliche
Kommandozeile mit TMAX eine gute Sache
weil es geht ja heute immer mehr davon
weg, dass man einfach reiner Entwickler ist
oder reiner Admin, selbst als Entwickler hat man
ein bisschen was mit Server zu tun und muss sich da
PSSH drauf verbinden und umgedreht
so, so guck, ihr seht jetzt hier unten
ist weitergelaufen mein Installer
oder mein Installer hier von LXD
sag ich ok, jetzt will er
dass ich ab und zu mal sag, ja schön
bestätigen, alles wunderbar
LXD, äh was, LXD
allow everyone in LXD to talk to LXD
ist mir wurscht
das ist doch vor allem auf meinem Desktop, ist mir doch egal was da
irgendjemand
machen kann, LXD needs
UID, GroupID
for root, so that it can create
unprivileged containers
ich weiß nicht, ob ich mir das
ob ich das machen will
ich werd mir das mal kurz zwischenspeichern
falls ich das später nochmal brauche
das ist jetzt übrigens auch so eine coole Sache
ich könnte mir zum Beispiel jetzt hier ein eigenes
ein eigenes Notiz
Tab aufmachen, da würd
ich dann einfach, wenn ich mir irgendwas notieren will
würd ich einfach dann immer drauf zurückgehen
und es hier reinschreiben
also man kann mit Tmux viel machen
halt je nachdem was man will
das schreibt dann halt nix vor
ja, FlixCoder
das ist wirklich praktisch
so, jetzt wollen wir mal gucken was man jetzt als nächstes machen muss
LXC
check soll ich ausführen, machen wir
ok, alles enabled
dann, ach ja und übrigens
noch was cooles
noch was cooles an LXC
äh äh an, sorry
an Tmux, wenn ich jetzt wieder hier
mal ein paar Panels auf
und
ich hab hier jetzt ein paar Kommandos ausgeführt
so hier oben ein paar Kommandos, da ein paar
Kommandos, hier läuft oben das ASCII
Aquarium, weil es so schön ist
und
ich möchte jetzt zurückscrollen
und ist das normalerweise
immer ein bisschen schwieriger, vor allem wenn man gesplittete
gesplittete
Views hat
ich möchte ja nicht überall zurückscrollen
also ich möchte nicht hier nach oben, geht gar nichts
nicht hier nach oben zurückscrollen, sondern nur
hier in diesem Paint drinnen
und Tmux hat einen eigenen
Scroll Buffer
für jeden dieser, dieser Panels
das ist, das ist wirklich sehr praktisch
äh warte mal kurz, bin sofort wieder am Start
so, übrigens die Uhrzeit ist falsch
fällt mir da gerade auf
so, ähm, hab jetzt den Krempel installiert
nachdem ich jetzt lange hier drum rum gelabert hab
Seba-, der Sebavo ist da
ah wunderbar, endlich ein Mod am Start
ups
das hab ich zugemacht, ganz clever
muss mir echt mal meine Tmux-Config hier draufziehen
äh Sebavo
könntest du, falls du das machen kannst
falls du weißt wie das geht und du das
als Mod machen darfst, kannst du das Ausrufezeichen
Tool grad mal deaktivieren
irgendwie denkt
mein Rechner, es ist Date 20.3
äh
20.3, fuck
20.33, Gott, ich kann ja gar nicht reden
okay
so, jetzt hat er das installiert, wir haben ja auch Check gemacht
sieht alles gut aus
ich kann jetzt hier zurückscrollen ohne dass ich das Terminal dazu bräuchte
alles Tmux
Scrollback Buffer, das sieht gut aus
alles aktiviert
und nun, was soll ich jetzt machen
das ist doch kein Ding
LXC Profile Edit Default
Moment
darf ich das als normaler User überhaupt
ja ich wollte es doch grad sagen, geht doch gar nicht
ähm, danach können wir Container starten
und dann machen wir uns wie gesagt einen Ubuntu Container
einen CentOS Container
ähm, ah Start
ja okay, ich soll starten, also
machen wir mal, ROOT
ROOT werden ist nie verkehrt
Systemctl, Start LXD
bam, Status
LXD, läuft
nice
sehr sehr nice
darf ich das als normaler User, nein darf ich nicht
haha
ich darf das nicht als normaler User
was aber auch okay ist
was aber auch in Ordnung ist
ich pack mich einfach in die LXD Group
Test
bester Username
oder komm
eigentlich brauche ich das nicht
ich kann das auch als ROOT machen
so
jetzt können wir Container starten
LXD List
es läuft nichts, wer hätte das gedacht
und jetzt machen wir mal
jetzt legen wir uns mal ein Ubuntu System an
hat er sogar hier oben als
irgendwo geschrieben
so nach dem Motto, wenn das das erste Mal ist
dass ihr das ausführt, dann probiert es doch mal aus
und es ist damit
mit dem Linux Container ist es super einfach
ihr werdet es jetzt gleich sehen
ich bin hier auf meinem Desktop Manjaro drauf
und ich lege mir jetzt einfach mal
nen Ubuntu 1604 an
auf der ich dann meine
ok was muss ich machen
ok was muss ich machen
config
ich muss anscheinend noch irgendwas ausführen
auch gut
das wäre ja auch zu einfach, wenn das einfach funktioniert
oder Sibaro hat editiert, sehr nice
was muss ich denn machen
no storage pool found
ok
das ist unter Ubuntu standardmäßig konfiguriert
keine Ahnung wie das funktioniert
wir machen jetzt mal
google driven adminning
guck mal was da sagt
no storage pool
gucken wie das funktioniert
was man da machen muss
storage pool list
gibt keine
ja gut, wenn es keine storage pools gibt
kann er auch keine anlegen
ich will kein ZFS, ich will einfach nur
einfach nur storage pool anlegen
lxd init muss ich machen
ah genau das habe ich ganz vergessen
ja genau
da macht er das nämlich alles für ein
ich wusste doch das da noch irgendwas gewesen ist
do you want to configure a new storage pool
yes
name of new pool
default gleich default jawohl
storage backend
btfs, nein directory
wir haben überhaupt kein btfs drauf
wie soll das funktionieren
ähm
btfs ddu was
available over network
ganz ehrlich das ist bei mir lokal im netzwerk
das ist vollkommen egal
no
would you like
image
jup
yes
wir machen das bei allem
yes yes
ok
jetzt funktioniert das ganze wahrscheinlich
launch ubuntu
ja jetzt funktioniert das
es ist egal ob man das jetzt mit lxd macht
mit end spawn macht oder mit ähm
ja meinetwegen sogar mit docker macht
wobei die philosophie hinter docker
ein bisschen anders ist
moin tommy k991
das ist halt super praktisch
ich bin jetzt auf
meiner desktop manjaro vm
und kann mir jetzt ein ubuntu installieren
und da rein wechseln
alter
was haste was hat er denn
was ist
wo ist dein problem lxd ja
bubble lehmann
das ist gut zu wissen
das wollte ich schon immer mal wissen
was hat er für schmerzen
was möchte er mir mit dieser fehlermeldung mitteilen
muss ich muss ich da oh ja da muss ich
kann das sein dass ich noch irgendwas zusätzlich angeben muss
ich will ja ein privilege container starten
ist ja vollkommen okay
eigentlich wollte ich euch jetzt zeichnen wie super simpel das ist
sich
ein container anzulegen
ah das muss man machen ok
und
warum ist das so kompliziert
what the fuck
ok anscheinend muss ich das
den befehl ausführen den wir uns vorhin notiert haben
gut dass wir ihn uns notiert haben
äh und das funktioniert natürlich nur mit root
so wenn man das richtig macht
gehts auch
hab ich da irgendwie
mist kopiert kann das sein
ja ich hab mist kopiert
das muss weg
so wunderbar
und jetzt
muss ich das jetzt restarten
ok und jetzt hoffe ich mal dass es funktioniert
ok
fick dich
was programmierst du heute
ich setze erstmal was auf dass ich was programmieren kann
warum geht denn das nicht
wisst ihr was
wisst ihr was bei allen problemen hilft
prinzipiell bei allen problemen
wenn man probleme hat reboot
reboot geht immer
wenn man nicht weiß was man machen soll
wird einfach reboot und alles ist gut
jetzt gehts
mach mal gucken
äh achso service
hat sich nett gespeichert
ah ne system ist das ja
aaah
nefft mich
was hat er für probleme
warum geht das nicht
das
ich hab da auch so einen kleinen tick
ich muss dann immer raus kriegen was ist das problem
wir könnten ja einfach mit dem anfangen
was wir YT machen wollten
aber das geht nicht
dann rauskriegen, was Sache ist.
Warum
kann ich keine Container starten?
Äh, kann ich machen. Easy.
Hehe.
Wo ist X-Fanboy?
Was soll ich mal ändern?
Moment,
haben wir doch schon.
Haben wir doch schon gemacht.
Haben wir doch schon gemacht.
Warum geht das nicht?
Oh, fuck mich das jetzt ab.
Genau das
haben wir doch hier drin stehen.
Nee, haben wir nicht.
Haben wir nicht.
Haben wir nicht.
Da muss doch LXD irgendwie reingeschrieben werden,
aus welchen Gründen auch immer.
Äh, dann machen wir das doch mal.
Nicht, dass ich eine Ahnung hätte davon,
was ich hier eigentlich jetzt genau mache.
Was war das?
Nicht, dass ich übrigens will.
Zeile kopieren.
J, äh, Y, Y.
Braucht man öfters mal.
So.
Wollen wir jetzt mal gucken, ob das jetzt funktioniert.
Restart.
Nicht Reboot.
Nein, nein.
Restart LXD.
Launch.
Ah.
Äh, wie man auf OBS die Follow-Sachen einbaut.
Nee, das kann ich dir nicht zeigen,
weil da sieht man im Zweifelsfall irgendwelche
ähm,
äh, Dings, Anmeldes, Daten und sowas.
Warum geht mir das nicht?
Das, das regt mich auf.
Ich will, wisst ihr Leute,
ich hab mir jetzt gedacht, wir installieren uns jetzt LXD,
erstellen uns drei Container, easy funktioniert alles.
Wa, warum geht das nicht?
Muss LXD nicht oben in der Config stehen?
Ich glaube, das ist egal.
Ich glaube, das ist egal.
Also ich kann mir nicht vorstellen, dass das irgendwie einen großen Unterschied,
äh, Unterschied macht.
Easy.
Haha, Reboot.
Reboot hat's einfach gekauft, funktioniert.
Das ärgert mich.
Das ärgert mich jetzt, ähm.
Das fuckt mich jetzt richtig ab.
LILUX eats schnell, was machen ist nie was.
Ja, das ist richtig.
Oh, Moment, ich, ich enable mal den Service.
Das ist ja, so.
Das muss ja sein.
Und der LILUX, dann wird das vielleicht heute kein TypeScript-Programming-Stream,
sondern ein Wie-kriege-ich-LXD-zum-laufen-Stream,
aber ist auch okay.
Launch.
Wo, wo ist denn dein Problem, Alter?
Was, was geht da nicht?
Okay, mal gucken, mal gucken, ob uns das,
vielleicht hätten wir einfach mal die, die, die Wiki-Anleitung hier,
durchmachen sollen.
Das haben wir ja schon gemacht.
Alles easy, hat alles wunderbar funktioniert, klappt.
Oh!
Ist das vielleicht das Problem?
Ich glaube, ich glaube nicht, dass es, der wird da, der wird da meckern.
Aha, hier, hier, hier meckert er ja rum.
Okay, bei dem ist das auch alles missing.
This was solved.
Okay, der hat das gleiche Problem, der, okay, der, der Typ hat das gleiche Problem wie ich.
End of threat wird's, wird's gesolved.
Äh, was?
With latest kernel, wir haben, ach so, haben, Moment, was haben wir denn für einen Kernel drauf?
Was haben wir, was haben wir denn für einen Kernel drauf?
Ah, komm, ich install, ich installiere jetzt den Scheiß drauf.
Wir installieren jetzt, äh,
15.
Ach so, geht ja nicht, soll ich vielleicht mal als Root starten?
Wir installieren jetzt den neuesten Linux-Kernel, ist überhaupt kein Ding, easy.
Zack.
Was wurde in der letzten Stunde schon alles besprochen, ja, eigentlich nur, was ich vorhabe,
hab ich mir gedacht, hey, zum Testen installieren wir uns mal drei Linux-Container, easy, überhaupt kein Ding, funktioniert, aber es läuft LXD nicht.
Okay, den Thread, den Bookmarken wir uns mal, den brauchen wir bestimmt noch.
Weil die haben alle das gleiche Problem wie wir.
Der hat genau das gleiche Problem.
Deswegen diese, diese, das, das Arch, äh, das Arch-Linux-Wiki und so ist wirklich, äh, oder Arch-Linux-Wiki ist wirklich praktisch und auch das Forum.
Gucken wir mal, was das hier ausgibt bei uns.
So, als welchen, als welchen User führt dann das Ganze aus?
Hat er installiert, okay.
Haben wir wahrscheinlich, ach, das gibt's bei uns gar nicht.
Okay.
Ähm, da machen wir nochmal das, was die hier in der Anleitung reingeschrieben haben.
Wir, wir sagen nämlich mal, dass unser User, ähm, zur LXD-Gruppe gehört.
Ja, ja.
Okay.
Jetzt rebooten wir mal und, äh, in den, in den neuesten Kabel.
Und zwar in 4.15.
So, und jetzt hoffen wir, dass es funktioniert.
Plus RNG.
Give Energy.
Ich will mal, dass ich loslegen kann.
Machen wir das? Wir machen es mal ohne Sudo.
Hä?
Hä?
100% CPU, lachst du schon mal gut?
Okay.
Mein Container heißt aus irgendwelchen Gründen auch immer, immer Clean Merkel.
Nee.
Clean Makkari, ähm, ich, ich fände, ich fände jetzt Clean Merkel ehrlich gesagt besser.
So, und nachdem ich jetzt 25 beziehungsweise 30 Minuten was anderes gemacht habe, als ich machen will, kann ich jetzt nochmal anfangen.
Im Prinzip ist es übelst einfach, sich Linux-Systeme mit Containern zum Testen zu installieren.
Weil jetzt kann ich einfach sagen, LXD, äh, LXD-List erstmal, übrigens bei der Gelegenheit.
Wir können den, den Mist, den wir eben konfiguriert haben, auch gerade nochmal rausschmeißen, weil den brauchen wir wahrscheinlich gar nicht.
So, jetzt können wir uns anzeigen lassen, was haben wir hier für Container.
Und wir haben hier ein, ein Clean, wir haben hier ein Clean Merkel am Start.
Und, da kann man sich jetzt ziemlich, man kann jetzt sagen, LXC-Exec, oh, ich habe die LXC-Auto-Vervollständigung nicht installiert, ganz schlimm.
Ging das so?
Ja, und jetzt sind wir im Ubuntu-System-Trenner.
Das ist richtig geil.
Das heißt, ich habe jetzt hier meinen Anstellungs-Desktop.
Jetzt haben wir einen Ubuntu am Start und, ähm, wie, wie, wie remove man eigentlich nochmal was?
So, also man kann auf jeden Fall sagen, LX, LXC, Stopp.
Dann macht das aus.
Also das ist quasi ein bisschen was wie eine VM, auch wenn es, auch ich weiß, es ist eigentlich keine VM.
Also das ist ja gerade der Sinn von Container.
Das könnte ja eigentlich keine VM sein.
Ähm, es geht halt super schnell.
Es kostet quasi
Keine Ressourcen so richtig
Und man hat ganz viele Systeme zum ausprobieren
Delete, Clean
Clean
Was ist das für ein Kackname
Kann man das, das müssen wir, das müssen wir
So
Aber
Kann man das nicht umbenennen
Wahrscheinlich kann man das umbenennen irgendwie
Normalerweise
Wie kann man, Moment, wie gibt man da nochmal
Einen Namen an
Wie gibt man da nochmal einen Namen an
Ah hier so, first, genau
Das gibt man einfach hinten dran an
Wie
Wie gibt man, wie macht man
LXC Autocompletion für die Shell an
Das nervt mich nämlich, dass ich das nicht drauf hab
Ich will hier Auto, Autocomplete
Für die
Gut, zumindest, das funktioniert jetzt
Also wir legen uns jetzt einen Ubuntu
Container an
Dann
Legen wir uns einen, was haben die sonst noch
So Linux Container
Was haben die sonst noch so zur Auswahl
Steht denn da was die, was die zur Auswahl haben
Ich glaube die haben nämlich einen Ubuntu
Die haben einen Fedora und die haben
Einen
Ich glaube auch einen Suse und sowas
Alpin Linux
Haben sie hier einen Arch Linux
Haben sie einen CentOS, haben sie
Wir installieren uns einen CentOS 6
Sowas richtig schön altes
Und wenn unser Programm darauf läuft, dann kann ich mir sicher sein
Das funktioniert einfach
Guck mal, die haben mittlerweile sau viel
Das heißt, wenn ich einfach mal
Ich einfach nur testen will, ob meine Software
Darauf ordentlich läuft
Dann ist es die einfachste und simpelste Variante
So installieren wir uns noch einen CentOS
CentOS 6 installieren wir uns
Richtig, richtig alles CentOS 6
Warum heißt es nicht CentOS
Das ist doch total hängengeblieben
Dass es nicht CentOS heißt
Ich mein, das eine heißt Ubuntu
Warum heißt Ubuntu nicht CentOS
Warum?
Aunt, CentOS 6, AMD 64
Ok, muss man das so schreiben?
Ok, muss man das so schreiben?
Ok, muss man das so schreiben?
Ok, muss man das so schreiben?
Das wäre total beschreibt, wenn man Ubuntu so schreiben muss
und das andere so
Hop
Tja
Nicht so einfach wie man sich das denkt
Was ist der Unterschied zwischen einem Container und einer VM?
Eine VM ist quasi ein komplett nachgebauter Rechner aus Sicht
Des Betriebssystems in dieser VM
Also du siehst nicht die echte Grafikkarte, nicht die echte Soundkarte
Gar nichts eigentlich von der echten Hardware
Ja, du kannst ein paar USB-Geräte
durchreichen, das funktioniert.
Bei einem Container
ist es was anderes.
Ein Container ist eigentlich,
da ist nichts drum herum.
Ein Container ist im Endeffekt
einfach nur ein Prozess,
der wie jeder andere
Prozess läuft, bloß dass
ein paar Isolationsschichten
dazwischen sind
im Kernel.
Ah, jetzt funktioniert es. Nein.
Ach, fick dich.
Warum ist das so schwierig?
Warum kann man Kommandos nicht konsistent
machen? Ubuntu
16.04, bam, installiert.
Aber, aber,
aber, CentOS 6,
das funktioniert natürlich nicht.
Das wäre viel zu einfach.
Wenn es kein CentOS 6 gibt,
dann installieren wir uns
ein Fedora, das geht genauso, das ist vollkommen wurscht.
Obwohl es ja hier angezeigt wird.
LXD, yes, yes, bla,
yes.
So, also das ist so der Unterschied,
würde ich sagen, zwischen
So, Fedora, installieren wir uns
ein Fedora 26, ein bisschen was älteres.
Fedora 26.
Was?
Sag mal,
bin ich jetzt bescheuert?
Ich meine, das ist Ubuntu 16.04.
Guck, bam, easy zu installieren.
Ubuntu darf ich installieren,
aber
ein anderes
nicht.
Images, images not found.
Obwohl wir gerade auf dieser Seite drauf sind.
Obwohl es da steht.
Lasse X-Camp schreibt,
ja, ja, darum nutze ich kein Linux mehr,
wegen den dauerhaften Workarounds und so weiter.
War nur noch am Rage am Ende.
Selbst in Ubuntu war es ja schon recht benutzerfreundlich.
Ja, deswegen habe ich keine Donation gekriegt.
Kann das sein, oder war das der Sound?
Ich habe nämlich kein Tippi-Stream auf.
Muss mal gucken.
Ja, man muss halt wissen, worauf man sich einlässt,
vor allem im Desktop-Bereich.
Deswegen empfehle ich auch keinem, oder überrede ich auch keinem,
auf Linux irgendwie umzusteigen.
Also, Donation, tatsächlich.
Easy Clap vom
JustMath, danke, 5 Euro.
Test, Easy Clap.
Poggers, Easy Clap, ja.
Ähm, da habe ich den Faden verloren.
Ja, also ich empfehle das auch keinem,
oder ich versuche auch nicht die Leute dazu zu überreden,
irgendwie auf Linux umzusteigen.
Linux ist für das, was wir hier machen, gut.
Als Entwicklungsumgebung, als
Testgeschichten
für Netzwerke und sonst was.
Ähm, ja.
In LXD,
this image server is reachable through images default remote.
Okay.
Also, das heißt jetzt was?
Vor allem, warum geht das mit Ubuntu und mit CentOS
und Fedora nicht?
Okay, dann machen wir das gleich jetzt nochmal.
Also setzen wir
Image, Image davor.
Nein. Images.
The requested image
could not be found. Wollen die mich verarschen?
Das ist, ich meine, hallo?
Da steht's doch.
Okay.
Wir, wir,
wir suchen uns jetzt mal einfach, wie das funktioniert.
Ich find's ja witzig, ne?
LXD launch Ubuntu easy, kein Ding.
LXD launch Fedora.
Oh.
LXD launch fails.
Ja.
Ja. Könnte man, könnte man so umschreiben.
Ich, okay, okay.
Ah, guck mal, guck mal, guck mal, so.
So schreiben sie es hier.
Also, LXD
launch
CentOS.
Ah.
Okay.
Das ist total, das ist so, das ist so eine typische Sache, wo ich mich bei Linux drüber aufregen könnte, wisst ihr?
Auf der einen Seite, jetzt mal das Schöne, dass wir ein T-Max haben, da kann ich es euch jetzt zeigen.
Auf der einen Seite, Ubuntu hier über LXD zu starten, einfach LXD launch Ubuntu, äh, Version, Name.
Kein Ding. Funktioniert. Ja.
Um jetzt irgendwas anderes zu starten, mit dem gleichen Befehl, ja, also im Prinzip eigentlich kein Unterschied, außer den Namen auszutauschen.
Nein.
Da muss es Images für Dora, äh, da muss es Images CentOS slash 7 slash AMD 64 sein.
Weil, weiß nicht.
Man weiß es nicht, warum das so ist.
Und, hab ich euch schon mal die schlimmste Manpage von allen gezeigt?
Hab ich euch schon mal die schlimmste Manpage von allen, von, von allen gezeigt?
Wo keine Sau versteht, was damit gemeint ist?
Wo mich, wo mich fast gefühlt täglich Leute fragen, was damit gemeint ist, beziehungsweise nicht verstehen, was er genau macht.
So.
Also, wir müssen endlich mal ein CentOS 6 drauf installieren. Jawohl. Funktioniert auch.
Gut. Und jetzt können wir uns nämlich noch, easy clap, jetzt installieren wir uns noch ein, was wollen wir uns noch installieren, ähm, noch nen, ne, richtig krass altes, altes, äh, Debian.
Ihr müsst dazu in den Chat schreiben, nein, ich hab euch das noch nicht erzählt.
Weil, sonst, sonst passt ja meine ganze Überleitung da nicht.
OpenSUSE.
Oracle. Oracle Linux. Bäh.
Wenn man Kotzreflex braucht und JavaScript noch nicht genug ist, macht man, macht, installiert man Oracle Linux.
Okay, komm, wir installieren, wir installieren auch noch ein Fedora 26 und gut ist.
So. Wunderbar.
Also, die ekligste Manpage, um jetzt mal wieder zurückzukommen, die mit Abstand beschissenste Manpage, also Manpage sind so Hilfeseiten, ne, wo dann drinnen steht, wie, wie, wie, wie Befehle funktionieren.
Die meisten davon sind ja auch ganz, ganz nützlich, ja.
Ich kann mir zum Beispiel die Manpage von Man, von, von Manpage aufmachen.
So, Manpageception.
Und da kann ich dann nach irgendwas, irgendwas suchen drin.
Ja, und das funktioniert dann auch.
Die ekligste, die unsinnigste Manpage, wobei, ich glaub, das hab ich euch sogar schon mal gezeigt, ist git push.
Also, allein schon der Titel.
Irgendjemand fragt sich, was macht git push.
Er will sein lokalen, sein lokales Repo irgendwo hinschieben.
Dann macht er die Manpage auf und das erste, was er liest, ist, update remote refs along, äh, was, update remote refs along with, es, es, es, so, es, ich kann nicht mehr.
Ich kann nicht mehr sprechen, ey.
Associated, ähm, objects.
Was?
Und das hier ist der beste Satz.
You can make interesting things happen.
Das ist genau das, was ich wissen will, wenn ich in die Manpage reingucke.
Update remote refs using local refs while sending objects, objects necessary to complete the given refs.
Was zum Teufel macht dieser Befehl?
Was macht dieser Befehl?
Das versteht doch kein Mensch, der diese Manpage liest.
Was das macht.
Ja, hätten die geschrieben, so nach dem Motto, du schiebst damit den letzten lokalen Stand auf den Server.
Dann hätte man das verstanden.
Das macht's ja im Endeffekt auch, ja.
Aber nein, sie schreiben hier irgendwas, wo du erstmal, äh, git studiert haben musst, dass du verstehst, was es, was es macht.
Das ist die schlimmste Manpage.
Und die git, die, die git Manpages, weil das hab ich fast täglich, dass es Probleme gibt mit git push.
Weil die Leute zum Beispiel, ähm, zu faul sind.
Git push remote und, und Branchname zu schreiben.
So, die meisten Leute schreiben nämlich nur git push.
Und das Default-Verhalten ist unterschiedlich, je nach git Version, was git push macht.
Ist echt hängengeblieben.
Okay.
So, jetzt können wir uns nochmal schön angucken, was diese Splits in TMAX bringen.
Ich kann jetzt hier zum Beispiel sagen, äh, LXC List.
Wir haben jetzt hier nen, wir haben jetzt hier laufen nen CentOS, nen Fedora und nen Ubuntu.
Dann kann ich jetzt sagen LXC List.
Dann kann ich jetzt sagen LXC Exec, äh, Fedora Bash zum Beispiel.
So.
Dann bin ich hier oben jetzt auf meinem Fedora Container.
Hier unten machen wir das gleiche für Ubuntu.
Und, äh, ups, hier oben machen wir das gleiche nochmal für, was hatten wir da sonst noch, nen CentOS.
So, und dafür sieht man, wie praktisch diese Splits sind.
Ich hab jetzt im Endeffekt hier meine drei Container auf und kann damit wunderbar dann gleich testen.
Gut.
Kommen wir jetzt mal zum Eigentlichen, was ich eigentlich heute machen wollte.
Und zwar ein bisschen JavaScript beziehungsweise TypeScript basteln.
Wir haben ja nur den ersten Schritt überhaupt erst erledigt.
Ich hab mal nachgeguckt, mit was man am besten TypeScript Linux äh, Development, irgendwie
sowas in der Richtung hab ich gesucht.
Und da hab ich rausgefunden, dass anscheinend der beste Editor mit der, also mit der besten
standardmäßigen Unterstützung für TypeScript ist Visual Studio.
Visual Studio Code.
Code haben wir grad nicht drauf.
Deswegen müssen wir das installieren.
Das hier ist auch noch ein Punkt, warum ich Arch Linux gerne hab, weil der Paketmanager
für äh, 3D-Pakete einfach so simpel ist.
Also da, dagegen kackt einfach YAM und, und ähm, ABT und sowas voll ab.
Einfach rausgesucht, was wir installieren wollen.
Visual Studio Code, Binaries, wir brauchen da keine, wir wollen das nicht selbst kompilieren
oder so.
Lädt da runter, installiert da und ist da und funktioniert.
Bist du jetzt gerade mit den Containern auf deinem Server oder in deiner VM?
Ich verliere den Überblick.
Ich bin heute nur auf meiner VM.
Nur.
Äh, Flixcoder, das, das ist auf Französisch, heißt das Joghurt.
Jaurt.
Oder wie auch immer man.
Wie ich, Leute, die, die Französisch kennen.
Französisch.
Woodface.
Achtung.
Das hören wir uns jetzt mal an.
Das hören wir uns jetzt mal an.
Von LSF.
Habt ihr es gehört?
Wartet mal.
Joghurt.
Joghurt.
Joghurt.
Joghurt.
Joghurt.
Joghurt.
Joghurt.
Joghurt.
Joghurt.
Ja, Joghurt.
Joghurt.
Joghurt.
Ja, Joghurt.
Joghurt.
Joghurt.
Ja, Joghurt.
Ok.
Gut.
Jetzt haben wir auch Französisch gelernt.
So.
Jetzt haben wir, jetzt haben wir auch was für die Allgemeinbildung in Italien.
Ja, aber ich bin heute nur lokal bei mir auf der VM unterwegs.
So.
auf der VM unterwegs.
Visual Studio Code ist immer noch am Runterladen.
Übrigens, wie so oft bei meinen Streams, ich habe jetzt was
zu essen, stehen schon die ganze Zeit und kommen nicht
zum Futtern. Weil der Gelegenheit
fällt mir ein, vielleicht sollten wir mal
die Uhr
richtig stellen, weil es ist nicht 20.37 Uhr.
Kann das sein, dass ich kein NTP
drauf habe und deswegen die Zeit so falsch läuft?
Ich brauche aber eigentlich auch kein
NTP, weil
meine VM
meine VM sollte
eigentlich dafür sorgen,
also, na, VM-Wer sollte eigentlich
dafür sorgen,
dass die Zeit richtig
gestellt wird.
Aber wir können ja mal gucken, ob wir das installieren dürfen.
Wie ist eigentlich der offizielle
Weg, NTP-Zeiten zu setzen
über Systemd? Die haben doch bestimmt irgendwas.
Die haben doch bestimmt
irgendwas.
Systemd-TimeSync-D, natürlich.
Selbstverständlich haben die da was eigenes, was sonst?
Ich setze jetzt, ich lasse
mal über NTP die Zeit.
Oh, der Download ist wahnsinnig schnell.
So, ähm,
ist jetzt Visual Studio installiert?
Äh.
Ah ja, Visual Studio ist installiert. Okay, cool.
Dann können wir es ja mal
starten, würde ich sagen.
Da ist es. Yeah.
Also Visual Studio Code.
Nicht Visual Studio, weil das war unter Linux.
So weit sehen wir aber Microsoft noch nicht.
Auch geil.
Einfach mal, um die Zeit
zu setzen, das ist halt so typisch Linux, ne?
Um die Zeit per NTP zu setzen und ich will
erst mal, erst mal kompilieren.
Wichtig.
Erst mal eine halbe Stunde kompilieren,
dass ich jetzt gleich meine Zeit setzen kann.
Erst mal kompletten NTP sauber kompilieren.
Einfach.
Warum auch immer.
Ich meine, ich hätte ja auch mit Date einfach die Zeit
mal von Hand auf 20 Uhr, äh, auf 18.09.30
setzen können.
Oh, fuck.
Fuck, ich muss es noch mal machen.
Ich hab Enter gedrückt.
Edit, no.
Yes.
Fuck.
Ähm.
Set, Time, NTP,
Systemd.
Gibt's da nix?
Okay.
Äh, Hawks, mal ein wenig off-topic vom Stream.
Aber meine Windows-Datenträger-Verwaltung will eine Festplatte nicht erkennen.
Äh.
Oh, okay, was genau willst du von mir wissen?
Äh, Captain Seekai, hast du, fragt, hast du deine Dot-Files irgendwo?
Findet deine Shell voll nice.
Ähm.
Wir haben hier gar nix gemacht.
Großartig.
Das ist das gleiche Manjaro, was wir vor ein paar Streams zusammen installiert haben.
Ich hab, ich hab nichts großartig.
Ich hab irgendwie so ne, so ne, äh, T-Max-Config draufkopiert, die ich mir, ich glaub, die
hab ich, müsstest du mal im Stream nachgucken, wo ich die herhabe.
Ich glaub, irgendwo von GitHub hab ich mir die runterkopiert.
Und das ist im Prinzip die, die Vollinstallation hier von, von Pretzto.
Dann sieht die Shell so aus, wenn man die, ich hab, wir, wir haben nix großartig konfiguriert.
Äh, ja.
Äh, DE-Pool.
Punkt NTP, Punkt Org.
Bam.
Permission failed.
So.
Gucken wir mal, wie man jetzt die Uhrzeit setzt.
Ich hoffe, das war der richtige Zeit, war das der richtige NTP-Server?
Server!
Yeah, die Uhrzeit stimmt.
So, und jetzt können wir NTP, NTP-Date wieder runterschmeißen.
Perfekt.
Gut.
Jetzt haben wir auch die Uhrzeit gesetzt, nachdem wir mal selbst was zum Uhrzeitsetzen
kompiliert haben.
Das wär ja auch viel, viel zu simpel gewesen.
Gut.
Dann würde ich sagen, machen wir uns mal einen eigenen Ordner.
Oder haben wir hier einen Repos-Ordner?
Ja.
Einen Repo-Ordner bei mir im, ich hab keinen Repos, ne?
Doch, hier Repos.
Warum hab ich eigentlich standardmäßig so bescheuert eingestellt?
So.
Ich will nämlich L haben, dass es mir listet, zwar nicht all und auch nicht nach new, sondern
alphabetisch.
Das ist ja nämlich viel einfacher.
So.
Ah, jetzt sieht man nämlich auch die nicht versteckten Ordner nur.
Da sieht man, ich hab einen Repos-Ordner.
Da sind schon ein paar Sachen drinne.
Da ist auch irgendwas vom Stream drinne.
Was haben wir da das letzte Mal gemacht?
Tolle Script.sh.
Oh, krasses Script.
Beste.
Das ist nicht, das ist es glaube ich nicht wert, für die Nachwelt erhalten zu werden.
Ach, das war unser, nach, ne, das war unser Git, unser Git, äh, wir lernen Git streamen
war das.
Löschen wir den mal.
Ich glaub, das brauchen wir nicht mehr.
So.
Machen wir uns mal ein neues Git-Repo.
Und nun können wir anfangen.
Ähm.
Hast du eigentlich kein Interesse mehr in Overwatch?
Ich hab grad kein Bock auf Overwatch.
Ich hab mir überlegt, ob ich es nicht vielleicht mal wieder ange-, mal wieder geben soll, nachdem
Mercy jetzt genervt wurde.
Was wird das am Ende?
Äh, ich will, um zwar, wie fasse ich das jetzt am besten zusammen?
Ich möchte mit TypeScript ein Programm basteln, also nix großartiges, das darf einfach mal
Hallo Welt oder sowas machen am Anfang und dann gucken, wie ich das am besten zusammenpacken kann,
dass da.
Äh, eine einzige ausführbare Datei rauskommt, die quasi läuft unter allen Linux-Versionen,
unter Windows und unter Mac.
Da hab ich auf der Arbeit einen Anwendungszweck für, gerade.
Ich wollt mal ein bisschen rumprobieren, was es da so für Möglichkeiten gibt.
Jetzt ist natürlich die große Preisfrage, die ich mir so gerade stelle.
Warum mach ich das eigentlich bei mir daheim im Stream und nicht auf der Arbeit, wo ich
Geld dafür krieg?
Hm.
Warum?
Warum?
Wieso ist es so gut, dass ich so gut, ich weiß es nicht so genau.
Wahrscheinlich, weil es mich auch interessiert.
Guck mal, der Nilsson ist da.
Moin.
So.
Ähm.
Fangen wir mal an.
Also.
Als erstes haben wir, haben wir Node.js drauf.
Nein, haben wir nicht.
Da müssen wir erstmal Node.js installieren.
Wie ist denn unter, der beliebteste Weg unter Archilux Node.js zu installieren?
Über Paketmanager oder?
Oder wollen die lieber, dass man es anderweitig installiert?
Install Node.js Package.
Ja.
Dann machen wir das doch mal.
Vier.
Node.js.
Hopp.
So.
Node.
Da ist es.
Console.
Log.
Woodface.
Funktioniert.
NPM.
Funktioniert nicht, weil NPM irgendwie nicht mehr mit gebundled ist mit Node.
Was haben wir auch immer nicht.
Okay.
Installieren wir NPM noch.
Enderboi.
Nice.
So ist das.
So war ich das.
Ist Node.js einfach nur ein JavaScript Interpret?
Ja.
Node.js ist soweit ich weiß, die Chrome V8 Engine aus Chrome ausgebaut.
So im Kern.
Der Node.js Kenner wird wahrscheinlich sagen, Max, so einfach ist es nicht.
Aber was man, eine Sache, die man heute eindeutig bei meinem Stream gesehen hat, ist, die meisten
Sachen sind nicht so einfach, wie sie sich.
Aber wie sie am Anfang aussehen.
Okay.
Ähm.
Ja.
Easy.
Das ist ja kein Ding.
So.
Ähm.
Jetzt ist natürlich die Frage, installiere ich TypeScript über über NPM oder TypeScript
irgendwie über Package Management?
Ich würde sagen, wir installieren TypeScript über.
Über Package Management oder ist noch nicht drauf.
Na gut.
NPM install TypeScript.
Ging doch so, oder?
Ach Quatsch.
Jetzt installiert er das ja im gleichen, im gleichen Ordner.
Moment.
Das will ich doch gar nicht.
Wie mache ich denn das?
Oh, wie funktioniert denn das mit Node?
NPM install TypeScript.
Ne, ne, ne, ne.
Ich weiß, dass es mit minus g geht, aber ich will das nicht mit minus g installieren.
Minus g installiert, ne, ne, will ich nicht.
Minus g installiert es ja auf dem System.
Ich will es ja nur für meinen User installieren.
Wisst ihr was?
Wir installieren es jetzt mal in meinem Heimatverzeichnis und dann fügen wir das einfach, dann fügen
wir einfach mal Node module spin oder wie das heißt.
Fuck, wie macht man das am besten?
Minus u?
Geht das mit minus u?
Hä?
Ich habe es doch gerade installiert.
Probieren wir mal aus.
Ne.
Okay.
NPM install inside home.
How to install local packages.
Das ist doch schön.
Ich habe mal eine kleine Anleitung dazu.
Moment, ich will das nicht in meinem Programmverzeichnis installieren.
Ich möchte das, ich will das quasi global für meinen User installieren.
Kann doch nicht so schwierig sein.
Was hat ein, was hat ein NPM für, für Dinger?
JavaScript Camera, wo seid ihr denn?
Wie funktioniert denn das?
Ich will das nicht global installieren, installieren.
Ich will es einfach nur installieren bei mir lokal im User.
Ich meine, ich habe eine Idee, wie man das machen könnte.
Ich könnte es über den Node package, äh, ich könnte, könnte Node nicht über den Paketmanager
installieren, aber das ist ja bescheuert.
Ja, genau.
Boah, das kann doch nicht sein, das ist so kompliziert.
Das ist.
Ich habe doch vom anderen Rechner das auch so eingestellt, dass es im Heimatverzeichnis
installiert.
Da gibt es eine global, ich will ja global nicht.
Nodes sucht vom aktuellen Ordner den ganzen Tree nach oben, bis es den Node modules Ordner
findet.
Ne, ne, ne.
Das habe ich eben nicht.
Irgendwie war mir anders eingestellt.
Ich, ich weiß, es ist auf meinem anderen Linux Rechner installiert er mir das im Heimatverzeichnis.
Ohne Minus G, ah, ja genau, das, das kenne ich, dass man, dass man Node über den, über
NVM installiert.
NPM ist Default Directory, ah genau, genau, genau.
Okay, ja, ja, genau.
Ich glaube, so, so habe ich das, habe ich das bei mir, anderen Rechner auch gemacht.
Ja, das machen wir gleich, das tragen wir gleich in die, in meine, ein Path ein.
So, und nun sollte das eigentlich funktionieren.
Install, TypeScript, jetzt kann ich es probieren beim Minus G, install, geht das jetzt?
Ja, nice.
Ja, ja, funktioniert, so ist das schön.
Hallo Rastler, Rastia, nein Rastler, Rastler war schon richtig.
Ja.
Ja, aber so funktioniert.
So funktioniert es.
Und jetzt habe ich hier unter NPM Global, ja, wunderbar, genauso will ich das haben, weil
ich habe keinen Bock auf meinem System irgendwie da, wenn ich einfach nur was ausprobieren
will, rumzusauen.
Ja, ist doch komplett dämliches Vorgehen, ist aber so, ja, das denke ich mir bei JavaScript
oft das mal, dass manche Sachen ein bisschen doof sind.
Okay, dann können wir jetzt ja anfangen.
Chapeau.
Ich habe Hunger.
Leute, habt ihr was dagegen, wenn, wenn wir ein, wenn ich ein bisschen Social, Social Eating,
hier, das war, eine Runde Social Eating machen?
Ich habe übelst Hunger.
Ich habe sie direkt neben mir stehen.
Okay, ähm, ich habe jetzt TypeScript installiert, alles gut.
Das heißt, im Endeffekt, als nächstes kann ich wahrscheinlich Visual Studio Code starten.
Machen wir das doch mal.
Code.
Super.
Ist das System eigentlich in einer VM?
Ich sage dazu nur so viel.
Kann man Visual Studio Code auch irgendwie überreden?
Im Open Folder, Repos, Stream.
Okay.
Bam.
Da sind wir.
Welcome.
Piss dich alle.
So.
Dann.
So, wie funktioniert denn das jetzt richtig?
Also, ich gehe mal davon aus, wir müssen einfach eine neue Datei anlegen, eine neue
Datei anlegen, wo wir einfach mal reinschreiben.
Die, die, die speichern wir einfach mal als, ähm, ähm, Main Punkt.
Wie gesagt, Leute, ich habe, ich mache wenig mit JavaScript, vor allem, vor allem Serverseitig.
Äh, ja, also Browser ab und zu mal, aber Serverseitig, beziehungsweise, ja, auf dem Rechner selbst
relativ wenig, Node.js.
Ich habe von JavaScript und TypeScript Best Practice Geschichten, oder wie auch immer
das heißt, überhaupt keine Ahnung.
Und ich will ja auch nichts super komplexes machen.
Wir machen jetzt einfach mal eine Main TypeScript Datei.
Schreiben wir mal rein.
Console.
Okay, es funktioniert schon mal.
Es ist nice.
Es funktioniert schon mal.
Guckt, Leute, es funktioniert schon mal.
Und das ist das Geile, das ist das Geile an, an, an Visual Studio und TypeScript, finde
ich.
Ich habe da, ich habe vor einer Weile da schon mal ein paar, ein paar Videos drüber geguckt,
dass sie sich wirklich, dass sie es geschafft haben, in diesem ganzen JavaScript-Datei,
in diesem ganzen JavaScript-Dschungel, wo, wo man, wo man nie so genau weiß, wie, wie
ruft man was auf und was genau kommt da jetzt eigentlich zurück, dass sie ordentliche Tools
gebaut haben mit, mit Autovervollständigung, dass ich weiß, was muss ich hier angeben und
sowas in der Richtung.
So.
Console.log.
MonkaS.
Gucken wir mal, ob das Ganze funktioniert.
Ähm, na, das funktioniert ja so schon mal, so schon mal nett.
Das ist jetzt ein TypeScript.
Ich muss jetzt erst mal zu JavaScript umgewandelt werden, was ich dann ausführen kann, weil
das ist quasi 1.2.
JavaScript.
Wie geht denn das jetzt?
Wie geht, wie funktioniert das?
Ich habe keine Ahnung.
Äh, Getting Started Visual Studio Code TypeScript.
Hier gibt es bestimmt super Artikel, die auch für mich, für Noobs wie mich, was das angeht,
verständlich sind.
Simples TypeScript Project Using Visual Studio Code.
Das klingt ganz schlecht.
NPM Install Timescript.
Das haben wir schon gemacht.
Configuration.
TSCinit macht man da.
Aha.
War aber TSCinit.
Sprachen, die kein Semikolon am Ende haben.
Äh, TypeScript möchte das.
Wenn ich mich richtig erinnere.
Ich habe, ich habe den, auf der letzten Build-Konferenz vom ehemaligen C-Sharp-Oberguru und jetzt
TypeScript-Oberguru so eine, so ein Intro zu TypeScript gesehen.
Seitdem dachte ich mir, ich muss das mal ausprobieren.
Und, ähm.
Ich habe, ich habe den, auf der letzten Build-Konferenz vom ehemaligen C-Sharp-Oberguru und jetzt
TypeScript-Oberguru so eine, so ein Intro zu TypeScript gesehen.
Seitdem dachte ich mir, ich muss das mal ausprobieren.
Und, wie gesagt, ich habe damit nicht großartig was gemacht.
Und ich wage mich daran zu erinnern, sie sagen, dass sie gerne das Semikolon hätten
am Ende der Zeile.
Allerdings, es ist optional und nur in manchen Fällen wirklich Pflicht.
Okay.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
TSCinit.
Successful.
Successful, das ist immer die beste Ausgabe.
Dann muss ich gerne mal weiter gucken.
Create Sourcecode haben wir schon gemacht.
Hier, denen ja fancy, hier Forcecode.
Wir haben den besten Forcecode aller Zeiten.
...
Okay wie geht's jetzt weiter?
Now we want to set up a convenient build process.
Press Control Shift P.
Control-Shift-P
Dann geht ein Menü auf in Visual Studio Code
Und dann
Configure
Ne, was?
Ach, easy, Default
Ich wollte den Default-Bild-Task machen
Bam
Oder auch nicht
Das stimmt nicht, was da steht
Die Anleitung ist schon wieder outdated
Lul
Ich glaube, das funktioniert
So wie ich mir das gedacht habe
Viel besser
Configure Default-Bild-Task
Watch, dass der im Hintergrund schaut
Ob sich was geändert hat
Und dann haut er mir ein JavaScript-File raus, das ich ausführen kann
So, Bild
TSC not found
Ah, ja natürlich ist
TSC not found
Jetzt ist TSC found
Ja
Easy, funktioniert doch
Wir brauchen überhaupt kein Tutorial
Tutorial braucht es für Noobs
So
Und nun haben wir
Ne
Main.js-Datei
Die wir ausführen können mit Node
Und was kommt raus?
Monk.js
Genauso wie wir das da reingeschrieben haben
So, also nur mal so für mich, dass ich checke, was da jetzt passiert
Ich schreibe jetzt was in Visual Studio Code
Im Hintergrund
Also so
Ich schreibe in Visual Studio Code TypeScript
Im Hintergrund läuft der TypeScript-Compiler
Und
Kompiliert
Mein TypeScript-Compiler
Mein TypeScript-Compiler
Zu
Einfachem
JavaScript
Und
Node
Führt
Das JavaScript dann aus
So weit
So weit
So gut
Jetzt wäre es natürlich cool, wenn ich den Bildtask noch irgendwie überreden könnte
Das automatisch auszuführen
Weil jedes
Jedes mal hier rüber switchen
Übrigens auch mal eine coole Sache hier von
Von Tiling Window Manager
Und wenn man
Sachen mit Tastatur macht
Zum Beispiel
Also mal angenommen
Ich habe jetzt
Hier was geändert
Ich habe das hier gespeichert
Der hat kompiliert
Was er ja hier im Hintergrund macht
Guck und wenn ich hier Mist reinschreibe
Sagt er mir auch
Code Not Compile
So
Jetzt kompiliert er das
Und jetzt will ich
Das ganze ausführen
Jetzt könnte ich mit der Maus hier rüber klicken
Aber nee
Ich drücke hier einfach
Linke
Linke
Linken Pfeil
Eins nach oben
Für aus
Zack
Moin
Kurze Frage
Warum
Wie sieht die JavaScript-Datei aus?
Ich vermute mal
Genauso wie das hier
Weil das ist eins zu eins
Auch JavaScript
Okay
Nein
You strict
Ein bisschen streng
Streng sind wir heute
Bei Microsoft
Bei Microsoft
Wir ganz streng
Wenn man
Wenn man nicht aufpassen kommt
Bill Gates persönlich vorbei
Oder noch schlimmer
Steve Ballmer
Kommt dann vorbei
Und stellt sich
Wenn ich aus dem Bett morgens
Aufstehen will
Nehme mich
Und touch
Developers
Also muss man aufpassen
Heute sind wir
Heute sind wir
Ganz strikt
Bei Microsoft
Also ja
Die Frage
Warum
Ist ein
In
Also ich will
Ich will was basteln
Aber was auch immer
Da genau rauskommt
Aber ich möchte das zusammenpacken
Zu einem
Exekutable
Oder nur eine Datei
Am Ende rauskommt
Was für das
Automatische
Neustart
In des Notches
Prozesses
Kannst du
Notemont
Benutzen
Oder TS
Note
Für das
Direkte
Ausführung
Von TypeScript
In Notches
Also ich hätte gerne
Vielleicht
Ich schreibe hier irgendwas, kompiliere es und er führt es mir hier aus.
Was nehme ich davon dann am besten?
Notemon.
Notemon klingt wie irgendwas, was einfach ausführt, was ich ihm angebe.
Machen wir mal einen Vorschlag.
Oh, noch eine Donation.
Da fuck.
Von.
Das ist Ibarro wieder.
10,51 Euro.
Ich bin selber noch BDO.
So langsam finde ich mich in BDO immer wohler und Crying macht auch Spaß.
Und ich muss mir nur mal die Zeit nehmen, mir meine Daily Login Rewards anzuschauen, was man damit machen kann.
Ja, ich habe auch noch 3 Millionen Daily Login Rewards, Ibarro.
Und das Beste ist ja an BDO, ist der Kreisel Crying.
Warum schreibst du das überhaupt in TypeScript und nicht in JavaScript?
Zum Beispiel, dass ich sowas hier habe.
Ordentliche Autovervollständigung, eine Anzeige von Parametern und sowas.
Ich habe einfach eine unglaubliche Abneigung in JavaScript an sich.
Und...
Deswegen...
Ich wollte auch schon seit einer Weile mal ein bisschen was in TypeScript machen.
Äh, jetzt...
Was wäre da im Skype?
Oh...
Nein, Leute, während man streamt, was?
So.
Äh, ich bin wieder am Start.
So.
Äh, übrigens, noch einmal, was mir gerade einfällt.
Äh, mal ein Beispiel, was ich an JavaScript fragwürdig finde.
Das ist wahrscheinlich ein Beispiel, was, äh, was immer gebracht wird in dem Fall.
Ähm...
Mal angenommen.
Nochmal so, mal...
Ähm...
Zum zeigen, was...
Was JavaScript für komische Dinger macht, ne?
Also, das hier ist jetzt, äh...
Eine JavaScript-Konsole, wo ich Zeug ausführen kann.
Wusstet ihr...
Ich hoffe, ich schreibe das jetzt richtig.
Oder fragen wir mal anders an den Chat.
Was würdet ihr jetzt erwarten, was hier rauskommt?
Was...
Was kommt da raus?
Also, ich meine, die Antwort, das ist ja ein Vergleich.
Die Antwort kann ja nur true oder false sein.
Was...
Was meint ihr, was da rauskommt?
Bei JavaScript.
Ja, jetzt...
Jetzt nicht raten, im Hinblick auf...
Auf...
Okay, ich denke, es kommt das raus, aber es ist JavaScript, es kommt was anderes raus.
So ganz instinktiv.
Was meint ihr, was da rauskommt?
Ich kann euch sagen, dass true oder false rauskommt.
Eigentlich soll da ein Fehler kommen.
Nein, es kommt, es funktioniert.
Wir machen...
Moment, wir...
Das...
Da müssen wir jetzt...
Wir müssen jetzt mal eine Abstimmung machen.
Sorry, Leute.
Äh...
Straw...
Pool.
Oh, da kommt Scheiß drauf.
Also, ich...
Ich glaub's euch.
Also, ich...
Ich...
Ich...
Ich würde mal sagen, die meisten...
Die Mehrheit der Leute...
Die Mehrheit der Leute meint, da kommt false raus.
Richtig.
Das ist aber auch noch relativ verständlich.
Zumindest...
Zumindest könnte ich mir das noch erklären.
Ich...
Das könnte ich mir noch erklären.
Ich könnte sagen, okay...
Das hier ist ein Bool-Typ.
True.
Also, das ist ein Bool-Typ, der jetzt auf true gesetzt ist.
Und ich gucke, ob der equal ist nem String.
Wo einfach nur die...
Die Buchstaben true drinne stehen.
Da kann ich verstehen, dass...
Dass da false rauskommt.
Das ergibt irgendwie...
Das ergibt noch Sinn, ja?
Das verstehe ich.
Aber...
Was meint ihr denn, was da rauskommt?
Also, quasi exakt der gleiche Vergleich.
Bloß, dass wir jetzt...
Ähm...
Nicht mehr fragen, ist true gleich true, sondern ist false gleich true.
Das heißt, es müsste ja von der Logik her jetzt exakt das Gegenteil von dem da oben rauskommen.
Weil wir haben ja den Check einfach nur umgedreht.
Also, sprich...
Wenn true gleich gleich true false ist, ist jetzt die Frage, was ist false gleich gleich true?
Und ich sag's euch...
Es ist auch false!
Warum?
JavaScript!
Warum?
Warum ist das false?
Also, ich...
Beides für sich gesehen könnte ich noch irgendwie verstehen, ja?
Aber beides in Kombination ergibt überhaupt keinen Sinn.
Ist das jetzt schon Timescript oder JavaScript?
Das ist JavaScript.
Weiß nicht, warum ich das nicht verstehe.
Naja, guck mal.
Hier oben...
Das macht überhaupt keinen Sinn.
Hier oben vergleichst du dieses Ding...
Also, das da mit dem da.
So, es kommt als Ergebnis false raus.
Hier unten machst du genau das gleiche, nur dass du die linke Seite änderst.
Von true auf false.
Und da kommt immer noch false raus?
Das ergibt für mich keinen Sinn.
Ja, wenn bool niemals string sein kann, ist die Frage, warum kann man das überhaupt vergleichen?
Da gibt's bestimmt eine super...
Eine super krasse JavaScript-Erklärung für...
Aber ich weiß nicht, wie sie genau ist.
Es ist zumindest in JavaScript viel, viel komplizierter, als man sich das Ganze so vorstellt.
So, jetzt fangen wir aber mal an.
Ja, das Problem ist, Rastler, was ich halt bescheuert finde, ist...
Du machst ja einen Vergleich.
Du sagst, es kann ja bei einem Equal-Vergleich...
Es kann ja nur rauskommen, ja oder nein.
Das heißt, wenn irgendwo nein rauskommt und ich dreh die Bedingungen dann links um von irgendeinem bool-Wert,
dann muss von der Logik her, im umgedrehten Fall, musst du rauskommen.
So bescheuert es jetzt eigentlich in dem Fall auch sein mag, sonst ergibt es ja an sich überhaupt keinen Sinn.
Es ist aber halt nur in JavaScript so, wo das Sinn ergibt.
Wahrscheinlich ist es wirklich so, dass er sagt, die Typen sind nicht gleich.
Allerdings, das stimmt ja auch nicht.
Weil unter...
Unter der Haube führt er das garantiert nicht mit einem bool-Typ und einem String-Typ durch.
Das ist...
Das ist...
Das ist JavaScript.
JavaScript-Zeug.
Übrigens.
Ich hab's...
Ich hab jetzt nur grad nachgeguckt.
Das hab ich mal in...
Das hab ich mal in irgendeinem Vortrag, in irgendeiner Präsentation gesehen.
Noch was...
Noch was Schönes, was in JavaScript...
Was in JavaScript merkwürdig ist.
Fällt mir grad ein.
Da muss ich aber nachgucken.
Warte mal, wie ging das?
Moment, das muss ich mal kurz raussuchen, wie das...
Wie das ging.
Das war ganz, ganz mir.
Da hab ich mich aber kaputt gelacht bei.
Wie ging das nochmal?
Das war...
Das war richtig, richtig bescheuert.
Wie ging das?
Moment, das muss ich mal kurz raussuchen.
Genau.
Ich glaub, das hier war's.
Achso, übrigens.
Quick...
Das ist auch geil.
Quick Maths.
True plus true.
Was kommt da raus?
JavaScript.
Überlegt mal.
True plus true...
True plus true.
Was ist das in JavaScript?
True plus true ist vorhanden.
True plus true ist vorhanden.
True plus true ist vorhanden.
Ja, das wissen wir ja.
Aber was ist true plus true?
Quick Maths.
Also, auf Chat.
Leute, nicht nachgucken.
Es ist zwei.
Ganz klar.
Was sonst?
Warte mal, ich wusste...
Das andere müssen wir uns noch kurz angucken.
Ich find's grad nicht.
Wo ist es denn gewesen?
Achso.
Ich hab's gefunden.
Noch besser.
Noch besser.
Noch mehr Quick...
Quick Maths.
Quick Maths.
Was kommt hier raus?
Achtung.
Ey.
Okay.
Kann ich...
Darf ich das copy-pasten?
Nee, darf ich nicht copy-pasten.
Also.
Hahaha.
Das ist ja geil.
True plus true...
Mal...
Mal true plus true...
Allein schon das das das ein gültiger Ausdruck ist, ist ja schon schlimm.
Minus two...
Drei!
Was sonst?
Easy!
Drei.
Easy clap.
So hab kein Ding.
Ich mein...
Binär ergibt es irgendwie Sinn, ja?
Also quasi...
Zwei.
2 mal 2 ist 4 minus 2 plus, also ne, 4 minus 3, äh, minus, minus 1 ist 3, aber warum ist das erlaubt?
Das ist einfach so, mhm.
So, und ich hab übrigens das andere gefunden, was ich euch noch zeigen wollte.
Wo wir grad bei JavaScript-Bashing sind.
Genau.
Pass int.
Pass int.
Das ist dafür gedacht, dass man, dass man einen String zu, zu Nummern passen kann.
Also, zum Beispiel hier, 32 ergibt 32, ne.
Also, insofern, klar, so.
Ähm, 32 fuck is not a number.
Soweit, soweit sind wir uns einig, oder?
Chat, we, we cool, we cool?
Also, können wir uns auf dieses Ergebnis einigen?
Das Pass int, String 32, 32 ist ein Pass int fuck is not a number.
Okay, aber jetzt kommt das Beste.
Wisst ihr was?
Not a number equals not a number is.
Jetzt, jetzt kommen die JavaScript-Profis raus.
Nach alledem, was ich bisher gesehen hab, würde ich sagen, das ist true.
Also, nach allen Logiken würde ich sagen, das, das, das ist, das ist true.
Weil, ich mein, links ist der gleiche Ausdruck wie rechts.
Und nach der Logik her würde ich jetzt, nach dem, was wir vorher gesehen haben, würde ich sagen, okay.
Es ist true, aber es ist false.
Ich mein, es hätte auch 32 sein können.
Das wäre genauso logisch gewesen.
Nur, äh, ihr wisst, ich, äh, nur mal so als Beispiel, warum ich kein großer JavaScript-Fan bin.
Ja, ja, äh, ich, ich glaub dir, dass, äh, Isoam, äh, ich glaub dir das, wenn man, wenn man sich damit auskennt, ja.
Und sich das im Detail mal alles angeguckt hat.
Ey, das, äh, man, man kann da bestimmt durchsteigen.
Aber es ist nichts sonderlich intuitiv.
Und das ist das, was mich an JavaScript, JavaScript nervt.
Das, ja.
Das Batman-Beispiel kenn ich auch.
Das ist auch geil, das kenn ich.
Das, das, das machen wir gleich nochmal, weil das einer ins, ins, ins Chat geschrieben hat.
Das Beispiel ist auch geil.
Ich darf übrigens aus dem Chat nichts copy-pasten, deswegen muss ich das jetzt nochmal tippen.
Äh, Array 16, Join, Jazz.
Das muss man auch, das muss man auch korrekt immer schreiben, sonst klappt's nämlich immer, ne?
Das ist dann der Zeichen davor.
Batman.
Das ist das beste Beispiel.
Das hab ich auch mal in irgendeinem Stream gesehen.
Das, das ist aber echt geil.
Das hab ich mal in irgendeiner, in irgendeiner Präsentation gesehen.
Okay.
Nur, aber.
Wo sind wir denn stehen geblieben?
Ich muss was essen.
Doch, ich muss was essen.
Okay.
Ähm, was wollte ich denn eigentlich jetzt noch machen?
Genau, das.
Ich wollte das ausprobieren.
Was ich eigentlich vorhatte.
Und zwar unser wahnsinnig hochkomplexes, ähm, Console.log.mong.ks.
In ein eigenes Programm verpacken.
Aber vorher machen wir das, unsere Mong.ks Programm noch ein bisschen,
ein bisschen schöner.
Und zwar gucken wir mal, wie wir Konsolenfarben, äh, Node.js, Console.colors,
eher Konsolenfarben machen.
Okay, es gibt was, das nennt sich Colors, das klingt schonmal gut.
Ja genau, sowas, sowas wollen wir machen.
Sowas ist top.
npm install colors.
Minus g, muss man jetzt natürlich machen.
Colors.
Colors.
Easy.
So.
Äh, äh, wie macht man das jetzt?
Moment, wie, wie macht man das in TypeScript?
Fuck, wie macht man das in TypeScript?
Wie, wie, wie include ich Sachen?
Import.
Okay.
Namespace and modules.
Import.
Import.
Import.
Und dann require, oder was?
Also sag ich so quasi.
Import.
Colors.
Colors.
Gleich.
Require.
Ah.
Ah ja.
Colors.
Findet er nicht.
Warum findet er das nicht?
Findet er nicht.
Ich hab's aber noch installiert.
Wo ist das Problem?
Also ich mein, äh, Node selbst findet es ja noch nicht mal.
Warum, JavaScript Kenner, warum findet, warum findet mein Node das Modul nicht?
Machen wir's mal so.
Hä?
Jetzt findet er es?
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Jetzt findet er es, oder was?
Weil's false ist?
Jetzt hat er, jetzt hat er hier noch nen Node Module Ordner.
Ach der sucht da garnicht drinnen oder wie?
Ja klar, der sucht ja in meinem NPM.
NPM global sucht er ja überhaupt nicht drinnen.
Jaja ist logisch, der, der sucht ja überhaupt nicht.
I-cend diesem Ordner nach, nach Modulen.
Ok das, ok passt, leucht, leuchtet ein.
Er sucht nur in nicht versteckten Ordern, die
Node-Modules heißen.
Das ist gut.
Habe ich jetzt installiert. Gut, das ist...
Okay. Ah, da findet es immer noch nicht.
Allerdings, allerdings.
Mein Node findet es doch jetzt, oder?
Mein Node findet es.
Node findet es.
Import... Import...
Was mache ich jetzt? Verkehrt?
Was? Import xy
from x...
What? Restart.
Ja, Restart hilft bestimmt.
Ach, ich kann da gar nichts aus mit Chat.
Also, was? Import...
Colors...
Ja, was denn? Sternchen? Geht sowas?
Hä? Could not find
module colors.
Ich mache den Editor jetzt mal zu und wieder auf.
Lull. Ach ja, fuck.
Jetzt muss ich ja hier nochmal starten.
Ah, jetzt erkennt er es. Okay.
Was auch immer da rumgespackt hat, aber jetzt erkennt er es.
Und jetzt meckert er.
Could not find
a declaration file for module colors.
Okay.
Er findet es jetzt.
Alles klar.
Äh, ich muss jetzt allerdings
Type-Definitionen installieren.
Und das kann ich ja wohl einfach damit machen.
Findet er es jetzt?
Was hat er denn für Schmerzen?
Kann doch nicht sein, dass ich...
Kann doch nicht sein, dass ich da
jedes Mal den Editor rein starten muss, oder?
Das kann doch nicht Sinn und Zweck da...
Ach, ne! Moment.
Ich, ich... Das ist falsch.
Dann mache ich das jetzt nochmal so, wie ich es ursprünglich gemacht habe.
Colors gleich.
Require.
Das ist ja allein schon eine Wissenschaft für sich, was...
Ja, funktioniert. Sehr schön.
Hat funktioniert.
So, wie schreiben die denn eigentlich mal
TypeScript, die man das macht?
Ja.
Der macht das genauso.
Wahrscheinlich gibt es da wieder 20 Varianten, das zu machen.
Ich meine, das ist ja unter der Haube immer noch JavaScript.
Ja.
Gäbe ich dir recht, so ein Minhego.
Warum muss das so kompliziert sein?
Ich glaube, auch meine Notes,
sind nicht die besten.
Somit, dass es im Heimatverzeichnis liegt, oder sonst was.
Hast du den Stay-Hydrated-Bot aktiviert?
Nein, was ist das?
Den Stay-Hydrated-Bot
habe ich nicht aktiviert.
Das ist wahrscheinlich ein Bot,
der rumspammt irgendwo.
Und nervt.
Jaja, ich habe es gesehen.
Ne, ne, habe ich nicht aktiviert.
Der geht wahrscheinlich einfach mal in Channels rein und
spammt.
So.
Ähm.
Ist das jetzt Visual Studio Code?
Sieht fast aus wie Brackets.
Ja, das ist Visual Studio Code.
So, wie verwendet man dieses Colors-Ding jetzt eigentlich?
Colors.
Okay, das ist einfach.
Oder so.
Ja, das ist, das ist simpel.
Also sage ich dir so was wie Colors.
Punkt.
Das ist halt das Geile an Types.
Amerika.
Kennt ihr eine Farbe, die Amerika heißt?
Also ich meine,
Schwarz, Blue, Zyran, Green, Magenta, Red, White.
Sagt mir alles was.
Aber was zum Teufel ist die Farbe Amerika?
Das probieren wir jetzt mal aus.
Colors.
Bold.
America.
Bin ich mal gespannt, was da für eine Ausgabe kommt.
Hat er das jetzt kompiliert?
Soll ich den dann?
Ne, solange das nur einmal schreibt, ist mir das recht.
Okay.
Ach ja, sorry, falls ich es vorhin überlesen habe.
Äh.
Irgendjemand hat, hat, hat, hat was geschrieben.
Wie man das, wie man das automatisch ausführen kann, die Node-Programme.
Das habe ich nicht gesehen.
Aber wahrscheinlich ist derjenige auch weg, weil ich jetzt erst mal so krass über Javascript die ganze Zeit abgeflammt bin.
Also falls, falls derjenige noch da ist, würde mich das mal interessieren, wie das jetzt genau funktioniert hat.
Funktionieren würde.
Mit automatisch ausführen.
Okay, gucken wir mal, wie Amerika aussieht.
Ach, mit NodeMon, genau.
Also meins in NodeMon sollte es werden.
Main.js
Hm, habe ich das falsch gemacht?
Muss ich, muss ich so, muss ich nur Amerika machen?
Machen wir mal nur so.
Bäm, Amerikaschrift.
Hahaha, was ist das für ein Schwachsinn.
Kann ich wenigstens so sagen?
Bold, so rum jetzt? Geht das?
Das ist ja hässlich.
Wie kann ich denn das bold machen?
Bold funktioniert?
Wie, wie kann ich denn bold und, und ne Farbe?
Zusammen machen?
Das muss doch funktionieren.
Das muss doch, das muss doch gehen.
Ich muss doch sagen können, bold, guck mal, macht der hier noch auch.
Bold und in grün, zum Beispiel.
Okay.
Bold.
Punkt.
Green.
Geht doch. Okay, warum geht das mit Amerika nicht?
Ist verbuggt.
Ich würde mal sagen, es ist verbuggt.
Guck mal.
Green.
Easy clap.
Amerika, kaputt.
Weil?
Wahrscheinlich, weil JavaScript oder so.
Es funktioniert. Amerika ist verbuggt.
Es geht mit bold nicht.
Bold und Amerika zusammen, nope.
Aber Amerika alleine funktioniert.
Da bin ich ja froh.
Okay, das probier ich jetzt mal aus.
Also, du installierst Notemon über NPM.
Und dann führst du statt
Notemon Scriptname aus.
Gut, das ist ja einfach.
Hat das jetzt so schnell installiert, oder was?
Ach nee.
Ich hab install vergessen.
Lol, alter, lol.
Jetzt sag ich einfach Notemon main.js.
Oh, das ist ja richtig nice.
Übrigens, wir müssen mal unsere Anordnung ein bisschen optimieren.
So, ist das besser?
Das Terminal hier unten machen wir auch mal weg.
So, jetzt sehen wir nämlich ein bisschen mehr.
So.
Hallo?
Oh, nice, das funktioniert.
Das ist schick.
Das ist echt sehr, sehr schick.
Ich kann das,
theoretisch könnte man den Scheiß hier auch mal ausblenden.
Oh, eh keiner.
Oh, das ist nice.
Das gefällt mir gut.
Das hat jetzt
fast schon Visual Studio
Komfort.
Wobei,
das ist voll durch die Brust ins Auge.
Muss man sich jetzt mal überlegen.
Hier oben läuft im Hintergrund ein TypeScript Demon,
der dann mein TypeScript zu Node.js
übersetzt.
Und dann läuft ein File System Watcher,
der guckt, ob main.js aus dem
TypeScript Compiler wieder neu ausgekotzt wird,
um dann festzustellen,
es hat sich geändert und muss jetzt wieder neu ausgeführt werden.
Passt zu JavaScript.
So,
America, also
bold, bold, red.
Bam, funktioniert.
Nice, sehr nice, sehr nice.
So, und jetzt bin ich mal gespannt.
Ich würde jetzt gerne
mal einen
HTTP, das will ich nämlich noch ausprobieren.
Wir machen zwei Sachen.
Wir importieren ein Modul.
Wir geben
irgendwas doofes auf der Kommandozeile
aus in
America Color, weil es geht.
Das Feature finde ich irgendwie witzig.
Und jetzt,
weil das brauche ich für mein
Tool,
jetzt probieren wir mal ein HTTP GET
zu machen.
Ich habe noch nie in Node.js
ein HTTP GET
gemacht.
Moin, Papa, Keks live.
Ist ein guter Name.
Also FetzenSQL,
ich muss sagen, das Setup hier gefällt mir richtig
gut jetzt, ja.
Das finde ich sehr, sehr
nice.
Nicer, nicer.
So.
Node.js HTTP GET.
Kann ja nicht so schwierig sein.
Ich meine, Node.js,
das ist ja
geboren worden für HTTP
Zeugs.
Wie macht man hier ein GET?
GET Header? Nein, Response.
HTTP GET.
What? Moment.
Okay, das ist nur ein Beispiel.
Ich wollte gerade sagen,
es kann doch nicht sein, dass ich
das hier machen muss, um eine Webseite
abzurufen. Beziehungsweise
ein GET.
Was machen die da überhaupt?
Moment.
Was passiert
da eigentlich? HTTP GET.
Das ist die URL. Das verstehe ich noch
soweit. Wir machen genau
das gleiche hier jetzt.
Genau, das rufen wir jetzt mal ab, testweise
in unserem Programm. HTTP GET.
Node.js Org.
Okay, probieren wir das mal aus. Also, wahrscheinlich
müssen wir dann sagen, import
http gleich require
http
Geht nicht.
Doch funktioniert.
Fuck, wie blende ich jetzt die
Konsole wieder ein?
Nope. Da ist das Terminal wieder.
Kann man das nicht links?
Ja, so. Da. Da ist gut.
Da will ich das andocken.
Could not find module http
What?
Das ist Standardlib.
Das ist eingebaut.
Oh Gott, JavaScript. Ey, das
require
http
Geht.
Kein Ding. Could not find
module http. Ja.
Warum nicht?
Okay.
Google
ups.
Could not find
module http. Warum kann man
kein Standard?
npm install types
node
Wir machen
Das ist das wahre Stack Overflow Driven
Programming, was wir hier betreiben.
repos
stream
Da wollen wir hin.
npm install types
node
Ja, und das ist auch das Schöne an so einem
Tiling Window Manager.
Windows-Taste F, Vollbild.
So, mal gucken, ob es jetzt funktioniert.
Could not find module http.
Warum erkennt
er die Scheiße denn nicht?
Ich wette mit euch, wenn ich den Editor neu starte,
ist
alles gut. Es funktioniert wieder.
100 pro.
Das muss ich noch mal ein bisschen
überarbeiten. Das ist nervig.
Ja, jetzt funktioniert es.
LOL.
Gerade ist das beknackt.
Okay, was wird gerade programmiert?
Ich versuche mich an
Typescript
und
also erstens habe ich da nicht großartige Ahnung von
und zweitens versuche ich jetzt mal
einen http get
zu machen. Und nachdem
ich es geschafft habe, einen http get
zu machen, dann
möchte ich daraus
eine Anwendung bauen
komplett
in einer Datei. Also komplett
self-contained.
Und das ist auch
der Grund, warum ich auch was in Node.js mache.
Mal ausprobieren
wie das ist und weil ich einen Anwendungszweck
dafür habe auf der Arbeit.
Gibt es
Gibt es Abkürzungen für
log? Ah, nice.
Log. Test.
Macht er das jetzt?
Natürlich nicht.
Also ich meine
wer könnte ja auch
damit rechnen, dass in
JavaScript ein http get
auf diese url
jetzt etwa den Text
der Seite anzeigt.
Ne, ne, ne.
Das ist das Ergebnis von JavaScript.
Das ist ein JavaScript-Objekt
was ich zurückkriege und gibt es da drin
irgendwie ein Body oder sowas wenigstens?
Stimmt.
Ja, ja, Siburi hat recht. Das ist wahrscheinlich
asynchron alles.
Deswegen...
Ich will das aber gar nicht asynchron machen. Gibt es da nicht eine
synchrone Variante von?
Weil ich kann eh nicht weitermachen.
Also ich kann nicht weitermachen,
wenn ich das nicht hab.
Und ich kann in der Zwischenzeit auch nichts machen.
Wie Body
oder so.
Okay, wir haben jetzt das Beispiel hier.
Okay, du brauchst eine Funktion, die dann
den...
What?
Okay, okay, okay, okay, okay.
Also, also, also.
Okay, okay.
Das probieren wir jetzt mal aus.
Wir machen das wieder hier unten und die Ausgaben
machen wir mal, machen wir wieder
links hin und ein bisschen
kleiner, dass ich was sehe.
Die Sidebar brauchen wir eigentlich überhaupt nicht.
So. Okay.
Ähm.
Die Schrift ist ein bisschen groß.
Bäh.
Bäh.
Das ist doch genauso, wie es da steht.
Hä?
Das war doch genau das Beispiel.
So, jetzt machen wir hier einfach
wieder zu.
Ah, ne. Ha, die
abschließende Klammer fehlt.
Es funktioniert.
App crasht. Bäm.
Perfekt.
Also, weil
test not, das ist richtig.
Okay.
Das klappt.
Okay. So.
So, dann würde ich jetzt mal irgendwas mit 200 erwarten.
What?
Warum ist der Exit Code
sowas hier?
Ach, ne, Moment. Status Code
brauche ich ja auch.
Nicht Exit, nicht Reset.
Hallo? Ausführen, please.
Hat funktioniert.
Hat funktioniert. Okay, Exit Code
200.
Das ist geil an TypeScript, dass du
für dieses, für dieses normalerweise
antypisierte JavaScript Zeug jetzt, ähm,
sagen wir jetzt, Headers, Body.
Gibt's da sowas wie Body? Das gibt's natürlich nicht.
Das wäre jetzt ja auch viel zu simpel.
Okay, ich krieg schon mal,
ich krieg schon mal den Exit Code. Wie kann ich denn jetzt,
wie kann ich jetzt den Inhalt
lesen?
Kompliziert, da könnte man es nicht machen. Ich weiß, sorry
Leute, JavaScript Flame, aber
Kompliz...
Da könnte ich das ja auch in Rust programmieren.
Das ist eh nicht kompliziert gewesen.
Moment, das ist irgendwas Eventbasiertes.
Nein, nein, nein, nein. Patrick, das ist nicht einfach.
Content. Das wäre viel zu einfach.
Kannst du nicht .NET Core nehmen?
Doch, das war meine erste Idee,
.NET Core zu nehmen.
Aber .NET Core krieg ich nicht komplett
selfcontained hin. Das hat immer noch
ein paar Abhängigkeiten.
Okay, das heißt, ich muss hier dieses komische,
ähm...
Boah, ich muss das,
ich muss das selbst,
ich muss mir das selbst zusammenbauen?
Ich mein, ich hab
an sich keine Schmerzen mit, dass das geht.
Ja?
Das ist schön, wenn das ein Stream ist,
aber ich will das doch einfach nur benutzen.
Ich will jetzt da keine High-Super-Performance-Geschichten machen
oder es nicht woanders hin streamen.
Ich will einfach nur den Text.
Was die Node.js Standard
Standardlib ist ziemlich low level.
Ich merk's grad.
Am einfachsten ist eine Library zu nutzen
wie Axios. Axios kenn ich.
Das hab ich schon mal verwendet. Ha, das kenn ich.
Sagt mir sogar was.
Das hat auf GitHub irgendwie, keine Ahnung,
9000, äh, Sterne oder so.
Äh, okay, sorry.
30.000, knapp vorbei, ist auch daneben.
Was ist das für eine Linux-Distribution?
Das ist Manjaro Linux.
Das ist ein Arch-Linux mit besserem Installer.
Axios. Axios kenn ich.
Und, ähm,
ich hab sogar gesehen,
das hat schon TypeScript-Sachen
dabei und sowas.
TypeScript...
Nice. Nice.
Ja, easy. So, so genau.
Sowas will ich das haben. So einfach.
Okay.
Ach so, ja.
Jetzt muss ich erst mal installieren.
Ähm, ja.
NPM...
NPM install
Axios.
Includes TypeScript definition.
Nice.
Hey.
Ähm, ach so, get.
Ah, es funktioniert anscheinend.
Also, irgendwas ist an meinem
Node-Setup noch failing.
Das merk ich daran, dass ich meinen Editor
neu starten muss, dass ich überhaupt
Module installieren muss.
Dass er mir erkennt, dass ich
Module installiert hab. Da stimmt was nicht.
Das muss ich mir in Ruhe mal angucken.
Aber das müssen wir jetzt nicht machen.
Ja, so ist das nice. Das gefällt mir.
Axios get.
So, und da machen wir jetzt quasi das gleiche,
was wir hier auch gemacht haben.
Getten wir mal den da.
Den getten wir.
Hallo? Ach so.
Ich hab das Compiler nicht gestartet.
Okay, das ist schon mal ohne Fehler.
Swing zurück.
Swing.
Okay.
Im Prinzip scheint das, glaub ich, gewesen zu sein.
Äh, bis bald.
Macht man das überhaupt noch mit var?
Ich hab jetzt total oft let gelesen und sowas.
Was ist der Unterschied?
Var ist Global Scope, let ist Local Scope
oder wie ist das?
Mal so an die JavaScript-Pros.
Okay, es funktioniert fast.
Ah, Moment.
Moment. Oh, wir können jetzt den richtig
krassen C-Sharp-Style machen.
Oder auch nicht.
Passt, passt.
Ich hab gedacht, es funktioniert vielleicht.
Ah, okay, das muss man in der Function machen.
Okay.
Das...
Warum auch immer, aber...
Das leuchtet irgendwo zumindest noch so halbwegs ein.
Ja, gut, das ist ja in C-Sharp auch so,
dass der Wait nur in Async geht.
Das leuchtet ein.
Deswegen sind sie jetzt auch alle so happy,
dass man Async Main machen kann in C-Sharp.
Okay, mal angenommen, ich möchte das
ohne.
Ohne Await machen.
Dann sage ich jetzt hier Get.
Then.
Brauche ich dann immer noch so eine
komische Funktion,
die aufgerufen wird, wenn es fertig ist?
Ich will jetzt erst mal gucken,
wie macht man das jetzt?
Wie ruft man da jetzt einfach den Inhalt der Seite ab?
Okay, ja, okay.
Man muss so eine
Geschichte machen anscheinend.
Das ist ja nicht so wild.
Zweites Beispiel von oben.
Ja, so was.
Die macht einfach Punkt, Punkt, Then und dann schreibt er
Ja, das leuchtet ein.
Das leuchtet ein, dass man das
so machen muss.
Dann brauchen wir dieses Result auch nicht.
Sondern so.
Ha! Funktioniert!
Das ist schick.
So.
Jetzt kann ich das doch bestimmt parsen.
Response.
Gibt das jetzt wenigstens direkt
Text zurück?
Kann ich das nicht direkt parsen?
Warum nicht?
Response-Data willst du? Aha.
Das kann gut sein, dass ich das will.
Nein, das will ich nicht.
Was hat er denn?
Unexpected Token?
What?
Oder ist Data schon
chasen?
Moment.
Ist Data schon chasen
geparst?
Kann das sein?
Ist das schon?
Also kann ich jetzt
quasi first.
Geht sowas?
Hat das sowas?
Ne. Stimmt.
Ich könnte noch setzen.
Ja.
Den Typ von Data sieht man nicht.
Das ist natürlich auch ganz dolle.
Das ist bestimmt viel einfacher
als ich mir das jetzt vorstelle.
Ja, da stand sowas. Warte mal.
Automatic transforms
for chasen data.
Chasen default.
Data ist schon chasen.
Also jetzt kann ich mir
das erste Element ausgeben.
Funktioniert. Das ist ja einfach.
Ist viel einfacher als ich mir das vorgestellt habe.
Ich kann jetzt wahrscheinlich einfach sagen
Response-Data. Gibt es da sowas wie
Type oder so?
Gucken wir mal. Status.
Status ist 200.
Status Text.
Okay.
So.
In Headers müsste ich jetzt ja sehen,
was es für ein Type ist.
Wie Content-Type
oder sowas.
Content-Type Application Chasen.
Jawohl. Ja genau. So ist das doch.
Das ist doch sehr schick.
Gut. Das ist das, was ich haben will.
Oh, MrFryGuy.
Auf leeren Magen so eine Frage
jetzt zu beantworten. Da muss ich mir
echt mal ein bisschen näher Gedanken drüber machen.
Aber da kann ich mal in einem
der nächsten Streams drauf eingehen.
Das ist so deep wieder. Diskussion jetzt.
Ne. Da muss ich mir
erstmal ein bisschen Gedanken drüber machen.
Ich schreib mir dazu mal was auf.
Da kann ich in dem nächsten Stream was dazu erzählen.
Auf nüchternem Magen bin ich grad so
unkreativ,
mir da Gedanken drüber zu machen.
Okay.
Was ist ein sehr gutes
CMS für das Erstellen seiner eigenen Internetseite?
Keine Ahnung.
Habe ich nicht wirklich viel mit zu tun.
Und ich muss mich zum Glück...
Ich musste mich früher mal um ein paar Wordpress-Sachen kümmern.
Also rein Linux-Betriebssystem
seitig.
Dann habe ich mich um ein anderes gekümmert.
Da war ich auch sehr froh drum.
Was ich empfehlen kann.
Doch, mir fällt eine Empfehlung ein.
Was ich empfehlen kann ist ein statischer
ist ein Seitengenerator, kein CMS.
Also CMS
in Form von Wordpress, wo du quasi online
irgendwas verwalten kannst.
Nehm dir irgendwie einen statischen Seitengenerator,
wo du dann quasi lokal
deine Sachen erstellst. Lässt die Seiten durch
diesen Generator laufen und lädst es dann hoch.
Das hat den riesen Vorteil,
also je nachdem,
wieviel dynamische Sachen
und was du mit der Seite machen willst.
Das hat den riesen Vorteil,
es ist absolut nullanfällig gegen
irgendwelche Sicherheitslücken.
Wenn du quasi alles, was du haben willst,
bei dir lokal generierst,
mit so einem Seitengenerator.
Wie heißt denn der?
Da gibt es den Python, den ganz bekannten.
Ich komme gerade nicht drauf, wie der heißt.
Gibt es ein paar.
Gibt es ein paar.
Wie hieß das Zeug überhaupt so?
Ich glaube, der hier ist relativ bekannt.
Ja, also musst du dich mal schlau machen
in der Richtung, das ist wirklich praktisch.
Da erstellst du einfach lokal
die Seiten, wie du es haben willst.
Lässt es durch den Generator laufen
und dann kommen statische Seiten
am Ende raus, die lädst du hoch.
Das hat halt einen riesen Vorteil.
Genau, Jekyll ist es, den meinte ich.
Aber es gibt noch mehr, es gab es ja noch nie.
Ghost oder sowas.
Ghost, Block oder irgendwie sowas.
Ne, das war was anderes.
Das, wobei, das ist doch auch sowas.
Das war doch auch was,
was statische Seiten generiert.
Wenn ich da jetzt nicht komplett falsch liege.
Ah, keine Ahnung.
Musst du dich mal schlau machen,
das ist auf jeden Fall echt praktisch.
Du hast überhaupt keine Sicherheitsprobleme.
Bei Wordpress hätte ich immer die Bedenken,
dass da irgendwas nicht richtig funktioniert
und Leute,
ok, Ghost ist sowas wie Wordpress.
Ne, ne dann.
Dann ist Mist, was ich erzählt habe.
Irgendwie hatte ich das im Hinterkopf noch.
Aber musst mal gucken, was es
an der Sachen gibt, so statische
Seitengeneratoren, das ist super.
Wenn du was kleines machen willst, ist das ganz toll.
Und selbst allgemein, wenn du was
alleine machen willst, mit hauptsächlich statischem
Content, also im Backend
wohlgemerkt, ne. Das Javascript
kannst du immer noch tolle Dinger machen.
Dann hast du nicht das Problem, dass du da
anfällig wärst für irgendwelche PHP,
Wordpress, sonst was, Sicherheitslücken.
Sondern, dass statische Seiten,
mit ein bisschen Javascript drauf,
da kann dir nix passieren auf Serverseite.
I
Bayden
i?
Oder wahrscheinlich einfach nur Bayden
und das ii ist, weil es damals cool war,
einfach i's drumherum zu haben.
Sagt, würde mich mal
über ein i3 Setup Video von dir freuen.
Ich benutze i3 jetzt schon seit ein paar Jahren,
auch mit Qt, aber so richtig nett
sieht's leider nicht aus bei mir.
Wir haben diese VM hier, haben wir zusammen
in einem Livestream eingerichtet.
Zusammen i3 installiert
und die Standard-Configs draufgemacht.
Da ist nicht viel dran angepasst.
Musst du mal gucken
in den Worts, ob's diesen
diese Aufzeichnung noch gibt.
Wenn's die nicht mehr gibt,
fällt mir jetzt auch nix ein.
Wir haben nicht viel dran gemacht.
Also wir haben i3 installiert, ein paar Farbschemen
und paar Config-Dateien
draufgezogen.
Ja, Sibaro, kenn ich.
Mittlerweile würde ich allerdings sagen,
ich würde es eher auf .NET Core setzen,
anstatt auf Mono. Mono würde ich nur verwenden,
wenn ich Cross-Plattform irgendwelche GUI-Sachen
in C-Sharp machen will. Und selbst dann
würde ich eher gucken,
dass ich entweder den GUI-Teil mit Qt mache,
da muss halt immer sauer ein Apfel C++ beißen,
oder
ne Browser-GUI mache
oder Elektron oder sowas.
Oder gucke, dass Avalonia
irgendwann mal was taugt, was ja auch auf .NET Core
funktioniert. Okay.
So, und jetzt kann ich aber eigentlich das probieren,
was ich die ganze Zeit probieren wollte.
Ich werde daraus jetzt mal mit diesem komischen Tool,
was ich da gefunden habe, eine Anwendung
zusammenbasteln, die komplett
self-contained ist, quasi, um es mal jetzt
mit Windows ausdrücken
zu sagen, eine einfache Echse.
Wobei, das darf man unter
Linux nicht sagen.
So, jetzt gucken wir uns mal, wie das compiled
JavaScript aussieht.
Hässlich wie die Nacht sieht es aus,
aber es ist halt JavaScript. Vor allem
transpiled der JavaScript sieht nochmal
eine Nummer schlimmer aus als echter JavaScript.
Sibaro, wie hast du
so schnell meinen Stream da hochgeladen?
WTF?
Wie hast du das so schnell gemacht?
Das ist ja krass.
Unterhosentroll fragt, kannst du mal kurz
erklären, was ich genau tue, was du genau tust?
Also, wir haben
ein paar Container aufgesetzt am Anfang
und
jetzt probiere ich, habe ich gerade
ein bisschen TypeScript ausprobiert.
So, ganz billig Zeugs.
Nichts großartiges.
Oder vielleicht weißt du, ich bin nicht so der große JavaScript
Pro.
Jetzt versuche ich daraus eine einzelne Anwendung
zu packagen lassen
mit diesem Tool, was ich hier gefunden habe.
Weil
ich habe da nämlich
einen Anwendungszweck für.
Ich habe auf der Arbeit ein Tool programmiert
vor eineinhalb Jahren oder so.
Das ist das Lull-Tool.
Das heißt wirklich so.
Das habe ich so genannt, weil ich das lustig fand
und irgendwie auf der Arbeit kaum einer weiß,
was damit gemeint ist.
Und das habe ich in der Programmiersprache geschrieben,
auf die ich absolut keinen Bock mehr habe.
Deswegen will ich das jetzt neu machen
in einer anderen Sprache.
Ich habe zwar auch nicht großartig Bock auf JavaScript,
aber ich kann mit JavaScript
wenigstens wahrscheinlich,
das will ich jetzt ausprobieren, eine Anwendung basteln,
die alles enthält, was sie braucht
und einfach auf jedem Linux, auf jedem Windows läuft.
Was ich mit Rust
auch konnte,
das alte Programm war in Rust programmiert,
da konnte ich auch mit 4,5 MB
self-contained
executable
bauen.
Was auf jedem Linux lief,
die Node.js Anwendung wird jetzt ein bisschen
größer sein, gehe ich mal von aus.
Dafür kann
ich es in JavaScript machen.
Es ist zwar nicht so, dass ich ultra Bock auf
JavaScript hätte, aber ich habe gar keinen Bock auf Rust.
Rust ist nicht schlecht.
Das Witzige ist,
Rust ist nicht eine Sprache, wo ich sagen würde,
die ist scheiße,
so wie JavaScript.
Rust ist eine Sprache,
die versucht dich
zu Recht die ganze Zeit zu nerven.
Das ist das Konzept hinter
Rust. Rust versucht dich die ganze Zeit zu nerven
und die ganze Zeit zu sagen, wenn du etwas
unsicheres machst. Und ihr könnt euch
nicht vorstellen, man macht permanent etwas
unsicheres.
Rust ist gut. Rust ist eine super Sprache.
Aber für so einfache,
für so simple Anwendungen, so nach dem Motto, hier
lass mal von ein paar Seiten was
abrufen und generiere daraus eine Konsolenausgabe,
ist es einfach zu umständlich.
Da versuche ich jetzt mal, ich beiße mal,
ein Apfel und bastle eine Node.js
Anwendung,
packe die zusammen und
gut ist.
Übrigens an die Leute,
weil ich gerade sehe, ich kriege hier ein paar
Follows. Normalerweise, ich mache öfters mal
Programmier-Streams oder irgendwelche
Linux-Streams oder sonst was, aber
ich mache so, ich würde
sagen, in letzter Zeit war es eher so
50-50. Also so 50
Prozent irgendwas Programmieren,
Linux-Technik-Kram und
50 Prozent irgendwelche
Gaming-Geschichten. Also nur, dass ihr das wisst.
Ich mache nicht nur Programmier-Kram.
Und hauptsächlich bin ich
auch gar nicht auf Twitch aktiv, sondern auf YouTube.
Twitch ist für mich eigentlich
eher komplett Entspannung, deswegen
habe ich hier auch, ich kündige die
Sachen nirgendswo großartig an.
Ich habe mich auch
noch null um
Affiliate, Sub oder irgendwas
gekümmert. Brauche ich nicht.
Ich mache das hier wirklich komplett zur Entspannung.
Okay.
Package.
Wie funktioniert der jetzt?
npm install package. Das ist einfach, das kriege ich hin.
Oh, ganz wichtig,
wir müssen ein git commit machen.
Ich gehe mal davon aus, dass man das da
wahrscheinlich nicht adden sollte
in git.
Wie ist code?
Das sollte man wahrscheinlich nicht adden.
Da nehme ich keinen Bock, um jetzt eine git exclude zu machen.
Machen wir einfach mal add
tsconfig.
Brauchen wir das? Ja, das brauchen wir wahrscheinlich auch.
git commit
damit
Ich kann da mal schreiben.
a-m
Okay, jetzt haben wir committed.
Ist zwar nicht wirklich notwendig gewesen,
aber gehört sich so.
So, npm install
package. Haben wir.
Okay, pkg.
Entry file.
Ja gut, entry file.
Okay, wie sind denn die Optionen
von diesem Tool?
Hallo, Mausrad.
Okay, achso.
Einfach die Datei angeben.
Okay, das ist einfach.
main.js
Bam.
Guckt, und das finde ich halt,
das ist geil an dem Ding.
Deswegen wollte ich das auch mal ausprobieren.
Der baut
hier standardmäßig jetzt die Anwendung
zusammen als single
file self-contained executable
für Linux, für Mac und für Windows.
Das heißt, wir haben jetzt für
alle gängigen, ich gehe mal davon aus,
für BSD und so kann er auch.
Ja.
BSD, Linux, Mac, Windows.
Für ARM-Plattformen,
für x86,
x64, also alles, was man braucht.
Und man
hat jetzt quasi für jedes
Betriebssystem, was man so braucht,
unsere super
dolle Anwendung,
die im Endeffekt eine Seite abruft und was ausgibt.
So, dann probieren wir mal aus,
ob das funktioniert. Main Linux.
Bam.
Geht. Nice.
Main MacOS werden wir wahrscheinlich nicht ausführen
können. Falsches Format. Und Windows werden wir auch nicht
ausführen können, weil
ja, weil halt nicht Linux-Format.
Aber das ist gut.
Das ist richtig krass, dass das funktioniert.
Das ist echt geil.
Das ist genau das, was ich brauche. So, und wie groß ist der Kram
denn jetzt im Endeffekt?
430 MB.
Ich meine, das ist schon
viel, wenn man sich überlegt,
dass die Anwendung im Endeffekt nichts macht.
Ja. Allerdings,
wenn man sich überlegt, dass da eine komplette
Node.js-Runtime drinsteckt,
dafür geht's eigentlich wieder.
So, ähm, wie groß ist denn die,
gucken wir mal, wie groß die anderen sind.
Windows-Anwendung ist die kleinste.
Leuchtet auch irgendwo ein.
Bei Windows kann man sich wohl am meisten drauf verlassen,
dass gewisse Sachen einfach
vorhanden sind, weil sie
halt bei jeder Windows-Installation da sind.
Und es nicht 3000 verschiedene Sachen gibt.
Okay, ich würd sagen.
Also, wir sehen jetzt schon mal, dass es funktioniert.
Unter Linux. Das ist schon mal
ganz toll.
Jetzt probieren wir das erstmal, bevor wir es unter
Windows ausprobieren, probieren wir es nochmal
unter anderen Linux-Distributionen
aus. Also, wir wissen jetzt, dass es unter
dem aktuellen Arch-Linux
funktioniert, das Ganze.
So.
Wie komm ich eigentlich per SSH da drauf? Gar nicht.
Wie kopier ich denn jetzt überhaupt was auf meine
Container?
Kann ich mich auf den Host-SSH connecten?
Achso. Ne, ich kann mich nicht
SSH connecten, weil ich schlicht und ergreifend
kein SSH installiert habe.
Ich hab wahrscheinlich einfach kein SSH laufen.
Mühen wir das mal aus.
Ah, jaja.
Ups.
Fuck. Why? Warum?
Darf man da nicht auf den Host zugreifen?
Installieren wir das mal im Container.
Wie heißt denn das SSH-Package?
Wir machen das erstmal unter
im Ubuntu-Container. Da weiß ich, wie man
SSH installiert.
Ist schon installiert?
Okay.
Systemctl start sshd
Das müsste eigentlich funktionieren.
Ich mein, ich kann's
ja auch anpingen.
Ah, geht doch. Geht doch.
Hab ich keinen Account hier drauf.
Das müsste doch eigentlich auch in die andere Richtung gehen.
Also quasi.
Ach, ne. Ha, ich weiß, warum's dann
funktioniert hat.
Was ist denn mein Host?
Das da? Ja.
Ja, geht doch. Easy.
Easy clap.
Ich kann mich jetzt hier nämlich einfach
auf meinen Host verbinden.
Als Test.
Mit meinem
highly secure password.
Und kann's mir rüberkopieren.
SCP. Das ganze
liegt unter Repos.
Ah, keine Ahnung. Verfolgung.
Stream. Wo liegt der Kram?
Main Linux.
Main Linux.
What?
Achso. Ja.
Okay. Jetzt bin ich mal gespannt, ob das funktioniert.
Main Linux.
Bäm! Das ist so geil!
Dass das einfach klappt.
Sehr nice. Sehr nice. Gefällt mir.
Okay, unter Ubuntu funktioniert der Shit, schau mal.
Wir kopieren uns jetzt grad mal das SCP,
dass ich das dann jedes Mal wieder machen muss.
Okay, dann
probieren wir das Ganze jetzt mal unter CentOS aus.
Das ist ein uralt CentOS 6.
Das ist steinalt.
Oh, ich hab mir das falsche kopiert.
Was hier, Baro? Was ist denn?
Hab ich was übersehen?
Main Linux. Bäm!
Geht...
Leute, ist euch mal aufgefallen, wie schnell das geht?
Unter dem uralt CentOS 6
läuft es mit Abstand am schnellsten.
Ich weiß nicht genau warum.
Ach nee, ich glaub, der Sau hat einfach nur schnell geantwortet.
Wenn du willst, kann ich die Streams
seit September 2017 als Archivseite
aufbereiten mit Titel und Embedded Stream.
Auf welcher Seite?
Jetzt auf Twitch, oder?
Stimmt!
Theoretisch könnte man den Krempel als Wort auf Twitch
wieder zur Verfügung stellen.
Oder irgendwo anders.
Mach ich mir mal Gedanken drüber, Baro.
So, okay.
Auf dem CentOS funktioniert es jetzt auch.
Das ist geil, das ist echt geil.
So, dann machen wir den letzten Test.
Wir gehen mal auf ein Fedora-System drauf
und kopieren uns das Gleiche.
Gucken, ob es funktioniert.
Aber wenn es unter dem uralt CentOS funktioniert hat,
wird es da auch funktionieren.
Okay, es fehlt irgendeine
wahrscheinlich ziemlich
irgendeine Standard-Lib,
die nicht so ziemlich überall drauf ist.
Bloß auf irgendeinem Fedora nicht.
Was natürlich ziemlich räudig ist,
wenn das sogar auf dem CentOS 6 funktioniert.
Aber was man daran
schön sieht ist,
es hat sich jetzt gelohnt,
dass wir uns vorher angeguckt haben,
wie man ein paar Container macht,
zum Testen.
Weil ich meine, der Hauptzweck der ganzen Sache ist ja,
dass es auf unterschiedlichen
Betriebssystemen läuft.
Und jetzt wissen wir schon mal, so tut es unter Fedora nicht.
Wahrscheinlich muss ich
jetzt einfach nur irgendwie den Krempel hier installieren
unter Fedora und gut ist.
Ach ne, ist er nicht.
DNF jetzt, wir sind hier unter Fedora.
Ah, Version.
Version 7.
Deswegen geht das Ganze nicht.
Der will Version 6,
allerdings die haben Version 7.
Das war übrigens einer der Gründe,
falls derjenige von ganz am Anfang noch da ist,
warum ich
keine dynamisch gelinkte C++-Anwendung
machen wollte.
Aber ich glaube,
jetzt funktioniert es.
Dann war das eher ein Bug vorhin, oder?
Weil ich meine, es ist Version 7,
was auch immer.
Oder war die einfach nicht installiert?
Die war einfach nicht drauf.
Fedora hat standardmäßig keine
C++-Standard-Library drauf.
Das habe ich auch noch nicht gesehen.
Aber es ist halt sehr raw.
Sogar CentOS hat das drauf.
Fuck.
Na gut,
wenn es denn Fedora ist mit
irgendwas mehr als
Standard-Installation, dann ist das auch
dort drauf. Definitiv.
So, und jetzt kommt der große
Knackpunkt. Meint ihr,
es funktioniert auch unter Windows?
Ich meine, ich habe hier meine Windows-Echse.
Warum steht denn kein
File-Manager drauf?
Ich brauche mal einen File-Manager,
dass ich ordentlich Dreck enttrocknen kann.
Meint ihr, es funktioniert unter Windows?
Werden wir jetzt gleich sehen.
Nein, ich habe keine File-Manager-Tools.
Warum habe ich keine
File-Manager-Tools?
Oh, ich habe OBS kaputt gemacht.
Ich habe es zerstört.
Ich habe OBS da drauf
Dreck enttrocknet.
Ich denke auch, dass es ohne Probleme
funktionieren wird. Ich muss es nur
erstmal auf Windows draufkriegen.
Wir können es bei Windows einfach
per SSH hier drauf verbinden.
Hallo? Ach, ja, ifconfig gibt es da nicht.
Bei IP-Ads ist es halt gut.
Da haben wir noch eine ordentliche
Windows-Shell. Da zahlt es sich mal wieder
auch eine ordentliche Windows-Shell zu haben.
Es hat gerade gelaggt.
War anscheinend zu advanced,
dass ich die jetzt aufgemacht habe.
Ich kann doch nicht copy-pasten?
Zwischen der VM
und meinem Windows.
Da habe ich noch irgendwas nicht installiert,
VM-Tools-mäßig, dass es nicht funktioniert.
Naja, VM-Tools an sich
habe ich installiert, sonst würde das Resizing
hier nicht richtig funktionieren.
Aber
was habe ich vergessen?
Muss man nicht irgendeine hässliche
GTK-Library installieren?
Muss man nicht irgendeine hässliche
GTK-Library installieren?
Das kann ich mich vom letzten Stream
noch daran erinnern.
Man musste irgendeine ganz, ganz
fragwürdige GTK-Version installieren,
dass es funktioniert.
Es gibt keinen Installer.
Das sind die Open-Tools,
die einfach da sind.
Wenn man alles richtig installiert hat.
Was war denn das nochmal?
Ich muss mich an die
ersten Streams erinnern.
Man musste so eine doofe,
was nirgendwo stand,
was wir auch erst nach 5 Stunden rausgekriegt haben,
das letzte Mal,
irgendeine komische GTK-Library installieren.
Ist das irgendwie so?
Ja.
Ah, die haben wir installiert.
Okay, die haben wir installiert.
Kann das sein, dass das einfach nur rumbackt?
Ich weiß es nicht. Mir ist auch egal.
Wir kopieren das jetzt mal per SSH.
Reinstallieren?
Nein.
Reinstallieren will ich die VMWare-Tools
jetzt eigentlich nicht.
Wie gesagt, das sind nicht die normalen
VMWare-Tools, die du wahrscheinlich kennst
mit dem Installer und so.
Das sind die aus dem Paketmanager.
Ich kann es mal reinstallen.
Ich glaube nicht, dass es was bringt.
Ich SSH mir das jetzt einfach rüber.
Ich habe hier, was habe ich für eine IP
gekriegt bei einer VM?
167.
Oh, das ist so schnell unter Windows hier.
Das ist der Windows Defender,
der da im Hintergrund was guckt.
Okay, Test.
Ja.
Oh!
Meine Windows-Konsole hat Probleme damit.
Der mag die Farben und das Zeug nicht.
Okay, SCP
von
repos
slash stream
slash main-win
exe hieß das Ding, oder?
Ja, ja. Punkt.
Ja, funktioniert.
So, jetzt bin ich mal gespannt, ob das unter Windows
funktioniert. Jetzt probieren wir es erstmal hier drinnen auszuführen,
ob das funktioniert. Geht. Easy.
Genau das war
Sprache im Endeffekt.
Auf jedem
System läuft es. Das einzige, wo es nicht
gelaufen ist, ist auf einem
absoluten Mini installierten Fedora,
wo irgendeine 10++
Standard-Library nicht dabei ist.
Ähm.
Damit kann ich aber leben.
Ich meine, die Leute, die bei uns Fedora
arbeiten, die haben das als Desktop-Betriebssystem
und auf dem Desktop-Fedora
ist definitiv die Standard-C++-Library
dabei. Aber
hundertprozentig.
Vielleicht hat er sogar irgendwie was
hier.
Ah, nee, es heißt libstd
C++. Muss er richtig rummachen.
Gucken, ob die vielleicht sogar
da irgendwas stehen haben auf
ihrer Seite, dass das schon mal
einer geschrieben hat, dass es bei
manchen Betriebssystemen nicht funktioniert.
Aber da kann ich mitleben. Das ist dann nur
wirklich fast überall drauf.
Ja, das ist gut. Das funktioniert.
Ja, schick.
Schick. Was will dieser
komische Hydrated-Bot eigentlich?
Den, den hab ich nicht, den
hab ich nicht hier invited.
Wenn ich da nachher auf Google such, spammt
der auch noch in anderen Channels rum.
Ähm. Weiß nicht, wo der herkommt.
Ist das, ist das vielleicht
irgendwas vom Night-Bot oder so?
Oder hat das irgendeiner meiner Mods
da lustig, wobei es hat doch eigentlich gar keiner
Rechte irgendwelche.
Braucht man, wie läuft das eigentlich auf Twitch?
Braucht man irgendwelche Rechte, um Bots in den Channel zu holen?
Oder wie, wie funktioniert das?
Also, ich mein, klar,
beim Night-Bot weiß ich, da musste ich das anklicken.
Aber, ich mein, theoretisch könnte jeder
nen Bot programmieren, der will.
Ja, wenn man nach diesem
Bot sucht, findet man auch viele, die sich drüber aufregen.
Dass irgendwelche random Bots
unterwegs sind.
Ja, das ist ja beknackt.
Piss dich, Alde. Weg ist er.
Ja, ich muss sagen,
das war doch relativ erfolgreich. Das war's mit den
anderen.
Ich hab mich ein bisschen ärgert, dass das
auf dem Fedora
standardmäßig nicht lief.
Allerdings, ich mein,
ich glaub, man wird kein Fedora-System
finden, wo die Standard-Lib
fehlt.
Wir können es ja nochmal ausprobieren.
Wir machen Stop Fedora.
Wir machen nochmal ein Fedora.
Wir haben nämlich vorher nen
26 angelegt.
Legen wir mal nen 27 an.
Gucken wir mal, wie's da ist.
Wie findet ihr eigentlich...
Find ich echt schick, ne?
Am Ende vom Lilux-Einrichtungs-Stream
haben wir das ja gemacht.
Wie findet ihr eigentlich die Leiste hier oben?
Ich find die extrem stylisch, muss ich ehrlich sagen.
Ich find die extrem stylisch.
Man sieht ja auch,
die wird teilweise rot,
wenn man CPU-Last verursacht.
Also wenn man jetzt zum Beispiel irgendwie macht,
keine Ahnung, hoch
irgendwas nach BC.
Ich hab BC nicht drauf.
What?
What?
What face?
Da hab ich kein BC drauf.
So, wenn ich ein bisschen CPU-Auslastung generiere
jetzt, dann sieht man auch,
das verändert sich sogar grafisch, ne?
Das ist richtig geil.
Das ist richtig geil.
Die i3-Configs gibt's nicht auf GitHub, weil
wir haben, wie gesagt,
das haben wir alles zusammen im Stream gemacht.
Hier ist nichts großartig custom.
Das einzige, was wir gemacht haben, ist
die Gaps zwischen den Fenstern
angepasst auf 5 Pixel.
Und ansonsten,
das ist quasi 1 zu 1
die Standard-Config
bis auf das
ein Chrome am Anfang gestartet wird.
Es ist nichts dran
im Endeffekt.
Das haben wir alles im Stream gemacht.
Ist das Bumblebee-Status? Nein, das ist
i3-Rust-Status.
Sibaro,
was ist denn
FinFisher?
Wie auch immer.
Was ist das für eine Uhr?
Das probier ich jetzt noch schnell,
ob ich noch einen Fedora 27,
ob es da ähnliche Probleme gibt.
Wenn nicht, war das vielleicht einfach nur ein Bug.
exec
fedorabash etc redhead-release
es27
ups
scp
Scheiße.
Leute,
meine Frage an euch, die auch öfters mit Linux arbeiten.
Nervt es euch auch, dass es i3-Config nicht
mehr standardmäßig gibt? Ich habe mir über Jahre
so sehr angewöhnt, if-Config
einzugeben für die Netzwerk-Config,
da ich mir das ganz schwierig nur noch abgewöhnen kann.
Das ist wirklich nervig.
repo
stream
main
Okay,
das ist aber anscheinend irgendein Bug in
Fedora, keine Ahnung,
26, was wir installiert haben gewesen.
Deswegen sind Container
eine richtig geile Sache.
Man kann einfach mal so ausprobieren, total schnell,
unter anderem unter anderen
Linux-Betriebssystemen.
Ja, ich könnte ein if-config-alias
machen, oder, ich meine, ich könnte auch einfach
ich könnte auch
einfach if-config installieren.
Ich weiß gar nicht, in welchem Paket das drin
steckt. Ja, genau,
net-tools-package.
Wenn ich das reinhau, habe ich mal wieder if-config.
Ich meine, das ist ja nicht so, dass es groß wäre, irgendwie
120 KB oder so.
Guck, bam, if-config am Start.
Wie sieht man mit dnf, ob was installiert ist
oder nicht. Alter, Leute, ich muss jetzt gleich los machen.
Ich habe mega Hunger, das Essen steht die ganze Zeit eh bei mir.
Wie kann ich mit dnf checken,
dnf
search
status, ist das installed?
Nein.
Ich kann doch einfach machen.
Scheint installiert zu sein.
Ja, ist eine gute Frage.
Das kann nicht euer
Ernst sein, oder?
Das ist so mega...
Also, RPM-Paketverwaltung finde ich so
übertrieben
umständlich.
Okay, anscheinend ist bei Fedora
27
die C++-Shared-Library
dabei.
Und bei...
Und bei Fedora 26 ist sie nicht dabei?
Okay.
Tatsächlich.
Okay, auch gut
Fedora.
Aber kann ich mitleben?
Wenn es quasi nur bei einem
nackten Fedora 26 Probleme gibt.
Und wenn es überall läuft,
wunderbar, passt.
GG, easy.
So, Leute.
Wollt ihr noch
irgendwas Linux-technisches wissen?
Oder irgendwie was, was sich
an Fragen ergeben hat?
Dann können wir
das jetzt noch kurz...
Guck mal, es wird sogar rot, wenn ich das Ding
voll auslaste. Geil, oder?
Poggers!
Man sieht sogar Upload und Download.
Guck mal, wir machen jetzt mal einen Speedtest.
Wobei, da kackt der...
Da kackt wahrscheinlich der
Stream jetzt ab.
Wir machen jetzt mal einen Speedtest.
Und man sieht hier so richtig, guckt, dass er oben
aktualisiert sich sogar. Bäm.
10M. Down.
Gleich kommt der Upload-Test, dann laggt der Stream.
Achtung. Upload-Test.
Bäm. 3M.
4,4M.
Bäm.
Stream laggt.
So, Stream hat hoffentlich fertig gelaggt.
Also,
das stimmt nicht so ganz.
Also, wenn ich das jetzt ein paar Mal
probieren würde, der Durchschnitt wäre irgendwie so
37 oder so. Und irgendwie
ein paar 90. Aber damit kann ich leben.
Ich weiß, dass es laggt. Das war lagg mit
Ankündigung.
Oh, ja.
Was kennst du das Linux-Programm, das
RR-RF macht?
Das ist ja langweilig.
Es hat mal auf der Arbeit einer, das kann ich jetzt mal kurz zeigen,
der hat sich irgendwo was
copy-pasted.
Das war auch sowas nach dem Motto
rm
bla bla bla
slash bla bla bla
slash bla bla
und irgendwie war in dem
Dokument, wo er das raus copy-pasted
hat, ich mein,
das kann auch nur
bei den krassen Business-Leuten
passieren, dass man quasi
Shell-Befehle über den Ticketsystem,
über den PDF an andere Leute
verschickt, die es dann raus copy-pasten und einfach
Enter drücken.
Ist halt so.
Und da ist irgendwie
irgendwie so war das, glaub ich. Und da ist dann hinter
ist, weil hier ein Zeilenumbruch war, ist in dem
PDF, was er copy-pasted hat,
ein Leerzeichen gelandet.
Und da war halt ein bisschen mehr.
Wahrscheinlich war es ja noch, wahrscheinlich war es noch sowas,
ne?
So, und da hat er das System kaputt gemacht, weil er
falsch copy-pasted hat.
Jebaited.
Der Serious Maxx PDF und copy-pasten,
nicht nur PDF,
es hat irgendjemand in der Shell das quasi
ausprobiert, muss man sich mal vorstellen, ne?
Es hat jemand in der Shell ausprobiert,
dann hat er das,
dann hat er das
raus copy-pasted
wahrscheinlich in
wahrscheinlich
über Skype
oder über
irgendwas anderes, ja,
an irgendjemand, der dann
ein PDF draus gemacht hat,
das PDF
wurde an ein Ticket angehängt
und derjenige, der das bearbeitet hat,
ist dann in das Ticket rein, hat das PDF
geöffnet und den Befehl aus
dem PDF copy-pasted,
ihn sich nicht angeguckt und
Enter gedrückt. Das ist schon
sowas von Fail, der ganze Ablauf.
Ja,
fällt mir eigentlich nix mehr dazu ein.
Jetzt könnte man sagen, wenn man so einfach gedacht
könnte man sagen, der Typ, der Enter gedrückt hat, ist
dran schuld, aber der Typ, der
Enter gedrückt hat, ist genauso dran schuld, wie
alle anderen auf dem Weg dieser Kette auch.
Weil du kannst, man kann sich nicht immer
damit rausreden, der Typ, der Enter drückt, ist dran schuld.
Weil der Typ, der Enter drückt, der drückt
verdammt oft am Tag Enter.
Und da kann auch mal was durchrutschen.
Das muss von vornherein vermieden werden,
dass so ein Kacke, Kacke passiert, ja.
Nehmt einfach die Leute mal ein bisschen mitdenken.
Ähm, ja, das bezüglich
Screen mit Handy abfotografieren
hatten wir auch jemand, der hat das gerne gemacht.
Der hat gerne, der hat gerne
Screenshots von
Hausnamen gemacht und hat sie dann rumgeschickt.
Und hat gesagt, dieser Server bitte
blablabla ...
bis ihm ... bis, bis ihr dann mal
irgendjemand in
ins Ticket kopiert hat.
Das hab' ich gesehen, hat irgendjemand
was ... da hat dir dann irgendjemand
ins Ticket kopiert, halt mit dem Typ dahinter.
Irgendwie so ...
NE Moment nicht das, nicht das, ähm,
Warndorstsnot, das da
das ist ja der gleiche Typ.
Hat ihm irgendjemand
ins Ticket rein kopiert so nach dem Motto,
does not simply
copy-paste images, oder irgendwie sowas.
Eigentlich total unlustig, ja, gebe ich zu.
Aber ich glaube, das hat er
dazu, glaube ich, nicht so ganz verstanden.
Wenn auf der Arbeit gememt wird,
weißt du, du bist richtig.
Mich nervt es ein bisschen, muss ich sagen,
dass ich nicht mehr so viel
selbst programmieren kann, beziehungsweise
nicht mehr, oder,
können schon, aber
gerade nicht muss,
beziehungsweise
selbst nur noch so wenig
im Vergleich zu früher technische Sachen
mache. Sowas wie, was wir heute
hier gemacht haben, zum Beispiel,
das geht mir auf der Arbeit ein bisschen auf den Keks.
Das mache ich mir, ehrlich gesagt, am liebsten.
So irgendwelche anderen Sachen ist jetzt
gar nicht so. Wenn du dir
quasi um eine Zeile,
die du tippst, mehr
Gedanken machen musst, als
um was du da tippst, dann
stimmt irgendwas nicht.
Eigentlich sollte man sich da hauptsächlich Gedanken drüber machen,
dass man da was Gutes,
sich was Gutes ausdenkt, und nicht noch
...
... Riesenaufwand drumherum.
Klingt nach meinem Büro. Ja, das ist, glaube ich, überall so.
Überall bei den krassen
Business-Läden
ist das so, wo halt dann
krasses Business gemacht wird.
Nach irgendwelchen
Qualitätsstandards und
Dingern, die ja an sich
nicht schlecht sind.
Sagt ja keiner dafür, sagt ja keiner,
dass sowas unsinnig wäre.
Es wäre manchmal
nur von Vorteil,
das habe ich jetzt auch schon öfters beobachtet,
dass das eben nicht passiert.
Es wäre manchmal von Vorteil, wenn man
sich solche komischen Abläufe ausdenkt,
beim Ausdenken die Leute fragt,
die sie am Ende machen müssen.
Das hätte seine Vorteile.
Dann ist es manchmal auch nicht so komplett
an der Realität vorbei.
So, ich muss mir mehr aufschreiben.
Was aufschreiben? Video? Warte mal.
So, Leute. Ich werde jetzt
mein Abendessen futtern. Wir sind fertig.
Hat eigentlich gut funktioniert heute.
Also,
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
Wir haben öfters mal irgendwelche super krassen Qualitäts, ähm,
Qualitäts-Best-Practice-Konsulten-Typen da,
die sich geil finden.
Und da kommt dann auch immer irgendwas raus.
Und am Ende wird es dann trotzdem nicht gemacht.
Obwohl ja da auch die ein oder anderen sinnvollen Sachen dabei sind.
Da will ich da gar nichts gegen sagen.
Gut, ich werde jetzt was futtern.
Ich hoffe euch hat das Stream gefallen.
Weil, ich meine im Prinzip,
Außer, dass es auf Fedora nicht richtig lief, auf Fedora 26, war das sehr erfolgreich.
Ich glaube, ich werde mein neues Lull-Tool nicht mehr in Rust, sondern in JavaScript, in TypeScript auf Node.js-Basis programmieren.
So, also Leute, macht's gut, bis zum nächsten Mal, tschüss.
