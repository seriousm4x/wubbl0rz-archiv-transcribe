Hallo, warum nicht früher?
Das ist die genauere Frage, wie warum nicht später.
Wahrscheinlich sind die meisten gerade auf dem Heimweg.
Ich kann dir sagen, warum nicht früher.
Weil ich früher keinen Bock hatte.
Kannst du mal mitbekommen, kannst du mal noch ins Wort gucken.
Ansonsten gibt es ja noch mehr.
Oh Mann, mir tut das Bein weh, Leute.
Was es heute zum Mittagessen gab?
Nudeln mit Lachs?
Ne, es gab keinen Nudeln mit Lachs.
Es gab, oh ja, ja, Leute, furchtbar gesund, furchtbar gesund gab es heute zum Mittagessen.
Mozzarella Sticks und Pommes Frites.
Highly, highly, äh, Bio Pommes Frites und Mozzarella Sticks.
Aber kurz die VM an- und Updater mal.
Ja, furchtbar gesund, ultra gesund, hyper gesund.
Es reicht ultra gesund, reicht nicht mehr.
Hyper gesundes Mittagessen gab es heute.
Wisst ihr, meine VMs sind so dämlich benannt, dass ich meistens auf den ersten Blick nicht weiß, welche ich benutzen muss.
Muss ich Poggers benutzen oder muss ich Stream benutzen?
Nein, ich muss Stream benutzen, weil Poggers ist die alte Stream-VM.
Warum habe ich die überhaupt noch?
Wahrscheinlich zum Zeug nachgucken, falls ich mal was brauche.
Ahem.
Spaghetti mit Lachs.
Äh, mal gucken, ob es das passende Hintergrundbild heute gibt.
Gucken, was für ein random Hintergrundbild ausgewählt wird heute.
Moment, Moment, das hat er noch nicht geupdatet.
Ich muss erstmal Package-Updates machen und dann rebooten.
Dann mal gucken, was für ein random Bild ich bekomme.
Ich schreibe am 28., ach, ist es mal wieder soweit, ja.
Meine erste AP1.
Ach ja, ich dachte, ich dachte, das ist...
Eher sowas wie Zwischenprüfung im Februar.
Naja.
Immer so zwei bis drei.
Ah, ne, habe in den Probe-Prüfe immer so zwei bis drei.
Und habe mich mit so einem Vorbereitungskurs und ein Vorbereitung durch...
Und ein Vorbereitung-Buch vorbereitet.
Meinst du, das reicht aus?
Ja.
Wenn du immer ganz gut durchkommst.
Ich würde dir allerdings empfehlen, trotzdem noch ein paar Probe-Prüfungen...
...zu machen, weil in der Probe-Prüfung ist es immer einfacher, als wenn man dann echt vor Ort da sitzt.
Also guck lieber, dass du bei der Probe-Prüfung das nicht gerade so packst, sondern wirklich easy.
Und dann schaffst du es auch ganz gut vor Ort.
Weil das ist wirklich was anderes, ob man dann da sitzt und es ist ja zu weit.
Und dann teilen die IHK-Leute das aus und man versteht die Hälfte der Fragen nicht, weil die schon so scheiße formuliert sind.
Also es ist immer ganz gut, wenn man im Vorfeld besser ist und nicht gerade so...
Oh, ich denke...
Ich denke, das reicht aus.
Mein Vorbereitungs...
Was hast du gemacht?
Ein Vorbereitungskurs.
Du hast Probe-Prüfungen gemacht.
Also ganz ehrlich, viel mehr kannst du nicht machen.
Es wird schon hinhauen.
Aber es ist schade.
Ich mache ruhig noch ein paar Probe-Prüfungen.
Bis...
Ich meine, guck mal, es ist ja noch jetzt eine Woche Zeit.
Ach, das ist nächste Woche Montag, gell?
An die nächste Woche Mittwoch.
Ja, da kannst du schon noch mal so ein paar Prüfungen machen.
Umso mehr du dich in diesen IHK-Speak und in diesen ganzen Plänen...
in diese Blödsinn da reindenken kannst, umso besser.
Ja, mach dir aber nicht zu viele Gedanken.
Im Prinzip sind die Prüfungen einfach.
Das Schwierige an den Prüfungen ist, die IHK-Sprechweise und die IHK-Logik verstanden zu haben.
Die Prüfungen selbst sind nicht schwer.
Äh, ich kann nicht mehr richtig reden, Alter.
Die Prüfungen selbst sind nicht schwer.
Zu verstehen, was die wissen wollen und wie die Fragen stellen, das ist das Schwierige dran.
Die Fragen selbst, wenn man wirklich verstanden hat, was die wollen,
sind teilweise so trivial, simpel.
So, ihr kennt ja diese typischen IHK-Prüfungen so.
Ordnen sie die Punkte zu.
Dass du links dann so...
Oder bringen sie die Punkte in die richtige Reihenfolge.
Das ist meistens so hirnverbrannt easy,
wenn man verstanden hat, was die eigentlich wollen.
Ach, AP1 ist jetzt...
Ach, das ist die Zwischenprüfung. Heißt das jetzt AP1?
Bei mir hieß das noch Zwischenprüfung.
Aber es kann sein, ja, macht ja Sinn, dass das jetzt AP1 heißt.
Weil, die Zwischenprüfung zählt jetzt ja auch zur Abschlussprüfung irgendwie, gell?
Ich blicke da nicht durch. Ich habe mich da ehrlich gesagt nie wieder damit beschäftigt.
Habe ich auch keinen Bock, weil warum?
Ich bin... Warum sollte ich mich jemals wieder mit IHK-Prüfungen beschäftigen?
Warte mal, habe ich jetzt Reboot oder nicht?
Ja, habe ich. Moment.
Alter, was ist denn das für ein Zufall, Mann?
Guck mal, Leute. Ich habe rebooted.
Und er hat von irgendwie 20 möglichen Hintergrundbildern exakt das Gleiche.
Und er hat von irgendwie 20 möglichen Hintergrundbildern exakt das Gleiche.
Und er hat von irgendwie 20 möglichen Hintergrundbildern exakt das Gleiche.
Moment, das muss ich jetzt checken, dass wir hier nicht gebetet werden.
Der Gebet-Test.
20% zählt die, okay.
Ja, tatsächlich.
Das war Glück.
Jetzt haben wir den Workout-Champ im Hintergrund.
Den Workout-Pepo im Hintergrund.
Tü-tü-tü-tü-tü-tü-tü.
So, diesen ganzen Krempel hier mal zu.
Tü-tü-tü-tü-tü-tü-tü.
Tü-tü-tü-tü-tü-tü.
Ja, also macht dir keine allzu vielen Gedanken.
Wie gesagt, die Prüfungen sind easy.
Und solange du das nicht machst, dann ist das alles.
Das IHK, die IHK-Sprechweise,
was die wissen wollen, verstanden hast, schaffst du das locker.
Ich würde trotzdem noch mal
bis 28.2.
Also, wie gesagt, mach ruhig noch die Woche
noch ein paar Prüfungen.
Weil, sonst vergisst man es ja auch wieder.
Es schadet nicht, noch mal so
zwei, drei Prüfungen zu machen.
Mach noch mal irgendwie die Woche
zwei, drei Stück.
Nächste Woche musst du dann, ich mein, hier ist gut.
Bis kurz davor muss man das nicht machen.
Das schadet nicht. Es gibt ja auch mittlerweile genug.
Ich weiß gar nicht.
Gibt es eigentlich mittlerweile eine offizielle
Quelle für alte
IHK-Prüfungen? Oder ist
das immer noch so ein Ding,
irgendeinen File-Hoster
suchen, wo es mal einer drauf abgelegt hat?
Also, ich meine
offizielle, kostenlose Quelle.
Dass man die sich kaufen kann, irgendwo
weiß ich, ja.
Soll ich euch mal sagen, ich
finde das nach wie vor ein komplettes
Unding, dass ein Azubi sich alte
Prüfungen kaufen sollte.
Ich weiß gar nicht, was kosten die eigentlich?
Was kosten
sowas eigentlich?
Ja, ja, später.
Fachinformatiker-Prüfung.
Was ist das für eine Webseite, Mann?
Was ist das für eine Webseite,
Alter?
Optimiert für Microsoft Internet Explorer
in 1024x768,
oder was?
Exzellente Bewertung haben die, guck mal.
Exzellent.
Ecomi.
Exzellente Bewertung. Alle ablehnen.
Exzellent.
Das Wordpress?
Mal kurz gucken, was das ist.
Ähm.
Webstyles?
Wie?
Ws?
Ist das Wordpress?
Chatge?
Ihr kennt euch mit sowas besser aus.
Websale.
Websale ist das.
Was ist Websale?
Shopify für Arme, oder wie?
Webshop as a Service.
Also, seriously.
Wenn das ein Webshop as a Service ist,
dann verstehe ich die Welt nicht mehr.
Das sieht aus,
als hätte das mal vor 20 Jahren einer gebaut
und danach wurde das nie wieder angepasst.
Also nach einer Service-Anwendung
sieht das beim besten Willen nicht aus.
Okay.
Wie dem auch sei, Systemintegration.
Was kosten so Abschlussprüfungen?
Fachinformatiker
Erfolgs-Paket
plus Abschlussprüfung Teil 1.
Was genau ist denn das Erfolgs-Paket?
Was genau ist denn das Erfolgs-Paket?
Was ist das Erfolgs-Paket?
Was ist das Erfolgs-Paket?
Erfolgs-Garantie auch noch.
Da wäre ich aber mal zurückhaltender.
Da wäre ich aber mal zurückhaltender.
Was ist denn da drinnen?
Ihre Vorteile.
Perfekt gepackt.
Ja, und was ist jetzt dabei?
Ja, und was ist denn jetzt dabei?
Erfolg.
Das Selbstcoaching-Buch.
Meine Güte, machen die jetzt auf keinen Fall
KLS oder was?
Die Versandkostenfreilieferung schont ihr Budget.
Der Shit kostet 74 Euro, Mann.
Der Shit kostet 74 Euro, Mann.
Okay.
Im Prinzip sind das einfach nur Abschlussinhalte.
Prüfungstrainer-IT-Berufe.
Braucht keiner. Lernkarten braucht auch keiner.
Prüfungs...
Ja, das vielleicht schon eher.
Original-IHK-Abschlussprüfung Dezember.
Moment, da ist nur eine Prüfung dabei.
Herbst 2003. Nur eine Prüfung?
Die wollen dich doch verarschen, oder?
Die wollen dich doch verarschen, oder?
Ganz ehrlich, Leute.
Wir haben das damals von RapidShare oder so
runtergeladen.
Mich würde nicht wundern...
Ich möchte natürlich keinen dazu auffordern.
Mich würde nicht wundern,
dass es das heute auch noch gibt.
Vielleicht nicht auf RapidShare.
Weil ich glaube, RapidShare selbst gibt das nicht mehr.
RapidShare hat auch ein bisschen
die Arschkarte gehabt, dass sie so einer der ersten
so OneClick...
Wie hieß das?
Free...
So Share...
OneClick-Hoster?
Wie nannte sich der Krempel denn?
Davon will ich gar nichts wissen.
Wenn ich sehe, wird es gelöscht.
Kappa.
Share-Hoster.
Guck mal, es ist die eine Sache,
was ich offiziell sagen muss,
und das andere, was ich mache.
Ich erlaube nicht, dass auf meinem Discord
solche Sachen gepostet werden.
Wo kämen wir denn dahin, Mann?
Wo kämen wir denn dahin, Mann?
Wo hast du die Programmiersprache Java?
Viel wichtiger ist die Frage,
wie man das ausspricht.
Ist es Java?
Ist es Java?
Bisschen die Frage wie bei Kubernetes.
Ich mag Java
nicht sonderlich,
ich habe aber auch nichts dagegen.
Ich würde zumindest meine Projekte
nicht in Java machen.
Java ist zumindest alles,
was ich bisher gesehen habe,
beziehungsweise gelesen habe,
ist ultra verbose
oder verbis,
wenn man das ganz richtig aussprechen muss.
Also es sieht irgendwie so bloated aus.
Man könnte dann sagen,
dass es bei .NET und C-Sharp ähnlich ist,
aber ich finde es bei weitem
nicht so krass wie in Java.
Gibt es eigentlich wirklich noch Unternehmen,
die Programmierer nach programmierten Zeilen bezahlen?
Gibt es eigentlich wirklich noch Unternehmen,
die Programmierer nach programmierten Zeilen bezahlen?
Das gibt es doch nicht mehr, oder?
Das macht doch 2024 niemand mehr.
Go ist nice.
Viele Java-Leute schwärmen ja von Kotlin,
so ein bisschen,
aber sind dann richtig sätge,
dass sie im Beruf nicht Kotlin verwenden dürfen,
sondern weiter mit Java rumhantieren.
Ja, dass sie weiter mit Java rumhantieren müssen.
Ja, dass sie weiter mit Java rumhantieren müssen.
Ja, das schadet nicht.
Es ist jetzt nicht so, als wäre Java und das Java-Ökosystem
unerträglich kacke.
Ich glaube das Schlimmste
am Java-Umfeld ist tatsächlich Oracle.
Wobei es ja mittlerweile
mit OpenJDK und was es sonst nicht gibt,
ich bin da nicht so drin,
was das Java-Ökosystem angeht,
sicherlich ja auch vieles gibt,
wo man einen großen Bogen
um Oracle machen kann.
Ein Kollege von mir auf der Arbeit
mag Oracle auch nicht.
Man muss aber wissen,
der hat früher bei Sun gearbeitet
und wurde dann zwangseinverleibt
von Oracle
und hatte dann nach ein paar Jahren keinen Bock mehr.
Das finde ich
das trifft echt ganz gut.
Das trifft echt ganz gut.
Go, wenn es schnell gehen soll
und Rust, wenn man nichts von Bugs wissen will.
Das ist natürlich im Detail
nicht so,
aber so ganz grob finde ich das gar nicht so schlecht.
In Go kann man wirklich auf die Schnelle
was zusammenzimmern,
was man übrigens in C-Sharp und Python
und anderen Programmiersprachen auch kann.
Kommt dann ein bisschen drauf an, was man machen will.
Und Rust ist die einzige Programmiersprache,
die ich kenne, wo man sagen kann,
dass es in der Regel,
sobald es kompiliert, das macht, was da steht
zu sehen glaubt.
Dass man jetzt selbst irgendwie einen Denkfehler gemacht hat
und der Ablauf nicht richtig ist,
da kann Rust auch nichts dagegen.
Aber zumindest in der Regel
macht Rust Code das, was da steht.
macht Rust Code das, was da steht.
Also ne, was da steht,
sollten sie alle machen, außer C++.
C++ macht noch nicht mal das, was da steht.
Das ist kein Witz.
Letztens habe ich euch wieder was gezeigt,
wo in C++ was anderes gemacht wird,
als da steht.
Aber bei Rust ist es so,
das, was da steht und das, was du verstehst,
ist in der Regel, sobald es sich kompilieren lässt,
auch das, was es macht.
Also Rust ist da schon ganz gut.
Wenn du natürlich Blödsinn reinschreibst
und einen Denkfehler drin hast,
da kann Rust auch nichts dagegen machen.
Ich finde das auch ganz gut gemacht.
Rust hat ja von Anfang an gesagt,
Exceptions wollen wir nicht,
wir haben nur Result Types und Option Types
und sowas.
Die haben das halt konsequent gemacht.
In Go haben sie es nicht konsequent gemacht.
Und in C++ kann man das auch machen
und Recovern.
So halbe halbe ist das.
Und in C Sharp kannst du auch beides machen.
In C Sharp kannst du auch Error Types verwenden
oder
also ich glaube,
offizielle Option und Error Types
gibt es in der Standard Library nicht,
aber kannst du ohne Probleme verwenden.
Und Exceptions,
was halt richtig nice wäre,
in C Sharp, wenn sie es mal hinkriegen,
würden, dass du
also ohne den gleichen Base Type zu haben,
mehrere Sachen,
unterschiedliche Types returnen könntest.
Irgendwelche Union Types,
aber das wollen sie irgendwie nicht.
Hast du auch studiert
oder Ausbildung als Fachinformatiker?
Ich habe 2007,
also das jetzt vor,
ach du Scheiße, ist das schon lange her, Mann.
Das ist ernsthaft,
17 Jahre her schon.
Quick Maths, stimmt das?
17 Jahre her
habe ich eine Ausbildung als Fachinformatiker,
Systemintegration gemacht.
Das gab es zu dem Zeitpunkt noch nicht so lang.
Schon ein paar Jahre, aber noch nicht so lang.
Meinungen zu Broadcom Lizenzmodell der Zukunft?
Meinungen zu Broadcom Lizenzmodell der Zukunft?
Ich habe absolut keine Ahnung,
was das Broadcom Lizenzmodell der Zukunft ist.
Was das Broadcom Lizenzmodell der Zukunft ist.
Was das Broadcom Lizenzmodell der Zukunft ist.
Nein, nein, nein, da fangen wir jetzt nicht hin.
Übrigens, das ist das einzige,
was ich jetzt zu C++ sage.
Wisst ihr eigentlich,
dass in C++
das hier
while
oder while true
ich kann C++ nicht aus dem Kopf gescheit
while true, hier
print
print
Was glaubt der denn jetzt eigentlich
Ach ja, was kacke.
Wisst ihr eigentlich, dass in C++
es nicht klar ist, was hier
passiert?
Habe ich schon mal erzählt, ja, aber
in C++ ist es tatsächlich nicht
so, dass das passiert, was man
denkt. Was würdet ihr denken
bei diesem Code? Was
passiert da? Es ist jetzt übrigens keine
konkrete Programmiersprache.
Nur vom Ablauf. Wenn ihr sowas
ähnliches in C++ stehen hättet,
in C++ ist es dann nochmal
Standard, ne, ähm,
doch Standard
so irgendwie. Allein schon,
wenn ich diese Syntaxe immer sehe, kriege ich
Anfälle.
Kommt auf den Compiler an. Das ist
korrekt. Die Schleife ist
leer und wird je nach
Dings wegoptimiert.
Korrekt. Psytech. Genau so
finde ich sollte das auch sein. Es ist aber
nicht zwangsläufig.
Also ich würde auch sagen, es muss eindeutig
so sein, damit das halt passt, was
da steht. Es gibt das aus und
dann hängt es unendlich. Aber nein, das ist
nicht so. Und es ist übrigens nicht
so, weil die Schleife wegoptimiert
wird.
Es ist so, weil
while ohne Abbruchbedingungen
undefined behavior ist. Warum auch immer.
Das haben sich die Leute im
C++-Gremium sicherlich gut überlegt.
Und das ist so schlimm, dass es
zwischen Compiler-Versionen und
Compiler-Upgrades sich ändert. Also sprich,
wenn du das hier, sagen wir mal, mit GCC9
kompilierst, dann hängt es in der
Endlosschleife. Kompilierst du es mit
GCC10, dann gibt es
Keckel 1 und Keckel 2 aus.
Es ist so ein Bullshit,
diese Sprache und was die
Standard-Leute da bauen. Ich meine,
allein schon, dass eine leere,
ich weiß gar nicht, ob das leer sein muss,
eine Endlosschleife ohne
Abbruchbedingungen undefined behavior ist.
Wer hat sich diesen dummen
Schwachsinn ausgedacht?
Ja, also C++ kannst du echt knicken.
Zumindest ist C++ die einzige Sprache,
wo du wirklich vom angucken
nicht wissen kannst, was es macht.
Aber Rust ist schon gut
in der Beziehung.
Das weiß ich nicht. Es geht aber
hauptsächlich darum, warte mal.
Zumindest hat der Typ das
in der Präsentation so erzählt.
Ich habe den Standard nicht gelesen.
Ich habe in der C++-Con-Präsentation
geguckt, wo es um undefined behavior
geht.
Und der meinte, das Problem ist
die Endlosschleife ohne
Abbruchbedingungen, das wäre nicht definiert.
Ne, kann man nicht.
Das schaffen die doch nicht mal selbst.
C++ ist einfach komplett für'n Arsch.
So, machen wir das mal zu.
Machen wir das mal zu. Wobei, einen Browser brauchen wir schon noch.
Wie gucken wir uns heute
Welt 5 an?
Ich gebe zu, die Streamingzeit
ist vielleicht nicht für alle so
praktisch.
Die meisten Leute sind jetzt fertig mit der Arbeit, fahren jetzt heim.
Aber ich schwätz ja lang genug rum.
Vielleicht seid ihr ja mittlerweile schon daheim
und könnt gucken. Ansonsten gibt's immer noch
das Wort.
Oder wir machen ja demnächst noch ein paar mehr Streams
in der Richtung. Zumindest
ich wollte mir heute mal das
Welt 5 angucken, weil
das ist ja irgendwann gescheduled
bis 2024 irgendwann,
wenn ich das richtig gelesen hab.
Und, das Welt 5 hat
bei der Ankündigung
einen riesen Aufschrei
in der Svelte Community verursacht.
Weil sich die Syntax
etwas ändert.
Als ich das das erste Mal gesehen hab,
wir gucken uns das gleich an. Ich hab ne coole Seite
gefunden in nem Video auf Youtube,
wo man schön die alten und neuen Versionen
vergleichen kann.
Zumindest war der Aufschrei relativ groß,
weil sich an der Syntax ein bisschen was
geändert hat.
Und ich dachte mir am Anfang auch,
ich weiß nicht,
irgendwie falte ich die alte Sache
ja ganz cool.
Aber jetzt nachdem ich's mir ne
Weile überlegt hab, glaub ich das neue ist wirklich
besser und
eindeutiger. Ihr könnt
das ja gleich selbst entscheiden, wenn wir's uns angeguckt
haben. Ich bin übrigens bei weitem kein
Frontender oder Svelte Professional.
Also es kann durchaus sein,
dass ich auch in Svelte 4 bei einigen Sachen
gar nicht so genau weiß aus dem Kopf, wieso
ich das so richtig ausdrücke,
aber ich will das jetzt mal einfach mal
definieren.
Kein TypeScript mehr? Ne, wir machen hier
nie TypeScript.
Oder was meinst du?
Ach, Svelte 5 kein TypeScript mehr?
Ne, du kannst das mit TypeScript verwenden,
wenn du willst. Du kannst es auch sein lassen.
Ne ne ne ne. Das einzige, wo die kein Type...
Das hat auch nen riesen Aufschrei verursacht.
Als die, äh, angeblich
verwendet Svelte 5 kein TypeScript mehr.
Das ist auch Blödsinn.
so wie sie es welt bauen quasi verwenden sie intern kein typescript mehr aber du kannst welt
selbstverständlich mit typescript benutzen und die offiziellen beispiele sind auch zum größten
teil mit typescript ja genau das heißt nicht dass du es welt nicht benutzen kannst mit typescript
sie verwenden intern ins welt kein typescript mehr das liegt daran ich habe auch ein video gesehen
mit dem mit dem es welterfinder die haben gesagt weil sie große probleme haben es welt kompiliert
das ja dann zu playen javascript alles was du da an syntaktischen zucker ins welt machen kannst
die ein große probleme typescript da zwischendrin zu passen deswegen machen sie glaube ich jetzt
js docs intern und verzichten auf typescript du kannst aber das welt wunderbar mit typescript
verwenden und du wirst sogar glaube ich in offiziellen docs dazu ermutigt so nach dem
motto macht es mit typescript
also dass das was die intern machen und das wie du es dann am ende verwenden kannst hat ja gar nichts
miteinander zu tun so und ich habe eine seite gefunden in einem youtube-video ich zeige euch
das youtube-video mal also wir gucken uns das jetzt an ich habe ein youtube-video gefunden und
zwar das da und er hat da drin eine wirklich coole seite gezeigt und zwar guckt mal hier
component-party.dev kanntet ihr das also ich kannte das vorher nicht das ist aber extremly nice
denn man kann hier beispielsweise alle möglichen frontend frameworks vergleichen wie ähnliche
konstrukte untereinander aussehen also wir können jetzt zum beispiel sagen wie sieht dann state
handeling aus in concertville versus react oder wie sieht state handling aus ins welt 5 versus
wird oder imanu drei oder view 2 oder so sieht man sieht man die unterschiede es aber richtig nice also sieht es in
also aber richtig nice also sieht es in 12 4 aus so sieht es im react aus 12 5 aus so sieht es so
sah es in view 2 aus view 2 fand ich super nice damals das war so das erste frontend framework
wo ich so wo ich so richtig wo mir so richtig gefallen hat ich habe das interesse ein bisschen
verloren weil das upgrade zu view 30 so schleppend so schleppend hingezogen hatten irgendwann bin ich
dann was welt gelandet um alle anderen mache ich ein bisschen den bogen was ich mir irgendwann mal
angucken wollte ist tatsächlich soll weil soll es ja dachte ich eigentlich ich dachte eigentlich
dass soll quasi wie react ist nur ohne jsx aber anscheinend anscheinend doch nicht weil das ist
doch eindeutig jsx hier unten oder es ist es ist html in javascript vielleicht haben sie das auch
nur für die einfachheit halber der beispiele gemacht
egal zumindest wir planten hier mal alles aus wir planten solid aus für planten view aus für
pländen react mussten react react aus da bleibt jetzt nur übrig fällt 4 und 12 5 die seite ist
mega podcast muss man sagen und wir kommen zwar ein paar beispiele an ich habe sogar gesehen man
kann das mittlerweile ziemlich easy ausprobieren man muss das nicht mehr offiziell in diesem
offiziellen
baulkasten machen sondern man ein neues source-kit projekt anlegt mkr die das dumme ist ich guck mal
hier bei einem ordner namen alter fiel aber das npx nee alter javascript ökosystem wie ging das
nochmal mpx auf der conversation und das welt mit zwei ist es ankea 2 intersects war in japan aber
für dich muss ich das den ersten hier zu Ende geben und du kannst mir gehen sie citizens also du kannst
mich nicht Tool Day für die buchhaltung gucken kommentieren wie mach ich hier so ans polygon die
ich hab mir center gallery das anticipier y что habe ich wirklich bei dennis werden sie zuowie verbunden
heutzutage ja ich kenne fcf ich mag das aber für die history nicht benutzt das sogar auf
der arbeit für host auto completion so nach dem motto ich suche die web server kiste aus dem und
dem projekt ja ich kenne dass ich habe das glaube ich sogar installiert ja das sogar installiert
kennst du c oxide ja das kenne ich das ist ein cd in rust verwende ich aber auch nicht
aus genau dem gleichen grund warum ich auch kein fcf verwende für sachen wie shell history und
sowas und das liegt darin das liegt daran dass ich ein nicht unerheblichen teil meiner arbeitszeit
auf remote system verbringen per ssh und dort ist dieser ganze kram die
nicht drauf und wenn du dich daran gewöhnt dass du nur noch cd navigieren kannst mit sie auch
sei dass ich nur noch dran gewöhnt dass seine best history fasi searchable ist dann drehst
du durch auf server system weil es hat sehr viel damit zu tun was man gewöhnt ist zu tippen und
man tippt ja oftmals schneller als man wirklich realisiert was passiert man denkt sich im kopf
schon immer das was dann kommt und tippt dann weiter bis man feststellt auch fakt das ist ja
hier gar nicht drauf ganz vergessen also dass das ist der grund warum ich das nicht verwende
ist auch der grund warum ich bei allen standard tools die standardsachen verwende warum ich bei
ls und auch ls verwende und nicht etwa eines der 5000 ls rewrites in rust so wie ging das jetzt hier
nochmal svelte create latest my app nein nein nicht latest via example so angeblich svelte demo app skeleton pro
so angeblich svelte demo app skeleton pro
check angeblich soll er mich jetzt fragen ob ich nicht ein svelte 5 testprojekte ach hier guck mal
try the svelte 5 preview unstable genau das will ich haben browser testing wer braucht tests wenn
alles immer first try funktioniert ok npm install mal schauen mal schauen wie viele
pakete gleich wieder installiert sind das sparen wir uns das brauchen wir gleich ok node modules
was ist das warum sind es nur 28 mb bei einem neuen projekt
das ist viel zu wenig also ich glaube unter zwei gigabyte node modules ist
irgendwas verkehrt und das funktioniert jetzt ja na gut immerhin 48 node package ist am start
was ist der da so installiert eigentlich übrigens kam er minus r und das war nicht minus r dass er die farbe macht also guck mal hier was hat er gemacht ganz einfach
Was installiert er?
Acorn, was auch immer das ist.
Am Projekt, keine Ahnung.
Cookie Debug, Deep Merge.
Cleor.
Magic String.
MS, Nano ID.
Pico Colors.
Sirf.
Wied und Wiedfu.
Zimmer Frame.
Zertke.
Installiert, guck mal, der installiert Zertke.
Okay, dann starten wir das mal.
Und gucken, wie es mit Svelte 5 aussieht.
Achso, ne Moment, Moment.
Das machen wir jetzt nicht, das starten wir jetzt nicht.
Wir starten jetzt erstmal Visual Studio Code hier drinnen.
Schieben Visual Studio Code auf den zweiten Bildschirm.
Und jetzt starten wir den Camp.
So.
Und jetzt können wir es auch rüberschieben.
So, Demo-Anwendung sieht noch genauso aus, wie die alte Demo-Anwendung.
Nur, dass es jetzt Svelte 5 ist.
Source.
Was fällt mir denn auf?
Als erstes, dass ich nicht weiß, wo meine, sag ich jetzt mal eine Startzeit.
Gut, da kann da noch nichts auffallen, weil das mehr oder weniger plain HTML ist.
Ohne Spirenzien.
Svelte ist pfeifert.
Ja, Svelte ist richtig pfeifert.
So, und jetzt können wir das mal vergleichen, was der Unterschied ist zwischen 4 und 5.
Zum Beispiel eine Sache, die sehr kontrovers war.
Also als Svelte 5 angekündigt wurde.
Announcing Svelte 5.
Svelte 5.
Hier, das war so eines der ersten Sachen, die bekannt wurde über Svelte 5.
Das haben die dann hier gezeigt.
Und da war dann auf Reddit, gingen sie alle wieder ab, dass sie das scheiße finden.
Und ein paar fanden es auch gut, aber der überwiegende Teil fand es ziemlich kacke.
Ich musste mich auch erst mal am Anfang dran gewöhnen.
Ja.
Naja.
Zumindest ist das jetzt der Unterschied zwischen alt und neu.
Also früher hat man, wir nehmen das hier einfach mal als Beispiel.
Ja, wir kopieren uns das mal als Beispiel.
Ja, cute chat.
Wenn man das...
Ja.
Also früher hat man State so deklariert.
Also man hat überhaupt nicht erkannt, dass das State ist.
Das war in Svelte gewisserweise irgendwie Magic.
Da hat man eine Variable deklariert im Skriptteil und konnte das dann hier verwenden.
Ich meine, das ist ein bisschen minimalistisch, das Beispiel.
Weil hier auch nix geupdatet wird oder irgendwas passiert.
Zumindest in Svelte 5 ist das gleiche Beispiel, ein Ticken länger.
Und...
Also der einzige Unterschied zwischen Svelte 4 und 5 ist, dass du hier noch State drumherum machen musst.
Also dass das hier nicht mehr automatisch passiert.
Ich fand es am Anfang doof, als ich das erste Mal das Beispiel gesehen habe.
Habe ich mir gedacht, warum muss man das noch...
Also warum...
Muss man da noch was drumherum schreiben, wenn man das noch automatisch machen kann?
Ich glaube, den Vorteil erkennt man erst, wenn man ein bisschen mehr als 3, 4 Variablen hat.
Spätestens wenn man Variablen anlegen will, die kein...
Wie soll man sagen?
Kein State sind, den du irgendwie im View verwenden willst.
Aber Svelte automatisch das versucht irgendwie zu tracken, dann bringt es wahrscheinlich was.
Fehlt mir ein bisschen die Erfahrung.
Auf der anderen Seite...
Auch als jemand, der jetzt nicht hauptberuflich als Frontend-Entwickler arbeitet.
Eine Sache, die ich an der neuen Syntax persönlich ganz gut finde, ist,
dass man eben halt genau sieht, wann was Reactive ist und wann nicht.
Oder ist Reactive das richtige Wort?
Also das ist der Unterschied zwischen Svelte 4 und Svelte 5, wenn es um State geht.
Ich weiß nicht, ob man dazu Reactive sagen darf.
Weil ist es ja im Endeffekt auch.
Du kannst jetzt da ja auch Two-Way-Binding oder sowas machen.
Oder man kann ja auch zum Beispiel an der Stelle jetzt sagen, hier, das ist Count.
Count fängt an mit 1.
Fängt an mit 1 und dann machen wir irgendwie einen Button dahin und sagen hier On, Klick.
Das geht übrigens jetzt auch anders.
Ich glaube, man kann jetzt einfach sagen direkt On, Klick.
Also On, Klick.
Und dann sagen wir jetzt hier Count, Count, Plus, Plus.
Und jetzt sollte der hochzählen, wenn ich hier unten draufklicke.
Also sieht man, das geht Two-Way.
Das geht einmal in den View rein und einmal quasi von Interaktiv klicken, dann auch wieder.
So, und ich glaube, das Problem, was die versuchen damit zu lösen ist,
dass wenn ich jetzt noch mehr solcher Dinge habe, hier Count,
hier, was weiß ich, wenn ich mal angenommen habe, ich habe jetzt Name
und das soll halt wirklich nur intern in meinem JavaScript hier oben verwendet werden,
dann würde Svelte das trotzdem tracken, ob damit nicht was passiert,
obwohl man eigentlich genau weiß, es passiert nichts damit.
Und in Svelte 5 passiert das nicht, weil man sagen muss, hier Dollar State.
Das sieht mir zu sehr nach PHP aus.
Das sieht legit null aus wie PHP.
Ich meine, es ist JavaScript und HTML.
Das machst du inline in PHP oftmals auch, ja.
Das Ding ist nur, das Ding ist nur, wie verwendet man das jetzt?
Also machen wir da mal jetzt Svelte 5 draus, ja.
Dollar State muss da im Endeffekt bloß hin.
Dollar State.
Und es funktioniert wieder, ne?
Ansonsten muss man da nichts ändern.
Muss man das nicht irgendwie includen oder so?
Ja, das ist so.
Das ist so.
Das ist so.
Das ist so.
Das ist so.
Das ist so.
Das ist so.
Das ist so.
Das ist so.
Dollar State, das scheint Standard Library zu sein.
Okay, und das in den Klammern ist der Initial Value.
Dollar State ist insofern schon mal ein bisschen verwirrend für mich, weil Dollar war in Svelte immer Stores.
Aber das scheint jetzt kein Store zu sein.
Das ist jetzt irgendwas anderes.
Moment, das ist nicht TypeScript.
Definition.
Das ist jetzt irgendwas anderes.
Gut.
Gut.
Wie dem auch sei, das von uns.
Ich muss mal den Hintergrund hier ein bisschen anders machen.
Das sieht ja abartig aus.
Ach so.
Moment, wir haben ja gar keinen Tailwind.
Wie macht man mit Plain CSS Background Color?
Machen wir irgendwas?
Keine Ahnung.
Was ist eine schöne Background Color?
Monke ist...
Ah, hier ist...
Alter, sieht das kacke aus.
Kann man da nicht irgendwas, kann man da nicht irgendwie ein bisschen angenehmeres verwenden, so?
Hier.
Ach nee, das ist Alpha.
Alpha will ich nicht.
Irgendwie sowas hier oder so.
Ah, okay, schon nicht mal ganz so schlimm.
Oder kannst du Syntax aus 4 und auch in 5 verwenden?
Also, Freesay, dankeschön für den Sub 420, Prog Subscription.
Oder kannst du Syntax aus 4 auch in 5 verwenden?
Also.
Soweit ich das gelesen habe, kannst du die alte Syntax weiterverwenden.
Du musst nicht jetzt deine komplette Anwendung umschreiben, wenn du Upgradest auf Svelte 5.
Was wohl Probleme machen kann ist, oder was schlicht und ergreifend dann gar nicht kompiliert ist,
manche Svelte 5 Konstrukte im gleichen File mit manchen Svelte 4 Konstrukten.
Also was wohl nicht funktionieren muss, ist $state und die alte...
Und diese alte...
Schreibweise.
Da mag er nicht.
Guck, da sagt...
Dollar Doppelpunkt ist not allowed in Runes Mode.
Das ist die alte Schreibweise für mach irgendwas reaktiv und update das immer, wenn davon sich was ändert.
Das kann man nicht verwenden zusammen mit der neuen.
Aber was du machen kannst ist, wenn du jetzt eine Komponente hast, die noch mit der Svelte 4 Syntax geschrieben ist,
dann kannst du sie in einem Svelte 5 Projekt einbinden.
Beziehungsweise kannst du die auch weiterhin...
Hast du ja gesehen.
Ich kann es auch weiterhin so machen.
Und das funktioniert jetzt auch.
Also man kann bloß manche Sachen nicht zusammen im gleichen File verwenden.
Aber im besten Fall macht man diese einzelnen Komponenten-Files ja eh halbwegs übersichtlich.
Class machen wir jetzt mal.
Nicht Class, Style.
Text.
Color?
Ne, ne, Moment. Es ist einfach nur Color in CSS, oder?
Ja.
Excellent.
Massive Web Design.
Font, Family.
Wow, huge.
Massive Web Design.
So Skills wieder am Start hier.
Magst du an's Trinken erinnern? Ja.
Mein Wasser ist leer. Ich hab nur noch ein bisschen hier.
So, also es geht weiter.
Declare State wissen wir jetzt, dass das funktioniert mit Dollar State.
Das hat vorher auch schon funktioniert.
Das war jetzt rechtsübersichtlich.
You have Docker installed on your system.
You have Docker installed on your system.
Ja, no shit Microsoft.
Sag mal, sind die Icons hier neben anders als früher?
Sag mal, sind die Icons hier neben anders als früher?
Oder bin ich einfach nur...
Möchte mir Microsoft irgendwas mitteilen,
Möchte mir Microsoft irgendwas mitteilen,
dass die C++ Extensions ganz oben stehen?
dass die C++ Extensions ganz oben stehen?
Ne, die sind wahrscheinlich einfach alphabetisch sortiert.
Ne, die sind wahrscheinlich einfach alphabetisch sortiert.
Ja, das alles ohne Konzeptzeichnung.
So, jetzt geht's weiter mit Update State.
So, jetzt geht's weiter mit Update State.
Gut, das haben wir ja schon mehr oder weniger grad ausprobiert,
Gut, das haben wir ja schon mehr oder weniger grad ausprobiert,
indem ich hier unten bei dem Button der ganzen Sache was zugeordnet hab.
indem ich hier unten bei dem Button der ganzen Sache was zugeordnet hab.
Also sprich, das müssen wir nicht ausprobieren.
Ändert sich nix.
Bleibt weiterhin das mal Dollar State.
Computed State.
Okay, jetzt wird's spannend,
weil in Svelte 4, und das ist das, was viele
weil in Svelte 4, und das ist das, was viele extrem mochten an Svelte,
extrem mochten an Svelte,
ist diese Syntax hier,
dass man Sachen Reactive macht,
beziehungsweise automatisch
sich ändern lässt,
wenn es Abhängigkeiten
untereinander gibt. Also was man in Svelte 4
machen konnte,
machen wir jetzt mal ein Beispiel,
oder brauchen wir das gar nicht, machen wir das mal weg.
Also was man in Svelte 4 machen konnte ist,
man kann zum Beispiel,
das einfachste Beispiel ist wahrscheinlich
mit nem Console Log.
Also mal angenommen, ich möchte jetzt was ausführen,
jedes Mal, wenn sich
was verändert, dann konntest du in Svelte 4
einfach sowas hier sagen,
Log Count.
Und jedes Mal,
guckt, seht ihr's hier unten,
jedes Mal, wenn sich Count ändert,
wird das hier
ausgeführt. Das war so diese
Reactivity Syntax von Svelte 4.
Und das haben ganz viele Leute
extrem gemocht an Svelte.
Das war für viele so ein bisschen wie damals
in Vue 2 eben diese so
Klassenschreibweise von den Komponenten,
die viele gut fanden.
Viele extrem gemocht in Svelte.
Und das gibt es in der Form jetzt nicht mehr.
Ja und nächstes Beispiel, was man
hier drinnen machen kann zum Beispiel ist,
ja okay, ich will jetzt jedes Mal,
jedes Mal irgendwie, wenn sich
Count ändert, will ich
irgendwas damit
machen. Ja zum Beispiel könnt ihr sagen,
let name
keckel oder so.
So und jetzt geben wir nicht
Count aus,
sondern geben Name aus.
Und jedes Mal, wenn sich eben
Count ändert, sage ich
name gleich
ja name plus
das ist jetzt Javascript,
dass das funktioniert.
Guckt, das geht auch nur
in Javascript, ein String und
eine 1 und ein Plus.
Keine Ahnung, fragt nicht, aber das funktioniert.
Das war so die Reactivity
Syntax von Svelte 4. So,
das hat sich jetzt geändert und zwar
kann man,
achso das war die Kurzschreibweise.
Das war die Kurzschreibweise von
dem, was ich euch gezeigt habe. Also
anstatt das so zu machen,
könnte ich auch, solange es einzeilig
bleibt, das war auch so ein Ding, was mich immer ein bisschen
genervt hat in Svelte 4, dass
das nur einzeilig ging.
Ja also sprich, anstatt
so, hätte ich quasi auch
schreiben können, Dollar
name gleich
name
weiß gar nicht, ob das funktioniert hätte überhaupt.
Plus 1?
Kann ich das hier weg machen? Keine Ahnung, ob das funktioniert.
Not the number?
Nee, fand's gar nicht, guck mal.
Ha!
Ah nee, nicht plus 1, plus count, ich kack nur, weil da.
Nee, das geht gar nicht.
Wahrscheinlich, weil das nicht belegt ist.
Ah jetzt, jetzt, jetzt.
So, und das haben sie jetzt abgeschafft.
Das haben sie jetzt
abgeschafft.
Und die neue Syntax ist jetzt
explizit,
dass man explizit
definieren muss, wenn man
ab-
hängigkeiten hat.
So genau, warum das derived
heißt, habe ich ehrlich gesagt
nur semi-kapiert.
Hm. Achso,
Moment, derived, dann muss das hier Dollar
State sein, dass das funktioniert, oder?
Derived wahrscheinlich,
weil das, was in derived
drinne steht, hier hinten dann die Abhängigkeiten
sind. Also es ist jetzt nicht mal Magic
wie in Svelte 4, wo
das hier im Endeffekt dafür gesorgt hat, dass der
gepasst hat, so, was
ist da hinten drinne, ist das Reactive, wie hängt das
von ab? Jetzt musst du explizit sagen, ey,
ich will eine Variable
haben, und wenn sich an dieser Variable
was ändert, möchte ich das hier neu ausführen.
Das geht halt mit dieser derived
Geschichte. Übrigens, ich habe bis heute nicht gecheckt,
warum sich das Runes nennt.
Brauche mir
ein cooles Wort für. Ja, also
ich könnte da jetzt natürlich auch sowas hier machen.
Cackle
plus count
und dann wird das auch hochzählen.
Wo ich mir nicht ganz sicher
bin,
geht sowas?
Wahrscheinlich nicht, oder?
Das mag er nicht, also
man kann da nicht auf sich selbst referenzieren, okay.
Ich bin mir
ehrlich gesagt auch nicht sicher, wie oft ich das
verwenden werde, weil so einzeilige Sachen
reichen mir meistens nicht.
Die Frage
ist jetzt ja auch, kann man dort
kann man dort irgendwie sowas?
Achso, ja gut, name.
Okay, warte mal, ich schreibe wieder count
rein. Kann man da sowas
machen, wie ausführen bei jeder
State-Änderung?
Wird auch nicht funktionieren, oder?
Ne, das mag der nicht.
Das ist irgendein Objekt,
das ist keine Function, aber ich kann bestimmt sowas machen, ne?
Haben wir jetzt nicht ausgeführt.
Okay, keine Ahnung.
Kann man andere derived Variablen
in derived reinmachen?
Das ist eine gute Frage, das probieren wir mal aus.
Machen wir nochmal, name.
So, name ist derived
Okay, jetzt machen wir mal
name2
name2
is derived from
name
plus 1, oder plus 0
und jetzt gehen wir mal
hier name2 aus.
Ja, das funktioniert.
Das geht. Also man kann
Abhängigkeit
von Abhängigkeit von Abhängigkeit machen.
Das funktioniert.
Oh ne, nicht
nicht wieder heute.
Fangt nicht damit an. Dann rege ich mich jetzt
zwei Stunden über C++ auf und dann ist das
Stream vorbei.
Heute nicht.
Aber ganz grundsätzlich
gesagt, finde ich sehr schwach von
einer Programmiersprache, dass eine
Endlosschleife ohne Abbruchbedingungen
undefined behavior ist.
Es sollte das machen,
was da steht.
Ist egal, was der Fall ist. Solange es
da steht, sollte mein Code genau das machen,
was da steht. In jeder normalen Programmiersprache
ist das ja auch so, aber nicht in C++.
Zumal
die eigentliche Sache ja ist, dass
die Schleife keine Abbruchbedingungen hat.
Was ja wohl das Problem ist.
Und dass sich das dann noch zwischen zwei Compilerversionen
ändert von logisch zu unlogisch
ist ja auch nochmal bescheuert.
Aber wir machen jetzt weiter mit
Svelte 5. Also das funktioniert
schonmal. Jetzt habe ich mal
eine Frage an euch Chat.
Welche der beiden Sachen
denkt ihr ist besser?
Nehmen wir
jetzt, nehmen wir mal das Beispiel
hier unten. Da hat man halt die zwei Sachen drinnen.
Also, das ist die Svelte 4 Variante.
Das ist so quasi der Klassiker,
den ganz viele mochten.
Also sprich, ohne
dass du explizit sagen musst,
hier, tracke mir die Variable.
Ohne dass du hier explizit sagen musst,
sei reactive, wenn sich
was ändert.
Bevor ich jetzt sage, was ich denke,
frage ich mal, was ihr denkt.
Was findet ihr besser? Man könnte
auf den ersten Blick natürlich schon sagen, ey,
warum machen wir es komplizierter,
Svelte 5 ist ja doppelt gemoppelt
irgendwie hier mit den Dingen.
Svelte 5 ist im Endeffekt nur länger.
Für jemanden, der die Sprache zum ersten
Mal sieht, ist das neue besser.
Also viele mochten ja gerade
das hier und sind deswegen bei Svelte hängen geblieben.
Also unter anderem mochten sie sowas hier.
Also ich muss sagen,
für
um Leute zu
beeindrucken, um zu sagen, boah ist das
eine coole Sache, ist die Svelte 4
sonntags besser.
Aber für
Klarheit,
dass das, was du siehst, auch das ist
ja
also das, was du erwartest,
auch das ist, was passiert
und dass man die
dass man es auch besser erkennt,
was reactive ist und was nicht.
Also im Gegensatz zu
und defined behavior und C++, wo eine
Endlosschleife und Abbruchbedingungen
Dinger macht, die es nicht machen sollte,
finde ich Svelte 5 besser.
Aber gibt es denn jetzt mehrzeitige
Abbruchbedingungen?
Oder geht es analog zu Sternchen,
Doppelpunkte?
Das habe ich mich auch gerade gefragt.
Das habe ich mir auch gerade gefragt.
Das habe ich zumindest in dem Beispiel nicht gefunden.
Deswegen habe ich ja eben probiert,
ob man da nicht jetzt irgendwie
zum Beispiel
Ich habe eine Idee.
Dollar Effect, ja aber das kommt wahrscheinlich gleich noch.
Weiß ich nicht, jetzt habe ich auch schon
Also
was man vielleicht machen kann ist
...
Wie sieht denn sowas hier aus?
Nicht wirklich.
Das wäre jetzt fast schon React.
Jetzt muss ich wahrscheinlich Klammer machen.
Das funzt.
Das funzt.
Das ist aber glaube ich nicht im Sinne des
Erfinders, oder?
Wenn man das so macht.
Das funktioniert.
Das ist aber glaube ich nicht so gedacht,
ehrlich gesagt.
Und das sieht auch schon ein bisschen hässlich aus.
Wobei man immer noch sagen muss, man versteht,
man versteht tatsächlich ganz gut,
was von uns passiert.
Also alles in allem,
das hat ja für sehr viele Diskussionen
und Kontroverse gesorgt.
Am Anfang von 2005, von der Ankündigung.
Ich fand es auch am Anfang doof.
Aber
es ist schwer zu beschreiben.
Kennt ihr das? Ihr habt so einen,
als Programmierer oder auch als Admin
oder generell als jemand, der in IT arbeitet,
hat man so einen gewissen inneren
Ordnungssinn.
Man hat bei Sachen, die richtig aussehen,
ein gutes Gefühl. Wisst ihr, was ich meine?
Und ich habe,
wenn ich die Svelte 5 Sonntags sehe,
das bessere Gefühl.
Als bei der 4er.
Die 4er ist so Magic
und du erkennst
vom angucken her,
nicht genau, es sei denn du kennst Svelte gut,
was es macht.
Wohingegen du die Svelte 5 Sonntags
anguckst und dir eigentlich sofort klar ist,
okay, hier passiert irgendwas mit.
Vielleicht weißt du nicht hundertprozentig genau, was es ist.
Aber du siehst schon mal, okay,
das ist keine normale Variable.
Also ich muss sagen, ich finde das Svelte 5 besser.
Findest du, dass Svelte 5
weniger intuitiv aussieht?
Ich finde, es ist viel eindeutiger,
was es macht.
Ja, nimm Svelte.
Svelte ist nice.
Es gibt schon ein Releasedate, irgendwann 2024.
Ach ja, und
ein weiterer Nachteil ist natürlich
von der Svelte 4 Geschichte,
dass Svelte
alles, was du hinschreibst, irgendwie
retten muss.
Und hier nur das, was du explizit markierst,
als dass es getrackt werden muss.
Also ich glaube, das hat
mehrere Vorteile. Über die, sagen wir so,
was schöner ist, kann man sich sicherlich drüber streiten.
Auch was intuitiver ist, kann man sich
sicher drüber streiten, ja.
Ich persönlich kann das Svelte 5 Sache
tatsächlich mehr abgewinnen, jetzt nachdem ich mir das
ein paar mal angeguckt habe, als das
Svelte 4 Sache. Aber es wird
auch handfeste Vorteile haben.
Bei bisschen größeren Anwendungen.
Ich glaube nicht, dass sie das einfach
ganz vor Fun gemacht haben.
Ich kann euch nicht sagen, was, weil ich keine größeres
Weltanwendung irgendwie betreue.
Aber ich gehe davon aus, dass es noch weitere Vorteile haben wird.
Und nicht nur, dass es schneller ist.
Wobei das bestimmt auch eines der Punkte
sein wird.
Die Seite zeigt ja nur an, was der Unterschied ist,
und nicht, was sie sich dabei gedacht haben.
Da müsste man irgendwelche Blogposts lesen.
Ja, wie zum Beispiel hier, das da.
Ok, gucken wir mal weiter.
Also so sieht das mit Variablen und State aus.
Ich bin mal gespannt,
was sie bei, was sie mit
mit Stores
jetzt machen.
Weil ich habe im Vorfeld schon gelesen, es gibt
keine Svelte Stores mehr.
Stores war, um es kurz zu erklären,
Stores war eine Möglichkeit
ins Welt, Variablen
anwendungsweit zur Verfügung zu
stellen. Quasi global Variablen.
Also quasi sowas
hier, nur global.
Was durchaus sinnvoll ist,
zum Beispiel, stellt euch vor,
euer User lockt sich ein,
und ihr braucht den Username
auf mehreren Unterseiten,
in mehreren Unterkomponenten.
Wie wollt ihr das
sharen?
Und da hast du dann
beispielsweise einen Svelte Store gemacht,
der war dann anwendungsweit verfügbar,
und du konntest das in jeder Komponente importieren,
und dann konntest du auf den Username zugreifen.
Das gibt's jetzt nicht mehr,
habe ich gelesen. Moin, Sarix.
Also, weiter geht's. Update State,
Computed State, haben wir uns jetzt auch schon
angeguckt. So,
Templating.
Geht's jetzt weiter.
Minimal Template.
Da ist
legit kein Unterschied.
Styling. Da ist
auch kein Unterschied,
oder?
Seht ihr da einen Unterschied?
Ne, ich seh keinen Unterschied.
Loop.
Seh ich auch keinen Unterschied.
Ach ja, und übrigens, eines der coolen Sachen
ist, ich hab's am Anfang ja schon gesagt,
weil jemand gefragt hat, man kann
Svelte 4 Syntax auch in Svelte 5
benutzen. Man kann bloß nicht
alles mixen und matchen, wie man will.
Loop ist das gleiche.
Event-Click.
Ah, das ist
nicht das gleiche. Also, einmal hier
die State-Geschichte, aber auch
OnClick.
Jetzt bin
ich irritiert.
Ist das nicht hier der normale Vanilla
Plain JavaScript
OnClick-Händler von einem Button?
Also, wenn ich Button
Klick schreibe in Plain JavaScript,
dann sieht das genauso aus.
Anscheinend haben die ihre eigene
Event-Syntax
in die Tonne gekloppt jetzt.
Das ist in der Tat recht interessant.
Also, das müssen wir mal ausprobieren.
Also sprich, das sollte jetzt funktionieren.
Ah, es
funktioniert beides noch, okay.
Hätte das denn auch funktioniert
in der alten
in der alten Schreibweise?
Okay, genau so. Ja, das
ist anscheinend das eine nicht vom anderen abhängig.
Okay, es geht jetzt
beides. Man
kann jetzt, also wahrscheinlich sollte
man, sollte man jetzt das neue verwenden.
Man braucht keine spezielle Event-Syntax
mehr ins Welt, sondern
kann einfach die Build-In
Das ist, gut, ganz ehrlich,
da würde ich einfach sagen, das ist grundlegend einfach
mal besser. Warum eine extra Spezial-
Syntax, wenn man auch, weil man auch die
Build-In-Syntax benutzen kann. Die Frage ist
jetzt viel eher, gehen damit auch solche
Sachen wie, oh, was war das? Prevent?
Oder, oh, fuck, das weiß ich nicht mehr.
Svelte, Prevent, Default,
gab's doch irgendwie so ein On-Click.
Ja, Prevent,
Default konnte man in Svelte machen.
Geht das jetzt hier auch?
Ah, das geht nicht. Und das geht nur noch so?
Jetzt bin ich
unschlüssig,
ob das neue jetzt so viel geiler
ist, weil man die Modifier nicht mal verwenden
kann. Aber habe ich
zu wenig Beispiel von gesehen jetzt.
Keine Ahnung.
Aber die braucht man auch relativ selten. Braucht man eigentlich hauptsächlich
Performance und solche Sachen.
Finde ich aber gut, dass man jetzt normale
Event-Händler-Syntax
verwenden kann.
Anstatt, dass man Doppelpunkt braucht.
Was macht Prevent-Default?
Wenn ich dir sage,
dass Prevented das Default-Verhalten
sagt dir das wahrscheinlich nichts.
Stell dir mal vor, du hast eine Form mit einem Submit-Button.
Der Submit-Button macht
standardmäßig ein Post-Request gegen
den Server. Wenn du das nicht willst, brauchst
du Prevent-Default.
Wenn du sagst, type
submit und du
klickst hier drauf. Achso, Moment, das ist ja nicht
innerhalb von einer Form.
Wie geht das?
Form?
Ich bin kein JavaScript-Hacker, man.
Also, er macht jetzt
Server-Requests, wenn du das hier ...
Ich weiß gar nicht,
wie das funktioniert.
Ja, guck. Genau.
So.
Der Default-Verhalten von so einem Button
ist, dass er einen Post macht
auf den Form-Endpunkt.
So, und wenn du jetzt sagst hier
onClick
Prevent-Default
Achso, ich brauch einen Händler, ja.
Dann macht er nix mehr.
Dann führt er nur noch mein Event aus
und macht kein Post-Request mehr.
Wenn ich Prevent-Default weg mache,
dann schickt er das.
Dann schickt er wieder ein Post-Request.
Also, das braucht man bei so Sachen wie beispielsweise
Submit-Buttons in der Form und sowas.
Kommt nicht oft vor, dass man's braucht.
Aber wenn man's braucht,
ist man froh, dass es da ist.
Gut, anscheinend kann man in Svelte 5
jetzt die normale Event-Syntax verwenden
von Buttons. Okay, das ist doch schon mal
auch nicht verkehrt.
Das heißt, wenn man onClick definiert, wird das Default-File
immer nicht überschritten. Ne.
Tatsächlich. Ja.
Ja, so ist es.
Nur wenn du onClick
definierst, heißt das nicht, dass er das nicht
Default macht.
Du könntest in der Funktion selber,
du kannst ja auch noch sagen, Event
Event
Prevent-Default.
Das würde auch funktionieren.
Guck, jetzt macht er's auch nicht.
Das ist quasi ein Short, Shortcut
dafür, dass du's
selbst im onClick überschreiben musst.
Find ich eigentlich ganz nice, dass das
gibt. Gibt's übrigens in Vue auch.
Ich geh mal davon aus, in vielen anderen Frontend-Frameworks
tut das, wird das auch so funktionieren.
Okay, also, jo.
Kann man jetzt, kann man jetzt verwenden.
Alles gut. Nice.
DOMREF. Oh, das ist eine ganze
Ecke kürzer geworden.
OnMount.
Ah.
Guck mal, es gibt keine
Lifecycle-Events mehr. Kann das sein?
Also, bisher hat man
ins Welt, beispielsweise, wenn man, wenn
die Komponente
eingehängt wird in dein HTML
Element, äh, in dein, in dein
HTML-Baum, konnte man
beispielsweise bei OnMount
einmalig was ausführen lassen. Also,
stellt euch jetzt mal vor, ihr habt
ein Formular
und ihr wollt, dass dort
sobald das eingefügt wird
in die Webseite
die erste, die erste Zeile
Input
fokussiert wird.
Dann hättet ihr das früher so machen
müssen. OnMount und dann
InputElementFocus.
Und damit man auf das InputElement
referenzieren kann, musste man das
quasi hier so binden dran. Das, das
ist übrigens, das, das fand ich damals
schon übelst umständig. Anscheinend
immer noch das gleiche. Und jetzt gibt
es wohl Effect oder DollarEffect, was
mich ein bisschen an React erinnert, ja.
Dollar, ach, ist DollarEffect
sowas wie, wie früher
Doppelpunkt?
DollarDoppelpunkt? Also,
machen wir hier DollarEffect.
Dann kann man da einfach,
probieren wir mal, lock.
Und jetzt immer, wenn sich
Count ändert, wird das gelockt.
Ah, ja. Okay.
Also DollarEffect.
Das heißt, im Endeffekt
Doppelpunkt, also
DollarDoppelpunkt
ist das alte
Effect, beziehungsweise Effect ist das neue
Doppelpunkt, äh
DollarDoppelpunkt.
Ja, da kann man sich jetzt drüber streiten,
was da geiler ist.
Ich denke mal, im Endeffekt ist Effect
wahrscheinlich
weniger Magic.
Weil,
wenn du's Welt nicht kennst, hast du keine Ahnung, was DollarEffect ist.
DollarDoppelpunkt ist.
Auf der anderen Seite, jeder, der sich fünf Minuten mit's Welt beschäftigt hat,
wird DollarDoppelpunkt
kennen.
Ansonsten ist es einfach nur ein bisschen mehr.
Aber ich bin da auch nicht
tief genug drin, um die Unterschiede jetzt
so direkt rauslesen zu können.
Zumindest ist DollarEffect
anscheinend jetzt das gleiche, wie
DollarDoppelpunkt.
Okay, warum nicht?
Gewöhnt man sich auch dran.
Ich persönlich find's gut.
Ich finde, es ist weniger Magic.
Und ich gehe ganz stark
davon aus,
dass das
absichtlich gemacht wurde, weil's auch nicht
nur die, wie soll man sagen,
die Optik hier im Sourcecode
verbessert, sondern
auch anderweitig Vorteile hat.
Sei es nur Performance.
Gut, DOM-Referenz vom Element müssen wir uns nicht angucken.
Das funktioniert noch genauso wie
in der alten Svelte-Version.
Du definierst ne Variable.
Die machst du jetzt witzigerweise mit let
und nicht mit state.
Weil's kein state ist.
Weil's einmalig
reingeschrieben wird und dann war's das.
Aber dass es OnMount nicht
mehr gibt, find ich schade. Wobei ist die Frage,
gibt es denn OnMount auch gar nicht mehr?
OnMount? Doch, gibt es immer noch.
Also kann man
immer noch verwenden, wenn man will.
Der Unterschied ist jetzt halt hier,
dass
guck, der Unterschied ist halt hier,
dass DollarEffect
jedes Mal
ausgeführt wird.
Und DollarMount wird nur einmalig
ausgeführt,
beim Einhängen der
Komponente.
Ja, das ist aber dann
ein doofes Beispiel.
Es gibt ja durchaus Sachen, die man einmalig
nur machen möchte und nicht bei jedem Mal ändern
von der Variable.
Zum Beispiel initial irgendwie was runterladen
von irgendeiner API oder so.
Aber wisst ihr, ich glaube
auch eines der Änderungs-
Gründe, warum die so viel geändert
haben ist, dass Server-Site-Rendering
besser funktioniert.
Was ich ja bei SvelteKit sehr, sehr selten benutze.
Ich glaube, das liegt auch
mit daran.
Weil das waren hier so Dinger, die sind nur im Browser
gelaufen.
Und da weiß ich nicht, wie es hier ist. Ob das
dazu beiträgt, dass du die Seiten schon besser
vorrendern kannst, bevor du sie initial
auslieferst.
Kein Schimmer.
Aber zumindest muss man doch mit Effect auch irgendwas,
dass es nur einmalig
ausgeführt wird. Es wäre doch blöd, wenn das
nicht funktioniert.
DollarState, ja das haben wir gerade schon ausprobiert.
Ja, Effect.
ToRunSideEffects.
Ja, das haben wir auch
schon gecheckt. Wow!
Jetzt wird es aber advanced hier.
Aha!
So macht man jetzt OnMount.
Okay, das ist komplizierter als früher.
So, also entweder
kann man Effect benutzen, so als
jedes Mal ausführen.
Wenn sich der Value ändert.
Oder man kann einen Callback
zurückliefern.
Ne.
If a Callback is provided, it will run.
Immediately before the Effect reruns,
be when the Component is
destroyed.
Hä?
Da kann man irgendwie...
Hä?
Da kann man doch irgendwie aufräumen lassen
oder so danach.
Okay, das wird man...
Okay, guck, das ist das, was ich schon
vermutet habe. Das replaced
Dollar-Doppelpunkt.
Effect only run in browser, not
during server-side rendering.
Aha.
Untrack. What?
Effect pre?
Das wollen sie es aber wissen, ja.
Okay, da muss man im Ursprungs
nochmal wissen. Aber ich sehe jetzt noch nicht,
wie sich Effect... Die schreiben mir was von
OnMount, aber ich sehe jetzt nicht, wie sich
damit OnMount ersetzen kann.
Gibt es hier vielleicht
irgendwelche...
Ne. Ja, keine Ahnung.
Ich dachte, vielleicht gibt es
irgendwelche Effect-Arcs
oder so, aber das ist undefined.
Ja, keine Ahnung. Weiß ich nicht.
Also...
Ich wüsste jetzt nicht, wie ich damit
OnMount ersetzen soll.
Wenn die Variable
untrack ist...
Ja.
Aber was soll untrack?
Aha!
Oh, das ist aber schon ziemlich magic,
oder? Also würde ich jetzt sagen
untrack count?
Ne. Hä?
Das macht es schon ein bisschen komplizierter.
Ach so, da muss der Callback
dann rein. Also im
Endeffekt...
Oh, das ist ja...
Hä? Was ist denn das, Mann?
Und jetzt kann ich
sagen, lock count...
Und das ist jetzt quasi der Ersatz für OnMount.
Guck, jetzt wird es nämlich auch
nicht ausgeführt.
Jetzt wird es auch nur einmalig.
Ich weiß
ja nicht.
Ich weiß ja nicht. Ganz
ehrlich, da ist
OnMount doch schon irgendwie
die schönere Variante, oder? Was denkt ihr?
Ich meine, OnMount ist vollkommen
klar, was passiert. Wird einmal beim
Einhängen der Komponente ausgeführt und
ja, zum Glück gibt es OnMount noch. Aber
das ist doch echt ein bisschen durch die Brust
ins Auge.
Aber es hat auch
seinen Vorteil,
wenn ich irgendwo mal auf
einen State zugreifen
möchte, innerhalb von
Effekt, will aber nicht,
dass durch diesen State
getriggert
jedes Mal die ganze Funktion
läuft, dann ist untrack
sinnvoll.
Weil das war tatsächlich
ein Problem, wenn man die alte
syntax verwendet hat. Also
mal angenommen,
wir machen jetzt mal ein sinnloses
Beispiel, mal angenommen, ich wollte
jedes Mal, wenn sich count ändert, count
ausgeben, aber zusätzlich
wollte ich auch noch name ausgeben,
dann wurde jetzt bei jeder
Änderung von name und bei jeder
Änderung von count das ganze getriggert.
Und jetzt würde ich dann quasi sagen
untrack an der Stelle,
ja gut, so an der Stelle,
und jetzt wird das nicht
jedes Mal ausgeführt, wenn sich count
ändert. Das macht durchaus
Sinn, dass es das gibt.
Okay, ja, okay, leuchtet
ein. Also es gibt keinen direkt
Ersatz für Dollar-Doppelpunkt.
Weiß ich noch nicht.
Sie haben auch viele Verbesserungen
für Server-Site-Rendering drinne. Ich gehe
davon aus, dass es da schon einen Ersatz für gibt.
Hallo Max, bist du am merken? Ja,
ich bin gerade in deinem Twitch-Account drinne.
She baited. Eigentlich habe ich die Chat-Nachricht selbst
geschrieben. Oh man, wir brauchen
die richtige. Jetzt.
Okay. Wobei ich ja mittlerweile
die Variante bevorzuge.
Alter, ich bin müde, warum?
Weil es ist 17.33 Uhr,
kekwait. Okay, also
lasst uns mal weiter gucken. Event-Click.
Das hatten
wir schon. DOM-REF hatten wir auch schon.
Conditional. Okay,
was ist der Unterschied?
Const-Traffic-Lights.
Okay,
das ist State, das hatten wir schon.
Es ist nicht mehr
Dollar-Doppelpunkt, sondern es ist
Derived.
Und Click ist
anders. Und der Rest ist gleich.
Ja, das Beispiel, keine Ahnung.
Lifecycle.
Ah, ja.
Aber das Beispiel ist doof.
Weil, wie wir jetzt gerade schon gelernt haben,
ist OnMount nicht exakt
äquivalent zu Dollar-Effekt.
Sollte sich
nämlich
Page-Titel ändern,
dann wird das hier neu
ausgeführt.
Und hier nur einmalig beim Seite laden.
Beziehungsweise beim
Komponente einfügen.
Also das Beispiel ist
nicht richtig, was hier steht.
OnUnmount.
Ah, ja, gut. Guck, hier sieht
man das, was wir eben gelesen haben in der Hilfeseite
von Effekt.
Wenn auch super umständliches Beispiel.
Aber okay, man kann
eine Funktion zurückliefern und die wird dann quasi
so als Cleanup ausgeführt.
Das finde ich gar nicht schlecht.
Aber ich meine, seriously,
warum nicht einfach OnDestroy verwenden?
Ich finde das deutlich
wahrer als Effekt
für OnMount und
OnDestroy. Aber es bleibt
ja weiterhin drinne. Man kann es ja weiterhin verwenden.
Also für solche Sachen werde ich
weiterhin OnMount und OnDestroy verwenden.
Das finde ich unnötig kompliziert hier.
Hier versteht jeder,
was passiert, oder?
Und das war ja auch mein Argument für die andere Sache oben,
dass man in der Welt 5
das besser versteht, was passiert.
Aber hier versteht man eindeutig die 4er-Version,
wie sie es schreiben, besser.
Was passiert, wenn die Komponente quasi rausgeschmissen
wird aus der DOM?
Dann wird ClearInterval ausgeführt.
Und hier, hä, what?
Werde ich weiterverwenden.
12.5, ja. Wir gucken uns gerade Unterschiede an.
Also finde ich das hier schöner.
Okay, was geht weiter?
Component Composition.
Import User Profile.
Okay, importiere nochmal Svelte-Komponente.
Weiß nicht, ob du schon gesagt hast,
aber das ist 1 zu 1
UseEffect aus React.
Ne, das habe ich noch nicht gesagt.
Und ich weiß auch nicht, ob es so ist.
Weil ich bin kein React-User.
Ich habe
keine Ahnung von React.
Was genau ist hier der Unterschied? Nichts, oder?
Genau das Gleiche.
Was? Emit to Parent. Ah, Event Handling.
Okay. Ach stimmt, da gibt es ja
noch eine zweite Datei, tatsächlich.
Oh, das sieht tatsächlich
anders an. Anders aus
jetzt.
Was haben wir denn hier jetzt? Export
Let Name
Page Favorite Color is available.
Da unten drunter
der Kram ist alles gleich.
Und jetzt, was ist das?
Const?
Ne.
Okay, das finde ich jetzt auf den
ersten Blick
irgendwie
unintuitiver.
Das hat aber bestimmt auch seinen Sinn.
Wahrscheinlich kann man jetzt einfacher
Properties durchreichen oder sowas.
Aber das sagt mir jetzt ehrlich gesagt
nicht zu.
Lasst uns das mal ausprobieren.
Irgendeinen Vorteil muss das Ganze ja haben.
Legen wir mal eine Komponente an.
Irgendwas Kleines.
Das ganze Lib.
Wie machen die coolen Leute
unter Lib einen Components-Ordner?
Oder? Wie machen das die coolen
Svelte-Leute?
So, machen wir jetzt hier
keckel.svelt
Bestes Svelt-Komponente überhaupt.
Die kann nur eine Sache ausgeben, nämlich
keckel. Und das binden wir jetzt
in unsere Page ein.
Und zwar
hier oben drüber, keckel.
Oh ne, Visual Studio Code hat's
mal wieder nicht gecheckt, Mann.
Warum ist Visual Studio Code
so pepega teilweise? Reicht das, wenn ich
reloade? Oder muss das
groß geschrieben sein? Das muss groß
geschrieben sein, gell?
Oder nicht? Bin mir jetzt gar nicht sicher,
wo das hin muss.
Import
from
underlib?
Muss das groß geschrieben sein?
Oh ne, wie funktioniert
das jetzt nochmal?
Achso, ah ne, das muss man nicht.
Ah, okay.
Keine Klammern.
Dann funzt das auch.
Warum erkennt
Visual Studio Code das nicht?
Ja, da ist es doch.
Und stylen wir das
jetzt mal. Super high IQ.
Styling.
Style.
Color.
Color.
Color.
Brown.
Red.
Und jetzt machen wir da mal eine H2
draus, dann ist schön fett.
So, unsere Keckel Component ist am Start.
So, und was
kann die jetzt? Was kann die jetzt
exportieren? Das muss ich jetzt versuchen mal zu checken.
Also früher
hätte ich da jetzt
gesagt, okay.
Früher hätte ich gesagt, Script
script und jetzt export let text zum beispiel default text ist keckel und hier ändern wir
jetzt den text den wir übergeben ja das funzt so jetzt kann ich das ganze hier drinnen überschreiben
ich kann jetzt zum beispiel sagen text ist jetzt nicht keckel sondern lul und dann steht da lul
drin so und was ist jetzt der vorteil von dieser komischen geschichte hier also wenn man darf das
nicht mischen ok also anstelle also anstelle von export let sage ich jetzt text gleich sowas hier
sondern funzt wieder aber was ist jetzt der vorteil davon oder dass es komplizierter ausschaut
und
das check ich nicht was bringt das jetzt guck mal doch mal ok props to declare komponent props
use the props rune ok ja haben wir gemacht dass du alle props in einem projekt in einem objekt ja und
was interessiert mich das ob ich jetzt fünf exports untereinander schreiben oder das hier geklammert
macht doch für mich keinen unterschied aha ok ok ok you can use familiar destructing syntax
should have props in case
ja gut das ist ja sehr sagen wir mal nische jetzt das man schlüsselwörter dass man quasi
pop namen wie schrüsselwörter braucht aber okay gut dass to get all properties used 그랬onds
so
ok das ist glaube ich ganz nice gj
nice. Da bin ich
mir jetzt, also ich glaube, das ist ganz
nice. Da kann ich jetzt zum Beispiel
sowas hier machen.
Rest, nennen wir es mal. So.
Okay, okay.
Und mal angenommen, ich übergebe jetzt hier sowas wie
optional, ja, irgendwie.
Ich übergebe jetzt sowas wie, wie
onClick. Okay, ich glaube,
das ist tatsächlich sehr nice.
Ich übergebe jetzt onClick.
Count
plus plus.
So, und in diesem Rest ist
jetzt, so mal angenommen, ich habe jetzt hier
drinnen, wir machen das mal weg.
Ich habe jetzt hier drinnen einen Button, wir kopieren uns mal
den Button.
Ich habe jetzt hier drinnen einen Button
und
der kriegt jetzt, ja, wie mache ich denn das?
Dollar, Dollar, Rest
vielleicht? Ne, what the fuck?
Ops, so?
Rest?
Ne.
Einfach so?
Ne. Ah, ich habe gedacht,
das funktioniert.
Das sind Runes.
Ne.
Ich dachte, so funktioniert das.
Das wäre nämlich nice, wenn man das machen könnte,
aber so.
Also man kann es destructen.
This replaces export, let
export, ja, ja.
Was hat der gesagt?
It also replaces dollar, dollar
props and rest props.
So richtig checken
tue ich sein? Also,
wisst ihr,
wisst ihr, was ich jetzt eigentlich dachte ist?
Man kann so quasi Sachen durchreichen an Child-Elemente innerhalb dieser Component, ohne, dass ich jeden Mist extra definieren muss.
Das ging vorher auch schon, war aber vorher ein bisschen.
Ach so, ja, weiß ich nicht.
Was ist mit der Chat, als er da immer bist?
Alter, ich kann ja mal hinschreiben, ich glaube, what the fuck?
Ah, das Funst.
Nice!
Ja, das ist cool!
Das ist cool!
Okay, das gefällt mir, das hat was.
Ich mache mal kurz hier unten den Kram weg.
Guckt mal.
Äh, Moment, okay, count,
count muss ich da lassen, ich mache mal nur den Button weg.
Ja, das ist in der Tat jetzt wirklich nice.
Also, nur mal zur Erklärung.
Guckt mal.
Ich übergebe hier,
das kennt er jetzt natürlich nicht, oder?
Weiß der, dass ich on...
key oder so?
Weiß der, dass das in einem Button sitzt?
Ist der so schlau?
Also, guck mal, ich übergebe hier,
als Property gibt es Text.
Text ist das einzige, was ich definiert habe.
Aber ich kann auch onClick zum Beispiel übergeben.
Und onClick hänge ich dann hier unten drunter an den Button.
Das heißt, ich kann jetzt hier alles durchreichen an den Button in der Component.
Also, auch sowas wie,
ja, onClick,
keyDown und solche Sachen.
Das ist cool.
Das finde ich ganz nice.
Kann ich auch sowas durchreichen wie class gleich?
Class gleich?
Ähm,
ja, keine Ahnung.
Hallo?
Red?
Nee, das funktioniert nicht.
Das liegt aber bestimmt daran, weil das irgendwie, äh, reserved ist.
Das, das funktioniert bestimmt auch irgendwie,
wenn man es gescheit macht.
Aber, aber nicht, aber nicht direkt.
Aber Moment, das ist ja auch nicht class.
Style will ich durchreichen.
Das Funst, ja, das ist cool, dass das geht.
Das gefällt mir in der Tat ganz gut.
Da kann man, da kann man quasi jetzt auch
Komponenten stylen, wie man das in View machen konnte.
Ohne, ohne Trick 17.
Das finde ich gut.
Das gefällt mir.
Ja.
Ja, das hat was.
Das hat was.
Das ist eine gute Änderung.
Also, ich werde immer noch nicht so ganz mit dieser Syntax da oben warm, ehrlich gesagt.
Aber das gefällt mir.
Das, das ist cool.
Was schreiben die sonst noch so?
Oh, nix weiter, oder?
Das wird, das wird gebaut.
Gar nix.
Wir gucken uns die Unterschiede zwischen 12.5 und 12.4 an.
Ups.
Nee, das gefällt mir.
Das ist nice.
Das ist nice.
Dass man das so durchreichen kann.
Ohne, vor allem durchreichen kann, ohne irgendwelche Magic Sachen.
Es gab ja vorher auch schon so komische Dinger hier.
Aber das ist jetzt relativ klar.
Du siehst hier oben, okay, Reste, restliche Sachen stecken hier drin.
Und hier werden die dann quasi destructed.
Sehr nice.
Das ist eine gute Sache.
Das gefällt mir.
Okay.
Also, proper.
Ja, und ansonsten, hat das sonst irgendwelche Vorteile?
Nö, oder?
Einfach, dass es ein bisschen hübscher ist.
Wobei, das hier, da kann man sich jetzt echt drüber streiten.
Also, ich muss sagen, Export Let.
Finde ich.
Optisch schon etwas schöner als so, wie es jetzt ist in 5.
Aber das Destructing finde ich tatsächlich in 5 sehr nice.
Ja, gut.
Da muss man sich dran gewöhnen.
Es ist aber nicht so eine große Umstellung wie damals von View 2 auf View 3,
wo gefühlt alles anders aussah.
Man konnte zwar das alte noch verwenden, aber keiner wollte es.
Übrigens, vieles davon ist ähnlich, wie sie es auch in View 3 gemacht haben.
Ja.
In View 3 heißt es ein, dann Use Ref und so Zeug.
Okay, nice.
Ah, das gefällt mir schon mal.
Emit to Parent.
Ich sehe keinen Unterschied.
Ach so, ich muss den Button gucken.
Oh, okay.
Ach so.
Jetzt ergibt das mit den Props noch einmal ein bisschen mehr Sinn.
Man kann quasi auch darüber logischerweise dann Events, beziehungsweise Funktionen austauschen.
Ja, das ist cool.
Wobei.
Warum ging das eigentlich im Alten nicht schon?
Ich hätte das eigentlich fast erwartet, das ging im Alten auch schon, aber anscheinend nicht.
Ja, also in, ins Welt 4, da kann ich mich noch dunkel dran erinnern, da musste man so komische Dinger hier machen.
Also wenn du, wenn du eine Custom-Komponente hattest und ich sollte ein Event werfen
oder auch nur, oder auch nur das Button-Event irgendwie durchreichen,
dann musste man das mit Create Event Dispatcher machen.
Okay.
Ja, also sprich, das, was wir hier gemacht haben, wir haben, wir haben quasi intuitiv das gemacht, was wir in dem nächsten Beispiel erklären.
Ne, keine Ahnung.
Odol mit.
Wir haben das, wir haben das nächste Beispiel schon vorweg gegriffen, ohne dass wir es gesehen haben.
Die machen nämlich genau das hier.
Guck mal.
Die reichen quasi Child-Elemente, Events, durch an die Parent-Komponente hier mit OnClick in dem Fall.
Also wir geben die Funktion da rein, aber das OnClick-Event kommt ja von.
Von dem Button hier in der Child-Component.
Und das ging anscheinend vorher nicht.
Vorher musste man wohl jedes Event, was man weiterreichen möchte von einem, ja quasi Nested-Element in der Child-Component,
musste man irgendwie explizit nochmal exporten.
Ja, das ist nice, dass das jetzt nicht mehr braucht, dass man das jetzt nicht mehr braucht.
Das finde ich schon mal viel besser so.
Dann nehme ich auch diese komische Prop-Syntax in Kauf.
Das finde ich cool.
Doch, das hat tatsächlich was.
Ein Stream ist super, das ist schön, dass ihr das gefällt.
Oder um nicht zu sagen, sehr, sehr.
Chat wieder super freundlich zu neuen Leuten.
Jaja, ich sehe es schon.
Ja, das ist gut.
Ich glaube, das werde ich ausgiebig benutzen.
Wenn dann Svelte 5.
Wenn der Fiat Champ irgendwann mal weiterentwickelt wird,
was er ja nicht notwendig hat, weil es sind ja keine Probleme bekannt,
wie man hier sieht.
Das ist alles Skill-Issues auf User-Seite.
Wenn er mal irgendwann weiterentwickelt wird,
dann, oh, guck mal, ich habe die 80 Sterne.
Nice.
Dann kriegt er Svelte 5 Frontend.
Nicht won't fix.
Ich brauche Hashtag Skill-Issue.
Es ist ja offensichtlich der User-Fehler, dass es keine AM64-Version gibt, oder?
Kann ich doch nichts für.
Wobei, jetzt so blöd es klingt, ich glaube, es gibt wirklich eine AM64-Version davon.
Moment.
Moment.
Ach, nee, gibt es nicht.
Okay, ich habe nichts gesagt.
Es gibt nur eine AMD64 und eine AMV7-Version.
Auf der anderen Seite.
Der kann doch ohne Probleme die AMV7 auf AM64 laufen lassen, oder?
Natürlich geht das.
Also, ich bin jetzt immer fest davon ausgegangen, dass das funktioniert.
Guck mal hier, gar nicht so wenige Downloadzahlen, der Fiat Champ.
13.000 Downloads hier.
Pog.
Leute, ich habe Hunger.
Ich muss mir gleich was zu essen holen.
Aber wir sind noch nicht fertig.
Wir können auch kurze Pause machen.
Ich esse was, wir gucken irgendwas und danach machen wir weiter.
Könnte man auch machen.
Pause Champ, sozusagen.
Real Life Pause Champ.
Eat, Eating Champ, ja.
Dinner Champ.
Okay, was ändert sich noch?
Slot ändert sich.
12.4 vs. 12.5.
Ich sehe keinen Unterschied.
Da müssen wir hingucken.
Funny Button.
Okay, ich sehe einfach, dass es größer, dass es länger ist.
Let.
Okay, was bin ich hier sehend?
Let Children Props?
Render?
But why?
Was ist der Sinn davon?
Also Slot ist bei Svelte quasi ein Platzhalter,
wo andere Komponenten, also andere Sachen eingesetzt werden.
Also ich kann zum Beispiel, ich zeige euch das mal.
Ich kann jetzt zum Beispiel hier sagen,
keine Ahnung, Div.
Da schreibe ich rein Slot.
Slot.
Und.
Jetzt kann ich in die Komponente, kann ich noch was reinschreiben, was dann in den Slot gerendert wird.
Zum Beispiel Keck W.
Guck, dann taucht das da drin auf.
Der rendert quasi das, was ich hier reinstecke in den ersten Slot.
Vorher konnte man nicht selektieren, wo was angezeigt wird, wenn es mehrere sind.
Doch, oder?
Du konntest doch Name Slots verwenden.
Du konntest sagen Name Keck W.
Und dann konntest du das irgendwie...
Fragt mich nicht mehr, wie das genau funktioniert hat.
Ich weiß jetzt nicht, wie man da...
Also, da bin ich jetzt überfragt, wie man das jetzt dort richtig rein gerendert hat.
Musste man dann hier irgendwie sagen Slot oder so?
Keck W.
Ja, so ging das, kannst du...
Aber, da verstehe ich jetzt den Sinn davon ehrlich gesagt nicht.
Slot Render.
Ja, if...
Ja, okay, okay, das leuchtet mir alles ein.
Aber...
Slot.
Da müssen wir uns jetzt mal...
Render.
Ja.
Snippets?
Ist hier drinne?
Äh.
Endhändler Functions?
Render.
Add Render.
Hier ist nix drinne.
Ah, doch, tatsächlich.
Okay.
Also, das Ganze ist wohl ein Bestandteil von Snippets.
Was auch immer.
Okay, Beispiel.
Snippets and Render Tags are a way to create reusable chunks of markup inside your Components.
Also, quasi kleine Subkomponenten in der Kompon...
Naja, ne.
Ne, nicht Komponenten.
Klein...
HTML...
Ja, Snippets halt.
Wiederverwendbare...
Ach, so!
Ich glaub, so langsam aber sicher check ich, worauf das rausläuft.
Ich könnte jetzt quasi sowas hier reinschreiben.
Und das irgendwie mehrfach verwenden.
Wie...
Wie referenziert man da jetzt drauf?
Also, hier.
Kein Slot.
Oder wie auch immer.
Wie referenziert...
Das muss ich auch mal durch...
Das könnte tatsächlich was Cooles sein.
If Image...
Snippet.
Ah!
Ach so!
Okay, das ist in der Tat doch ganz cool.
Ich checke noch nicht, was es mit Slots zu tun hat, ehrlich gesagt.
Aber okay.
Das ist in der Tat ganz cool.
Okay.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
Also.
ッ
Also.
Die Kette und die Olmキ forma.
Ay.
nichts macht und jetzt kann ich sagen ich will das mehrfach rennen dann an
unterschiedlichen stellen und wie adrender ok also adrender kecke da ist
es einmal und jetzt aha ok das ist nicht übel
das ist tatsächlich ganz cool ich habe jetzt ich habe jetzt wirklich
gerade nicht greifbar weil ich das gebraucht hätte aber ich gehe davon aus
wenn es das gibt man braucht es tatsächlich öfters das beispiel ist doch
gar nicht so schlecht guck mal die wollen beide male wollen
sie hier image sachen rennen einmal bei der bedingung und einmal die fault im
endeffekt einmal wenn das gesetz sind einmal das
findet wenn das gilt ok
heißt im endeffekt wenn ich beispiel
beispielsweise ich habe ich habe ein gutes ich habe gutes beispiel avatar
bilder zum beispiel ja avatar bilder avatar bilder braucht man mehrfach auf
der seite mit ein paar unterschiedlichen settings vielleicht und dann legt man
sich einmal hier das snippet für avatar bilder an und kann das dann rendern ja
irgendwie was weiß ich oben links in der komponente und dann irgendwie noch mal
in der mitte von der komponente was auch immer
ich habe gerade noch kein wirklich so richtig greifbares richtig gutes
beispiel für aber ich glaube das kann man gut verwenden
ich meine an der stelle ist es natürlich bescheuert was ich hier gemacht habe das
beispiel weil ich könnte genauso gut dass hier alles weglassen eine schleife
machen ja eine schleife machen fünf mal image rein passen da brauche ich brauche
ich kein mager was ist natürlich in der tat ganz interessant macht ist dass man
jetzt hier verschiedene parameter reinstecken kann
also ich kann beispielsweise hier parameter einstellen sie über name gibt
das default parameter bei javascript geht es im snippet höchstwahrscheinlich
ja gucken wir doch mal gucken wir doch mal sagen die ford name ist leer da
machen wir jetzt mal so wenn es welt
if not name dann kecke
okay name ist diplomatic ich glaube javascript spinnt spinnt einfach nur um
aber jetzt ist es weg ja okay oder alternativ will ich einfach ja neben
anzeigen ja das funktioniert guck mal wenn ich etwas rein schreibe dann wird
das gerendert und wenn ich nicht reinschreiben
also wenn ich irgendwas rein treibt mit das geredet und ansonsten wird das gar
das gerendert das ist wirklich cool vor allem kann man das jetzt mehrfach an der seite verwenden mir
fehlt leider so richtig gutes beispiel jetzt dafür aber ich habe so irgendwie das juckt so in den
fingern zu sagen so das ist sehr praktisch und was hat es jetzt mit slots replacement zu tun
snippet params can be destructed aber wieso ist welt wenn man auf
you nutzen kann warum benutzt review nicht react oder jquery oder solid oder knockout
js oder gar angular doch das gefällt mir das hat was snippet scope passing snippets zu
components das ist cool gut passt
ist im prinzip genau das was die was die mit slot slot ist ein sonderfall von passing snippets
zu components mit jquery 2024 noch maintained du wirst überrascht sein jquery wird nicht nur
maintained sondern es kam vor noch nicht allzu langer zeit sogar jquery 4 am start anstatt es
ist noch beta ja aber guck hier
6 februar 2024 jquery 4.0 beta das ist nicht nur maintained das ist noch voll active in development
doch das feature gefällt mir hier snippets and slots in zwelt 4 content can be passed using
slots snippets are more powerful and flexible ja man kann weiterhin slot verwenden finde ich
eine gute sache ich fand es erstmal jetzt unsinnig das ist so ein ding wisst ihr man neigt ja persönlich
immer dazu sobald man so was hier sieht zum ersten mal sagt man das will ich nicht warum
nicht so ist doch viel einfacher wenn man sich mal mit ist mit vielen sachen soja wenn man sich
damit beschäftigt ein bisschen reicht manchmal ein bisschen an der oberfläche zu kratzen sich
anzugucken warum das gemacht wurde ergibt das durchaus sinn also oftmals durchaus sind und
hier ist es genauso wenn ich mir die sache hier mit den snippets angucke finde ich das
sehr sinnvolle sache und dementsprechend verstehe ich auch dass slots deprecated
sind weil snippets ersetzen im prinzip slots meine weiterhin slot slot verwenden kannst
für einfach sein okay interessant gefällt mir wie geht es weiter kontext jetzt kommt der ersatz von
stores das ist vielleicht zu kompliziert jetzt für den user store get context create user store
okay was ist der unterschied get content ich will sie ich will sie nicht und was bin ich
okay das ist das eigentlich interessante es gibt keine stores mehr aber es gibt jetzt
punkt welt punkt js files um sowas ähnliches zu machen oder wird es da wird es aber langsam
abgedreht also eine kombination aus export function und state ist quasi ein replacement
für stores es gibt keine stores mehr auch eines der features was ganz viele leute
super toll ins welt fanden weil das schon eingebaut ist das heißt jetzt braucht man
keine stores mehr jetzt kann man das mit was mit get und set erinnert mich ein bisschen an java wenn
ich ehrlich bin das muss ich mal ausprobieren blip nennen wir das jetzt mal einfach store
nee nicht store store ist blödsinn
ja
um es egal wie ich es nennen will
create
create
create
state
state
punkt welt punkt ne
punkt welt ich kann es aber schnell
punkt js
hauen wir das jetzt mal
rein initial username bla bla bla
bla
so und jetzt importieren
importieren wir das ganze mal
create ja das funktioniert nicht
also brauchen wir jetzt hier
wie importiert man den kram
hier create
state from ja ich hätte es mal
anders nennen sollen blip
okay das hat funktioniert
okay das hat funktioniert
create users date
aber hier let blub gleich zur initial state
aber hier let blub gleich zur initial state
omegle lullen
omegle lullen
das ist erstmal testen ob das ersatz für stores ist also wenn es ersatz für stores ist
dann machen wir das mal das hier mal weg
das waren die ganzen kämpfe marke geht's ganzen krempel und mal weg brauchen jetzt alles nicht
das waren die ganzen kämpfe marke geht es ganzen kräften und mal weg von jetzt alles nicht
und on klick
und on klick
und on klick
ändern wir jetzt nicht count die kommen wir machen hier wir machen hier eins rein ja und
wir ändern das anklick das geht ihr muss den dollar davor machen ms markt count
