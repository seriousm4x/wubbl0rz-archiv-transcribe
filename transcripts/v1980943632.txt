Was ist mit meinem Startmenü?
Leute, mein Startmenü ist kaputt.
Mein Startmenü ist broken.
Wie kriege ich das wieder gefixt?
Alter, mein Startmenü ist kaputt.
Keck, wait.
Mach schon mal die VM an.
Vielleicht
fixt sich das gleich von allein.
Hoffe ich mal.
Mein fucking Startmenü ist kaputt, man.
Chat,
habt ihr schon mal ein kaputtes Startmenü?
Dann mach ich mal ein bisschen was entspannteres machen.
Okay, Leute, mein Startmenü ist kaputt.
Ich kann nix mal starten und nix mal reintippen.
Ja, unter Linux
ist das kein Problem. Unter Linux geht das einfach.
Guck.
It's, it's.
Unter Linux wird es einfach
funktionieren.
Aber wie kriege ich das jetzt wieder gefixt?
Go Wizard, danke schön für den Sub.
Ein bisschen Go machen. Alter, was ist mit
meinem Startmenü los? Ein bisschen Go machen
wir heute auch. Okay.
Task Manager.
Kann man Explorer irgendwie abschießen oder so?
Okay, Explorer ist
weg. Hier.
YOLO Inject.
Klingt, als hätte ich irgendein Virus. Ist es aber nicht.
Das ist so ein Maushighlighter.
Hey,
es geht wieder. Nice.
Ja.
Super. Gut, dass es im Hintergrund läuft.
Aber.
Guck hier. YOLO Inject.
Das gehört zu
YOLO Maus.
Damit kann man, damit kann man
seinen Mauszeiger beispielsweise
in allen MMOs, wo das
heute viel zu klein ist, alles in der Mauszeiger zu klein
groß machen und rot färben und sowas.
Ganz praktisch.
Okay, mein
Startmenü funzt wieder. Das ist schon mal nice.
Jetzt ist es auch
blazingly fast, so wie das
heute sein muss.
Okay.
Wir machen mal Package-Updates in der
VRM. Dann zeige ich euch, was wir heute machen.
Also wir machen dort weiter.
Was will der denn? Wo wir das letzte Mal aufgehört haben.
Was möchte der hier denn jetzt? FFM-Pack.
Ja, okay. Gib ihm. Jawohl.
Halbes Internet runterladen.
Ach, Qt 6 ist raus.
Ich habe meine Zeit lang wirklich sehr interessiert
und fand das sehr spannend,
die neuen Qt-Versionen verfolgt, aber ich habe
schon ewig nicht mehr reingeguckt.
Die hatten tatsächlich jede Version irgendwas Cooles drin,
auf was man sich freuen konnte.
Ich frage mich aber, wie groß
die Verbreitung da in der aktuellen Zeit
noch ist.
Ich meine, von allen Cross-Plattform-Frameworks
auf dem Desktop wird das
wahrscheinlich eines der weitesten
verbreitetsten sein.
Jetzt bei Elektron und so außen
vor, aber wie weit die
Verbreitung insgesamt ist, weiß nicht.
Weil das ist halt hauptsächlich C++.
Man kann es aber ein bisschen peisend machen, aber letztendlich
kommt es bei Qt und C++ früher oder
später nicht rum und C++ ist halt einfach
der Sack.
Schon irgendwas Spannendes
von Black Friday gefunden.
Ich habe ehrlich gesagt auch gar nicht groß geguckt.
Ich habe, ich habe mal nach
SSDs geguckt, weil SSDs kann man nie
nie genug haben.
Ja,
ach, guck mal, Inhalationsgerät
Bäm, wie es
mir einfach, wie es mir einfach Copium-Gerät
vorschlägt hier.
Ja, ja, die Kinder sind voll glücklich,
wenn ihnen die Mama das aufsetzt.
Copium-Time.
Ansonsten es gibt halt nur Schrott, das gucken wir.
Vielleicht, vielleicht gucke ich mir
nachher mal.
Vielleicht, vielleicht gucke ich mir nachher mal.
Mal ne Runde an, wenn ich, wenn ich keinen Bock mehr auf Rast hab,
wenn mich Rast zu sehr aufregt.
Woow, woow, woow, woow.
Ganz ruhig, ganz ruhig.
Was für ein Smartphone verwendest du eigentlich?
Ein iPhone.
Also, um genau zu sein, zwei iPhones.
Ein iPhone
14, ist 15
das aktuelle?
Dann ist, ist, also
wenn 15 das ganz aktuelle Top, also
der erst letztens releast ist, dann hab ich ein iPhone
14 Pro, aber nicht Pro Max,
weil mir das zu groß ist das mit 120 hertz display und dann habe ich von der firma habe
ich noch ein iphone 12 aber benutzen tue ich eigentlich fast ausschließlich wenn ich was
mache außer ich muss für die firma irgendwas gucken das iphone 14 wir haben erstaunlich viel
apple zeug wir haben drei ipads dreieinhalb iphones im einsatz hat zwei personen 0w aber
android-geräte habe ich auch noch ein paar ich sage halt immer es ist sinnvoll das zu
verwenden wo das jeweilige system seine stärken hat ganz ehrlich wenn das iphone
2 11 gut funktioniert und wie schnell genug ist warum feature
management
tut sich doch die letzten jahre über eh nicht viel guck mal ich mein wenn das meiste worüber
du ausflippen kannst irgendein komischer neuer side button ist das sagt doch schon mal alles
daraus wie sinnvoll das upgrade ist ich meine ich hätte den auch gern den neuen action button aber
es ist wirklich nicht wert da irgendwie 1000 plus euro auszugeben und 70% batterie ja gut wenn die
batterie nachlässt aber muss das ding jeden tag aufladen insofern ob das jetzt bei 20 prozent
oder 30 prozent neu auslässt mann macht ja auch kein großer unterschied so alles Faculty silvier
renault
sozusagen
interaktion
aus
hacken
zeug
regular
zeska
raum
3 2 1
uzzit
wie mein i3 und es wird mir auf den keks gehen weil es kein i3 ist also insofern macht für mich
wenig sinn ja das kommt noch dazu wobei wobei das ja nun wirklich irgendwo noch gewöhnungs aber das
würde mir auch auf den keks aber das ist das ist gewöhnungs wenn du einwendungszweck für hast warum
nicht weil ich muss ich muss kann ein bisschen husten weil also keine keine sorge nicht monka
corona oder sowas in der richtung sondern ich habe hier direkt davor gerade noch meine runde
auf dem fahrrad gefahren also nicht real life sondern trainer daheim spiel zu spät jetzt gewesen
im dunklen kein bock außerdem ist mein fahrrad immer noch kaputt das kann ich fahren gerade die
versicherung hat übrigens immer noch nicht bezahlt das fahrrad ich habe zum ersten mal versucht hat
er jetzt eigentlich alles geupdatet ich habe zum ersten mal versucht auf zwift mit den 2 watt pro
kilogramm mit der 2 watt pro kilogramm gruppe mit
zu fahren da das ist echt gar nicht so ohne über 45 minuten für 50 minuten das ist ein das sind
das sind absolute einsteigerwerte jeder kack newt ist auf dem fahrrad besser als ich aber ich habe
angefangen mit mit ich glaube irgendwie 1,1 bis 1,5 watt pro kilogramm und habe sie letzten paar
wochen richtig reingetreten jeden zweiten dritten tag da bin ich schon mal zwei wacht pro kilogramm
über ein 2 watt pro kilogramm
heißt bei mir auch durchgehend 45 minuten 180 watt also da geht was ein rechner spielt immer
ab wenn ich wsl starte komischerweise ist erst seitdem ich meine ram vielleicht hast du kaputten
ramsig erwischt also rechner abschmieren ist so ein ganz klassisches zeichen von ram error es
gibt es gibt eigentlich zwei sachen cpu übertaktet und zu heiß und rahmenprobleme das sind so dick
die klassiker schlechthin warum der rechner komplett abkackt nur wenn wsl statt das ist
in der tat sehr merkwürdig da würde ich mir mal genauer die fehlermeldung angucken was er sagt
ob man da irgendwie auf wsl hindeuten kann ich meine wsl startet in der vm was auch immer das
sagt aber ich kenne mich nicht
die syntax ist grauenhaft guck dir das an man hier grauenhafte syntax leute lul weh guckt euch
guckt euch das hier an alter ich mein und das ist jetzt hier das ist noch hübsches das ist wirklich
noch relativ hübsches rust was wir gemacht haben hier das geht deutlich schlimmer glaubt mir
deutlich schlimmer ja also was ich mir überlegt habe für heute wir müssen gleich noch mal fünf
minuten schwätzen bevor es richtig los geht aber ich zeige euch schon mal was heute ansteht
und das ist ja auch schon mal so die kombination und ja da taktet sich dann runter aber gerade beim
übertakten wenn die cpu auch an den maximalen werten kratzt wird es dann schnell instabil im
vergleich zu wenn der auer um die ecke kommt mit flüssigstickstoff und das ding minus 150 grad ist
was für ein trainer ich habe ich habe ein
kicker core ohne ohne lüftung und ohne dieses hoch und runter fahrdingen einfach so ein ganz
normal die meine dinger sind teuer genug das einzige was ich gemacht habe für mein setup
hier daheim ist logischerweise mein fahrrad dran gemacht ja drauf drauf drauf gemacht also da muss
man die kette drüber machen und habe das auf eine matte gestellt dass wenn ich schwitze dass ich nicht
auf dem fußboden schwitze und ein handtuch hängt neben beim lenker das ist eigentlich mein
gesamtes setup und zwölft habe ich auf dem ipad laufen was neben dran steht auf meinem lenker
habe ich meinen iphone drauf das brauche ich da lasse ich ein bisschen musik laufen und die
companion app um es besser sehen zu können aber meistens auch im youtube und musik und sowas laufen
zu lassen einfach um zu gucken und mein garmin vorne drauf habe ich auch gepaart mit dem mit dem
app oder schwitzt fahre ich hin und dann kann ich nämlich für die app aufzeichnen weiß ich
gefahren bin und ich finde die an sich auf dem garmin viel angenehmer als auf der companion
app oder in svt selbst zumal man bei garmen mittlerweile ziemlich gut gibt es ein indoor
cycling profil und wenn man den gepaart hat mit seinem trainer ist es eigentlich recht
also windows windows support bin ich echt überfragt als freak danke für den sub
power
subscription
kann ich nur sagen sehr sehr und und moment ja also ich habe schon mal ein bisschen vorgebastelt
also ich habe das klonen uns das repo jetzt von von schritt ab nur limit xo danke für den
sub ich habe schon ein bisschen was vorgebastelt im prinzip ist es das gleiche was wir auch gebaut
haben nur ich habe ich habe mir das folgendermaßen überlegt bevor wir heute mit rust anfangen und es
funktioniert irgendwas nicht und ich habe gar keine ahnung wie ich am besten mache habe ich
die original web rtc library genommen und das ganze kurz in go gebaut und wir bauen quasi das
was ich in go gebaut habe nach in rust dann muss ich nicht so viel überlegen wie man es jetzt am
besten macht sondern kann mich hauptsächlich auf auf rast geduld konzentrieren deswegen wenn wir
einfach mal den ganzen camp lösen
dem was letzte gemalt wobei kommt wir löschen den nicht wir wir benennen den mal um und jetzt
klären wir das repo das übrigens public das könnt ihr auch klonen aber ich glaube nicht
dass dieses projekt irgendjemand was bringt der hat das auch letztens gemacht was ist das ja den
den kenne ich gucke ich nicht regelmäßig aber sagt mir was sagt mir was ich überlege gerade was also
Was sind so meine Lieblingsprogrammier-Channels so auf YouTube?
Also .NET gucke ich Nick Chapsas gerne.
Da merkst du auch, dass der Erfahrung hat.
Auch wenn er mir teilweise ein bisschen zu viel benchmarkt.
Der hat ja teilweise Zeiten gehabt, da war jedes zweite Video, ich benchmarke jenes und ich benchmarke das.
Dann gucke ich mir gerne die NDC-Konferenztalks an, wenn denn mal was Gescheites dabei ist.
In letzter Zeit war das oftmals der hundertste Aufguss vom gleichen Talk oder irgendwas, was mich, zumindest wenn es um Technik-Themen geht, echt nicht interessiert.
Und ansonsten, ich habe saumäßig viele subscribed und gucke.
Ich würde mal fast sagen, ich kenne die meisten Programmier-Influencer-Channels, Software-Entwicklung-Sachen auf YouTube.
Also deutschsprachig und vor allem englischsprachig.
Mir fallen jetzt aber so spontan, wenn ihr den Namen sagt, kann ich euch direkt sagen, ob ich den kenne oder nicht.
Mir fallen jetzt aber so aus dem Kopf gar nicht mal so viele ein.
Ein paar JavaScript-Leute gucke ich noch.
Wen ich auch gerne gucke, ist dieser CSS-Wizard-Typ.
Der heißt nicht CSS-Wizard, aber der macht immer Magic mit CSS.
Kevin irgendwas heißt er, glaube ich.
Den gucke ich teilweise ganz gern.
Da lernt man neues CSS-Zeug.
Ich weiß nicht, ja, kann sein.
Wen ich auch immer gerne geguckt habe, ist Academia Mind oder so früher, aber die machen wenig Videos in letzter Zeit.
Und wenn dann über Angular, und Angular ist halt wirklich Massive Weird Champ.
Also, nein, nein, nein, den meine ich nicht.
Nein, ich meine englischsprachig und der CSS-Zeug macht.
Aber CSS, YouTube, da gibt es nicht so viele, die CSS machen.
Ist da Kevin? Hast du nicht Kevin?
Ja, den hier, den hier, genau.
Den gucke ich noch ganz gerne.
Ich meine, du musst es erst mal schaffen, mit CSS-only 829.000 Abonnenten zu bekommen.
Also, das ist wirklich der absolute CSS-Checker, was das angeht.
Das gucke ich ganz gerne noch ab und zu.
Da ist man so ein bisschen up-to-date, was Frontend-Shit angeht.
Und ansonsten müsste ich jetzt mal auf meine Historie gucken.
Ich gucke, ich gucke.
Also, ich habe sehr viele Channels da.
Schon mal on und off geguckt und auch abonniert.
Aber ich gucke das immer so bei Bedarf.
Ach so, wen ich auch gerne gucke, ist...
Mein FireShip ist ja klar, den kennen wir alle.
Den gucke ich auch ganz gerne, wenn es um Svelte geht.
Der ist für Svelte-Sachen echt gut.
Wenn auch nicht so wahnsinnig.
Also, wenn ich sage, nicht so wahnsinnig hoher Output.
Jeder Channel auf YouTube hat mehr Video-Output als ich.
Ich, ganz ehrlich, ich glaube, er sagt bei Friends & Friends,
aber es könnte auch genauso gut sagen,
my Frontend-Friends.
Aber ich glaube, der sagt, hello, my Friends & Friends.
Der Scam-Journey ist vorbei, jetzt kann Bezos nicht ins Weltall.
Sädge.
Die Frage ist jetzt ja, ist es Sädge oder ist es Sätsch, wie das manche sagen.
Ich bin ja eindeutig für Sädge.
Sädge, genauso wie Bädge.
Weil es heißt ja auch nicht Bädge oder so.
Oder Soske-Agreedge.
Aber du kannst jetzt eigentlich davon ausgehen,
nachdem ich die letzten 13 Jahre nicht aufgehört habe,
werde ich auch nicht einfach random aufhören,
nur wenn mal irgendwie im Monat nichts hochgeladen wird.
Oder zwei.
Oder teilweise zweieinhalb, drei Monate.
Ja, oder ansonsten.
Es ist alles Mögliche.
Ich gucke das halt immer bei Bedarf.
Wenn ich gerade relativ viel Frontend-Zeug mache,
dann gucke ich halt JavaScript, CSS-Channels.
Wenn ich Microcontroller-Zeug mache,
gucke ich manchmal halt auch die einen oder anderen
Embedded-Channels.
Da gibt es Sachen und C++-Sachen.
Ja, leider, leider.
Und ansonsten halt irgendwie auch .NET und Go und Python,
je nachdem, was gerade angesagt ist.
So, aber ich zeige euch mal,
ich zeige euch mal, was wir heute versuchen.
Ach so, hat jetzt eigentlich er erklärt,
was das ist.
Ach so, App von Go in Rust umgeschrieben.
Ja, wobei meins, mein Beispiel, ziemlich klein ist.
Und glücklicherweise gibt es quasi einen,
also die Haupt-Library, die ich verwende in Go,
die gibt es quasi auch neu implementiert in Rust
von einem anderen Typ.
Das heißt, ich hoffe, man kann es relativ ähnlich machen
zu dem, wie es in Go ist.
Ja, Fireship gucken wir alle.
Ben Eater macht auch sehr nice Videos.
Was ich auch noch cool finde, was ich in letzter Zeit öfters gucke,
ist auch Simple Low-Code oder irgendwie sowas.
Hat mit Low-Code-Plattformen überhaupt nichts zu tun.
Der erzählt wirklich ultra abgefahrenen,
so Low-Level-Kram.
Weil, der erzählt dir dann sowas wie Virtual-Memory-Adress-Translation
funktioniert im Kernel und so ganze...
Wieso? Was ist mit Fireship?
Habe ich irgendwas verpasst?
Ich habe schon zwei, drei Wochen... War irgendwas?
Ach so, siehste? Siehste, habe ich gar nicht mitgekriegt.
Ja, ich mache meistens Sachen, auf die ich Bock habe.
Und dann baue ich damit irgendwas.
Und sobald es Probleme gibt,
wird gegoogelt, bis es die Probleme nicht mehr gibt.
Und gebastelt, gegoogelt und gebastelt.
Dann lese ich Sachen, die andere programmiert haben,
die andere gemacht haben.
Und versuche das halt so hinzubekommen,
wie es mir persönlich gefällt.
Ihr wisst ja, ich habe da so einen ganz speziellen...
Ich will nicht sagen Ordnungsanspruch.
Das ist falsch, weil ich bin nicht ordentlich.
Aber ich habe so eine ganz spezielle Vorstellung immer,
wie Sachen halt eben gut implementiert und gut gemacht sind.
Und so lange baue ich dann halt daran rum,
wie es mir gefällt im Endeffekt.
Und bis man halt eine Sache von neu bis ganz gut umgesetzt hat,
kann das durchaus mal zwei, drei Monate dauern,
bis man dann wirklich den Durchblick hat.
Aber dann hat man den Durchblick.
Und habe ich, glaube ich, schon mal geguckt,
sagt mir so spontan nichts.
Das sind die meisten Sachen, die mich persönlich interessieren.
Deswegen gefällt mir das Lernen einfach.
Ich glaube, ich war noch nie...
Ich meine, ich sage nicht nie,
aber nicht, dass ich mich jetzt so direkt erinnern könnte.
Nick, danke für den Zap.
...gezwungen, Zeug zu lernen,
also tiefgreifend und langfristig,
wo ich gar keinen Bock drauf hatte.
Also an Technik-Sachen.
Also wenn man jetzt von BWL-Zeug anfängt, dann schon.
Es ist nicht so, als hätte ich Bock auf BWL-Sachen gehabt.
Das Einzige, was wir mal gemacht haben, ist über Kobold.
Da hatte ich eigentlich überhaupt keinen Bock drauf.
Aber war dann trotzdem ganz lustig.
Ja.
Ich meine, was kommt als Nächstes dann?
Fortran oder so?
Also, Chatge, ich zeige euch jetzt mal...
Wir machen das einfach hier auf.
Ich glaube, da blickt man deutlich besser durch.
Ich zeige euch jetzt mal...
Prolo...
Oh, ja.
Und was kommt als Nächstes?
Ada, oder wie?
Moment.
Was?
Trustge.
Trustproject.
Also, ich zeige euch jetzt mal,
was ich gebaut habe und was wir...
Also, die App ist, was man sieht, relativ unspektakulär.
Aber es ist ganz cool, dass es funktioniert.
So.
Machen wir mal Rust hier auf.
Dann gehen wir mal ins Backend.
Machen Rider auf.
Also, das ist eine Mischung.
Es geht darum...
Was?
Ja, ja.
Okay, Rider.
Ach, Mist.
Ich kann...
Soll ich auch noch mal im Background starten?
So, Rider.
Also, wir haben...
Letztendlich ist das eine ASP.NET Core-Web-Anwendung
mit einem Low-Level-Go-Backend für WebRTC
und, ja, eine Index-HTML mit ein bisschen JavaScript.
Zeige ich euch jetzt.
So, ich glaube, jetzt habe ich echt alles geöffnet,
was es so zu öffnen gibt.
Heute brauchen wir echt fünf Desktop-Anwendungen.
Dafür...
Also, Index-HTML ist äußerst basic.
Was es da gibt...
Ich zeige euch, wie das Ganze aussieht.
Also, bevor wir uns das jetzt im Detail angucken...
Oh, ein bisschen klein, hä?
So, ist gut.
Und hier...
Was hat der für Schmerzen?
Ach, er findet mal wieder mein .NET-Framework nicht.
Gibt...
Hat der eigentlich .NET mittlerweile aktualisiert?
.NET-Version?
Nee, ist immer noch 7.0.
Nice.
Also, müssen wir das noch mal...
noch mal umstellen, dass er erkennt, dass ich...
Hallo?
...dass ich .NET 8 installiert habe.
.NET 8.
Äh...
Äh...
Ja, save.
So.
Also, ich habe mit Prolog noch nie was gemacht.
Mich wundert es, dass an der Uni auch ernsthaft irgendwie noch einer Prolo...
Ich meine, sollte man nicht...
Machen die meisten Leute an der Uni nicht Java?
Auch Java genannt von manchen Leuten.
Deswegen gibt es auch manche Leute, die sagen JavaScript.
Ups.
Komplett falsch, C-Mode.
Eigentlich wollte ich das mal...
FireShip sagt auch immer JavaScript.
JavaScript.
Also, auf Prolog hätte ich wirklich wenig... wenig Bock.
Okay, auf geht's!
Also, ich zeige euch mal schnell, was hier am Start ist.
Wir gehen hier in das Backend.
Starten das hier.
äh... .NET run.
Bäm.
Hallo?
Und es crasht!
Perfekt!
Perfekt zum Einstieg, Leute!
.NET run.
Ja.
Erst mal kurz die Experten über Teams anschreiben.
Ähm, warum crasht das?
Ach so!
Es crasht, weil ich die Go-Geschichte nicht kompiliert habe vorher.
Ja, das ist natürlich klar.
Also.
So.
Ihr müsst noch nichts verstehen.
Ich zeige es euch dann, wenn es soweit ist.
Äh... äh...
Go...
Build...
Build...
Mode...
Chat...
Library...
Minus...
O...
Ach so.
Äh...
Ja...
Meinetwegen heißt das so.
Und jetzt moven wir...
Oh, shit!
Ah!
Alter, was?
Äh...
Eigentlich bin ich keine Mathe mehr.
Ähm...
Go...
Build...
Hier, Bench...
Also, wie heißt das?
WebRTC?
Wie habe ich das genannt?
Wie soll...
Wie soll das heißen?
WebRTCLinux.so.
Okay.
Ich hoffe, dass das funktioniert.
Okay.
So.
Die Go-Geschichte kompiliert.
Warum heißt das GoLib?
Das soll nicht so heißen, Mann.
Ach so.
Hä?
Warum funzt denn das nicht, Leute?
Ist halt beim Output gleich so, Mann.
Soll mir recht sein.
Außerdem kann ich den Output direkt erstellen lassen, doch in...
Backend...
WebRTCLinux.so.
Genau.
So.
Da muss ich doch gar nichts moven.
So.
So.
Da sind wir.
So.
Jetzt kann ich starten.
Jetzt kann ich euch zeigen, was passiert.
Also.
Copy always.net.
Wir sind hier.
Run.
Gut.
Alles klar.
So.
Chrome aufmachen.
Und wenn wir jetzt auf Localhost...
Localhost Port 8080 gehen, werdet ihr was sehr unspektakuläres sehen, und zwar Connection
und Network Connected.
Also, was passiert, ist folgendes.
Kann man mal vielleicht die Browser Tools irgendwie ein bisschen...
Wo ist denn der Button dafür?
Irgendwie so, dass man es nicht total übertrieben...
Also, der baut eine WebRTC-Verbindung auf, vom Browser zum Backend.
Und das funktioniert folgendermaßen.
Also, WebRTC ist eine...
Blazingly Fast Connection, ja.
Der WebRTC ist eigentlich für Echtzeit-Audio-Video-Konfigurationen.
Kann auch für Chat-Nachrichten und so benutzt werden.
Aber hauptsächlich, muss man sagen, ist WebRTC im Audio-Video-Sektor zu Hause.
Und das heißt, wenn ihr Teams verwendet oder Zoom verwendet oder sowas, was wahrscheinlich
jeder von uns...
Ist eigentlich Slack noch angesagt.
Wobei Slack ist eher Chat, weniger Videokram, ne?
Und das ist alles WebRTC unter der Haube.
So.
Und...
Das funktioniert jetzt...
Ich glaube, mittlerweile schon.
Aber ich habe ehrlich gesagt Slack seit Ewigkeiten nicht mehr gesehen.
Also, Teams hat ziemlich zugeschlagen und eigentlich benutzt so gut...
Slack war mal eine Zeit lang richtig, richtig groß, ja.
Aber irgendwie ist mittlerweile echt Teams einfach nur...
Eigentlich das verbreitetste schlechthin.
Es kommt ab und zu mal vor, gerade wenn man mit irgendwelchen Ambitionen...
Konferieren muss, dass sie irgendwie Zoom-Calls einladen oder so.
Okay.
So.
Also, ich zeige euch jetzt mal, was ich gebaut habe, was wir umstellen auf Go.
Es ist...
Umstellen auf Rust.
Es ist relativ...
Relativ übersichtlich.
Also.
Ausgangspunkt des Ganzen ist ein .NET Backend.
Ihr seht, das ist sehr überschaubar.
Das ist alles.
Aus mehr besteht das nicht.
Das macht hier ein bisschen...
Das callt hier ein paar Sachen in Go.
Das gucken wir uns gleich an.
Und...
Das gucken wir uns gleich an.
Dann gibt es einen AP Endpunkt mit http get.
Slash WebRTC Start.
Dort erzeugt er eine neue WebRTC Connection.
Und schickt an den Client, also an den Browser zurück.
Die Magic WebRTC Verbindungsaufbau Dinger.
Das sieht dann so aus zum Beispiel.
Ist vollkommen egal.
Dafür fände ich eine Library.
Muss mich nicht mit auseinandersetzen.
Schickt er zurück an den Browser.
Der Browser nimmt das Ganze.
Der sagt, der baut auch eine Web...
Also der Browser versucht auch eine WebRTC Verbindung aufzubauen.
Callt diesen Endpunkt.
Und dann nimmt er das, was er von dem Backend geschickt kriegt.
Setzt das als Remote Description.
Das ist so eine WebRTC Verbindungsaufbau Geschichte.
Warum das so heißt, man weiß es nicht.
Aber WebRTC Handshake funktioniert so.
Eine der beiden Seiten, also bei WebRTC.
Das ist ja wie gesagt für Echtzeit per to per Videoübertragung eigentlich gedacht.
Bei WebRTC sind beide Seiten gleichzeitig Server und Client.
Und es können beide Seiten die Verbindung initiieren.
Das funktioniert so.
Eine Seite erstellt so ein Offer Package hier.
So ein Offer.
Wie heißt das?
SDP heißt das glaube ich.
So eine Offer Anfrage.
Schickt das an die andere Seite.
Und die erstellt darauf dann eine Antwort und schickt das zurück.
Und wenn beide sich darauf einigen können, dann wird die Verbindung aufgebaut.
Darauf einigen heißt, die tauschen.
Ihr seht das hier vielleicht auch.
Die tauschen zum Beispiel aus.
Hups.
Hat der irgendwie ein bisschen.
Ne, jetzt geht es doch.
Die tauschen hier zum Beispiel Endpoints aus für Video.
Man sieht ja mein Docker Interface wird auch mit geschickt, was ziemlich pepeger ist.
Ja, das ist UDP.
Das ist UDP tatsächlich.
Komplett UDP.
Man kann auch TCP verwenden.
Aber das ist für Videosachen ja meistens nicht so wichtig.
Die tauschen sich beispielsweise die Endpunkte aus für das Video.
Also ihre IPs.
Und sie tauschen sich aus, welche Codecs sie unterstützen.
In dem Fall unterstützt mein Server, meine Serverseite nur H264 mit diesem Profil.
Sonst nichts.
Und im Endeffekt einigen sich die zwei Seiten darauf, was sie denn jetzt als Videos austauschen wollen.
Also in der Offer steht drinnen.
Hey, Hallo, ich bin Client oder beziehungsweise Server XY.
Das sind meine Endpoints.
Das sind meine Video Audio Codecs, die ich unterstütze.
Und.
Dann antwortet, dann antwortet die die andere Seite drauf und sagt Hey, alles klar.
Ich unterstütze.
Ich unterstütze auch dieses Video Format.
Lass uns mal.
Lass uns mal anfangen, Video auszutauschen, sondern mit die Verbindung aufgebaut.
Also das ist im Prinzip das, wofür ich die WebRTC Library verwende.
Kann man, kann man da einen Key hinterlegen?
Ja, kann man irgendwo.
Aber ich lasse das aktuell alles die Library handeln.
Es geht, es geht auch.
Es geht auch mit mit mit TCP.
Du kannst, wenn du.
Also normalerweise muss man sagen, geht das, geht das verhältnismäßig gut.
Ich habe das auch schon mal gemacht, indem ich beispielsweise meine Tür Gegensprecheranlage auf mein Handy gestreamt habe.
Da drüber.
Per WebRTC.
Da habe ich den SIP Call gemacht und mit dem SIP Call dann die Sachen, die Sachen gepusht.
Aber das ging, das ging tatsächlich erstaunlich gut von außen.
Wenn es gar nicht geht, kann man noch so einen.
Ich habe vergessen, wie der Kram heißt.
Turn, Stun, wie auch immer Server einbauen, wo das dann quasi einmal über eine externe IP läuft.
Der Verbindungsaufbau, um schön Löcher ins jeweilige Nat zu machen.
Aber es geht erstaunlich, erstaunlich gut, ehrlich gesagt.
Und intern im Netzwerk ohne Nat dazwischen ist es eh kein Problem.
So, wo bin ich jetzt stehen geblieben?
Also das ist so die Basics, wie so ein WebRTC Aufbau funktioniert.
Und eigentlich ist jetzt, nachdem die Verbindung steht.
Ich kann euch übrigens auch zeigen, dass die Verbindung steht.
Moment.
About Web, ah ne Moment, wir sind in.
Ha, guck mal.
Chrome ist schlau genug.
About WebRTC.
Das hier suche ich, genau.
Guck, und jetzt kann man sich hier den Verbindungsaufbau ansehen.
Also man sieht, sie sind lokal connected.
Signaling State ist stable.
Connection ist aufgebaut.
Und ja, der Transport darunter ist auch aufgebaut.
So, und.
Also das ist die komplette .NET-Seite.
Mehr passiert nicht.
Der, also die Server-Seite generiert so einen Offer-Package.
Das kommt dann hier rein.
Also Client sagt, add CPU-Connection.
Das ist, das ist alles wurscht.
Dann callt er diesen Endpunkt.
Dann kriegt er diesen Klampel hier zurück.
Mit den Endpoints und dem supportenden Codex.
Das muss er sich dann setzen als Remote Description.
Nachdem beide Seiten, Server und Client, gleichzeitig sein können,
muss man immer einstellen, was er selbst ist und was die andere Seite ist.
Dann setze ich quasi das.
Dann erzeugt der Browser eine Antwort da drauf.
In der Antwort steht dann drauf, okay, ich unterstütze mindestens einen Codex,
den du auch unterstützt.
Wir können Videos miteinander austauschen.
Und dann schickt er das Ganze zurück.
Und das geht dann hier an den Post-Endpunkt von der .NET-Anwendung.
Und dann ruft er hier jeweils go-low-level-web-rtc-Sachen aus.
So.
Also hier am Anfang ruft er einmal in go die Sachen auf,
dass er UDP-Netzwerk-Geschichten setupt.
Dann, dass es einen Video-Track gibt, in dem man was reinschreiben kann.
Hier lässt er sich die Connection-Sachen generieren.
Und hier setzt er dann die Antwort vom Browser für die Connection.
Ich glaube, wenn wir das jetzt gleich in Rust bauen, das ist relativ klar.
Es ist auf jeden Fall recht übersichtlich.
Ich zeige euch jetzt noch mal schnell die go-Seite.
Ja, und am Ende, jetzt könnten die eigentlich Videos austauschen.
Warum ich das hier so ein bisschen bundig gemacht habe, einfach weil es schöner aussieht.
Also, der guckt hier, sobald sich der Connection-State ändert, schreibt er das halt hier rein.
Wichtig ist, dass beides connected ist, sowohl hier quasi der Transport
und die eigentliche Web-RTC-Connection an sich.
Ich könnte jetzt darüber beispielsweise Audio austauschen, Video austauschen,
mehr oder weniger.
Fast in Echtzeit.
Oder auch einen Data-Channel aufmachen, wo man den zum Beispiel für Chat oder sowas verwenden kann.
So, also das Frontend ist übersichtlich, 67 Zeichen.
Da müssen wir heute nichts dran machen.
Und an dem C-Sharp-Backend müssen wir auch so gut wie nichts machen.
Weil, das stellen wir ja um von go auf Rust.
Ich zeige euch jetzt, was go macht.
Und das ist das, was wir heute in Rust versuchen nachzubauen.
Und zwar ist, es ist auch recht übersichtlich, wobei es noch der komplexeste ist.
Das sind die ganzen Funktionen, die vom .NET-Backend aufgerufen werden.
Das erste, was der macht, ist init-Network.
Sieht man auch hier.
Init-Network, passiert folgendes.
Der erstellt so eine Liste mit supportetem Codex.
Also in dem Fall supporten wir nur, das steht hier oben, in dem Fall supporten wir nur H264.
Das ist das, was ihr auch eben gesehen habt in diesem langen Text.
In diesem langen Text.
Text-Output.
Doch, das habe ich selbst geschrieben, mit Error-Handling.
Allerdings nicht überall Error-Handling.
An vielen Stellen schreibe ich, wird der Error auch einfach weggeschmissen.
Ne, wird nicht rausgeschmissen.
Es wird go rausgeschmissen zu Rust.
Oder mal gucken, ob es in Rust funktioniert.
Ne, das habt ihr eben auch gesehen in diesem Verbindungsaufbau.
Wir unterstützen nur H264.
Und das ist halt so die Codec-Parameter für unser Video, was wir unterstützen.
So, also, als erstes legt ihr eine Liste an mit supportetem Codex.
Warum brauchst du noch das .NET Projekt?
Das .NET Projekt brauche ich, weil das eine noch ein bisschen umfangreichere Web-Anwendung wird.
Und ich keinen Bock habe, das in Go zu machen.
Auf der anderen Seite, so mega umfangreich wird die Web-Anwendung gar nicht.
Also, vielleicht ist das nächste, was wir machen, .NET noch rauszuschmeißen.
Mal ganz davon abgesehen, Go fliegt ja auch raus.
Das wird ja heute in Rust neu gebaut.
Vielleicht, vielleicht alles in Rust, aber das glaube ich nicht, dass ich mir das antue so abartig wie...
Ja, das ist, das ist wirklich, also, interop mit anderen Sachen ist Go echt pepega.
Das habe ich auch schon gemerkt.
Was es am Ende bringt, ja, das kann ich auch noch mal kurz erzählen.
Also, du kannst damit zum Beispiel jede x-beliebige Webcam oder, ja, also, alles, alles, was FFmpeg einlesen kann und was ein H.264-Stream hat, bekommst du damit eben als Video im Browser.
Also sprich, du hast irgendeine billige China-Chinesen-Webcam, die kannst du dir damit im Browser anzeigen lassen.
Du wirst jetzt sagen, hey, normalerweise kann man auch Webcams im Browser anzeigen lassen.
Kann man und kann man auch gleichzeitig nicht.
Es kommt immer drauf an, was die, was die Webcam unterstützt und was die Webcam anbietet.
Die aller, allerwenigsten Webcams bieten WebRTC, also quasi mehr oder weniger Real-Time-Streaming an und dann hast du auch nur eine Webcam drauf.
Also sprich, ich will ja eine Webseite haben, wo einfach meine ganzen Webcams drauf sind.
Ich habe, glaube ich, aktuell sieben Stück hier im Haus.
Also ich habe, warte mal, lass mal überlegen.
Ich habe zwei, drei Stück draußen, eine in dem Raum, wo die Katze immer abchillt und eine im Flur und eine im Keller.
Sechs Stück, sechs Stück sind das. Sechs Stück.
Und, ja, da will ich eine Webseite haben, wo die alle drauf angezeigt werden.
Mehr oder weniger, ach so, und das Ganze lasse ich in Home Assistant letztendlich anzeigen.
Entweder hier.
Entweder als iFrame oder als Pop-Up oder so, aber das hat ja mit Home Assistant nichts zu tun.
Seite. Und ich will das halt möglichst Echtzeit haben und auch Connection-Abrüche handeln.
Also das Backend wird eine Web-Anwendung in .NET.
Das macht nicht viel mehr als die, als die Webseite ausliefern und das ganze FFmpeg-Zeug.
Wir brauchen ja auch noch FFmpeg zum Auslesen von den Videostreams.
Das ist relativ simpel, das haben wir im Stream auch schon gemacht.
Also wenn man, wenn man weiß, wie der FFmpeg funktioniert.
Also die, das C, das C-Interface von FFmpeg geht das erstaunlich gut.
Ja, wie gesagt, vielleicht, vielleicht gefällt mir das in Rust dann auch so gut, dass ich auch .NET noch rausschmeiße und das einfach komplett in Rust mache.
Wobei ich, dann mache ich, dann würde ich es lieber komplett in Go machen.
Weil wenn ich es komplett in Go mache, ist letztendlich ja auch kein Interop mehr nötig mit anderen Sprachen und dementsprechend, ja.
Aber ich habe schon mal FFmpeg in Go gemacht, das ist auch Pains Champ.
Weil du da C-Sachen callen musst.
Wie dem auch sei, es geht ja auch darum, dass man ein bisschen was, was lernt.
Nicht so sehr, dass was super auch nie dagewesenes rauskommt.
So, und ich wollte euch noch mal kurz zeigen.
Ja, ganz ehrlich, die .NET Templates kannst du, kannst du vergessen.
Du brauchst eigentlich nur zwei Templates in .NET.
Du brauchst Console und Web.
Rest reicht.
Das ist aber schwierig mit CMD.
Einzelne Frames.
Aus einem RTSP H.264 Stream abzugreifen.
Und die dann weiterzuleiten über WebRTC.
Da wüsste ich jetzt nicht, wie ich das mit rein mit CLI und Streamen irgendwie über Standard in oder so machen soll.
So, also.
Die Go als erstes macht der .NET Network.
Ich zeige euch jetzt erst mal das, was wir neu bauen müssen in Rust.
.NET Network ist relativ simpel.
Der erstellt einfach eine Liste mit Codecs, die supportend sind.
Aktuell, wir supporten plus H.264.
Und mit, in dem Fall, kriegt es halt die ID 96.
So, dann gibt es ein bisschen Error Handling, der nicht wirklich viel macht.
Ihr könnt übrigens auch paniken.
Weil, will ich nicht returnen, kann man nicht gleich sagen Panic.
Kackel.
So.
Ist eigentlich wurscht, weil wir wollen Go gar nicht weiter verwenden.
So, dann.
Settings Engine.
Wir wollen UDP verwenden, anstatt TCP.
Beides mal angelegt.
Kann ich dazwischen umschalten.
Aber wir verwenden UDP.
Sieht man auch hier.
Der legt eine neue Settings Engine an, sagt Network-Typ UDP.
Und dann als Port verwenden wir 36.36.3.
Das heißt, alle WebRTC-Verbindungen werden multiplexed über diesen Port.
Normalerweise ist es bei WebRTC und Videokram so, dass für jede neue Verbindung und jedes neue Video ein eigener Port aufgemacht wird.
Das ist okay.
Das ist nicht schlimm.
Das einzige, wo das mega nervig ist, ist, wenn du Firewall freischalten musst.
Und mir ist es lieber, ich muss nur ein Port freischalten, als alle.
So.
Also, der listen auf UDP 36.36.3.
Mit TCP geht es auch auf einem Port, ja?
Hier, 35.35.3.
Ich kann dir auch gleich zeigen, dass es funktioniert.
So.
Dann erstellt er so eine komische WebRTC-API.
Das muss man machen.
Weil die Library das will.
Dann als nächstes wird ein Video-Track created, in den ich noch nichts reinschreibe.
Aber ich brauche ein Video-Track, dass die Verbindung ordentlich funktioniert.
Create Track.
Er generiert eine Unique-Track-ID.
Erzeugt einen neuen Track.
Und pusht den Track in ein Array, äh, in eine Liste.
Für später.
Dann als nächstes callt er Create Connection.
Create Connection ist das hier.
Create Connection wird eine neue WebRTC-Verbindung erzeugt.
Nicht fährtzeugt, erzeugt.
Der Track, der vorhin angelegt wurde, wird der WebRTC-Verbindung hinzugefügt.
Als neuer Video-Track.
Dann passiert das, was ich euch schon erzählt habe.
Es wird eine Offer erstellt.
Das ist dieses Ding hier.
Also, eine Offer erstellt.
Dann wird eingesammelt, was er für Endpunkte hat.
Also, im Prinzip sind das die Interface-IP-Adressen.
Dann wird gesammelt.
Connection-ID generiert.
Connection in eine Liste gepusht.
Und hier zurückgegeben an den C-Sharp-Teil.
Die Client-ID und den Text.
Und das kommt dann letztendlich im Browser raus.
Und wenn der Browser antwortet, wird das hier gecallt.
Und das ist auch das letzte, was es gibt.
Dann wird das hier gecallt.
Er holt sich die Connection raus dazu.
Passt den String raus.
Also wieder den C-String. Umwandelt es in den Go-String.
Was hat er hier für Schmerzen?
Use CamelCase instead.
So, und dann setzt er die Antwort vom Browser in die WebRTC-Verbindung.
Und dann ist der Handshake fertig und die Verbindung aufgebaut.
So, das ist im Prinzip alles.
Hat man das halbwegs verstanden?
Also, im Prinzip besteht das aktuell aus 155 Zeilen Go, 37 Zeilen C-Sharp und ein bisschen HTML.
Also, wir sind so ungefähr bei, keine Ahnung, 300 Zeilen.
Also, ich denke, es ist relativ übersichtlich.
Ach ja, eine Sache, die ich noch nicht gezeigt habe.
Damit man Go-Sachen aufrufen kann auf C-Sharp, muss man ein bisschen Interop-Magic machen.
Und das passiert hier.
Rust kommt jetzt.
Und das passiert hier.
Also, man muss dem quasi sagen, wie die Funktionen heißen, die man in Go definiert hat.
Und welche Return-Werte und Parameter-Argumente die haben, dass er die aufrufen kann.
Aber ansonsten, an Logik passiert hier eigentlich nichts drin.
Das ist alles.
Mag vielleicht jetzt erstmal verwirrend sein, aber wir bauen das jetzt in Rust nach und ich hoffe, das funktioniert.
Lazingly fast, natürlich.
Was sonst?
Und abfuck-kompliziert.
Wahrscheinlich auch.
Okay, also dann.
Dann verschieben wir das mal, das Go-Ding auf Desktop 8, das ich ja nachher nachgucken kann.
Und erstellen jetzt das Rust-Projekt.
Rust-New-Project.
Nennen wir es mal WebRTC Rust, weil ich glaube, ich habe den anderen Krempel ja auch WebRTC Go genannt.
Dann nenne ich es WebRTC Rust.
Create.
Gut.
So, jetzt müssen wir erst ein paar Sachen setzen.
Also das Ziel ist, wie gesagt, eine Library erzeugen in Rust mit Interfaces, die wir dann aus .NET aufrufen können.
Das funktioniert auf exakt die gleiche Art und Weise, wie das mit Go funktioniert.
Hier in dem Fall erzeugt Go eine Library, wo es eben diese Funktionen drinne gibt, die dann aufgerufen werden können.
Und Rust wird genau das gleiche machen.
Also sprich, Rust erzeugt eine Library, wo es dann so eine Funktion zum Beispiel drin gibt.
So.
Dass mit das funktioniert, da müssen wir jetzt erstmal abgucken.
Wir haben das alte doch gebackupt.
Weil da haben wir doch schon ein bisschen Rust-mäßig gebastelt.
Welches ZSH-Theme benutzt du?
Das ist selbst gebaut, allerdings basiert das auf einem.
Also als Prompt ist das Starship-AS.
Und dort gibt es Configuration.
Wo haben sie denn hier Beispiele für?
Theme?
Ja.
Keine Ahnung.
Ich habe diese Beispiele für Themes, aber ich bin gerade zu pepega, das zu finden.
Zumindest, ah, Presets, hier unten.
Das heißt nicht Themes, das heißt Presets.
Und das hat nicht so viele Presets dabei, Starship.
Und ich habe das hier genommen als Basis.
Pastel Powerline, basiert auf M365 Princes.
Also da haben sie sich alle gegenseitig befruchtet, inspirationstechnisch.
Nur, dass ich das noch ein bisschen angepasst habe.
Also ich habe die Schrift beispielsweise, die Farbe ein bisschen kontrastreicher gemacht.
Ich habe beispielsweise einen 2-zeiligen Prompt daraus gemacht.
Hier ist es ein 1-zeiliger Prompt.
Also ihr wisst, ich mag 1-zeilige Prompte nicht.
Ich mag eher 2-zeilige Prompts.
Was man auch hier dran sieht.
Das hier 1-zeilig wäre ja richtig noch ekliger.
Ja, da wirst du gar nichts sehen.
2-zeilig geht das hier halbwegs.
Und meine .Files hast du tatsächlich.
Hat ja gerade schon jemand im Chat.
.Config.
Starship.
Da ist meine .Config drinne.
Ja.
Und da kannst du dir das abgucken.
Also ich habe noch ein paar zusätzliche Sachen gemacht.
Ich habe zum Beispiel bei .NET Projekten noch reingeschrieben, was es für Projekt Framework ist.
Versus was systemweit installiert ist.
Unser Zeug.
Was das hier vorne ist, habe ich keine Ahnung.
Warum das da überhaupt angezeigt wird.
Achso.
Weil ein Header-File drin ist oder was.
Zeigt ja noch meine installierte GCC oder was auch immer das ist.
Für eine Version an.
Naja, gut.
Alles klar.
So, wir müssen jetzt noch ein bisschen was rüber kopieren.
Damit das funktioniert in Rust.
Und zwar, wir haben ja letztens schon mal ein bisschen gebastelt, was Interop zwischen .NET und Rust angeht.
Wir müssen im Prinzip das da.
Das da brauchen wir.
Cargo-Tommel.
Dependencies.
Lib.
Name.
WebRTC.
Rust.
Vollkommen ok.
Source.
Muss nicht main.rs sein.
Sondern.
Wo ist der Rename-Knopf?
Man.
Lib.rs muss das Ganze sein.
Und ich glaube, das war es schon.
Gehen wir mal in den Ordner rein.
Der Musikhof war immer so laut.
So, gehen wir mal in den Ordner rein.
Repos.
WebRTC.
Rust.
Cargo.
Build.
Ok.
Alter.
Das halbe Internet wird wieder runtergeladen und kompiliert erstmal.
So, dann müssen wir uns nämlich noch was rauskopieren hier aus dem alten Projekt, wo wir gebastelt haben.
Lib.rs.
Im Prinzip.
Können wir eigentlich, weil wir haben ja schon damit mehr oder weniger angefangen.
Das hier mal rüber kopieren.
Wie, ich habe keinen Vim?
Wait a minute.
Ich habe kein.
Ich habe keinen Vim mit.
Mit Clipboard?
Was ist das?
Warum habe ich keinen Vim mit Clipboard-Funktion installiert?
Moment, was?
Habe ich nicht.
Ich habe den normalen Vim.
Der hat, glaube ich, gar keinen.
Egal.
Wir wollen uns jetzt nicht mit Vim-Gedöns aufhalten.
Ok?
Ist das Sway oder E3?
Das ist E3.
So.
Gut.
Ja, ja.
Geh mal weg.
Geh mal weg.
Geh mal weg.
Hier oben.
Rust.
Alter.
Rust.
Geh weg.
Ok.
Main.
So.
Also.
Jetzt müssen wir gucken, wie wir den Krempel.
Was hat er denn eigentlich für Schmerzen?
Das müsst ihr doch nach wie vor erkennen hier.
Bild.
Bildet doch auch.
Aber meine IDE ist der Meinung, es bildet nicht.
Null.
Na geil.
Wollen wir neu starten?
Wie lädt man hier?
Kann man hier irgendwie ein Projekt reloaden?
Ist ja noch Beta.
Ist ja noch Beta.
Was ich programmiere?
Ein WebRTC, also ein Web-Backend für WebRTC mit einer WebRTC Rust Library.
Ok.
Ach, jetzt hat er es gecheckt.
Ja, das ist die Rust IDE von JetBrains.
Ob die was taugt?
Keine Ahnung.
Also ganz ehrlich.
Ich bin ja nicht der große Rust Checker.
Ja.
Was ich bisher an IDE Support gesehen habe für Rust, ist alles bisschen Pains Champ.
Und das auch.
Aber das ist noch mit am wenigsten nervig.
Ok.
Also.
Jetzt müssen wir diesen Krempel erstmal übersetzen von Go nach Rust.
Da fangen wir jetzt mal an.
Also das erste was wir haben ist diese InitNetwork Funktion.
Ich kopiere mir mal kurz das Go hier rüber.
Und dann vergleichen wir das mal mit dem was wir hier gebaut haben.
In Rust.
Ob das so halbwegs passt.
Also.
Wir legen eine Media Engine an.
Das mache ich hier auch.
So.
Dann registern wir einen Codec.
PayloadType, ok 96.
PayloadType 96.
Typ Video.
Ja.
Ne, ne, ne.
Das mache ich nicht mit ChatGPT.
Selbst.
So.
Das sieht.
Das sieht.
Also ich würde sagen.
So weit haben wir das schon mal drinne.
Dann eine Settings Engine.
Dann eine Settings Engine.
Wobei.
Sagen wir mal so.
Ich habe es hier umgedreht.
Aber mein.
Das macht jetzt ja nicht wirklich einen großen Unterschied.
Dann eine Settings Engine.
Mit Settings für UDP.
Habe ich auch.
Zur UDP Port 35353.
Wobei ich hatte 36363.
Ne.
Glaube ich.
UDP Port.
36363.
Ok.
So.
Und als letztes.
Gibt es noch das hier.
Was übrig ist von Go.
Und das habe ich hier glaube ich auch schon das letzte mal gebaut.
In Rust.
Aber das.
Viel mehr.
Viel mehr hatten wir da.
Hatten wir da glaube ich nicht mehr gemacht.
Also.
Also in Go sieht das so aus.
RP gleich WebRTC New RP.
With Settings Engine.
Settings Engine.
With Media Engine M.
So.
Das habe ich hier auch.
With Settings Engine.
Settings Engine.
With Media Engine.
Media Engine.
Und.
Das hier ist.
Um es als globale Variable zu haben.
Ne.
Genau.
Das ist Rust Magic dafür.
Um es als globale Variable zu haben.
Ui.
Ja gut.
Dann.
Würde ich sagen.
Der Teil.
Der Teil passt schon mal in Rust.
Der sieht genauso aus wie in Go.
Nicht viel Unterschied dazwischen.
So.
Dann machen wir mal weiter.
Mit.
Also.
Das.
Das klappen wir mal ein.
Das haben wir.
Das haben wir.
Ja.
Memory Leaks sind erstmal nicht so wild.
Create Track brauchen wir jetzt.
Da bin ich nicht sicher ob wir sowas.
Ne.
Siehste.
Haben wir noch nicht gemacht.
Also.
Create Track.
In Go sieht das ganze so aus.
Erzeugt sich eine Random Track ID.
Und dann legt er nen Track an.
Und speichert den sich in eine Liste.
Da gehts jetzt los.
Das wüsste ich schon mal nicht.
Wie ich das in Go.
Wie ich das in Rust gescheit mache.
Bei der Sache hier flippen die ganzen Rust Liebhaber schon aus.
Aber wenn du Interrupt mit anderen Sprachen machst.
Wüsste ich nicht wie man das gescheit machen soll.
Zum Stage sharen.
Wir bräuchten jetzt sowas wie.
Eine.
Eine Track Liste.
Enver Tracks.
Und das ist.
Tja.
Collection Typen.
In Rust.
Ich brauch eine Hash Map sowas in der Richtung.
So nen Dictionary quasi.
Hash Map.
Gibt es.
Nice.
Zwar eine Hash Map.
Aus Track ID.
Also quasi ein.
Sagen wir mal nen Int.
Zum Beispiel.
Nen Int.
Und einer.
Einem Track.
Also einem.
Ja.
Wie heißt das auch.
Local Static Sample.
Ja.
Nice.
Top.
Dann ist die Musik schon vorbei.
Ist das dann ein Server pro Client.
1 zu 1.
Ne.
Da können belieb.
Beliebig.
Bis der RAM ausgeht.
Viele Clients hin connecten.
Und die kriegen alle dann die gleichen Video Streams geschickt.
Ne ne.
Da können so viele.
Und alle über den gleichen Port.
Das ist ja das coole.
Das wird alles multiplex über den gleichen Port.
Deswegen musst du nur eine Sache in der Firewall freischalten.
Stimmt.
Da war irgendwas.
Ich weiß aber nicht mehr was.
Ich glaube ich musste.
Ich musste.
In Rust noch was aufrufen.
Für free.
Naja.
Wie gesagt.
Scheiß auf Memory Leaks.
Hauptsache es funktioniert erstmal.
So.
Cargo Build.
Moment.
Es funktioniert noch.
Da kann irgendwas nicht stimmen.
Da stimmt irgendwas nicht Leute.
Da stimmt.
Ich.
Wenn in Rust einfach was kompiliert dann stimmt was nicht.
Ok.
Also.
Dann legen wir mal los.
Wir tun mal.
Wir hardconen erstmal.
Ok.
Also.
Wir brauchen eine Track ID.
Wir sind in Rust.
Also Track ID.
Zwei.
So.
Hardcoded Track ID.
Ok.
Das hier lassen wir weg.
So.
Und das heißt wir brauchen jetzt einen Track.
Let Track gleich.
Und jetzt ist die Frage.
Wie lege ich das in Rust an?
Track Local Static Sample.
Irgendwie so.
Ah.
New.
Guck mal da.
Der braucht ein Codec, eine ID und eine Stream ID.
Oh Camel.
Never.
But I've tried Erlang.
And.
Also.
Also for languages with many parentheses.
Erlang.
And.
Can't remember.
I think it was Clojure.
Or something on Java base.
Also Camel ist gleich Rust mit GC.
Ok.
Also ich weiß, dass der ursprüngliche Rust Compiler in OCaml war.
So.
Wie funsten das hier jetzt?
Track Local Static Sample.
Also wir brauchen eine RTC.
Was?
Eine was?
Eine RTC.
RTP Codec Capability.
Ich glaube das ist das gleiche was wir hier.
Ne.
Ok.
Rust.
Das geht schon los.
Also was brauchen wir jetzt?
Ok.
Und jetzt Klammer auf.
Mime Type.
Channels.
Yep Clock Rate.
Was will der von mir?
Ah Default.
PyFat.
Ey können wir nicht.
Moment.
Hier ist es doch.
Hier steht es doch.
Moment.
Warte mal.
Hier ist es doch.
Hier ist es doch.
Hier ist doch hier.
Guck mal.
Hier ist doch alles.
Kann ich nicht.
Warte mal.
Kann man.
So was.
So was geht in Rust wahrscheinlich nicht.
Ne.
Das dachte ich mir fast schon.
Static.
Ne.
Geht nicht.
Weil.
Missing the Type for Static.
Wieso steht doch da?
Muss ich irgendwie noch so was machen?
Habe ich das von uns?
Das kompiliert doch im Leben nicht.
Alter.
Es war.
Ja.
Hätte mich auch.
Hätte mich auch ganz stark gewundert wenn das jetzt einfach kompiliert.
Wobei der meckert gar nicht da drüber.
Der meckert hier drüber.
Sack.
Ähm.
Ne.
Was?
Ok das geht in Static aus irgendwelchen Gründen nicht.
Warum auch immer.
Keine Ahnung.
Weil.
PyFat Rust.
Wir machen.
Wir machen jetzt einfach eine Funktion draus.
Public.
Ok.
Keine Ahnung.
Get.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ist gut.
Ich.
Ich habe schon was getrunken.
Wie sowas hier.
Ja.
Und wie funzt das jetzt?
Kann man das hier nicht?
Returnen einfach?
Moment.
Moment.
Oh.
Warte mal.
Warte mal.
Rust.
FN muss da noch davor.
Pub FN.
Ja.
Und jetzt will er Return Type.
Mach mal deinen Cargo Check unten an.
Ah.
Was.
Was will das von mir?
Anschein.
Anscheinend ist es aus.
Aber die große Preisfrage ist.
Wie mache ich es an?
Ok.
Gut.
Das heißt.
Wenn ich jetzt da irgendeinen Shit reinschreibe.
Ok.
Werden wir gleich sehen.
Also.
Get Capabilities.
Schreibt man das so?
Das schreibt man doch im Leben nicht so.
Oder?
Weißt du.
Kappa.
Bilities.
Ok.
Das.
Das.
Kompiliert das jetzt?
Ja.
Nice.
So.
Das heißt.
Wir können jetzt an der Stelle das einfach wegschmeißen.
Track Local Static Sample.
Gut.
So.
Da kriegt man jetzt.
RTC Code Capability.
Das da.
Können wir da reinhauen jetzt.
Stream Track ID.
Keine Ahnung.
1.
1.
Wir wollen jetzt.
Drauf geschissen.
Erstmal.
To Owned.
Nur mal gucken.
Ob das auch ordentlich läuft.
So.
Das Funst.
Kompiliert noch.
Ja.
Gut.
Gut.
Gut.
Also.
Das brauchen wir nicht.
Das haben wir.
Wir haben den Track.
Track Panic.
Kommt weg.
Ja.
Das wird ja viel kürzer sogar als in Rust.
So.
Und jetzt muss ich den Track hier drinnen irgendwie speichern.
Welchen Package Manager benutzt du?
Für was?
So.
Jetzt haben wir hier irgendwie eine Hash Map.
Für Tracks.
Linux.
Ja.
Pacman.
Arch by the way.
Ach so.
Das da meinste.
Das hier.
Okay.
Wie kriegt man jetzt in die Hash Map was Gescheites rein?
Moment.
Den haben wir noch gar nicht initialisiert.
Das wird er mir hier auch sagen.
Ne.
Ich.
Das hier unten müssen wir.
Wir müssen das glaube ich nochmal initialisieren.
Set.
Hash Map.
New.
Hoffe das funst jetzt.
Prager.
Prager.
Prager.
Prager.
Okay.
Noch.
Noch.
Kompiliert.
Alles.
Was ich bastle.
Ein Frontend wo ich per Web RTC Videos hin streamen kann.
Mischung aus Go.net für die Web Anwendung und bisschen HTML.
Hauptsächlich bisschen um Rust zu lernen.
Also ich hab das schon in Go gebaut.
Ich hab das schon in Go gebaut um zu testen ob es funktioniert.
Es funktioniert und jetzt bauen wir das in Rust nach.
Genau.
Genau.
Der Twitch Killer.
Was macht eigentlich Dings hier?
Kick.
Letztens.
Letztes Mal wieder reingeguckt.
Übelst zwielichtiges Zeug wieder gesehen und gleich wieder ausgemacht.
Also das ist echt nicht.
Das ist echt nicht die Twitch Konkurrenz.
Keine Ahnung ey.
Das deckt glaube ich ein ganz anderen.
Ein ganz anderes Klientel ab als Twitch.
Okay.
Und jetzt müssen wir den Track inserten in die Hash Map.
Also.
Tracks.
Insert.
Ne Moment.
Das ist in einem Once Log.
Das heißt ich brauch jetzt ähm.
Write.
Ne.
Brauch ich denn jetzt?
Get.
Get Mud.
Okay.
Get Mud.
Alles klar.
Rust.
Rust.
Things.
Unwrap.
Zack.
Natürlich geht es.
Es wäre viel zu einfach wenn das irgendwie.
Moment.
Das muss ja Mutt vorne hin wahrscheinlich noch.
Ne.
Es wäre viel zu einfach wenn das in Rust einfach gleich funktionieren würde.
Das.
Okay.
Jetzt geht es wieder los Mann.
Was hat er jetzt für Schmerzen Mann?
Also.
Wie habe ich das denn mit API gemacht?
Bisher habe ich das überhaupt schon mal irgendwo gemacht.
Ah.
Get.
Get muss man machen.
Moment.
Get Mutt.
Jetzt habe ich das doch schon mal hier.
Cannot borrow immutable local variable tracks.
Cannot borrow immutable static..
What?
Was willst du?
What?
Rust.
Ne das kann es nicht sein hier oder?
Das geht dann nämlich mit static das geht nicht.
Oh Gott.
Rust.
Alter.
Hier geht das.
Okay.
Get.
Get funktioniert.
Ne.
Get wird schon mal funktionieren.
Okay.
das geht jetzt nicht weil es nicht nicht nicht mut ist oh je jetzt kommen wieder rast geschichten
anstatt er sagt er nicht track id track nun okay hier sagt er mir geht nicht weil not mutable ist
und jetzt bin ich schon wieder beim lateinern ende am ende was rast angeht what let's track
was was was will er von mir genau doppelpunkt das geht doch nicht aber aber gett mut funktioniert
nicht man aber gett mut funktioniert nicht weil ich kenne keine bono im youtube
okay wahrscheinlich ist den one slot nicht genug ich
brauche keinen und beides hat nicht genug ich brauche nichts aber es ist ein one slot
wahrscheinlich noch einen Mutax oder irgendwas. Rust, jetzt komm. Rust, please. Okay, once lock, mutable. Okay, hier, da, also. Rust, erklär es. Once. What you want is a Mutax or RW-Lock. Ja, Moment, RW-Lock?
RW-Lock. RW-Lock alleine reicht mir doch gar nicht. Oder? RW-Lock. Nee, RW-Lock alleine reicht mir, glaube ich, nicht. RW-Lock. Im Moment, ah, fucking shit. Fertig? Ich, ich, ich bin verwirrt.
Warte mal, RW-Lock geht doch gar nicht, weil ich, weil ich hier jetzt nicht, nicht sagen kann, oder, weil ich jetzt hier nicht sagen kann, Hashmap,
New drinne. Oder doch? Oder doch? Ich bin mir da unschlüssig. Okay. Okay, RW-Lock. RW-Lock. Und jetzt, muss ich sagen, Ride, ne? Ride, unwrap. Oh man, Alter. Was? Alter, Rust.
Okay, mutable. Okay, Prage, Prage. Oh.
Cannot call non-const. Okay, das dachte ich mir doch. Das heißt, okay, okay, Leute, okay, ich, ich, ich, Achtung. Outplayed, Rust. Outplayed. Ich weiß, was Rust von mir will. Die will, die wollen ein Once-Lock, gerapptes RW-Lock. Wollen wir wetten. Das wollen die haben. Die wollen ein Once-Lock, RW-Lock.
Kannst du mal abholen, was du da machst?
Ich baue was, das ich in Go gebaut hab, um in Rust. Und aktuell versuche ich, Rust dazu zu bringen, dass ich in die Liste was reinschreiben kann. Und das ist in Rust schon mal gar nicht so einfach. So, RW-Lock.
New. Achso, und jetzt Hashmap. Hashmap. New. Jetzt, Prage, Prage, Prage, Prage. Okay, Tracks. Okay. Also, RW-Lock. Jetzt brauchen wir Get.
Dann brauchen wir Unwrap. Right? Unwrap. Okay, guck mal, es gibt keine Fehler mehr. Es gibt keine Fehler mehr. Easy. Es kompiliert. Also, okay.
Wir brauchen ein RW-Lock, gerappt in Once-Lock. Obviously. Ich meine, wem das nicht klar gewesen ist, dem ist auch nicht mehr zu helfen. Wir brauchen eine Hashmap. Also, eine generic Hashmap, gerappt in RW-Lock, gerappt in Once-Lock.
Klar ist klar. Alright. Easy, würde ich sagen, ist das. Das ist nicht einfach nur easy, das ist ultra easy.
Warum ich mir das antue, weil alle coolen Leute Rust verwenden. Und ich will auch cool sein.
Intuitiv, ich hätte die Sprache auch so designt. Was ich gerade verstanden habe. Also, ich habe eine Mischung verstanden aus Kekkel und Kekweight,
gepaart mit Weird.
Ja. Wobei, ich glaube, die richtig coolen Rust-Leute, die schreiben das sogar so, gell? Also, Chatge, es hat funktioniert. Wir haben einen Track erstellt. Also, wir haben das Go-Zeug nachgebaut. Wir haben einen Track erstellt mit der ID.
Okay. Achso, ja, Moment. Mit der ID. Wie macht man denn? Gibt es ein To-String? Ah, nice.
Eventuell gibt es auch eine einfachere Lösung. Wenn ihr eine kennt, Leute, keine Ahnung.
Also, Static RW-Lock Rusts. Also, das Problem ist ja, dass in diesem globalen Kontext hier nur statische Sachen erlaubt sind und keine Initialisierung von zum Beispiel einer Hash-Map.
Also, insofern bleibt ja nur Once-Lock, weil ich das so eine Art Constructor-mäßig initialisieren muss.
Und dann noch ein RW-Lock da drinnen, weil ich die Mutable Reference nicht aus dem Once-Lock rauskriege. Was auch immer.
Okay. Wieso ich die IDE benutze? Weil ich sie ausprobieren will. Und weil das Chatplanes-Zeug in der Regel ziemlich nice ist.
Okay, weiter. Insert Track. Wie geht das Go-Zeug weiter jetzt?
Also, in Go haben wir als nächstes jetzt Create Connection, Leute.
Connection. Das bauen wir jetzt nach in Rust.
Also, Create Connection. Als erstes brauchen wir die API-Funktion und legen eine neue Pair-Connection an.
Das habe ich auch schon gemacht in Rust. Das gibt es hier.
Dann adden wir die Tracks. Okay, das klingt auch logisch.
Also, hier haben wir unser API-Objekt, wo wir neue Connections anlegen können.
Okay.
Die Offer, die wir hier eröffnen.
Das kommt erst später. Und das hier kommt auch erst später.
So, hier haben wir die Pair-Connection.
Jetzt brauchen wir eine Loop über alle Tracks.
Jetzt bin ich mal gespannt.
For I in Tracks. Das geht so im Leben nicht.
Tracks. Moment. Ich brauche jetzt Get Unwrap.
Read. Jetzt tatsächlich nur Read Unwrap.
Ne. Unwrap?
Einfach so.
Let Tracks. Da haben wir hier eine lokale Variable draus, ja.
Tracks.
Funktionst du das jetzt?
Tracks.
Und jetzt Iteraten.
Okay, nice, nice, nice.
Kann die IDE irgendwie...
Use Destructing Declaration. Okay.
Also, einmal für ID und einmal für Pair Connection.
Aber ich merke schon, die Rust-Leute schreiben das nicht gerne aus.
So, kompiliert es noch?
Okay, nice, nice, nice, nice, nice, nice.
Also, das habe ich bei Rust gelernt. Sobald es kompiliert ist, dann geht das auch.
Meistens.
Kann man das hier irgendwie umbrechen, dass man das irgendwie ein bisschen besser lesen kann?
So, ha.
Ich weiß nicht, ob das die korrekte Formatierung ist für Rust.
Aber es fällt mir einfacher zu lesen, als das 500-mal Unwrap hintereinander zu machen.
Hintereinander.
Vorloop ist verboten.
Wieso, was ist... Hä?
Also, ich meine verboten offensichtlich ja nicht.
Aber was ist der Vorteil zum Loopen von einer Collection keine Loop zu nehmen?
Das klingt doch schon beim Aussprechen weird, oder?
Siehst du, verständlich. Ja, das stimmt.
Das ist ein gutes Rust-Kriterium.
So.
Jetzt muss ich die Pair-Connection, die braucht jetzt Add-Track.
So was gibt es hier bestimmt auch.
Natürlich nicht.
Moment.
Ich bin ja auch Massive, Massive-Pepega.
Das ist ja auch nicht Pair-Connected.
Was mache ich denn für einen Blödsinn?
Das hier sind ja die Tracks.
Nicht die Pair-Connections.
Das sind die Tracks.
Und die Pair-Connection, die habe ich hier.
So, Add-Track.
Track.
So.
Geht nicht.
Weil?
Warum?
Unused.
Await.
Perfekt.
Unwrap.
Noch besser.
Excellent.
Und jetzt mag er nicht.
Weil?
What?
Expected.
Arc.
Dünn.
Track.
Local.
Plus Send.
Plus Sync.
But found.
Artic Sample.
Was expectet der?
Ein Arc.
Dünn.
Track.
Local.
Send.
Sync.
Das ist ja fast schon schlimmer als C++, die Syntax hier.
Okay.
Ich kopiere mir das einfach mal raus und frage ihn, ob es das überhaupt gibt.
Ne.
Das gibt es gar nicht.
Okay.
Arc kenne ich.
Das ist, das ist Reference Counting Zeug.
Machen wir jetzt einfach.
Arc.
New.
Arc.
New.
Track.
Track.
Local.
Ne.
Einfach nur Track.
Okay.
Das geht nicht.
Weil?
Ach.
Der will das Objekt direkt haben und nicht einfach dereferenzieren.
Geht nicht.
Vermutlich.
Weil er sagt.
Cannot move.
Oh.
Oh.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
Nein.
und und das ist für irgendwelche callbacks also ich weiß ich weiß was wir machen müssen und zwar
ob wir es lieb wie jeder weiß ist dass hier oben noch nicht lang genug das heißt wir brauchen jetzt
kein oneslog rw log hashmap wir brauchen einen oneslog rw log hashmap arg das war eindeutig zu
kurz noch wir brauchen noch einen weiteres unwrap irgendwo wieso über die hashmap weil die weil die
random ids oder random also theoretisch random ids bekommt jede jeder track so und jetzt muss
ich sagen
natürlich beim track hinzufügen schon sagen arg new track track ah ja jetzt seht ihr seht ihr und
jetzt machen wir das ganze noch mal arg und jetzt kann ich das hinzufügen weil jetzt ist es ja schon
in einem arg drin nein kann ich nicht das war fucking shit weil aber warum nicht expected arg
dünn found arg
ok das ist ein referencounter da habe ich was drüber gelesen das ist ein referencounter ich
muss jetzt quasi sowas sagen wie klon ja pfeifertime die sache ist bloß die klone ich jetzt in track
oder klon ich jetzt den arg ich will den arg klonen und nicht den track ok track hat gar keinen klon
nee twoowned will ich wahrscheinlich twoowned will ich nicht weil das ja in der collection
weiterbleiben soll.
Ich clone den Arc.
Dann passt das doch, oder?
Was convert
to UFKZ?
Äh, was ist
UFKZ?
Universal Function Call Syntax.
UFKZ.
Okay, Chad, was ist, was ist,
was ist geileres, was ist
geileres Rust? Punkt Clone?
Oder Arc
Clone Track?
Was, was machen die wahren Rust
Könner? Moment, so funktioniert
es überhaupt nicht, oder?
Aber mit Clone funktioniert es.
Äh, das ist ja super,
wir.
Guck mal, die IDE bietet mir
an, das umzuwandeln, aber das umgewandelte
ist gar nicht äquivalent zu dem
hier. Seht ihr das?
So geht das nicht.
Aber, aber so geht es.
Ich verstehe aber gar nicht, warum nicht.
Weil unter
der Haube macht Clone doch wahrscheinlich auch
Wow, what? Also, okay,
Leute,
eins kann man den Rust-Leuten nicht
vorwerfen, sie hätten zu wenig
Docs. Ich meine, seriously,
die Funktion besteht aus
drei Zeilen Rust. Drei Zeilen
Rust und 80 Zeilen Docs.
Also das Gegenteil von meinem Kram.
Ne, heute, heute muss
Rust, heute musst du durch
mit Rust, so.
Okay, das haben wir auch.
Also den, den Go-Part
haben wir auch umgewandelt. Jetzt geht es
darum,
die Offer für den Browser zu
createn. Das können wir uns hier schon mal
merken. Okay,
Create Offer.
Bei Go ist es 0.
Hier ist es None.
Neue Zeilen kommen.
So, und jetzt
brauchen, okay, das, jetzt, okay, das
weiß ich nicht, wie es funktioniert. Jetzt müssen wir
IP-Adressen einsammeln. Also,
Endpoints, wohin das Video geschickt
werden soll. Da muss ich
GitHub WebRTC,
da muss ich bei denen gucken, wie das, wie das
funzt in den Examples.
Examples.
Wir hatten doch hier so einen Single
Port hier.
Ice Restart.
Gather.
Gather
Complete. Create a channel that is
blocked until Ice Gathering
is complete. Wir blocken
until Ice Gathering is complete.
Leute, ihr wollt auch schon immer, bis, bis
das Eis gesammelt ist, blocken.
Gibt es, gibt es zu.
Nicer, nicer Blocker.
So, let mut
per connection
gathering completed
promise await.
Lass mich raten, unwrap. Ach ne, hier kein unwrap.
Ach so, ja, Moment, weil ich da später
drauf warten will.
Meine Güte. Und jetzt,
okay, per connection
set, set
local description.
Set local description.
Ich baue ein
Programm mit,
.net, backend und
low-level Rust WebRTC
Zeug.
Und ich hab nicht so super viel Ahnung von Rust.
Okay, per connection
set local. Da müssen wir jetzt wahrscheinlich
diese Offer da rein schieben,
dass das funktioniert. Natürlich nicht.
Das wäre viel zu einfach, wenn das einfach
funktionieren würde. Ach so.
Vielleicht.
Await. Unwrap. Unwrap.
Die sind so hässlich,
man. So, und jetzt muss ich warten,
bis er alle IP-Adressen diskretiert.
Wie funktioniert das so?
Gather completed, receive async.
Unwrap? Nochmal unwrap.
Alles unwrappen.
Guck mal, die unwrappen das hier auch nicht.
Warum nicht? Ach so,
weil sie es einfach,
weil sie es einfach droppen.
Auch gut.
Wir machen das exakt so, wie das
Beispiel das sagt. Also,
da hätten wir doch das hier auch schon geschafft.
Ja, unique. Ach so,
ja, track ID.
Track ID
habe ich, ähm,
nee, nicht track ID, ähm,
per-connection-ID habe ich nicht.
Brauche ich auch nicht.
Wird, werde ich einfach ignorieren.
So.
Also, heißt im Endeffekt,
wir brauchen jetzt,
ah, wir brauchen noch, okay, wir brauchen
das gleiche nochmal für Connections.
Tracks, once log,
log, Hashmap, arg,
per-connection.
Connections.
Ja, okay. Nice. Ritter Ross,
danke schön für den Sub.
Du bist mir auch heute auf GitHub gefollowt.
Habe ich gesehen.
War nämlich heute mal wieder auf GitHub eingeloggt,
auf der Startseite, da habe ich deinen Namen gesehen.
Fällt mir gerade ein, wo ich dich hier im Chat sehe.
So, Connections, das passt.
Okay.
Also, jetzt,
jetzt müssen wir die Connections speichern,
hier in dem Array, beziehungsweise in der Liste.
Du kannst mit Rust auf WebAssembly
aber keine UDP-Pakete versenden.
Nee, aber das ist ja auch nicht
auf WebAssembly-Basis, das ist ein
Server-Backend.
Letztendlich ruft der Server
per RTSP von Webcams
die Streams ab und schickt die an
beliebig viele Browser, die sich verbinden.
Okay, wie geht das jetzt nochmal hier?
Connections,
get,
unwrap,
write,
unwrap,
keck, wait.
Machen wir das,
machen wir das richtig so, okay.
So, nochmal die, die,
wie die Rust-Pros,
Zeilen und Brüche rein,
okay, so.
So, Connections,
Insert,
eine ID, okay, ich brauch ne Random,
ne Random, okay, komm, 1.
Das ist doch vollkommen egal.
Und jetzt,
die per Connection inserten.
Please, einfach
Funktionieren. Ah man, was ist
denn das Problem jetzt schon wieder? Achso, Arc,
okay, Arc, New,
brauch ich, muss das überhaupt in den Arc rein
jetzt? Warum haben wir das
nochmal in den Arc gemacht?
Okay, keine Ahnung,
ich, ich lass es ein.
Einfach mal als Arc, okay.
Connections geht nicht, weil
es mutable.
Ah ja.
Das musst du hier oben bei Tracks auch machen.
Heu, Ritter Rust heute, ja.
Vorkname, Build.
Hey, Leute, es, es, es, es
bildet, das ist schon mal top.
Okay, hier müssen wir jetzt, jetzt wird's
tatsächlich, tatsächlich noch ein bisschen komplizierter,
hier müssen wir jetzt ein
Struct returnen.
Struct returnen.
Und zwar soll das Struct folgendermaßen aussehen.
Offer und dann Client ID.
Ja gut, das ist relativ easy.
Also brauchen wir noch ein Struct,
Struct,
wenn wir das, nennen wir das einfach,
ähm ja, Connection result,
wie in C sharp
auch, Struct, Connection result
und da drin, okay,
PAP, wir machen das, nee, wir machen das PAP.
So, und da drin,
brauchen wir jetzt was wir brauchen client id das ist ein 32 oder so und wir brauchen offer
offer das ist ein moment wie mache ich denn da jetzt ein c string konst das ist das ist das ist
gold konst bei oder so es gibt c string das ist aber glaube ich nur zum zurückwarten hier brauche
ich das ist ein konst okay moment rast strakt inter opc return of ffi ja strakt von stars wie
geht das jetzt wenn er sich letztens im stream schon mal ausprobiert
und ich habe es irgendwie wieder gelöscht ja c char gibt's will er hier das ist das ist die das
ist die go variante so connection result muss man das nicht noch irgendwie muss man nicht
gut repräsent c rep c oder sowas wieso ja okay ich hoffe ich hoffe dass von so ich hoffe dass
von so connection result das heißt wir brauchen jetzt ein strakt was man hier returnen und zwar
mit dass ab jetzt werden wir es auch erst mal in c sharp testen ob es prinzipiell funktioniert
was ich da gebaut habe ok also return connection result client id 1 machen wir mal hier eine
variable da können wir die später oder ja id 1 da können wir die später austauschen ja also
id id und offer ja das muss jetzt in c string werden jetzt wird es jetzt evaciticade spannend
jetzt jetzt was hat er hier für schmerzen introduces was will er von mir ach so der will mir sagen dass
meine funktion nix return ich verwende dies zweimal wohl nicht oder ich verwende id nicht,
ich verwende id nicht zweimal wo ich nicht oder ich verwende die id nicht zweimal wie jetzt carbon tonic
jetzt die id ist ein int das sollte er doch kopieren oder das sollte er das sollte er
doch checken das will er nicht weil es ein u32 ist und das hier okay das ist ein i32 dann ist
okay so jetzt ist die große preisfrage wie krieg ich hier raus einen konst also wie kriege ich
jetzt moment herr connection wie habe ich das jetzt wie habe ich das jetzt in grau gemacht ja
pc lokal description okay das brauche ich hier auch lokal description an rap aus irgendwelchen
gründen wieder ein rap ok und jetzt scp so dass die große frage wie kriege ich das jetzt in den
c string ja ich glaube das ist ein c string ja ich glaube das ist ein c string ja ich glaube das ist
bilden wir auch ein dass ich das dass ich das vorgestern schon mal hatte aber irgendwie habe
ich hier drin hatte ich das vielleicht moment moment hatte ich das vielleicht hatte ich das
im benchmark champ trainer ja ja genau da habe ich doch da habe ich doch das habe ich die ganze
zeit gesucht man ist okay cstr new an rap und hier oben sternchen mut wobei es ist eigentlich egal so
optique zweckletter zu Government livreblue so das ist natürlich keine어가 austauschen
also was cstring to also per connect schlossen overweight also ist es ja im prinzip 눈kelauf
und ich weiß nicht wie
also im ver talvez gmaal ja was heißt darauf meint see string nie also per connect schl dl
a weight also im prinzip will ich das dahin
im kann
genau raus sehr gut sehr gut
ja ist auf meine und jetzt so natürlich nicht warum
warfaren e-phonewood warum ist dass unfeier 60
Ey, die auf einmal in U64.
Ist das der Default-Typ dafür, oder wie?
Ey, dann meinetwegen in U64.
Soll mir recht sein.
Und das will er nicht, weil...
Const but found C-String.
Und das war das Into...
Into Raw.
S-Pointer.
Okay, was hat er wieder für Schmerzen?
Value borrowed here after move.
Okay, er gibt Sinn.
Dafür ist Rust gut.
Ich hab's zuerst in die Collection eingefügt, anstatt da.
Okay, nice. Bild.
Okay, jetzt bin ich gespannt, ob das...
Chat hier.
Was meint ihr?
Funds das jetzt?
Oder Pepega Crash?
Stimmt, dass man das Ding STR nennen darf?
Komisch, ne?
Ich glaube auch...
Ich glaube, dass es funktioniert.
Weil in der Regel, wenn Rust kompiliert, dann crasht es selten.
Dann geht's einfach.
Ob's dann das macht, was man will, sei mal dahingestellt.
So, jetzt müssen wir das hier noch ein bisschen anpassen.
Wir haben eine Rust-Methode, die sich Init nennt.
Das ist korrekt.
Wir haben eine Rust-Methode, die sich CreateConnection nennt.
Das brauchen wir noch.
Und das ist übrigens auch nicht libRTC, sondern...
libRTC Linux heißt das hier.
So, Init haben wir.
Dann brauchen wir CreateConnection.
Schauen wir uns das mal von Go.
CreateConnection liefert zurück ein Struct,
das besteht aus einem U64.
U64 und einem CharArray.
Also.
ConnectionResult haben wir doch hier schon drin.
ConnectionResult.
Idisposable.
Okay, das Scheiß auf Memory leaks.
Bevor es kaputt geht, ich schmeiß das mal raus.
Ein IntPointer.
Uint64.
Gefolgt von einem Pointer zu einem String.
Ja, das sieht gut aus.
Nehme ich SessionConnection.
SessionResult.
Jetzt bin ich mal gespannt, ob das funzt.
Ich werde das mal...
Äh.
Warum ist es jetzt auf einmal kaputt?
Ah!
Weil ich Idisposable weggelöscht habe.
Ja, komm.
Dann sind wir halt Memory-safe.
Halbwegs, wenn es sein...
Wir tun einfach so.
Wir jibäden einfach.
Wir machen einfach in das Dispose nix.
Dann ist er zufrieden.
So.
Letztendlich, wir returnen jetzt mal E an der Stelle und sagen jetzt
Interop Rust Init.
Interop Rust Create Connection.
Und jetzt bin ich mal gespannt, ob das funktioniert.
ClientID sollte 1 sein.
Und Offer sollte irgendwie ja langer Text bei rauskommen.
Brage, Leute.
Ich brauche mindestens 5 Brages, bevor ich das ausstelle.
Ich brauche mindestens 5 Brages, bevor ich das ausführen kann.
Damit das funktioniert.
Eine Runde Brage, please.
Ich trinke mal was in der Zwischenzeit.
Okay, 5 Brages sind zusammen.
Wir haben es geschafft.
Also.
.NET
Run.
Oh.
Was?
Entry Point not found?
Ich habe Rust gar nicht compiled und rüberkopiert.
Ich kack noob.
Lull.
Release?
Nee.
Ähm.
Cargo Build.
Minus Minus Release.
Okay, das zählt jetzt nicht.
Ich habe vergessen, Rust zu kompilieren.
Das macht ja keinen Sinn.
Kann man mit Cargo, Cargo Output Path, kann man einstellen, wohin der outputet?
So wie mit Minus O zum Beispiel.
Nee, das ist mir zu doof.
Dann kopiere ich es.
Ihr Schmolz-Dring ist auch wieder am Start.
Ich kopiere es, ich kopiere es von Hand.
Soll mir, soll mir auch recht sein.
Auf jetzt.
Alter, der benutzt einfach, guck mal.
Das sind meine CPU-Cores hier oben.
Der kompiliert blazingly fast, highly efficient.
So, MV, Target, Release, Web, nee, Linux.
Warum heißt denn das so dumm?
Ach so, weil ich das einfach so eingestellt habe.
Arsch.
Da fällt mir nämlich ein, dass ja...
Das Go-Binary und das Rust-Binary nicht gleich heißen können.
Okay, komm.
WebRTC, dann heißt das hier so, ja.
WebRTC Rust.
Da kann man es wenigstens unterscheiden.
So, WebRTC Rust.so hoch nach Backend.
Alles klar.
So, LibWebRTC Rust und kopieren in den Output.
Alles klar, auf geht's.
Bam.
Also, Chat, ich würde sagen, der erste Part hat funktioniert mit dem Struct.
Die zweite Sache mit dem String, nicht so richtig.
Warum nicht?
Pointer to UTF-8-Dings.
Das sieht, also der C-Sharp-Teil sieht, finde ich, richtig aus.
Was mache ich denn in den Go falsch?
Was mache ich in den Go falsch?
Das hatten wir vorgestern auch, ja.
Möglich?
Ich weiß, woran das liegt.
Chat, ich weiß, woran das liegt.
Guck mal.
Ich glaube zumindest, dass ich weiß, woran das liegt.
Das sind keine Encoding-Errors.
Das ist, weil das Memory freigegeben ist.
Nee, ich weiß, woran das liegt.
Guck mal hier.
Das da wird wahrscheinlich freed, wenn die Funktion returnt.
Der will ja.
Wobei, kopiert er das vielleicht?
Kopiert er das vielleicht?
Kann man das klonen?
Okay, klonen.
Mein Gott, Alter, das ist schon wirklich extrem hässlich, oder?
Hier.
Await unwrap.
Unwrap.
Und dann machen wir gleich hier S-Pointer drunter.
Oh.
Unsafe.
Ja, und?
Alter, ich weiß, dass das unsafe ist, Mann.
Dann lasse ich es halt weg.
Und mache es hier unten erst.
Okay, so.
Compile-Action.
Run.
Fuck.
Mach ich denn verkehrt?
Okay, lasst uns mal checken, ob das überhaupt in Rust richtig ist.
Okay, wir müssen mal was gucken.
Das hier ist Client-ID.
Client-ID ist ein U64.
Und das hier ist auch ein U in 64.
Das kann es schon mal nett sein.
Into Raw ist richtig.
Okay, ja.
Ja, ihr habt recht.
Ihr habt recht.
Das stand sogar in der Hilfe drin, gell?
Into Raw.
Und dann...
Moment, will der das jetzt?
Moment, warum geht denn das?
Warum geht denn das?
Das ist doch hier oben Kunst und nicht Mutt.
Rust-Ugly-Syntax.
Ja, Rust ist Ugly.
Das sehe ich auch so.
So, Funst ist jetzt.
Jetzt ausprobieren.
Auf Kompilieren.
Mach ich eine...
Ist nicht Blazingly-Fast-Compiler gerade?
Ah, viel besser.
Viel besser schon.
Da fehlt aber noch was, oder?
Das ist ein bisschen wenig.
Wir geben das hier trotzdem noch mal aus, kurz.
FMT.
Nee, nicht FMT.
Print.
Wir sind ja nicht in Go.
Print.
Fair Connection.
Local Description.
Oh Mann, was?
Await.
Unwrap.
Ja, okay, toll.
Ganz toll, Rust.
Perfekt.
Formatstring.
Sehr gut.
Wir lassen es auch noch mal hier ausgeben.
Aber ein bisschen...
Das ist ein bisschen kurz.
Das ist ein bisschen wenig.
Und ich glaube auch nicht, dass der eigentlich hiermit aufhören soll.
Ehrlich gesagt.
Doch.
Das ist...
Das ist zu wenig.
Das ist nicht...
Das ist nicht genug.
Da fehlen die ganzen Tracks und sowas drin.
Aber ich habe die Tracks hinzugefügt.
Warum offert der kein Track?
Das verstehe ich jetzt.
Null.
Haben wir hier irgendwas falsch?
Media Engine?
Payload Type 690.
Okay, das können wir noch später schreiben.
Wie weit wir sind.
Und?
Schwer zu sagen.
Also, das ist auf jeden Fall verkehrt.
Das ist zu wenig, was der hier zurückliefert.
With Media Engine.
Media Engine.
Haben wir hier alles?
Settings Engine.
UDP.
Das ist zu wenig.
Das ist zu kurz.
Was da zurückkommt.
Also, ihr habt es ja gesehen vorhin.
In Go kommt da viel mehr zurück.
Da fehlen beispielsweise auch die ganzen Tracks.
Mir ist fast so, dass ich hier nicht mehr so viel mehr zurückkomme.
Mir ist fast so, als ist Tracks leer.
Könnte das sein.
Sind drin.
Keck weh.
Wir können es leider nicht anders debuggen gerade.
Mir ist fast so, als wäre Tracks leer.
Die Once-Vlogs mache ich nicht leer.
Außerdem kann man Once-Vlogs gar nicht leer machen.
Dann müsste er meckern.
Siehste?
Tracks ist leer.
Das wird gar nicht ausgeführt.
Ich glaube, habe ich Add Track vergessen?
Oh.
Ich habe, Leute.
Add Track habe ich vergessen.
Lull.
Ja, kein Wunder, dass es nicht funktioniert.
Add Track.
Ist das so?
Add Track?
Create Track.
Okay.
Ja.
Ja, dann ist klar, dass es nicht drinnen auftaucht, wenn man es gar nicht aufruft.
Interop Rust.
Create Track.
So, jetzt nochmal, please.
Und jetzt einfach funktionieren.
Ja, das sieht schon deutlich besser aus.
Keck weh.
Das sieht viel besser aus.
So muss das sein.
Sehr schön.
Das ist gut so.
Das ist gut.
So, so sieht das in Go, so, so ungefähr sieht das in Go auch aus.
Du kannst auch was, das DBG-Makro benutzen.
Was, was macht das?
Das macht Zeug.
Ach, das gibt die Zeile aus.
Gut zu wissen.
Das ist nice.
Das brauche ich.
Okay.
Okay.
Also.
Der Part funzt.
Dann geht es weiter.
So viel ist es gar nicht mehr, was wir umziehen müssen.
Und dann kommt der Moment der Wahrheit, ob es funktioniert.
Aber das sieht gut aus.
Es sieht wirklich, es sieht wirklich gut aus.
Also jetzt nicht, nicht Rust Code an sich, sondern das sieht funktionierend aus gerade.
So, also weiter.
Das funzt.
Wir kriegen jetzt die.
Komm, lass uns, lass uns der Ordnung halber.
Ne, habe ich schon mutt hingeschrieben.
So, also das haben wir.
Wir haben, wir haben ja fast alles.
Guck.
Das haben wir umgezogen.
Das haben wir umgezogen.
Uns fehlt eigentlich nur noch das hier.
Und das ist echt überschaubar.
Nur noch das hier fehlt uns.
So, also das heißt, wir brauchen jetzt eine Function.
Gleiche hier nochmal.
Die heißt jetzt allerdings Set Answer.
Da kriegen wir als Parameter jetzt allerdings einen.
Das ist natürlich die Frage, ob das denn.
Ja.
Ja, das eigentlich, eigentlich kann das kann es auch Konst, ein Konstring sein.
Konst C Char.
Ja, komm, das heißt einfach Pointer.
Bester, beste Benahme gehabt.
Types mismatch.
Hier muss nichts returned werden.
Okay, wir brauchen das gleiche wieder wie hier.
Wir brauchen die Connections, die Connections, also die, die, die, die per Handshake schon aufgebaut wurden.
Wo ist das hier?
Connections.
Ah, Moment, Moment, Moment, Moment, eins habe ich ja noch vergessen.
Brauchen die Connections.
Wir brauchen, wir brauchen noch einen zweiten Parameter und zwar wir brauchen noch was?
Ein U64 und zwar die ID von dem Ding brauchen wir noch.
Das muss hier, das muss ja auch noch übergeben werden, sonst funktioniert das nicht.
Ich hoffe.
Ich hoffe, ich mache das hier schon.
Okay, also.
Set.
Äh, gibt ein Connection Result, kompletter Schwachsinn, Max.
Keine Ahnung, was du da gebaut hast.
So, und das ist jetzt genau das gleiche, genau das gleiche wie bei Go.
Ähm, ne, Uint64.
Und das Ganze soll als UTF-8 C-String Pointer da reingeschoben werden.
Gachi Bass.
Also wir bekommen eine ID.
Wir bekommen hier das Array mit den Connections.
In das ich jetzt übrigens nur lesen möchte.
Das ist so hässlich, oder?
So, jetzt kommt's, Traummann.
Also, get die ID.
Und dann ist, kriege ich die Connection raus.
Unwrapped, was sonst?
Was sonst?
Was hat der hier für Schmerzen?
Wir brauchen ein und.
Und wir brauchen eine Referenz.
ID.
Die C-Sharp-Methoden-Namen sind aber nicht, doch.
Das ist, das ist korrekte.
Korrekte .NET Naming Convention.
Die Rust-Sachen nicht, ne.
Die, die Rust-Sachen sind so gemacht, wie das die Rust-Leute gerne hätten.
Okay, Per Connection.
Da müssen wir jetzt.
Set.
Set.
Remote Description.
Brauchen wir da jetzt.
Und irgendwie müssen wir jetzt den String.
Pointer wieder zurück umwandeln.
In einen.
Oh.
Geht das?
Wie wandle ich?
Das muss ich googeln.
Das muss ich googeln.
C.
Sharp Pointer Rust to String.
How do I convert to uns?
Nein, ich will.
Ja, das will ich sowas in der Richtung.
C.
String from.
Okay, das ist einfacher als gedacht, ehrlich gesagt.
C.
String from Pointer.
Let still.
Was, was hat er jetzt?
Was hat er für Schmerzen?
In .NET sind doch Methoden-Namen immer groß.
Ja.
Ähm.
Du hast recht.
No.
I never tried to compile WebAssembly and I never used STL in Rust.
Du hast recht.
Die Methodennamen sind falsch.
Die sollen tatsächlich.
Komm, wir machen, wir machen es korrekt.
Wir machen, wir machen, dass sich Microsoft freut.
Können die mir gleich paar Influencer Millionen überweisen.
So gut.
Okay, was kommt jetzt als nächstes?
Also das funzt nicht.
Warum funsten das nicht?
Weil unsafe.
Okay, unsafe.
Alter, was ist mit der Idee los?
Die ist ja voll im Arsch.
Ja, unsafe to function.
Bam, geht nicht.
Wahrscheinlich, weil an der falschen Stelle.
Muss bestimmt hier hin.
Nee, muss dahin.
Ja, nice.
Gut.
Try and error.
Wo muss unsafe hin?
Also an der, an der Rust-Idee müssen die echt noch ein bisschen arbeiten.
Und jetzt müssen wir hier die Remote Description setzen.
Wie macht man das jetzt?
RTC?
Wie hieß das?
RTC Session Description.
Gibt es da irgendwie so ein Parse oder sowas?
Was?
Was soll ich umbenennen?
Ach, unsafe drumherum.
Ach Quatsch, das, das alles, was ich hier mache, ist unsafe.
Okay, Parse gibt es nicht.
From?
From.
From klingt gut, aber das ist from.
Jetzt ist die Frage, wie, wie parse ich denn jetzt meinen String als RTC Session Description?
Marschal.
Marsch?
Anmarsch?
Nee.
Ja, das ist jetzt wieder sehr fmt.
Nee.
Into? What?
Das ist jetzt wieder sehr pfeifert.
Ich kapier wieder die einfachsten Sachen nicht.
Vielleicht so?
Answer?
Achso, guck mal da.
SCP String.
Strrr.
Let's...
Ah.
Äh, Unwrap?
Was sonst?
Selbstverständlich.
Obviously immer Unwrap.
Okay.
Und hier.
Awaiten und Unwrappen.
Ich träume heute Nacht von Unwraps.
Das geht nicht, weil...
Ah, weil es ein C-String ist.
Jetzt ist die Frage, wie ich ein C-String...
Kann ich To String sagen?
Sehr schön.
Ex...
Moment, da gibt es einfach...
Wait a minute.
Das geht doch im Leben nicht.
Ich kann doch garantiert nicht sagen In To St...
Nee, Moment.
To String.
Nee, nee.
Es ist...
Jetzt habe ich mir schon fast gedacht, wenn das...
Was?
Okay.
Obviously.
Alles klar.
Rust Fehlermeldung.
Consti 8 doesn't implement standard format display.
Consti 8 cannot be formatted.
Beste.
Alles klar.
In To.
To Owned.
So.
Also das hat schon mal nicht funktioniert.
Aber kann ich vielleicht den hier To String machen?
In To C-String.
In To String.
Ich bin immer noch etwas verwirrt.
Etwas verwirrt, wie ich das da hinbekomme.
C-String.
From Pointer.
To String.
Und was?
To Owned.
Unwrap.
Alter.
Was ist...
Moment.
Alter, was ist das wieder?
Das ist ja Ausge...
Ausgeburt der Hölle.
Das könnte ja direkt aus irgendeiner C++ Anleitung entspringen.
From Pointer.
To String.
To Owned.
Unwrap.
So.
Jetzt haben wir ein...
Das geht immer noch nicht.
Und da muss ich jetzt wahrscheinlich nochmal hinten dran machen.
Nochmal To String.
Oder To Owned.
Nee.
To String.
MonkaS.
MonkaS, Mann.
Was?
To Owned?
Können wir auch machen.
Okay.
Hier habe ich To String ja schon drin.
Warum gibt es To String und Owned?
Nee.
Das ist wieder was anderes.
Der will hier einen String.
Das funktioniert...
Hä?
Hä?
Moment.
To Owned sagt doch ganz klar...
Ach nee.
Es returnt einen String.
Okay.
Warum gibt es...
Hier sagt To Owned ganz klar, es returnt einen Slice und keinen String.
Und wenn man es dann einfügt, dann returnt es doch einen String.
string ok man muss das nicht verstehen ob das funktioniert meint es liegt an
der idee ok prägen ob es funktioniert ich glaube wir haben alles umgezogen
also haben wir gemacht set answer
set remote description haben wir gemacht ok leute der moment der wahrheit
wir haben wir haben wir haben das portiert von rust von go nach rust jetzt
jetzt jetzt kommt es darauf an ob das funktioniert also interop rust create
track offer interop rust create connection ich meine wir haben nichts
wirklich an den interfaces geändert die haben alle die gleichen datentypen und
so das müsste jetzt eins zu eins austauschbar sein präge richtig hart
rein
prägen chat es muss jetzt muss massive geprägt werden dass das funktioniert so
und jetzt haben wir set interop rust set answer ach so weil es ein int64 ist
int64 so jetzt bin ich ja mal gespannt ob das funst man es crasht schon mal
net beim start
denn dann
oh shit es ist crasht es ist geclashd ich weiß nicht genau wo es gecrasht ist
credibility
feeling all shit es ist gecrashed es ist gecrasht ich weiß nicht genau wo esữ
crasht okay warum warum sind wir hier gecrasht das sieht alles gut aus warum
sind wir hier gecrasht was was was ist hier crash ich glaube wir
crasht weil stand da auch irgendwas result unwrapped mpsc sent channel
closed was soll das jetzt bedeuten der fehlerbehandlung ist überbewertet was
ist mpsc send channel closed was möchte mir es sagen wir suchen wir gucken uns
noch mal ein beispiel an set remote description offer await ja so ähnlich
ja so ähnlich können wir das moment wie heißt das ding ich brauche mal ein
ordentliches beispiel set remote description
code kann man nicht durchsuchen weil ich eingeloggt bin dann gibt es gibt es
eigentlich nur eine möglichkeit wir klonen uns da schnell und creppen da
drin immer ganz ganz ruhig terminal ganz ruhig ganz ruhig examples examples
grepp nach set remote description
ups
ja ice ice restart haben wir auch irgendwas wo wo ich die erst wo ich die
anfrage schick und nicht umgedreht hier set remote description answer data
channels create der rest ist eigentlich offer answer
ja eigentlich okay wir können uns so dass date data channels create rast beispiel
angucken so sollen wir auch recht recht sein wie man okay remote await
fragezeichen macht der typ ist das was was was direkt weg räumt möglich ich habe
keine ahnung was mir was sagen möchte ja ja connection set remote also irgendwas
ist close es ist gut dass an der stelle ein rap steht
weil das sehen wir wenigstens woran es liegt also wenn ich das richtig verstehe
der macht das hier auch so ein weight fragezeichen ist glaube ich das gleiche
wie an rap oder wenn es wenn man den passenden result type hat oben das geht
nur über den passenden result type hat hier was ich nicht habe weil es erzählt
weil weil es eine funktion ist für c ok aber heißt im endeffekt so was was räumt
er hier auf
channel close wir gucken einfach mal die issues rein super geil ja so toll geil
okay wir finden nichts dazu es ist closed ja ja die frage ist warum das
klaus ist ich meine das hier funst ja offensichtlich das ist die antwort so ok
chat
ich
notiert so machen okay da bin ich zu peter für keine ahnung wie das fonds
prinz
nach so format ach so man ach so man kann das
man macht das hier rein ok das ergibt sinn ja verstehe wieso sind die augen
kaputt wegen rast oder wegen dem kontrast vom editor chat ich muss mal
chat gucken ich habe bestimmt was
es ist keine idea dasrom mehr tatsächlichУng poirot
steht noch nicht klquisite
falsch
suas
ahnung was das ding von mir will null was macht denn set remote description
guck mal rein wirklich kein plan was das was das macht
mps mps c gathering complete hattest du nicht irgendwo kreislein code shows
watch ist non-blocking von alter was die syntax man da fuck ich mache doch gar nichts direkt mit
diesem channel das verstehe ich nicht was sie mir damit sagen wollen also was ich auch nicht
checke ist was der wo hier irgendwas ich blocke ich ich ich erwarte und rappe öfters mal aber
das kann ja nicht verboten sein also ich habe keine ahnung was sie hier sagen da drin was
irgendwie relevant ist so was könnte was könnte das denn sein man was hat was hat er hier für
schmerzen sollen wir einfach mal soll man einfach mal das ignorieren das wird nicht
funktionieren ich war ein fehler schon seinen sinn räumt er vielleicht wirklich irgendwo was
auf ich meine wo wo create ich denn die connection ich meine eigentlich
ach so das receive ja das ist bei hier ist das gathering complete ist das ja das erwähnt das
erwähnte ich bis das fertig ist aber das machen die auch das machen die auch hier das machen die
hier auch feuer und das muss ich auch machen sonst kann ich an den browser ja gar nichts
schicken ja keine also ich habe ich habe legit ich meine wir haben das gute ist wir haben den code
eins zu eins von go rüber übersetzt und da funktioniert das heißt also an der an der
prinzipiellen logik kann das nicht liegen eine sache die ich halt nicht checke ist wo macht er
überhaupt was mit ihr ihr selbst ist close return error ok kann man irgendwie sagen wait jetzt wie
geht das mit pattern matching kann man sich nicht irgendwie den den error irgendwie ja genau result
at
du kommst außerdem ruf werden was da denn ist dort ok ich dachte irgendwie speziell tearout typ oder so wir machen an various schon ok hier was macht er hier log await sie die jedenfalls nach dem channel aus und ja ich bekomme ich bekomme eine antwort wisst ihr was wir komp 발ieren das ganze noch einmal kurz im debug bekommt man im debug mot jetzt bekommt man da mehr infos irgendwas irgendwas sinnvolles wenn ich die leiter im debug get мар lại
modus kompilieren rast backtrace 1 to display ok hoffentlich geht das auch so
sieht man sogar was da ist so also wo kackt er jetzt ab an web 59 58 dass das
das also wo das ist habe ich schon gecheckt 58 hier bei dem an web ja das
ist mir auch klar dass das das ist so und jetzt sagt er was choris alt an web
set answer ja okay was cash park what blocking region guard aber das wird hier
nirgendwo aufgerufen ich habe es dann zumindest nicht gefunden
ok die fehlermeldung ist
für mich jetzt zumindest an set rast backtrace kann man das kann man das ganze also wieder
wieder kompilieren komplett lass uns mal weiter gucken was er hier macht so desk
passt passt so wo könnte der hier getrenn sie was vielleicht hier irgendwo getrenn sie was self
remote description
du bekommst von der library einen channel receiver ach so du meinst das ist gar keine fehlermeldung in dem sinn sondern es gibt eine fehlermeldung weil der hier aus dem scope raus geht aber warum aber warum moment aber warum nee nee nee nee aber warum kackt er dann ab beim an web und nicht irgendwie erst danach oder aber wo bekomme ich irgendwas ich sehe hier nichts meinst du das ding
für die
dikata komplett das ist doch was ganz was
was anderes
das ist doch hier fertig
das kann das hat auch damit nichts zu tun also das wäre doch wer ultra weird hat das was damit zu tun
also das ist ja für für ip adressen look up und und endpunkte sammeln was hat das jetzt das hat das eine mit dem anderen zu tun
du meinst das hier müsste ich quasi speichern sozusagen den
option
option
option
Oder was kommt denn da überhaupt raus?
Meinst du, ich muss das hier irgendwo speichern?
Das hier?
Nee.
Nee, das...
Das ergibt keinen Sinn.
Ich meine, wisst ihr, was wir machen können?
Kick, wait.
Also, wir lassen das einfach mal weg.
Wir lassen das mal weg.
Und...
Kann man in Rust irgendwie Async sleep?
Also, quasi sowas wie Task Delay.
Tokyo Timers.
Time.
Sleep.
Duration.
Okay, das ist gut.
Äh, Duration.
Oh Gott, wie fünften das jetzt?
Äh, gibt's da nicht irgendwie einen gescheiten...
From seconds.
Okay.
Wir lassen den einfach mal 5 Sekunden schlafen.
Und jetzt await.
Unwrap.
Nee, einfach so?
Wartet das jetzt an der Stelle 5 Sekunden?
Nee, im CamChamp ist das nicht drin.
Das hab ich noch nicht gepusht.
Außerdem geht's ja um den Library Code.
Wartet er jetzt hier 5 Sekunden?
Schauen wir mal.
Jetzt bin ich mal gespannt.
Okay, äh...
Nee.
Send.
Also, auch wenn ich das hier nicht verwende,
juckt ihn das nicht.
Das ist schon mal nett.
Das ist schon mal nett.
Okay, was?
Ähm...
Answer.
Ja, die machen hier auch nix Spezielles, ne?
Oh, was ist denn das hier?
Done?
Nee, das ist...
Das hat nichts...
Das hat nichts damit zu tun.
Das hier ist ihr komisches Signaling.
Das hat mit dem Kram nichts zu tun.
Okay.
Das ist für die Shell.
Danach wird geclosed.
Ich hab legit keine Ahnung, was das Problem ist.
Also, jede FFI-Funktion bekommt ihre eigene Runtime.
Ja, ist das schlimm?
Ich mein...
Ich hab hier so ein paar globale Dinger.
Ich würd den Tokio-Krempel ehrlich gesagt auch weglassen.
Aber dann funzt die Hälfte nicht,
weil die intern Tokio-Zeug verwenden.
Wenn die Library ein Background-Task spawnt,
dann ist das weg.
Du kannst auch eine Static-Runtime machen.
Aha.
Ich mach das nur, damit es funktioniert, ja?
Also...
Ich hab keine Ahnung, was...
Ich will das gar nicht verwenden.
Ich muss das aber verwenden,
weil die Library das irgendwie benutzt.
Ey, ich hab echt keinen Plan.
Wir haben eins zu eins von Go umgezogen.
Also, das muss jetzt irgendwelche Rust-Spezialitäten sein.
Was ist denn, wenn ich das einfach...
ignoriere, was der hier macht?
Dann wird's halt wahrscheinlich einfach nicht gehen,
aber nicht abkacken.
Ja.
Ja, äh, äh, äh...
Nee, jetzt kackt er nicht ab.
Jetzt kackt er nicht ab.
Aber es funktioniert halt nicht.
Alter, was ist das?
Hier, Remote Description.
Das Zeug kann halt keiner lesen.
Was?
Media, Media, RTC.
Ist mir wurscht, ob du das empfehlen würdest oder nicht.
Der einzige Grund, warum ich Rust verwende, ist,
weil ich die Library verwenden will und gucken will,
ob man das noch ein bisschen schneller als mit Go hinkriegt.
So.
Was macht der hier unten für Dinger?
Hier.
Komm mal da.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Hier.
Wen juckt's?
Ich muss wissen, wo der hier abkackt.
Ich hab keinen Plan,
was die hier dreimal...
Der Backtrace
hat
Rust interne Sachen gesagt.
Moment.
Der war nicht so wirklich aussagekräftig.
Guck hier.
Der erzählt, dass er
Probleme hat.
In meiner Zeile 65.
Runtime RS
von Tokio blocked on
multi-threaded
enter runtime
cache park
unwrap
core result unwrap
Bam. Was auch immer.
Das ist Rust Rover.
Ey, das ist ja
mega kacke, Alter.
Also jetzt mal ernsthaft.
Ich benutze das
mit diesem Tokio Main
ja nicht, weil ich da so scharf drauf bin,
sondern
weil das das Einzige ist, wie es funktioniert hat.
Ich hab halt absolut
keine Ahnung.
Also wenn ich das, wenn ich das lösche
hier zum Beispiel, dann
geht's
immer noch.
Okay.
Nee, er kompiliert, aber er funktioniert nicht.
Er erzählt
ja auch hier, dass das jetzt, dass das nicht
safe ist, weil das Async ist.
Ja, und ich kann's jetzt nicht
ja, und ich kann's jetzt nicht
awaiten. Gibt es, gibt es
sowas wie ein hartes Wait,
oder?
Ohne Await, oder?
Nee, gibt's nicht.
Gibt es nicht ein normales Wait?
Einfach?
Äh.
Mehr Error Handling.
Es gibt keine Errors, die ich handeln kann.
Ey, das geht nicht ohne.
Ey, das ist halt doof.
Wie würde ich dem denn sagen,
dass der alles mit der gleichen
Runtime, was auch immer, das
Okay.
Tokio Rust
Main.
Max, ey,
du bist echt bei der Selected Runtime.
Set up a Runtime with us.
Runtime or Builder directly.
Hier.
Das Marco can be used on any Function,
not just the main Function.
Using it on a non-main makes the Function
behaves as it, as it, if it was synchronously.
Was?
Starting a new Runtime each time it is con.
Ich meine, es stört mich nicht, aber es ist
wahrscheinlich nicht so schlau.
One Cell ist Standard Library mittlerweile.
Use current Thread Runtime.
Aha.
To use the single Thread Runtime known as the current Thread Runtime, the Marco can be configured.
Und dann werden die alle auf dem gleichen Thread ausgeführt, oder wie?
Okay.
Ich copy-paste es jetzt einfach mal rein.
Ich habe absolut keine Ahnung, was das macht, ey.
Das wird es nicht bringen, ne.
Moment, Moment.
Das ist Massive 5-Head Rust, ey.
Unwrap.
Die Fehlermeldung im Chat.
Hier.
Moment, ich habe die Hälfte.
Hier.
Oh!
Mein Copy-Paste ist wieder on point.
Zweifel, dass man damit groß was anfangen kann.
Habe ich jetzt überall? Single Threaded?
Excellent.
Schauen wir mal aus.
Äh.
Wird abgekackt.
Wir wissen ja noch nicht mal, ob das an irgendwelchen Tokio-Sachen liegt.
Bad-Kit-Time.
Ne, heute ist es ein bisschen länger.
Equivalent Code.
Not using Tokio Main.
Tokio Runtime.
Build a new Multithread.
Enable all.
Build.
Unwrap.
Block on.
Alles klar.
Aber wenn ich das mache, muss ich dann allen Code, den ich ausführen will, in irgend so ein komisches Ding hier reinwrappen?
Das kann es doch nicht sein.
All das.
Alles.
Also.
Oder.
Oder schreibe ich dann irgendwie da oben, oben hin.
Tokio.
Ich bezweifle auch irgendwie, dass das das Problem ist.
Warte, warte mal.
Wir suchen jetzt mal hier drinnen.
Silver.
Captain Sergeant Silver.
Danke.
Du musst nur die Funktion per Runtime get.
Unwrap.
Block.
Action.
Aber wenn ich das so habe.
Guck mal.
Wenn ich das so habe, ist das dann nicht auch alles in der gleichen Runtime, weil hier irgendwie was dransteht?
Also da wüsste ich jetzt nicht, wie ich das machen soll.
Das heißt, das heißt ja im Endeffekt, ich bräuchte.
Jede Funktion doppelt.
Im Prinzip jede Funktion doppelt.
Das ist super weird, Champ.
Das heißt, ich brauche.
Ich brauche jede Funktion hier doppelt und würde dann aus der aus der C-Funktion nur noch eine Runtime.
Get.
Unwrap.
Block.
On.
Das macht.
Macht dir das Bock?
Na dann.
Ich.
Das wirkt äußerst planlos gerade.
Ich glaube auch nicht, dass ich das hinkriege, heute das zu beseitigen.
Also ich meine, im Endeffekt bräuchte ich dann quasi.
So was.
Ja, das mal so.
So ein paar Blablabla.
In it.
Dann machen wir das hier weg.
Oh, das kommt dahin.
Das kommt weg.
So.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Alles gut schon lobbying gut das warumonsstoss so und dann würde ich und dann würde
ich quasi sagen, dass es das muss ich habe, das muss ja schon mal.
Nicht extra extern sein.
Und dann würde ich quasi sinngemäß sagen.
So.
So oder okay und.
Da bin ich ja mal gespannt jetzt.
Also ich baue mir.
Ich baue mir einen ran tay Suflower.
In es sollte nicht mehr es.
ach das hier ja ja ok ok so heißt im endeffekt ihr erinnert da kann ich das
ja machen so heißt im endeffekt tokyo runter bilder new multithreader blog
blog und hier das brauchen wir nicht wir brauchen den runtime und das muss in
so einen lock lock once rein was ist wirklich man runtime runtime was hat er
jetzt ach so ja das kann so so in it runtime geht's an rap ok also das heißt
wir sagen
jetzt runtime set runtime ok er ja nicht gedacht dass das überhaupt an rap
was das kombiniert er wirklich so meinst du das so so und jetzt würde ich im
endeffekt jedes mal wenn ich das aufrufe so in etwa so wir gucken mal was passiert
wenn ich es ja auch vor ob das nicht gleich crasht
es kräft
es kräft
noch nicht funktionieren aber eltern
ja so mein nicht gut das heißt wir haben das es ist ja gar kein so großer akt das
möchte ich nicht gleich weil es weht auch nicht funktionieren aber ja gleiche
error zumindest kommt als ausschließen dass das
eben in tokio schickt ist gut also dass heißt wir haben ja seither fall so
großer akt dass zu fixen also im endeffekt das dass das kann ich mir copy
interne sagt das kommt hierüber das kommt weg das kommt so hin so und das
muss nicht mehr es doch das muss das muss nicht mehr sein und das muss nicht
mehr extern c sein okay was habe ich jetzt vergessen
und worum es geht web rtc mit rust webcams stream in browser runtime an
web runtime get unwrap und unwrap so ach jetzt haben wir den return code krempel
am start create moment was hat er denn jetzt überhaupt für probleme hier oben
und
was will er hier nach multiple times und jetzt will er was ach so ja wie
kriege ich wie kriege ich denn da jetzt return types zurück oder machte das
automatisch ach so das checkt er automatisch okay ich muss gar nichts
machen nice ja das ist okay das ist wirklich nicht so um kompliziert das
jetzt umzustellen da brauchen wir nur die zwei funktionen
haben wir schon
so enko biver sowie continuer das hier gerade noch mal drüber so und das heißt
jetzt das ist gut so dann ruft das set estava auf den trend das hat kein
return type und das hier muss zwar noch an z èwl sein aber kein extern her jetzt
wird dir mal mit auf kochen chat dass ich nicht irgendwas vergisst dass es jetzt für ein bisschen wiem dass der check tennis friendly da als ich nicht irgendwas vergessen
Was ist jetzt für ein Problem? Achso, das ist hier noch dran.
So, jetzt sollte der eigentlich... Ich lecke Critical Information. Was ist jetzt?
Achso, Takes to Arguments. Okay, MonkaS, logisch.
Und Async weg. Takes to Arguments heißt im Endeffekt das da.
Und das Taked ID und Pointer. Bis in Dark Zone.
Äh, ja, komm. Unsafe. Equate.
Warum darf Unsafe nicht überall hin?
Was ist jetzt?
Oh je. Jetzt ist Deadge... Was?
Trade future is not implemented for... No, it's not English.
Was will der von mir überhaupt jetzt?
Ach, Async wieder rein. Oh man, da muss man sich echt voll konzentrieren.
Compiliert's? Ja. Gut, dann fehlt jetzt eigentlich nur noch eine Sache.
Dann, okay, dann blenden wir das um.
Internal, das hier ist easy. Da gibt's nix Input, nix Output.
Das kommt weg.
Extern C kommt weg.
So, das kommt auch weg.
Das kann, by the way, auch weg.
Ja, ja, ja, okay.
Create Track muss das heißen.
Hat keinen Input.
Internal bekommt auch keine ID.
So, hab ich irgendwas gecheckt?
If you have any questions, you can ask them in the chat.
But my English is not a yellow from the egg.
Ich hab keine Ahnung, ob ich irgendwas verkehrt gemacht hab.
Nutella rein soll ich ohne Butter drunter.
Okay.
Jetzt, wir gucken mal, ob's funktioniert.
Wir gucken mal, ob's funktioniert. Ich glaube, ich hab...
Blixkrone, hast du irgendwas gesehen? Hab ich irgendwo was vergessen?
Ich glaube nicht.
Glaube, glaube nicht.
Okay, Brake Time, Chat.
Chat, Brake, Brake.
Lass das jetzt funktionieren, ey.
Es geht! Es geht!
Es funktioniert!
Nice, nice, nice, nice.
Chat, ich muss, ich muss ehrlich sagen,
das ist eines der wenigen Vorkommnisse,
kommt ja sonst nie vor, ne, aber
ohne den Chat
hätte ich das diesmal nicht hingekriegt.
Der Chat ist ja sonst oftmals ziemlich
Community-ge,
aber heute war der Chat sehr hilfreich,
der Blixkrone auch gerade, und nicht nur der Odolmed und so,
also viele, also alle, die da waren.
Aber ein paar kennen sich eindeutig besser mit Rust aus als ich.
Und andere im Chat.
Okay, zweimal Refreshen von der Seite
funktioniert übrigens nicht.
Gescheit.
Weil ich Massive-Pepega bin
und die gleiche Connection-ID
wiederverwende. Also,
das ist noch nicht sonderlich
schlau gebaut alles, aber es funktioniert.
Boah, ist das...
Alter, das ist aber wirklich...
Also, Chat, da wäre ich ohne euch nicht drauf gekommen hier.
Beim besten Willen nicht.
Was war jetzt eigentlich nochmal das Problem?
Ich weiß... Moment, ich hab's gefixt,
aber ich weiß das Problem nicht mehr.
Wir wissen das nicht genau.
Tokyo Main
spawns every time
the function is called
a new runtime.
At least the readme
says so.
I have no idea what this
means.
Also,
ich gehe davon aus, dass eines...
Also, das Problem ist aufgetreten,
weil die...
weil die Funktionen in unterschiedlichen
Runtimes gelaufen sind.
Async Runtimes.
Warum es doch immer sowas gibt und nicht eingebaut ist,
man weiß es nicht.
Jetzt sorgen wir dafür,
dass es immer die gleiche Runtime ist,
die das Ganze ausführt.
Was genau das Problem war,
wissen wir aber trotzdem nicht.
Also, warum er sich daran gestört hat.
Wir wissen nur, dass er sich daran gestört hat.
Also, ich habe jetzt noch 20 Minuten Zeit.
Ich würde jetzt gerne das noch so bauen,
dass ich die Seite mehr als einmal refreshen kann,
dass ich die Seite mehr als einmal...
Das liegt daran.
Guck hier.
Now I use the same runtime.
But only because Flixcoder
ist 5-Head-Chatter.
Ich...
Ich frag mich jetzt.
Rust ist zu optimiert. Genau.
Also, wir können das doch...
Also, ich brauch... Okay, ich brauch random...
Was heißt random IDs? Ich brauch nicht random IDs.
Ich brauch unique IDs
für jeden Track und für jede Connection.
Track ist nicht so wild.
Track gibt es eh nur einen.
Gibt es sowas wie einen Atomic?
ID-Connect ist immer dieselbe.
Ja, das ist das Problem. Ja, ja, genau.
Gibt es irgendwie einen Atomic-Counter oder sowas?
Atomic...
Wow, what?
Ne.
Da habe ich auch schon dran gedacht.
UIDs.
Wobei, Leute,
ich habe die Idee.
Wir nehmen UIDs,
UIDs sind 128-Bit, richtig?
Und 128-Bit
ist relativ neu.
In .NET gibt es
einen U128.
Das machen wir. UID-Time, Leute.
Poggers. UID-Stells.
UID-Rusts.
Das brauchen wir.
Welches...
Welches...
Ist das das letzte Crate?
In Documentation?
Homepage?
1.5.
Okay.
Wie geht das?
Cargo?
Cargo-Add, gell?
Cargo-Add.
UUID.
Und jetzt Build.
Und jetzt erstmal wieder das halbe Internet
kompilieren.
Also, wo? Per Connection.
Gehe ich übrigens
richtig in der Annahme,
dass das jetzt auch deutlich schneller ist
beim Aufrufen der Funktion,
weil er nicht für jeden Funktionsaufruf
eine extra Runtime starten muss?
Minus FV4?
Was V4 ist?
V4 ist die
Random UID, gell?
V4 ist random und die anderen
sind irgendwie mit Date-Time-Stamp oder sowas.
Wenn ich das richtig im Kopf hab.
Chat, ich habe eine Zusage
für ein duales Studio bekommen. Kann jetzt für die
Theorie-Phasen für speziell
entscheiden. Einmal IT-Security
und einmal KI. Sollte ich einrollen, kann ich das auch machen?
Von beiden nehmen?
Was dir besser gefällt? Also,
keine Ahnung, was besser für dein Studium ist.
Das kann ich nicht beurteilen. Ich würde sagen, was dir
gefällt.
Also, Zukunft haben mit Sicherheit
beide Sachen. IT-Security
ist auf jeden Fall, sagen wir mal, safer.
Da weiß ich,
dass auf jeden Fall Leute gebraucht werden.
KI ist so ein Zukunftsding, wo man sagen würde,
ja, da werden auch Leute gebraucht und wahrscheinlich
in Zukunft noch mehr. Also, KI
ist ein bisschen vager, wo man jetzt nicht
so hundertprozentig weiß, wie viel
werden es mal wirklich, die da gesucht werden.
Aber IT-Security ist auf jeden Fall immer nicht
verkehrt. Wenn das nicht HackerMan
ist, dann hätte ich keinen Bock drauf.
So, lass mal hier kurz weitermachen.
Also, hier. Wie gehen das jetzt? UUID?
Import?
Warum?
Warum?
Hier steht doch bestimmt... Ja, V4.
Let's... Random... Was ist denn hier?
Hier, V1. Timestamp
und Counter. Ist doch für mich vollkommen
okay. Timestamp und Counter.
Random Data.
Was ist denn der Default überhaupt?
Wir können das mit Random Data machen.
Aber
wir testen ja erstmal prinzipiell, wie es funktioniert.
Okay, wie benutzt man den Kram
denn jetzt eigentlich? New?
New V4?
Moment,
kann das sein, dass nur V4
überhaupt... Moment,
wir machen das jetzt mal... Ich glaube, es ist
sogar nur V4 da.
ID 2.
Ich glaube, es gibt gar nichts anderes als V4
bei mir.
Cargo Run. Ne.
Run? Ach ne, das geht ja nicht.
Oder?
Weil Library.
Kackel. Moment.
Ich bin gerade etwas
verwirrt.
SU128.
Das ist top. Das brauchen wir.
Heißt im Endeffekt, auch den anderen
Krempel müssen
wir umstellen auf U128.
Client ID.
Achso.
Moment, Moment,
Moment, Leute. Gibt es überhaupt
in C ein...
Na ja, gucken wir einfach mal,
was er sagt.
Ja, ja, ich mach das dann.
What the fuck?
Found U64?
Achso, bei Connections.
Ja, Moment, bei Connections ist ja wurscht.
Bei Connections
kann das noch U64
bleiben.
Moment, ich blicke gerade nicht mehr durch.
Okay.
Ähm.
Wo sind wir jetzt?
Insert.
ID. Hä?
Expected U64?
Warum?
Ne, hä? Wieso?
Es sind doch beides
128.
Found U64? Hä?
Was?
Ach, jetzt sind wir bei Get.
Wo sind wir jetzt?
Connections.
Ach, hier.
Ah.
Not FFI safe, ja.
Ich weiß.
Ich weiß.
Es ist not FFI safe.
FFI, das ist so
ein allgemeiner Begriff, nur wenn du
Interop zwischen verschiedenen Sprachen machst.
Genau, Foreign Function Interface.
In der Regel ist damit gemeint,
dass beide
Sprachen quasi miteinander reden
können, so wie es C auch gemacht hätte.
Also, der kleinste
gemeinsame Nenner ist quasi die Art und Weise,
wie C aufgerufen wird.
Und das können so gut wie alle
Sprachen. GoCans,
PythonCans, RubyCans. Mir fällt eigentlich
keine, mir fällt eigentlich keine
Sprache ein, die kein C-Interface hat.
Wahrscheinlich sogar Fortran und
COBOL haben wahrscheinlich ein C-Interface.
Mit Sicherheit, die sind noch älter.
So, also, er sagt, das geht nicht.
Ich glaube ihm auch, dass das
nicht geht. Okay, ja, Chatge.
Ich glaube, dass das nicht
funktioniert, aber wir testen das jetzt.
Mal. Und zwar,
Run.
Kackt auf jeden Fall
nicht ab. Okay.
Und jetzt sagen wir, Interop
Rust Create
Connection.
Rust Create Connection.
Oder Splitten, dann hast
du 64. Nee, das ist aber nicht Unique
genug. Wenn dann einmal erst
die 20.000 User da drauf gehen.
Bei mir daheim auf die Webcams vor allem.
Null. Dann
geht das.
Okay, das Funst.
So, also, jetzt bin ich ja mal gespannt,
ob das funktioniert.
Connection Reset.
Das ist noch
Client ID. Ach, Moment.
Das ist ja das Falsche.
Das sind jetzt nur die ersten 64 Bit.
Das sind noch die ersten 64 Bit.
Das muss jetzt ein...
Ja, mal gucken, ob das überhaupt
funktioniert. Uint 128.
Ob das jetzt tut.
Oh, Shit. Was ist?
Int and System
cannot be passed by value
to unmanaged. Chat,
wir tricksen C Sharp jetzt aus.
Ich sag euch, wie wir das machen.
Passt mal auf. Absolut
Five Head Modus. Hatte ich gerade
spontan so eine Idee.
Nee, ich hatte nicht spontan so eine Idee.
Ich hab sowas ähnliches schon mal gemacht.
Ich hoffe, das funktioniert jetzt auch.
So, Struct. Wir nennen das jetzt einfach C
Uint
32.
Und sagen jetzt Public
Uint 64
Upper
Lower
Und jetzt ist das sowas hier.
Jetzt sollte es zumindest nicht mal
crashen. Es crasht nicht.
Passt mal auf. Und jetzt
Six Head Mode.
Uint 128
Pass
Convert
Moment.
Shit.
Convert?
Uint 128 gibts da nicht.
Hat das Ding ein
Constructor vielleicht? Uint 128?
Alter,
genau. Ich wusste es doch. Ich wusste es.
Ich hab das schon mal gemacht.
Ich hab schon mal Uint 128
gebaut aus zwei
Int 64s.
Deswegen.
Ich hab mich doch da richtig dran erinnert.
So, passt mal auf Chat.
Easy.
Jetzt müssen wir nur noch überprüfen, ob das
stimmt. Jetzt müssen wir nur noch checken,
ob das stimmt.
Du warst mit dem Splitten, ne, du warst mit dem
Splitten unwissentlich relativ gut dabei.
Jetzt müssen wir nur noch gucken, ob das
stimmt. FMT, ach
Mann, Alter. Moment, gibt es
sowas hier?
Das ist eklig.
Ist hier was cool, wenn man
einfach. Ah!
Kann man ja.
Kann man auch DBG machen?
HiIQ
IDE, Mann.
Einfach 8 CPU-Kerne voll.
Okay.
Shit.
Das sind unterschiedliche
Zahlen.
Das sind unterschiedliche
Zahlen. Okay.
Passt mal auf. Nur für den
Fall, dass ich es vertauscht hab, okay?
Nur für den
Fall, dass ich es vertauscht hab.
Easy. Ich hab's vertauscht.
Ich hab's vertauscht.
Ich hab's vertauscht.
An welcher Stelle? Moment, wo hab ich's denn
vertauscht hier nochmal? Upper?
Lower? Okay.
Wo hab ich's denn vertauscht?
Ähm.
Struct?
Wo ist das denn überhaupt?
Ach, ich bin doch falsch.
Hä?
Ich find mein eigenes Zeug nicht mehr.
Hier.
Ach, Rust, schick die
einfach andersrum.
Ach so.
Wobei,
ich hab, ich hab die
einfach falsch rum hier, oder?
Ich hab die nicht falsch rum, das ist doch richtig rum.
Upper zuerst, Lower
als zweites. Warum ist die
Warum ist die in Rust? Mal ganz
davon abgesehen,
es ist eh keine allzu schlaue Idee.
Es ist eh keine
allzu schlaue Idee,
das so zu machen, wenn der hier schon
drüber meckert. Ich meine,
ich hab keinen Aufruf,
ich return das Int einfach.
Aber,
wir sollten das, wir sollten das wahrscheinlich eh anders
machen, weil man
kein U128 returnen
kann. Ähm.
Was mach ich denn da jetzt
am besten? Ich mein,
ich kann doch einfach auf die Meldung scheißen, ja?
Und sagen, ist mir doch
egal, ob das
safe ist oder nicht.
Jaja, mach ich, mach ich.
Aber hier muss ich's vertauschen.
Als String,
nee, als String schick,
schick ich das nicht.
Das ist nicht blazingly fast.
Als String wär ja easy, nee, nee, nee,
das muss schon als Int.
Gibt es, Moment,
Int U128 Rust Fwe, gibt's das?
Als Byte Array?
Byte Arrays kann man nicht,
kann man nicht als Value schicken,
vermute
ich.
Byte Arrays kannst du eigentlich nur als Pointer
schicken.
Oder? Ja, doch.
Ich könnte, ich könnte
zwei, ich könnte einfach
zwei Sachen schicken, ja? Ich könnte
hier so, so
Upper, Lower und so, das könnte ich schicken.
Zwei, zweimal, aber
das ist doch trotzdem doof.
Wir können doch einfach echt auf die Meldung scheißen,
das scheint ja trotzdem zu funktionieren.
Und wisst ihr was? Soll ich euch mal was sagen?
Es ist auch vollkommen egal,
ob Upper oder Lower,
die Zahl, die am Ende rauskommt,
ist trotzdem Unique, wenn es in der Mitte
gesplittet ist. Also wenn es,
wenn es, wenn die erste Hälfte
plus die zweite Hälfte
Unique ist zusammen,
dann ist auch die zweite Hälfte
plus die erste Hälfte Unique.
Also insofern, die Hälfte
würde schon ausreichen, nein,
komplett muss das.
Ey, da muss ich mir mal Gedanken drüber
machen. Chatge, weil ihr
so nice heute wart,
push ich das jetzt auch auf GitHub, okay?
Weil ich muss gleich Badge.
Git ignore musst du
auf jeden Fall, musst du es rein.
Git add.
Oh shit, ich glaube,
ich füge gerade den ganzen Output da hinzu.
Max, ganz schlechte Idee.
Ich, ich, ich füge
30 Milliarden Rust-Sachen.
Wollen wir
weitermachen? Ja.
Oh shit, ich füge gerade,
wie groß ist denn mein Rust-Ordner, bitteschön?
2,7 Gig in's Git.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
Wie um alles in der Welt kommen da Windows-Line-Endings rein.
Der Rest ist alles gut.
Wo, wo, hä?
Das ist Linux-only entstanden.
Warum macht Rider, nee, nicht Rider, doch Rider.
Warum macht Rider Windows-Line-Endings da rein?
Was ist das für ein Shit?
Okay, wir müssen eben mal was anpassen, schnell.
Wir machen das jetzt einfach mal rückgängig.
Okay, ja.
Nee, das funzt aber nicht mehr.
Egal, das ist temporärer Stand.
Will eh keiner ausprobieren.
Ähm, hier.
Da, nee.
So, und jetzt?
Jetzt muss er bestimmt Reformat oder so machen.
Wie kommt das auf Windows-Line-Endings, Mann?
Okay.
Ja, das ist schon besser.
Schon besser.
Keine Windows-Line-Endings mehr drin.
Richtig ekelhaft gewesen, Mann.
Nee, das ist in Rider.
Nicht in Rust.
Ihr, ihr auch, guckt.
In der Projektdatei.
In, Alter.
In, in der Projektdatei, Mann.
Unload.
Hier.
Das ist nicht Default.
Also, vielleicht ist es Default, aber ich hab das ja vorher auch mit Rider erstellt, aber es nicht so.
Oh.
Jetzt Status.
Oh, wow, wow, wow, wow, wow.
Oh, Java.
Okay, please.
Ich, ich sollte mir mal n Hook einbauen, dass ich keine Windows-Line-Endings mehr hab.
Okay, keine Windows-Line-Endings mehr.
Alles gut.
Oh.
Nice, niceke.
Niceke.
Okay, nix mehr.
Uncommitted, Git, Push,
Origin,
Master,
Ah,
ich kack noob.
Git, Remote,
Remote, AM,
Origin, Git, Remote,
Add,
Cam,
Champ, Git,
Push, nice.
Da brauchen wir keine
Force-Pushers sein aktuell.
Aber ich Force-Pushe gerne.
Ich bin meistens auch der Einzige, der
quasi Master-Force-Push-Berechtigung
auf der aktuellen Arbeit
nicht, aber auf der aktuellen Arbeit gewesen ist.
Auf der aktuellen Arbeit
stelle ich mir das aber auch immer ein.
Ich darf Force-Pushern.
So, gut.
Ich würde sagen,
wir haben ordentlich was...
Äh.
Das wurde eh entfernt.
Wir haben ordentlich was auf die Reihe gekriegt,
Chat-Gehäute.
Viel gelernt.
Pfeifern, Rust,
High IQ.
Und ich würde sagen,
schön, dass ihr so lange mit am Start wart.
Ging ja heute lang.
23 Uhr.
Wir sehen uns.
Bis denn.
Bis morgen früh.
Denkt dran, morgen früh,
Aufwach-Stream.
Es kann sein,
dass ich erst kurz nach 9 da bin,
weil ich eventuell,
wenn es morgen früh nicht pisst,
wie aus, äh,
regnet aus Strömen, so,
äh, 10 Kilometer Runde mache.
Wieder.
Und das bietet sich sonntags immer an.
100 Kilometer, ja.
Nee, morgen probiere ich noch mal 10 Kilometer Runde.
Ich bin ja, äh...
Wann war das?
Letzten oder vorletzten Sonntag?
Auch schon die Runde gelaufen?
Also, ich muss sagen, war gar nicht...
War gar nicht...
Muss ich mich...
Ich muss mich ja kurz, mal kurz, ähm...
Eine Runde selber lobpreisen.
Ähm...
Am 5. November, okay,
ist vorletzten Sonntag gewesen.
Guck mal hier.
Gar nicht mal so kacke, oder?
10,3 Kilometer mit 6,34 pro Kilometer im Schnitt.
Geht auch voll in Ordnung.
Irgendwann schaffe ich es auch noch mal unter einer Stunde.
Also, unter einer Stunde heißt...
Man glaubt gar nicht, wie viel schneller das ist,
aber das ist sehr viel schneller.
Also, man denkt so, das ist easy.
Man bekommt doch da ohne Probleme 7 Minuten weg.
Aber, Leute, lasst euch gesagt sein,
...
Jeweils...
Jeweils, sagen wir mal, 40 Sekunden schnell...
Das ist echt...
Also, es sieht nicht so viel aus,
aber es ist echt viel anstrengender,
das zu rennen.
Das heißt, weil bei einer Stunde
muss ich ja quasi permanent unter 6...
Und knapp unter 6 Minuten pro Kilometer rennen.
Das ist deutlich anstrengender als 6,34.
Wir sehen uns, Leute.
Bis morgen.
See you.
