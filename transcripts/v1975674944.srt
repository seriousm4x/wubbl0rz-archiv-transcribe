1
00:02:29,230 --> 00:02:44,790
So, heute Pfeiffer-Time, Leute.

2
00:02:47,690 --> 00:02:48,450
Broggers, ja.

3
00:02:49,170 --> 00:02:50,870
Wir benchmarken heute mal ein paar Sachen.

4
00:02:52,130 --> 00:02:55,910
Und zwar, ich glaube, ich zeige euch das.

5
00:02:55,990 --> 00:02:57,650
Bevor ich jetzt lange erzähle, ich zeige euch das einfach.

6
00:02:58,930 --> 00:03:04,600
Also, wir haben ja auch im Stream schon ein bisschen mit Web...

7
00:03:04,600 --> 00:03:06,520
Ich muss mal ein bisschen leiser machen.

8
00:03:07,700 --> 00:03:09,560
Heute schon gesportet, ja, heute Morgen.

9
00:03:09,560 --> 00:03:21,770
Und, allerdings, die Lautstärke kann zwar wieder nicht entscheiden.

10
00:03:24,610 --> 00:03:24,910
Okay.

11
00:03:25,950 --> 00:03:29,510
Aber heute nur 5,56 Kilometer.

12
00:03:30,150 --> 00:03:32,510
Nicht wieder 10 plus wie letzten Sonntag.

13
00:03:33,730 --> 00:03:36,290
Also, ganz normale Runde, die ich sonst auch renne.

14
00:03:36,910 --> 00:03:38,970
Die, naja, wobei nicht exakt die gleiche.

15
00:03:38,990 --> 00:03:40,430
Meine normale Runde 6,2.

16
00:03:44,150 --> 00:03:45,890
Ich mach schon mal meine VM an.

17
00:03:45,890 --> 00:03:49,950
Ich muss jetzt erstmal, bevor es losgeht, ich zeige euch jetzt, was wir machen.

18
00:03:50,730 --> 00:03:58,090
Und, dann futter ich nochmal zwei Plätzchen, die ich mitgebracht habe, hier gerade.

19
00:03:59,330 --> 00:04:02,250
Aber in der Zwischenzeit können wir nochmal Package-Update auf der VM machen,

20
00:04:02,350 --> 00:04:04,310
falls es es in der Zwischenzeit schon gegeben hat.

21
00:04:05,050 --> 00:04:07,610
Weil, ich glaube, zuletzt haben wir heute Morgen geupdatet.

22
00:04:08,910 --> 00:04:10,450
Also, ich zeige euch, was wir heute machen.

23
00:04:10,550 --> 00:04:11,790
Ich glaube, das wird recht spannend.

24
00:04:11,910 --> 00:04:13,910
Zumindest interessieren mich die Ergebnisse auch.

25
00:04:17,050 --> 00:04:20,270
Und zwar, wir rufen heute von C-Sharp aus,

26
00:04:20,830 --> 00:04:22,030
sowohl Rusty, als auch von C-Sharp, aus.

27
00:04:22,030 --> 00:04:22,530
Sowohl Rusty, als auch von C-Sharp, aus.

28
00:04:22,550 --> 00:04:25,550
Sowohl Rust Funktionen auf, als auch Go-Funktionen.

29
00:04:26,030 --> 00:04:30,170
Das liegt daran, ihr könnt euch vielleicht noch dran erinnern,

30
00:04:30,690 --> 00:04:35,310
ich hab im Stream ja schon öfters mal ein bisschen mit WebRTC auf Serverseite rumgebastelt.

31
00:04:35,710 --> 00:04:41,970
Zum Beispiel, dass man sich connecten kann in einem Browser und dann Webcams abspielen und solche Geschichten.

32
00:04:42,050 --> 00:04:44,530
Also, ich hab ja schon öfters mal ein bisschen mit WebRTC rumgebastelt.

33
00:04:45,470 --> 00:04:50,170
Und ich hab die letzten Tage über mal so ein bisschen Just for Fun wieder ein bisschen rumgebaut mit WebRTC.

34
00:04:50,390 --> 00:04:52,170
Also, WebRTC ist quasi...

35
00:04:52,550 --> 00:04:55,210
Realtime Video im Browser

36
00:04:55,210 --> 00:04:58,030
Nicht Streaming, wohlgemerkt, nicht Streaming

37
00:04:58,030 --> 00:04:59,810
Sondern, also Streaming

38
00:04:59,810 --> 00:05:00,850
Ist ja meistens HLS

39
00:05:00,850 --> 00:05:03,110
Also HLS ist

40
00:05:03,110 --> 00:05:03,830
Was heißt das?

41
00:05:05,010 --> 00:05:06,650
Für was steht HLS eigentlich?

42
00:05:08,880 --> 00:05:09,500
Gute Frage

43
00:05:09,500 --> 00:05:12,860
HTTP Live Streaming, okay

44
00:05:12,860 --> 00:05:15,080
Wusste ich gar nicht

45
00:05:15,080 --> 00:05:17,040
Also die ganzen Streaming Seiten

46
00:05:17,040 --> 00:05:18,520
Die funktionieren meistens über HLS

47
00:05:18,520 --> 00:05:21,140
HLS ist relativ easy, HLS gibt es

48
00:05:21,140 --> 00:05:21,580
Eine

49
00:05:21,580 --> 00:05:25,020
M3U8 Datei

50
00:05:25,020 --> 00:05:26,580
Und da stehen dann URLs drin

51
00:05:26,580 --> 00:05:28,760
Die rotated werden und alle paar

52
00:05:28,760 --> 00:05:30,920
Sekunden gibt es da

53
00:05:30,920 --> 00:05:32,340
Einen neuen Eintrag drin und dann

54
00:05:32,340 --> 00:05:34,720
Streamt das, also das macht ab und zu mal ein Get

55
00:05:34,720 --> 00:05:37,140
Und dann holt sich so ein 5 Sekunden Häppchen vom Stream

56
00:05:37,140 --> 00:05:38,800
Und dann macht es wieder ein Get

57
00:05:38,800 --> 00:05:39,980
Neues 5 Sekunden Häppchen

58
00:05:39,980 --> 00:05:42,920
WebRTC ist tatsächlich Realtime

59
00:05:42,920 --> 00:05:45,300
Von Endgerät zu Endgerät

60
00:05:45,300 --> 00:05:46,740
Das ist besonders gut, wenn man

61
00:05:46,740 --> 00:05:48,660
Möglichst Latency Free Video haben will

62
00:05:48,660 --> 00:05:50,020
Was cool ist für

63
00:05:50,020 --> 00:05:52,640
Ja Audio Calls

64
00:05:52,640 --> 00:05:54,120
Also beispielsweise Microsoft Teams

65
00:05:54,120 --> 00:05:56,320
Und sowas, das läuft nach Möglichkeiten über WebRTC

66
00:05:56,320 --> 00:05:58,280
Und halt auch

67
00:05:58,280 --> 00:06:00,220
Für Videokameras

68
00:06:00,220 --> 00:06:02,520
Wenn man zum Beispiel drauf gucken will, wer vor der Tür steht

69
00:06:02,520 --> 00:06:03,020
Und sowas

70
00:06:03,020 --> 00:06:06,220
Und das möglichst Latency Free sehen will

71
00:06:06,220 --> 00:06:07,840
Alles, dann ist WebRTC gut

72
00:06:07,840 --> 00:06:09,500
Aber das machen wir heute nicht, ich sag nur

73
00:06:09,500 --> 00:06:10,700
Wie ich drauf gekommen bin

74
00:06:10,700 --> 00:06:14,120
Und ich verwende für

75
00:06:14,120 --> 00:06:16,200
Oh ich hab irgendwas im Auge, das ist ja super

76
00:06:16,200 --> 00:06:17,100
Abartig ey

77
00:06:17,100 --> 00:06:21,040
Razer, danke für den Sub

78
00:06:21,040 --> 00:06:25,480
Und by the way, wir installieren gerade mal

79
00:06:25,480 --> 00:06:26,440
Die neue

80
00:06:26,440 --> 00:06:28,640
Die neue Jetbrains

81
00:06:28,640 --> 00:06:32,120
IDE für Rust

82
00:06:32,120 --> 00:06:34,660
Erstmal

83
00:06:34,660 --> 00:06:35,740
Erstmal hier updaten

84
00:06:35,740 --> 00:06:38,020
Die Toolbox darf auch updaten

85
00:06:38,020 --> 00:06:39,720
Genau und normalerweise

86
00:06:39,720 --> 00:06:42,000
Hab ich das immer mit dieser Library hier gemacht

87
00:06:42,000 --> 00:06:45,280
Und die ist in Go

88
00:06:45,280 --> 00:06:47,940
Die ist in Go

89
00:06:47,940 --> 00:06:51,280
Und eine Sache, die mich in Go

90
00:06:51,280 --> 00:06:53,460
Immer genervt hat, ist Stripes, danke schön für den Sub

91
00:06:53,460 --> 00:06:55,340
Eine Sache, die mich in Go

92
00:06:55,340 --> 00:06:56,600
Immer genervt hat, ist

93
00:06:56,600 --> 00:06:58,840
Dass Go

94
00:06:58,840 --> 00:07:01,160
Interopt mit anderen Sprachen

95
00:07:01,160 --> 00:07:02,900
So langsam ist

96
00:07:02,900 --> 00:07:05,540
Die IDE ist absoluter Müll

97
00:07:05,540 --> 00:07:07,500
Echt, hast du schon ausprobiert?

98
00:07:08,740 --> 00:07:09,620
Wie heißt denn das Ding überhaupt?

99
00:07:09,740 --> 00:07:11,460
Hier, Rust Rover

100
00:07:11,460 --> 00:07:15,040
Was verwendest du, wenn das kacke ist?

101
00:07:16,500 --> 00:07:17,620
Meistens sind die Jetbrains

102
00:07:17,620 --> 00:07:19,480
Singer doch immer ganz gut, ja

103
00:07:19,480 --> 00:07:21,520
Zumindest Goland ist nice

104
00:07:21,520 --> 00:07:22,600
Und Rider ist nice

105
00:07:22,600 --> 00:07:37,760
Oh Max

106
00:07:42,210 --> 00:08:00,100
Was macht Visual Studio Code besser?

107
00:08:00,100 --> 00:08:29,430
Plätzchen, Stealth

108
00:08:29,430 --> 00:08:39,930
Easy Light, keine Ahnung was die da treiben

109
00:08:39,930 --> 00:08:45,260
Das denke ich persönlich auch

110
00:08:45,260 --> 00:08:47,180
Es würde mich wegen der interessieren

111
00:08:47,180 --> 00:08:50,660
Was Mr. Robot nicht gefallen hat, beziehungsweise

112
00:08:50,660 --> 00:08:59,600
Was ist denn wie das Code besser ist?

113
00:08:59,600 --> 00:09:06,250
Okay, Update ist raus, installieren wir das

114
00:09:06,250 --> 00:09:15,880
Das Ding buggt in der VR manchmal ein bisschen

115
00:09:15,880 --> 00:09:18,780
Also, nachdem ich meine Plätzchen weggestellt habe jetzt

116
00:09:18,780 --> 00:09:20,000
Kann ich weiter erzählen

117
00:09:20,000 --> 00:09:21,600
Genau und die Library, die ich immer

118
00:09:21,600 --> 00:09:22,480
Wie gesagt, ich sage euch gleich

119
00:09:22,480 --> 00:09:23,920
Wir machen heute nicht viel WebRTC

120
00:09:23,920 --> 00:09:25,000
Wenn überhaupt, gar nicht

121
00:09:25,000 --> 00:09:27,380
Es ist nur nicht, wie ich auf die Idee gekommen bin

122
00:09:27,380 --> 00:09:31,500
Und zwar, für WebRTC habe ich immer diese Library hier verwendet

123
00:09:31,500 --> 00:09:37,280
Aber eine Sache, die mich an Go aufrufen aus anderen Sprachen

124
00:09:37,280 --> 00:09:38,960
Immer extrem abgefuckt hat, ist

125
00:09:38,960 --> 00:09:44,400
Dass das, wenn man das öfters callt, ziemlich langsam ist

126
00:09:44,400 --> 00:09:46,160
Es gibt zwei Varianten

127
00:09:46,160 --> 00:09:50,000
Wenn man aus Go selber C-Funktionen aufruft

128
00:09:50,000 --> 00:09:52,460
Also quasi von Go auf Go

129
00:09:52,480 --> 00:09:54,240
Andere Sprachen aufruft

130
00:09:54,240 --> 00:09:55,140
Dann ist das langsam

131
00:09:55,140 --> 00:09:58,760
Aber es hält sich noch halbwegs in Grenzen

132
00:09:58,760 --> 00:10:02,280
Wenn man aus anderen Sprachen in Go reincallt

133
00:10:02,280 --> 00:10:03,760
In Go-Code reincallt

134
00:10:03,760 --> 00:10:07,620
Dann ist das in der Vergangenheit zumindest extrem langsam gewesen

135
00:10:07,620 --> 00:10:11,340
Also, wir reden hier von

136
00:10:11,340 --> 00:10:15,400
Ein Native Function Call von C-Sharp nach C-Sharp dauert

137
00:10:15,400 --> 00:10:17,540
Was weiß ich

138
00:10:17,540 --> 00:10:19,380
Keine Ahnung

139
00:10:19,380 --> 00:10:21,600
Eine halbe Nanosekunde oder so?

140
00:10:22,480 --> 00:10:24,240
Es ist kurz

141
00:10:24,240 --> 00:10:29,480
Und ein Call nach Go rein dauert irgendwie 300 Nanosekunden

142
00:10:29,480 --> 00:10:32,240
Also, Go ist sehr langsam

143
00:10:32,240 --> 00:10:35,720
Wenn es um Interop mit anderen Sprachen angeht

144
00:10:35,720 --> 00:10:38,240
Das hat mich immer genervt, weil

145
00:10:38,240 --> 00:10:41,360
Ich sende mehrfach

146
00:10:41,360 --> 00:10:47,280
Also ich sende 30 mal die Sekunde pro Kamera

147
00:10:47,280 --> 00:10:52,340
Neue Video Frames nach Go und die WebRTC Library verarbeitet

148
00:10:52,340 --> 00:10:53,340
Die dann

149
00:10:53,340 --> 00:10:54,340
Im Endeffekt

150
00:10:54,340 --> 00:10:58,340
Ich habe, sag mal, wenn du 30 FPS pro Kamera hast

151
00:10:58,340 --> 00:10:59,340
Hast 10 Kameras

152
00:10:59,340 --> 00:11:02,340
Was sagst du, hast du 100 Kameras?

153
00:11:02,340 --> 00:11:06,340
Hast du 3000 Function Calls die Sekunde

154
00:11:06,340 --> 00:11:07,340
Das ist nicht viel

155
00:11:07,340 --> 00:11:10,340
Und das ist auch, ganz ehrlich

156
00:11:10,340 --> 00:11:16,340
Selbst wenn es richtig, richtig langsam ist in Go

157
00:11:16,340 --> 00:11:18,340
Nicht so wirklich das Bottleneck

158
00:11:18,340 --> 00:11:19,340
Aber mich nervt

159
00:11:19,340 --> 00:11:21,100
Deswegen wollte ich das erstens mal ausprobieren

160
00:11:21,100 --> 00:11:22,100
Naja

161
00:11:22,100 --> 00:11:24,100
Also es gibt noch nichts zu rewriten in Rust

162
00:11:24,100 --> 00:11:26,100
Aber wir probieren das mal in Rust aus

163
00:11:26,100 --> 00:11:29,100
Also zumindest wir machen heute kein komplettes WebRTC-Example

164
00:11:29,100 --> 00:11:31,100
Vielleicht im nächsten Stream oder so

165
00:11:31,100 --> 00:11:33,100
Aber das geht erstmal zum ausprobieren

166
00:11:33,100 --> 00:11:34,100
Zumindest

167
00:11:34,100 --> 00:11:36,100
Wollte ich erstmal ausprobieren

168
00:11:36,100 --> 00:11:39,100
Ob das schneller geworden ist mittlerweile

169
00:11:39,100 --> 00:11:41,100
Also C und Go Interop

170
00:11:41,100 --> 00:11:43,100
Ich sag C stellvertretend

171
00:11:43,100 --> 00:11:45,100
Für alle anderen Sprachen die es gibt

172
00:11:45,100 --> 00:11:47,100
Weil jede Sprache

173
00:11:47,100 --> 00:11:48,100
Oder sagen wir so

174
00:11:48,100 --> 00:11:49,100
Mir fällt keine Sprache ein

175
00:11:49,100 --> 00:11:50,100
Die nicht

176
00:11:50,100 --> 00:11:51,100
Interop mit C macht

177
00:11:51,100 --> 00:11:52,100
Wie C Funktionen aufruft

178
00:11:52,100 --> 00:11:53,100
Hat sich so ein bisschen als Standard etabliert

179
00:11:53,100 --> 00:11:54,100
In der Programmierwelt

180
00:11:54,100 --> 00:11:55,100
Ist egal ob das jetzt Python ist

181
00:11:55,100 --> 00:11:56,100
Node

182
00:11:56,100 --> 00:11:57,100
C Sharp

183
00:11:57,100 --> 00:11:58,100
Was auch immer

184
00:11:58,100 --> 00:11:59,100
Alle können sie eigentlich

185
00:11:59,100 --> 00:12:00,100
Dynamisch C Funktionen aufrufen

186
00:12:00,100 --> 00:12:01,100
Also mir fällt keine Sprache ein

187
00:12:01,100 --> 00:12:02,100
Die nicht

188
00:12:02,100 --> 00:12:03,100
C Funktionen aufrufen kann

189
00:12:03,100 --> 00:12:04,100
Sagen wir mal

190
00:12:04,100 --> 00:12:05,100
Kompilierte Sachen

191
00:12:05,100 --> 00:12:24,480
Die mit C Interop

192
00:12:24,480 --> 00:12:26,480
Interface rausgefallen sind

193
00:12:26,480 --> 00:12:29,480
Und das Ding ist

194
00:12:29,480 --> 00:12:31,480
Ich hab irgendwas im Auge

195
00:12:31,480 --> 00:12:33,480
Das ist wirklich richtig nervig

196
00:12:33,480 --> 00:12:42,170
So und

197
00:12:42,170 --> 00:12:44,170
Das Ding ist

198
00:12:44,170 --> 00:12:46,170
Wir testen jetzt erstmal

199
00:12:46,170 --> 00:12:47,170
Ob das schneller geworden ist

200
00:12:47,170 --> 00:12:48,170
Mit Go

201
00:12:48,170 --> 00:12:51,170
Was hab ich eigentlich für eine Go Version drauf hier

202
00:12:51,170 --> 00:12:53,170
Go minus minus Version

203
00:12:53,170 --> 00:12:55,170
Sieht man das

204
00:12:55,170 --> 00:12:57,170
Ah ne das ist die Minus Minus Minus Version nur so

205
00:12:57,170 --> 00:12:59,170
Ne das ist einfach nur Version

206
00:12:59,170 --> 00:13:00,170
Warum macht jetzt eigentlich jeden

207
00:13:00,170 --> 00:13:02,170
Command Line Tool

208
00:13:02,170 --> 00:13:03,170
Irgendwie anders

209
00:13:03,170 --> 00:13:04,170
Das ist so

210
00:13:04,170 --> 00:13:05,170
Bei Java ist es glaube ich

211
00:13:05,170 --> 00:13:06,170
Minus groß V

212
00:13:06,170 --> 00:13:07,170
Oder so

213
00:13:07,170 --> 00:13:10,170
Das kann man sich ja echt nicht merken

214
00:13:10,170 --> 00:13:12,170
So und Rust müssen wir auch gleich mal installieren

215
00:13:12,170 --> 00:13:15,170
Ne Rust ist schon installiert

216
00:13:15,170 --> 00:13:17,860
So

217
00:13:17,860 --> 00:13:18,860
Und

218
00:13:18,860 --> 00:13:23,500
Das

219
00:13:23,500 --> 00:13:26,500
Der Kompilierer für die deutsche Programmiersprache

220
00:13:26,500 --> 00:13:27,500
Oh je

221
00:13:27,500 --> 00:13:46,680
Ja das mit dem einen

222
00:13:46,680 --> 00:13:47,680
Mit dem einen Minus

223
00:13:47,680 --> 00:13:49,680
Ist in der Go Welt

224
00:13:49,680 --> 00:13:51,680
Voll verbreitet

225
00:13:51,680 --> 00:13:53,680
Ich versteh es ehrlich gesagt nicht

226
00:13:53,680 --> 00:13:56,680
Man hätte sich da ein bisschen an Lilux Standards halten können

227
00:13:56,680 --> 00:13:58,680
Und Lilux Standard ist

228
00:13:58,680 --> 00:13:59,680
Minus Minus ausgeschrieben

229
00:13:59,680 --> 00:14:01,680
Einfaches Minus mit Abkürzung

230
00:14:01,680 --> 00:14:03,680
Aber Go hat sich gedacht

231
00:14:03,680 --> 00:14:05,680
Scheiß drauf wir lassen das einfach

232
00:14:05,680 --> 00:14:10,780
Und

233
00:14:10,780 --> 00:14:12,780
Wobei in dem Fall ist es ja sogar nicht nur einfaches Minus

234
00:14:12,780 --> 00:14:14,780
Sondern sogar

235
00:14:14,780 --> 00:14:16,780
Ganz ohne Minus also Sub Command

236
00:14:16,780 --> 00:14:18,780
Leute wartet mal

237
00:14:18,780 --> 00:14:20,780
Muss mal kurz

238
00:14:20,780 --> 00:14:22,780
Wasser ins Auge machen ey

239
00:14:22,780 --> 00:15:16,120
Ey Champ gefixt

240
00:15:16,120 --> 00:15:17,120
Hoffe ich

241
00:15:17,120 --> 00:15:21,900
Aber geht das auch so

242
00:15:21,900 --> 00:15:23,900
Wobei bei Git bin ich es gewöhnt

243
00:15:23,900 --> 00:15:24,900
Ich finde das gar nicht so schlimm

244
00:15:24,900 --> 00:15:25,900
Man muss sich einfach nur dran gewöhnen

245
00:15:25,900 --> 00:15:27,900
Dass Sub Commands sind

246
00:15:27,900 --> 00:15:29,900
Aber Version finde ich halt doof als Sub Command

247
00:15:29,900 --> 00:15:32,900
Minus Minus Version ist einfach viel intuitiver

248
00:15:32,900 --> 00:15:37,790
So also das ist das erste was ich ausprobieren will

249
00:15:37,790 --> 00:15:41,790
Ob Go Interop mit anderen Sprachen immer noch so langsam ist

250
00:15:41,790 --> 00:15:43,790
Und dann

251
00:15:43,790 --> 00:15:45,790
Ja dann kam das nächste wie ich auf Rust gekommen bin

252
00:15:45,790 --> 00:15:47,790
Ich hab gesehen

253
00:15:47,790 --> 00:15:49,790
Das es eine Rust

254
00:15:49,790 --> 00:15:51,790
Reimplementation

255
00:15:51,790 --> 00:15:53,790
Von dieser Go Library

256
00:15:53,790 --> 00:15:55,790
Gibt in Rust

257
00:15:55,790 --> 00:15:57,790
Also das Ding ist ziemlich beliebt

258
00:15:57,790 --> 00:15:59,790
11.900 Sterne und das da

259
00:15:59,790 --> 00:16:01,790
3500 Sterne also fast so viel

260
00:16:01,790 --> 00:16:07,660
Wie der Fiat Champ

261
00:16:07,660 --> 00:16:09,660
Hat da jemand sein Issue geschlossen kann das sein

262
00:16:09,660 --> 00:16:18,220
Guck mal ich sag doch

263
00:16:18,220 --> 00:16:20,220
Keine Fehler im Fiat Champ

264
00:16:20,220 --> 00:16:22,220
Einfach immer

265
00:16:22,220 --> 00:16:30,140
Versteht keiner wie man es verwendet

266
00:16:30,140 --> 00:16:32,140
So und dann hab ich gefunden

267
00:16:32,140 --> 00:16:34,140
Dass es eine Reimplementierung

268
00:16:34,140 --> 00:16:36,140
Von dieser WebRTC Library in Rust gibt

269
00:16:36,140 --> 00:16:38,140
Und dann hab ich mir überlegt

270
00:16:38,140 --> 00:16:40,140
Okay jetzt wärs doch mal an der Zeit

271
00:16:40,140 --> 00:16:42,140
Bevor ich irgendwie

272
00:16:42,140 --> 00:16:44,140
Eine der beiden Libraries benutze

273
00:16:44,140 --> 00:16:46,140
Mal zu gucken

274
00:16:46,140 --> 00:16:48,140
Was sich prinzipiell angenehmer aus .NET

275
00:16:48,140 --> 00:16:50,140
Aufrufen lässt Rust oder Go

276
00:16:50,140 --> 00:16:52,140
Ich persönlich tippe drauf

277
00:16:52,140 --> 00:16:54,140
Dass es meilenweit Rust

278
00:16:54,140 --> 00:16:56,140
Sein wird

279
00:16:56,140 --> 00:16:58,140
Sowohl easy easier zu benutzen

280
00:16:58,140 --> 00:17:00,140
Als auch also nicht zu schreiben

281
00:17:00,140 --> 00:17:02,140
Sondern anzusprechen

282
00:17:02,140 --> 00:17:04,140
Es ist auch deutlich höhere Performance

283
00:17:04,140 --> 00:17:06,140
Vom Callen von C-Sharp aus

284
00:17:06,140 --> 00:17:08,140
Aber so sicher

285
00:17:08,140 --> 00:17:10,140
Ganz sicher bin ich mir nicht

286
00:17:10,140 --> 00:17:12,140
Ich geh aber davon aus dass Rust meilenweit vorne sein wird

287
00:17:12,140 --> 00:17:14,140
Das Problem an Rust ist

288
00:17:14,140 --> 00:17:16,140
Dass Rust absolut abfuck zu schreiben ist

289
00:17:16,140 --> 00:17:18,140
Aber

290
00:17:18,140 --> 00:17:20,140
Der Interop mit C-Sharp

291
00:17:20,140 --> 00:17:22,140
Sollte schneller sein

292
00:17:22,140 --> 00:17:24,140
Deswegen probieren wir das jetzt überhaupt gar nicht

293
00:17:24,140 --> 00:17:26,140
Leute

294
00:17:26,140 --> 00:17:28,140
Ich bin ja schon seit MW1

295
00:17:28,140 --> 00:17:30,140
Der Meinung dass das Kreativität

296
00:17:30,140 --> 00:17:32,140
Komplett bankrott dort ist

297
00:17:32,140 --> 00:17:34,140
MW2

298
00:17:34,140 --> 00:17:36,140
War schon nochmal der Aufguss

299
00:17:36,140 --> 00:17:38,140
Remake Aufguss

300
00:17:38,140 --> 00:17:40,140
Und MW3 komplett

301
00:17:40,140 --> 00:17:42,140
Ich hab heute bei Huskers in den Stream reingeguckt

302
00:17:42,140 --> 00:17:44,140
Hab festgestellt

303
00:17:44,140 --> 00:17:46,140
Die haben zwar teilweise Karten dabei

304
00:17:46,140 --> 00:17:48,140
Aber das Gameplay was ich sehe

305
00:17:48,140 --> 00:17:50,140
Ist das gleiche

306
00:17:50,140 --> 00:17:52,140
Up Aim

307
00:17:52,140 --> 00:17:54,140
MW1

308
00:17:54,140 --> 00:17:56,140
Reboot Gameplay

309
00:17:56,140 --> 00:17:58,140
Mit ultra hoher Time to Kill

310
00:17:58,140 --> 00:18:00,140
Also niedriger

311
00:18:00,140 --> 00:18:02,140
Also ich hab's

312
00:18:02,140 --> 00:18:04,140
Ich hab mir null davon angeguckt

313
00:18:04,140 --> 00:18:06,140
Das interessiert mich nicht

314
00:18:06,140 --> 00:18:11,570
Findest du ernsthaft

315
00:18:11,570 --> 00:18:13,570
Ich find Rust ist eklig

316
00:18:13,570 --> 00:18:15,570
Sowohl Go als auch Rust sind jetzt nicht gerade die schönsten Sprachen

317
00:18:15,570 --> 00:18:17,570
Aber ich find Rust extrem umständlich

318
00:18:17,570 --> 00:18:19,570
Deswegen werden wir das jetzt mal ausprobieren

319
00:18:19,570 --> 00:18:21,570
So also

320
00:18:21,570 --> 00:18:23,570
Hey Max

321
00:18:23,570 --> 00:18:25,570
Kannst du eventuell berichten wie es in dem Bankenwesen

322
00:18:25,570 --> 00:18:27,570
Seine Ausbildung zum Anwendungsinformatiker zu machen

323
00:18:27,570 --> 00:18:29,570
Weiß ich nicht

324
00:18:29,570 --> 00:18:31,570
Ich hab keine Ausbildung gemacht

325
00:18:31,570 --> 00:18:33,570
Bei der Versicherung

326
00:18:33,570 --> 00:18:35,570
Ich habe bei einem Internet Provider

327
00:18:35,570 --> 00:18:37,570
Meine Ausbildung gemacht

328
00:18:37,570 --> 00:18:39,570
Da hatte ich

329
00:18:39,570 --> 00:18:41,570
Nicht direkt zumindest

330
00:18:41,570 --> 00:18:48,660
Was damit zu tun

331
00:18:48,660 --> 00:18:50,660
Nein du solltest dich dort bewerben

332
00:18:50,660 --> 00:18:52,660
Wo die Stelle möglichst vielversprechend aussieht

333
00:18:52,660 --> 00:18:54,660
Ich mein der Laden

334
00:18:54,660 --> 00:18:56,660
Dass der dir vielleicht zusagen sollte

335
00:18:56,660 --> 00:18:58,660
Ist nicht verkehrt

336
00:18:58,660 --> 00:19:00,660
Aber bewerb dich ruhig bei einer Bank

337
00:19:00,660 --> 00:19:02,660
Oder bei einer Versicherung oder sowas

338
00:19:02,660 --> 00:19:04,660
Finanzbranche ist gut

339
00:19:04,660 --> 00:19:06,660
Wenn du deinen Fuß in der Tür hast

340
00:19:06,660 --> 00:19:08,660
Es gibt so eine Tabelle

341
00:19:08,660 --> 00:19:10,660
Ich glaub das erste waren Banken

342
00:19:10,660 --> 00:19:12,660
Das zweite waren Versicherungen

343
00:19:12,660 --> 00:19:14,660
Das dritte war Pharmaindustrie in Deutschland

344
00:19:14,660 --> 00:19:16,660
Ich glaub das vierte Automobilindustrie

345
00:19:16,660 --> 00:19:18,660
Oder sowas für IT Kräfte

346
00:19:18,660 --> 00:19:20,660
Es könnte auch umgedreht gewesen sein

347
00:19:20,660 --> 00:19:22,660
Es könnte auch zuerst Automobil

348
00:19:22,660 --> 00:19:24,660
Und dann Pharmaindustrie

349
00:19:24,660 --> 00:19:26,660
Aber erster Platz, zweiter Platz war auf jeden Fall Banken

350
00:19:26,660 --> 00:19:28,660
Und zweiter war Versicherung

351
00:19:28,660 --> 00:19:30,660
Das heißt wenn du in der Finanzbranche irgendwie deinen Fuß in die Tür kriegst

352
00:19:30,660 --> 00:19:32,660
Ist sinnvoll

353
00:19:32,660 --> 00:19:34,660
Und meistens

354
00:19:34,660 --> 00:19:36,660
Sind die auch ein bisschen größer

355
00:19:36,660 --> 00:19:38,660
Was oftmals echt von Vorteil für die Ausbildung ist

356
00:19:38,660 --> 00:19:40,660
Also

357
00:19:40,660 --> 00:19:42,660
Je nachdem was für eine kleine Klitsche das hier ist

358
00:19:42,660 --> 00:19:44,660
Da wird halt sehr viel so auf

359
00:19:44,660 --> 00:19:46,660
Gut meinen gemacht

360
00:19:46,660 --> 00:19:48,660
Ob es dann gut ist

361
00:19:48,660 --> 00:19:50,660
Weiß man nicht

362
00:19:50,660 --> 00:19:52,660
Bei den großen Läden kommt es halt weniger

363
00:19:52,660 --> 00:19:54,660
Oft vor

364
00:19:54,660 --> 00:19:56,660
Dass keiner Plan hat

365
00:19:56,660 --> 00:19:58,660
Wie das bei einer Ausbildung laufen soll

366
00:19:58,660 --> 00:20:00,660
Dass du keinen Ansprechpartner hast

367
00:20:00,660 --> 00:20:02,660
Dass sich keiner um dich kümmert

368
00:20:02,660 --> 00:20:04,660
Das hast du bei großen Läden weniger

369
00:20:04,660 --> 00:20:06,660
Und dann hast du in der Finanzbranche einen Fuß in der Tür

370
00:20:06,660 --> 00:20:08,660
Weil die bezahlen einfach gut

371
00:20:08,660 --> 00:20:10,660
Also ganz ehrlich

372
00:20:10,660 --> 00:20:12,660
Wenn du die Möglichkeit hast das zu machen

373
00:20:12,660 --> 00:20:38,720
Würde ich mir das angucken

374
00:20:38,720 --> 00:20:40,720
So sieht es aus

375
00:20:40,720 --> 00:20:42,720
Jetzt habe ich erklärt was wir machen wollen

376
00:20:42,720 --> 00:20:44,720
Jetzt probieren wir das ganze mal aus

377
00:20:44,720 --> 00:20:46,720
Also wir legen mal ein neues Projekt an

378
00:20:46,720 --> 00:20:48,720
Also wie gesagt

379
00:20:48,720 --> 00:20:50,720
Wir fangen ganz simpel an

380
00:20:50,720 --> 00:20:52,720
Wir machen ein Go-Projekt

381
00:20:52,720 --> 00:20:54,720
Exportieren dort

382
00:20:54,720 --> 00:20:56,720
Eine Funktion die nichts macht

383
00:20:56,720 --> 00:20:58,720
Rufen die von C-Sharp auf

384
00:20:58,720 --> 00:21:02,720
Und wir machen ein Rust Projekt

385
00:21:02,720 --> 00:21:04,720
Mit einer leeren Funktion

386
00:21:04,720 --> 00:21:06,720
Und rufen die von C-Sharp aus

387
00:21:06,720 --> 00:21:08,720
Und dann benchmarken wir das erstmal

388
00:21:08,720 --> 00:21:10,720
Und gucken was da schneller ist

389
00:21:10,720 --> 00:21:12,720
Beim reinen Function Call

390
00:21:12,720 --> 00:21:14,720
Da wissen wir auch schon mal

391
00:21:14,720 --> 00:21:16,720
Dass das nicht daran liegt

392
00:21:16,720 --> 00:21:18,720
Dass die eine Sprache irgendwas besser kann

393
00:21:18,720 --> 00:21:20,720
Als die andere Sprache in der Implementierung

394
00:21:20,720 --> 00:21:22,720
Sondern einfach so der reine Funktionsaufruf

395
00:21:22,720 --> 00:21:24,720
Mal gucken wie schnell der ist

396
00:21:24,720 --> 00:21:26,720
Man würde erwarten dass der saumäßig schnell ist

397
00:21:26,720 --> 00:21:28,720
Vielleicht nicht so schnell wie der Native Aufruf

398
00:21:28,720 --> 00:21:30,720
Aber immer noch schnell

399
00:21:30,720 --> 00:21:32,720
Ich weiß aber aus Erfahrung

400
00:21:32,720 --> 00:21:34,720
Das Go Interop mit anderen Sprachen

401
00:21:34,720 --> 00:21:36,720
Echt problematisch war

402
00:21:36,720 --> 00:21:38,720
In der Vergangenheit

403
00:21:38,720 --> 00:21:40,720
Gerade wenn das was ist was wirklich

404
00:21:40,720 --> 00:21:42,720
Hunderttausendfach aufgerufen wird

405
00:21:42,720 --> 00:22:01,710
Die haben

406
00:22:01,710 --> 00:22:03,710
Große Unternehmen haben Ausbildungsverantwortlichen

407
00:22:03,710 --> 00:22:09,840
Da passiert sowas eigentlich selten

408
00:22:09,840 --> 00:22:11,840
Danke

409
00:22:11,840 --> 00:22:13,840
Was ist für dich groß

410
00:22:13,840 --> 00:22:15,840
50 Mann sind nicht groß

411
00:22:15,840 --> 00:22:17,840
100 und 200 Mann sind auch nicht wirklich groß

412
00:22:17,840 --> 00:22:25,890
Ich bin mir nicht sicher

413
00:22:25,890 --> 00:22:27,890
Ob das eine T-Bait Frage ist

414
00:22:27,890 --> 00:22:29,890
Oder ernst gemeint

415
00:22:29,890 --> 00:22:31,890
Egal ich sag dazu nix

416
00:22:31,890 --> 00:22:33,890
Weil wenn ich damit anfange

417
00:22:33,890 --> 00:22:50,060
Dann hör ich heute nicht mehr auf

418
00:22:50,060 --> 00:22:52,060
Das muss nicht sein

419
00:22:52,060 --> 00:22:54,060
So dann legen wir mal los

420
00:22:54,060 --> 00:22:56,060
Ich leg mal neues

421
00:22:56,060 --> 00:22:59,700
Benchmark Champ

422
00:22:59,700 --> 00:23:01,700
Wir testen jetzt erstmal

423
00:23:01,700 --> 00:23:03,700
Wie schnell das ganze ist

424
00:23:03,700 --> 00:23:05,700
Und wenn das in Rust wirklich

425
00:23:05,700 --> 00:23:07,700
Und das ist ja zu erwarten

426
00:23:07,700 --> 00:23:09,700
So viel schneller ist

427
00:23:09,700 --> 00:23:11,700
Dann kann ich das ganze WebRTC in Rust programmieren

428
00:23:11,700 --> 00:23:13,700
Wobei ich weiß jetzt schon

429
00:23:13,700 --> 00:23:15,700
Das ich durchdrehen werde dabei

430
00:23:15,700 --> 00:23:17,700
Ein gutes hat's

431
00:23:17,700 --> 00:23:19,700
Das ist quasi eine

432
00:23:19,700 --> 00:23:21,700
Rust Reimplementation

433
00:23:21,700 --> 00:23:23,700
Von der

434
00:23:23,700 --> 00:23:25,700
Go Library hier

435
00:23:25,700 --> 00:23:27,700
Das heißt ich hoffe

436
00:23:27,700 --> 00:23:29,700
Wenn man die Go Library ein bisschen kennt

437
00:23:29,700 --> 00:23:37,040
Kommt man ja auch ganz gut klar

438
00:23:37,040 --> 00:23:40,480
Müssen wir mal schauen

439
00:23:40,480 --> 00:23:42,480
Das ist ziemlich groß

440
00:23:42,480 --> 00:23:44,480
Da gibt es doch eigentlich Ausbildungsbeauftragte

441
00:23:44,480 --> 00:23:46,480
Und Leute die dann

442
00:23:46,480 --> 00:23:48,480
Das es so

443
00:23:48,480 --> 00:23:50,480
Reingeschissen wird

444
00:23:50,480 --> 00:23:52,480
Bei großen Unternehmen was Ausbildung angeht

445
00:23:52,480 --> 00:23:54,480
Das sehe ich eher gehäufter bei den kleinen

446
00:23:54,480 --> 00:23:56,480
Okay

447
00:23:56,480 --> 00:23:59,860
Wir installieren mal eine neue .NET Version

448
00:23:59,860 --> 00:24:01,860
Wird mal Zeit

449
00:24:01,860 --> 00:24:03,860
Weil ich glaube es gibt eine neue Preview Version

450
00:24:03,860 --> 00:24:05,860
Wenn ich das richtig sehe

451
00:24:05,860 --> 00:24:07,860
Ja es gibt

452
00:24:07,860 --> 00:24:09,860
801

453
00:24:09,860 --> 00:24:11,860
Wobei 100 haben die glaube ich immer

454
00:24:11,860 --> 00:24:13,860
RC2

455
00:24:13,860 --> 00:24:15,860
RC2 23502.2

456
00:24:15,860 --> 00:24:17,860
Sag mal .NET Team

457
00:24:17,860 --> 00:24:19,860
Wie viele Versionsnummern wollt ihr eigentlich noch haben

458
00:24:19,860 --> 00:24:21,860
8.0

459
00:24:21,860 --> 00:24:23,860
Das lass ich mir ja noch gefallen

460
00:24:23,860 --> 00:24:25,860
8.0.100

461
00:24:25,860 --> 00:24:27,860
Ist schon ein bisschen pepege aber auch noch okay

462
00:24:27,860 --> 00:24:29,860
Aber 8.0.100

463
00:24:29,860 --> 00:24:31,860
Minus RC2

464
00:24:31,860 --> 00:24:33,860
.23502.2

465
00:24:33,860 --> 00:24:35,860
.23502.2

466
00:24:35,860 --> 00:24:37,860
Also

467
00:24:37,860 --> 00:24:46,930
Irgendwann ist auch mal gut

468
00:24:46,930 --> 00:24:48,930
Also ich mein bis hierhin geht's ja irgendwie

469
00:24:48,930 --> 00:24:50,930
Nur halbwegs klar

470
00:24:50,930 --> 00:24:52,930
Aber das dahinter ist schon komplett bescheuert

471
00:24:52,930 --> 00:24:56,430
Das hat dann mit

472
00:24:56,430 --> 00:24:58,430
M wäre auch nix mehr zu tun

473
00:24:58,430 --> 00:25:00,430
Weil das interessiert Microsoft eh nicht

474
00:25:00,430 --> 00:25:02,430
Also .NET

475
00:25:02,430 --> 00:25:04,430
New Console

476
00:25:04,430 --> 00:25:06,430
Wir machen mal

477
00:25:06,430 --> 00:25:08,430
Wir machen mal ein paar neue Ordner

478
00:25:08,430 --> 00:25:10,430
Mkdir Rust

479
00:25:10,430 --> 00:25:12,430
Mkdir Go

480
00:25:12,430 --> 00:25:16,060
Mkdir Benchmark

481
00:25:16,060 --> 00:25:18,060
So irgendwie

482
00:25:18,060 --> 00:25:20,060
Benchmark legen wir das

483
00:25:20,060 --> 00:25:22,060
Das .NET Projekt an

484
00:25:22,060 --> 00:25:24,060
Wow

485
00:25:24,060 --> 00:25:26,060
Wer interessiert Blazor

486
00:25:26,060 --> 00:25:28,060
Wer auch immer das benutzt

487
00:25:28,060 --> 00:25:30,060
Also Microsoft will das zurzeit

488
00:25:30,060 --> 00:25:32,060
Boosten wie sonstwas

489
00:25:32,060 --> 00:25:34,060
Aber auch wenn ich

490
00:25:34,060 --> 00:25:36,060
Großer C Sharp Fan bin

491
00:25:36,060 --> 00:25:38,060
Ehrlich im Browser wie es bisher ist

492
00:25:38,060 --> 00:25:40,060
Brauch ich das nicht

493
00:25:40,060 --> 00:25:42,060
So dann haben wir hier Go und haben Rust

494
00:25:42,060 --> 00:25:44,060
Dann kopieren wir uns mal das Verzeichnis

495
00:25:44,060 --> 00:25:46,060
Und ich würd sagen

496
00:25:46,060 --> 00:25:50,780
Dann fangen wir mal ganz easy an

497
00:25:50,780 --> 00:25:56,020
Mit

498
00:25:56,020 --> 00:25:58,020
Und öffnen wir das mal in Rider

499
00:25:58,020 --> 00:26:00,020
Und tun mal so als wüssten wir was von machen

500
00:26:00,020 --> 00:26:02,020
So Repos wie hab ich das genannt

501
00:26:02,020 --> 00:26:04,020
Benchmark

502
00:26:04,020 --> 00:26:06,020
Champ

503
00:26:06,020 --> 00:26:08,020
Ah hier da öffnen

504
00:26:08,020 --> 00:26:13,060
So hier

505
00:26:13,060 --> 00:26:15,060
Auf dem vierten Bildschirm machen wir Go Land auf

506
00:26:15,060 --> 00:26:17,060
Und auf dem fünften

507
00:26:17,060 --> 00:26:19,060
Auf dem fünften

508
00:26:19,060 --> 00:26:21,060
Boah das kostet Ramm Leute

509
00:26:21,060 --> 00:26:23,060
Das kostet Ramm

510
00:26:23,060 --> 00:26:25,060
3 Jetbrain Ideen ist offen

511
00:26:25,060 --> 00:26:27,060
MonkaS Java

512
00:26:27,060 --> 00:26:29,060
Und hier machen wir das Rust Ding auf

513
00:26:29,060 --> 00:26:32,940
I confirm that I have Red Angst

514
00:26:32,940 --> 00:26:34,940
Ja ja ja ich

515
00:26:34,940 --> 00:26:36,940
Ich confirme alles hier

516
00:26:36,940 --> 00:26:38,940
Wir wollen nix senden

517
00:26:38,940 --> 00:26:40,940
Ok New Project was haben wir hier

518
00:26:40,940 --> 00:26:42,940
Rust Version detected 173.0

519
00:26:42,940 --> 00:26:44,940
Ja perfekt top

520
00:26:44,940 --> 00:26:46,940
Wir wollen allerdings

521
00:26:46,940 --> 00:26:48,940
Location Repos

522
00:26:48,940 --> 00:26:50,940
Benchmark Champ

523
00:26:50,940 --> 00:26:52,940
Rust

524
00:26:52,940 --> 00:26:54,940
Da wollen wir rein

525
00:26:54,940 --> 00:26:56,940
Binary Application

526
00:26:56,940 --> 00:26:58,940
Standard Library

527
00:26:58,940 --> 00:27:00,940
Egal

528
00:27:00,940 --> 00:27:02,940
Die Standard Library von dieser Version halt

529
00:27:02,940 --> 00:27:04,940
Weiß nicht wo die ist

530
00:27:04,940 --> 00:27:06,940
Rust

531
00:27:06,940 --> 00:27:11,280
Zack Create

532
00:27:11,280 --> 00:27:13,280
Let's go

533
00:27:13,280 --> 00:27:15,280
Oh geht ja gut los

534
00:27:15,280 --> 00:27:17,280
Erstmal Minischrift

535
00:27:17,280 --> 00:27:19,280
Und als nächstes irgendwelche komischen Errors

536
00:27:19,280 --> 00:27:21,280
Nice

537
00:27:21,280 --> 00:27:23,280
Rust am Start

538
00:27:23,280 --> 00:27:25,280
Cargo failed

539
00:27:25,280 --> 00:27:27,280
Sync Rust Project

540
00:27:27,280 --> 00:27:29,280
Retrieving Rust Standard Lib

541
00:27:29,280 --> 00:27:31,280
Hä warum muss er die noch retrieven bitte schön

542
00:27:31,280 --> 00:27:33,280
Rust kommt mit der Standard Library dabei

543
00:27:33,280 --> 00:27:35,280
Deswegen heißt es Standard Library

544
00:27:35,280 --> 00:27:40,260
Rust up not found

545
00:27:40,260 --> 00:27:43,890
Ja und jetzt

546
00:27:43,890 --> 00:27:45,890
Was der Rust up braucht

547
00:27:45,890 --> 00:27:47,890
Damit das hier funktioniert

548
00:27:47,890 --> 00:27:49,890
Ich kann auch Rust up installieren wenn es sein muss

549
00:27:49,890 --> 00:27:54,290
Easy

550
00:27:54,290 --> 00:27:56,290
Tag installieren wir Rust up

551
00:27:56,290 --> 00:27:58,290
Auch gut

552
00:27:58,290 --> 00:28:00,290
Deinstallieren wir Rust installieren wir Rust up

553
00:28:00,290 --> 00:28:02,290
Top

554
00:28:02,290 --> 00:28:08,540
Ist jetzt Cargo und so da

555
00:28:08,540 --> 00:28:10,540
Run Rust

556
00:28:10,540 --> 00:28:12,540
Default Stable

557
00:28:12,540 --> 00:28:14,540
Ok nice

558
00:28:14,540 --> 00:28:16,540
Also das mag ich

559
00:28:16,540 --> 00:28:18,540
Das mag ich an Rust

560
00:28:18,540 --> 00:28:28,420
Ich hab ja auch nicht so viel

561
00:28:28,420 --> 00:28:30,420
Ich hab ausgemacht

562
00:28:30,420 --> 00:28:32,420
Und ab und zu

563
00:28:32,420 --> 00:28:34,420
Ich muss jetzt mal

564
00:28:34,420 --> 00:28:36,420
Ich muss jetzt rufen

565
00:28:36,420 --> 00:28:38,420
Da wird ausgeliefert

566
00:28:38,420 --> 00:28:40,420
Das ist z.B.

567
00:28:40,420 --> 00:28:42,420
Screenplay

568
00:28:42,420 --> 00:28:44,420
Einfach

569
00:28:44,420 --> 00:28:46,420
Da wird es

570
00:28:46,420 --> 00:28:48,420
Genau so

571
00:28:48,420 --> 00:28:50,420
Also jetzt mal

572
00:28:50,420 --> 00:28:52,460
anderen Sprachen. Zumindest war das in der Vergangenheit

573
00:28:52,460 --> 00:28:52,720
so.

574
00:28:54,380 --> 00:28:56,460
Es wird aufgerufen, C-Sharp nach Go

575
00:28:56,460 --> 00:28:58,340
und C-Sharp nach Rust. Es wird

576
00:28:58,340 --> 00:29:00,060
nicht C-Sharp Go Rust aufgerufen.

577
00:29:00,520 --> 00:29:02,400
Es wird C-Sharp nach Go und dann C-Sharp nach Rust

578
00:29:02,400 --> 00:29:04,380
aufgerufen. Wir gucken mal, was schneller ist. Ich tippe

579
00:29:04,380 --> 00:29:06,320
einfach, dass Rust in allen Belangen

580
00:29:06,320 --> 00:29:08,340
komplett meilenweit ahead

581
00:29:08,340 --> 00:29:10,260
of Go ist, weil Go bekannt

582
00:29:10,260 --> 00:29:12,340
dafür ist, dass Go langsam ist als Interop

583
00:29:12,340 --> 00:29:14,180
mit anderen Sprachen. Also langsamer als ziemlich

584
00:29:14,180 --> 00:29:15,820
jede andere halbwegs

585
00:29:15,820 --> 00:29:18,040
bekannte Programmiersprache. Und Go ist

586
00:29:18,040 --> 00:29:19,500
super langsam, was das angeht.

587
00:29:20,420 --> 00:29:22,140
Also das ist langsamer als so ziemlich

588
00:29:22,140 --> 00:29:24,120
jede andere Sprache, die mir so einfällt.

589
00:29:25,140 --> 00:29:26,260
Das ist langsamer als

590
00:29:26,260 --> 00:29:28,640
Python, langsamer

591
00:29:28,640 --> 00:29:30,380
also nur in diesem einen Fall, ja.

592
00:29:30,940 --> 00:29:32,140
Also Callen

593
00:29:32,140 --> 00:29:33,800
von und nach anderen

594
00:29:33,800 --> 00:29:36,160
Sprachen über irgendein C-Interface.

595
00:29:37,000 --> 00:29:38,360
Das ist langsamer als Python,

596
00:29:38,540 --> 00:29:39,780
als Java, als

597
00:29:39,780 --> 00:29:41,760
alles einfach nur.

598
00:29:42,920 --> 00:29:43,320
JavaScript.

599
00:29:45,080 --> 00:29:45,920
Das ist wirklich

600
00:29:45,920 --> 00:29:47,380
Go ansonsten ist ja recht flott,

601
00:29:47,760 --> 00:29:49,300
aber in dem Bereich ist es wirklich

602
00:29:49,300 --> 00:29:50,400
PP.

603
00:29:50,420 --> 00:29:52,140
Mega langsam. So, also

604
00:29:52,140 --> 00:29:54,160
hat es jetzt, jetzt

605
00:29:54,160 --> 00:29:56,240
starten wir nochmal dieses Rust-Ding, ob das jetzt

606
00:29:56,240 --> 00:29:58,300
besser funktioniert, nachdem ich Rust-Up installiert

607
00:29:58,300 --> 00:30:02,710
habe. Ja, nice, scheint zu funktionieren.

608
00:30:04,330 --> 00:30:05,730
Was hat Go für Vorteile?

609
00:30:06,590 --> 00:30:08,350
Go hat ein paar

610
00:30:08,350 --> 00:30:10,430
Vorteile. Zum Beispiel ist Go relativ

611
00:30:10,430 --> 00:30:10,730
flott.

612
00:30:12,330 --> 00:30:14,230
Wie gesagt, was langsam ist, ist ja nur diese

613
00:30:14,230 --> 00:30:16,150
eine Sache, die ich gerade gesagt habe.

614
00:30:16,810 --> 00:30:17,950
Champshifter, danke für den Sub.

615
00:30:19,250 --> 00:30:20,370
Ansonsten ist Go relativ

616
00:30:20,370 --> 00:30:22,370
flott. Go ist

617
00:30:22,570 --> 00:30:24,330
richtig gut, wenn man

618
00:30:24,330 --> 00:30:26,490
Self-Contained Binaries haben

619
00:30:26,490 --> 00:30:28,570
möchte, die rückwärtskompatibel einfach auf jedem

620
00:30:28,570 --> 00:30:30,450
Linux-System laufen. Da ist Go so

621
00:30:30,450 --> 00:30:32,050
ziemlich die beste Sprache, die es gibt,

622
00:30:32,570 --> 00:30:33,910
die existiert, die man dafür

623
00:30:33,910 --> 00:30:35,490
benutzen kann.

624
00:30:36,650 --> 00:30:38,050
Auch im Cloud-Umfeld

625
00:30:38,050 --> 00:30:40,610
ist Go sehr beliebt.

626
00:30:40,810 --> 00:30:42,530
Warum kann ich die Font-Size nicht ändern?

627
00:30:44,290 --> 00:30:44,530
Und?

628
00:30:54,460 --> 00:30:55,820
Ach, jetzt geht's auf einmal, okay.

629
00:30:58,160 --> 00:30:59,280
Okay, JetBrains

630
00:30:59,280 --> 00:31:00,400
Mono, meinetwegen.

631
00:31:01,760 --> 00:31:03,280
Oh, aber ich glaube,

632
00:31:03,320 --> 00:31:04,840
die Schriftgröße ist ganz okay, oder?

633
00:31:05,820 --> 00:31:06,940
Ich glaube, Jetge,

634
00:31:07,660 --> 00:31:09,240
ich muss mal kurz in meiner Vorschau...

635
00:31:09,240 --> 00:31:10,680
Ja, die Schriftgröße ist gut.

636
00:31:11,320 --> 00:31:13,000
Ich sehe das gerade hier in der Vorschau, die ist okay.

637
00:31:13,160 --> 00:31:13,940
Da kann man nichts sagen.

638
00:31:15,620 --> 00:31:17,320
Das ist eigentlich sehr angenehm zu lesen

639
00:31:17,320 --> 00:31:18,740
gerade. Ich gucke mir das gerade auf der

640
00:31:18,740 --> 00:31:19,960
Vorschau-Monitor an.

641
00:31:20,840 --> 00:31:22,880
Auch nettes, recht

642
00:31:22,880 --> 00:31:25,300
nicht so ins Augen brennende

643
00:31:25,300 --> 00:31:27,220
Dark-Theme dabei, das ist okay.

644
00:31:29,930 --> 00:31:30,950
So, MainPrint,

645
00:31:31,030 --> 00:31:32,390
hallo World, ja, das kommt schon mal weg.

646
00:31:32,850 --> 00:31:34,410
Wir brauchen gar keine Main-Funktion.

647
00:31:34,650 --> 00:31:35,090
Ach,

648
00:31:35,210 --> 00:31:37,050
so, ja, Moment, ich muss das ja

649
00:31:37,050 --> 00:31:38,070
umstellen auf eine Library.

650
00:31:39,190 --> 00:31:41,130
Wir legen erst mal das Go-Projekt an.

651
00:31:41,550 --> 00:31:42,470
Was haben wir hier noch offen?

652
00:31:42,570 --> 00:31:44,590
New Session, New Message,

653
00:31:48,040 --> 00:31:49,540
Create Session, New Sender.

654
00:31:52,080 --> 00:31:53,260
Ach so, ah, ich weiß,

655
00:31:53,400 --> 00:31:55,420
das ist, ja, ja, ja, das haben wir mal

656
00:31:55,420 --> 00:31:56,620
gebaut, naja, das können wir wegmachen.

657
00:31:58,160 --> 00:31:59,500
Da müssen wir ein neues Projekt anlegen.

658
00:32:00,720 --> 00:32:01,440
Also legen wir ein neues

659
00:32:01,440 --> 00:32:02,480
Go-Projekt an.

660
00:32:04,940 --> 00:32:06,160
Wo ist das hier? Go,

661
00:32:06,160 --> 00:32:08,160
New Project,

662
00:32:09,000 --> 00:32:10,820
und zwar wollen wir

663
00:32:10,820 --> 00:32:12,060
nach Repos

664
00:32:12,060 --> 00:32:14,580
Benchmark Champ

665
00:32:14,580 --> 00:32:16,520
Go. Und jetzt wollen wir

666
00:32:16,520 --> 00:32:18,560
ein Go-Modules-Projekt

667
00:32:18,560 --> 00:32:20,940
anlegen. Ich glaube, das macht er standardmäßig.

668
00:32:22,420 --> 00:32:22,800
Was ist

669
00:32:22,800 --> 00:32:24,320
Enable Vendoring Support?

670
00:32:38,840 --> 00:32:41,740
Äh, verstehe ich

671
00:32:41,740 --> 00:32:42,020
nicht.

672
00:32:43,840 --> 00:32:45,360
Sollte ich das an- oder ausschalten?

673
00:32:45,460 --> 00:32:47,420
Ich verstehe die Hilfe nicht.

674
00:32:48,320 --> 00:32:48,860
Kann weg.

675
00:32:49,500 --> 00:32:51,500
Ich habe keine Ahnung, was es mir überhaupt sagen soll,

676
00:32:51,500 --> 00:32:58,600
ehrlich gesagt. Okay, ihr habt auch

677
00:32:58,600 --> 00:33:00,720
keine Ahnung. Wenn der Chat keine Ahnung hat,

678
00:33:00,820 --> 00:33:01,680
dann beruhigt mich das immer.

679
00:33:05,430 --> 00:33:07,630
Okay, create this window.

680
00:33:11,410 --> 00:33:12,470
Close. So, jetzt muss ich

681
00:33:12,470 --> 00:33:14,190
erstmal gucken, dass ich wieder ein bisschen

682
00:33:14,190 --> 00:33:16,050
anfange, Go zu checken.

683
00:33:17,490 --> 00:33:18,350
Go war doch so.

684
00:33:18,470 --> 00:33:19,770
So, wir gehen jetzt mal Repo,

685
00:33:20,410 --> 00:33:22,430
Benchmark Champ, Go.

686
00:33:23,490 --> 00:33:24,790
Und jetzt sagen wir

687
00:33:24,790 --> 00:33:26,570
Go run.

688
00:33:27,610 --> 00:33:28,710
Und dann kackt's ab.

689
00:33:29,390 --> 00:33:29,710
Weil

690
00:33:29,710 --> 00:33:32,290
Missing Go Version Modload.

691
00:33:34,810 --> 00:33:35,210
Nice.

692
00:33:38,390 --> 00:33:39,910
Ach so, es fehlt eine Main, oder?

693
00:33:40,810 --> 00:33:43,150
Einfach eine Main-Datei. Dann ist die Fehlermeldung

694
00:33:43,150 --> 00:33:44,390
aber pepega as fuck.

695
00:33:44,930 --> 00:33:46,270
Also, new Go-File

696
00:33:46,270 --> 00:33:47,710
main.go

697
00:33:47,710 --> 00:33:49,630
package

698
00:33:49,630 --> 00:33:52,930
Moment, warum heißt das Projekt

699
00:33:52,930 --> 00:33:54,810
Go? Das ergibt doch gar keinen Sinn.

700
00:33:55,290 --> 00:33:56,830
Das Projekt soll

701
00:33:56,830 --> 00:33:58,910
heißen... Ach so, das heißt so

702
00:33:58,910 --> 00:33:59,550
wie der Ordner.

703
00:33:59,930 --> 00:34:01,870
Und das hier heißt auch Rust.

704
00:34:02,230 --> 00:34:05,150
Es sollte durchaus auch okay sein, dass das

705
00:34:05,150 --> 00:34:07,110
heißt. So, Package Main muss das

706
00:34:07,110 --> 00:34:09,170
ja sein, weil wir sind ja hier in Go.

707
00:34:09,570 --> 00:34:10,650
Und dann braucht man...

708
00:34:10,650 --> 00:34:13,010
Function Main.

709
00:34:13,130 --> 00:34:14,530
Und dann sagen wir sowas wie FMT

710
00:34:14,530 --> 00:34:15,790
Brindeln

711
00:34:15,790 --> 00:34:19,030
Keg Wait. So, und das sollte

712
00:34:19,030 --> 00:34:20,710
jetzt kompilieren, oder? Nein.

713
00:34:21,490 --> 00:34:22,030
Warum nicht?

714
00:34:28,660 --> 00:34:30,380
Das darf bestimmt nicht so heißen, oder?

715
00:34:30,980 --> 00:34:32,620
Das ist bestimmt pepega, weil der Ordner

716
00:34:32,620 --> 00:34:34,680
Go heißt. Garantiert kann das das nicht

717
00:34:34,680 --> 00:34:36,640
ab, weil der Ordner Go heißt. Könnte ich wetten

718
00:34:36,640 --> 00:34:38,320
mit euch. Was?

719
00:34:39,080 --> 00:34:40,500
Go Mod Init? Das muss man doch

720
00:34:40,500 --> 00:34:41,560
normalerweise nie machen.

721
00:34:43,160 --> 00:34:43,420
Äh.

722
00:34:44,380 --> 00:34:44,700
Mod?

723
00:34:46,500 --> 00:34:48,740
Das ist 100

724
00:34:48,740 --> 00:34:50,260
Pro. Ich wette mit euch.

725
00:34:50,680 --> 00:34:52,740
Das ist, weil der Ordner Go heißt.

726
00:34:58,510 --> 00:34:59,670
Go hat so komische

727
00:34:59,670 --> 00:35:01,530
Dinger. Das kann ich mir richtig

728
00:35:01,530 --> 00:35:02,230
gut vorstellen.

729
00:35:05,250 --> 00:35:06,870
Wir löschen das nochmal.

730
00:35:13,450 --> 00:35:15,250
Man sieht ja ins Terminal nicht. Ja, in dem Fall

731
00:35:15,250 --> 00:35:16,910
gibt es da eh nichts. Wir löschen

732
00:35:16,910 --> 00:35:19,090
das nochmal und machen MKT

733
00:35:19,090 --> 00:35:20,830
Go App. Okay? So.

734
00:35:21,170 --> 00:35:22,830
Das sollte nicht

735
00:35:22,830 --> 00:35:24,430
problematisch sein.

736
00:35:29,780 --> 00:35:30,900
Also, New Project.

737
00:35:31,920 --> 00:35:32,680
Jetzt hat er das schon wieder.

738
00:35:33,460 --> 00:35:35,480
Lass ich das mal enabled. Vielleicht macht es das dann

739
00:35:35,480 --> 00:35:40,040
richtig. So, wir wollen

740
00:35:40,040 --> 00:35:41,360
nach Benchmark Champ

741
00:35:41,360 --> 00:35:44,040
Go App. Und eigentlich

742
00:35:44,040 --> 00:35:45,540
da rein direkt. Genau.

743
00:35:46,820 --> 00:35:47,260
Create.

744
00:35:50,290 --> 00:35:51,250
Und jetzt sage ich

745
00:35:51,250 --> 00:35:54,530
Go App. Go Run Punkt.

746
00:35:54,890 --> 00:35:56,330
Ja, siehste? Siehste? Jetzt funktioniert

747
00:35:56,330 --> 00:35:58,310
es auch. Ich weiß jetzt nicht, ob das an diesem

748
00:35:58,310 --> 00:36:00,190
automatischen Vendoring Support

749
00:36:00,190 --> 00:36:01,350
lag. Was auch immer das macht.

750
00:36:02,090 --> 00:36:04,310
Oder weil das Ding. Ich tippe auf den Ordner

751
00:36:04,310 --> 00:36:06,290
Namen. Ich tippe auf den. Bei Go weißt

752
00:36:06,290 --> 00:36:07,690
du nie. Go hat so viele

753
00:36:07,690 --> 00:36:10,150
Magic Sachen, die so sein müssen.

754
00:36:10,250 --> 00:36:12,090
Weil sie so sein müssen. Beispielsweise auch Klammern

755
00:36:12,090 --> 00:36:14,070
bei einem If oder so. Dass ich mir das gut

756
00:36:14,070 --> 00:36:16,330
vorstellen kann. So, Main Punkt

757
00:36:16,330 --> 00:36:19,800
Go. So, das ist

758
00:36:19,800 --> 00:36:21,540
auch merkwürdig gemacht, dass das

759
00:36:21,540 --> 00:36:23,400
nicht so heißen darf wie die App, sondern

760
00:36:23,400 --> 00:36:25,020
So, und jetzt machen wir hier

761
00:36:25,020 --> 00:36:27,120
Function Main

762
00:36:27,120 --> 00:36:28,940
FMT Prindeln

763
00:36:28,940 --> 00:36:31,580
Keg Wait. So, und das sollte

764
00:36:31,580 --> 00:36:35,870
jetzt funktionieren. Ja, okay.

765
00:36:36,010 --> 00:36:37,810
Nice. Funktioniert. Mal kurz checken,

766
00:36:37,870 --> 00:36:38,970
ob Rust auch funktioniert.

767
00:36:38,970 --> 00:36:42,860
Seht ihr das Terminal hier, wenn ich da

768
00:36:42,860 --> 00:36:44,880
was tippe? Leute, hier unten. Sieht man

769
00:36:44,880 --> 00:36:45,040
das?

770
00:36:46,540 --> 00:36:47,920
Ne, da ist der Chat davor, gell?

771
00:36:48,760 --> 00:36:50,720
Dann machen wir es so. Wir machen so. Dann

772
00:36:50,720 --> 00:36:51,640
seht ihr es auf jeden Fall.

773
00:36:53,730 --> 00:36:55,930
Jetzt ist genug Platz unter Chico

774
00:36:55,930 --> 00:36:57,570
hier rechts. Da sieht man nichts.

775
00:36:58,590 --> 00:37:00,070
Dann machen wir auch das Terminal

776
00:37:00,070 --> 00:37:00,850
hier unten drunter.

777
00:37:02,410 --> 00:37:02,750
So, ja.

778
00:37:04,110 --> 00:37:06,150
Also, Repos, Benchmark, Champ,

779
00:37:06,250 --> 00:37:06,570
Rust.

780
00:37:08,510 --> 00:37:09,910
Und jetzt machen wir mal, ich glaube

781
00:37:09,910 --> 00:37:11,570
Cargo Run ist es.

782
00:37:11,590 --> 00:37:14,110
Okay, Rust

783
00:37:14,110 --> 00:37:15,150
Kompiliert fehlerfrei

784
00:37:15,150 --> 00:37:18,370
Erstmal im Kalender anmarken

785
00:37:18,370 --> 00:37:19,510
Tja

786
00:37:19,510 --> 00:37:21,770
Jetzt geht's schon los

787
00:37:21,770 --> 00:37:24,190
Ich glaube

788
00:37:24,190 --> 00:37:26,010
Es ist Brindeln, ne

789
00:37:26,010 --> 00:37:29,860
Auch in Rust

790
00:37:29,860 --> 00:37:31,520
Kick, wait

791
00:37:31,520 --> 00:37:36,290
Okay, ja, funktioniert, nice

792
00:37:36,290 --> 00:37:38,130
Okay, also

793
00:37:38,130 --> 00:37:39,490
Jetzt kommt das nächste

794
00:37:39,490 --> 00:37:42,490
Also das ist jetzt ja einfach nur um zu gucken

795
00:37:42,490 --> 00:37:44,190
Ob alles richtig aufgesetzt ist

796
00:37:44,190 --> 00:37:47,670
So

797
00:37:47,670 --> 00:37:50,730
Also, das Ding, was hat er hier für Schmerzen

798
00:37:50,730 --> 00:37:52,810
Could not load

799
00:37:52,810 --> 00:37:53,290
Ah ja

800
00:37:53,290 --> 00:37:56,390
Das liegt, nicht toll

801
00:37:56,390 --> 00:37:57,270
Bild

802
00:37:57,270 --> 00:38:04,470
Das liegt daran, dass er meine .NET Version

803
00:38:04,470 --> 00:38:06,490
Nicht erkannt hat, warum auch immer

804
00:38:06,490 --> 00:38:08,530
Reload

805
00:38:08,530 --> 00:38:10,230
Project, jetzt sollte es hoffentlich

806
00:38:10,230 --> 00:38:12,150
Gleich gehen, machen wir auch nochmal

807
00:38:12,150 --> 00:38:13,110
Eine Konsole auf

808
00:38:13,110 --> 00:38:16,110
CD, Repos, Benchmark

809
00:38:16,110 --> 00:38:19,290
.NET

810
00:38:19,290 --> 00:38:21,790
Run

811
00:38:21,790 --> 00:38:25,270
Ja, Funst, okay

812
00:38:25,270 --> 00:38:26,870
Alles klar

813
00:38:26,870 --> 00:38:28,990
So, also, was ich jetzt vorhabe

814
00:38:28,990 --> 00:38:29,650
Ist folgendes

815
00:38:29,650 --> 00:38:32,010
Ich möchte jetzt sowas hier machen

816
00:38:32,010 --> 00:38:32,710
Ich will jetzt

817
00:38:32,710 --> 00:38:34,350
Wir brauchen, wir brauchen

818
00:38:34,350 --> 00:38:36,650
Wir machen mal den .NET Teil

819
00:38:36,650 --> 00:38:38,530
Als erstes

820
00:38:38,530 --> 00:38:39,630
Und dann den anderen

821
00:38:39,630 --> 00:38:40,830
Wir machen jetzt mal eine Datei

822
00:38:40,830 --> 00:38:42,130
Interop.cs

823
00:38:42,130 --> 00:38:44,410
Die kriegt eine Public

824
00:38:44,410 --> 00:38:46,390
Eine

825
00:38:46,390 --> 00:38:48,950
Unsave

826
00:38:48,950 --> 00:38:51,150
Public Static Class

827
00:38:51,790 --> 00:38:53,790
Warum Unsave?

828
00:38:53,790 --> 00:38:54,470
Naja, weil ich

829
00:38:54,470 --> 00:38:57,030
C-Sachen mit Pointern und so

830
00:38:57,030 --> 00:38:58,430
In anderen Sprachen aufrufen will

831
00:38:58,430 --> 00:38:59,710
Also das muss Unsave sein

832
00:38:59,710 --> 00:39:01,790
Und damit das funktioniert

833
00:39:01,790 --> 00:39:04,670
Muss ich Unsave erlauben

834
00:39:04,670 --> 00:39:07,030
Ich weiß eh nicht, warum das nicht

835
00:39:07,030 --> 00:39:08,030
Standardmäßig an ist

836
00:39:08,030 --> 00:39:10,070
Ich meine, wenn man es nicht verwendet, verwendet man es halt nicht

837
00:39:10,070 --> 00:39:12,830
So

838
00:39:12,830 --> 00:39:16,050
Und jetzt will ich

839
00:39:16,050 --> 00:39:18,150
Beispielsweise sowas hier aufrufen

840
00:39:18,150 --> 00:39:21,050
DLL Import

841
00:39:21,050 --> 00:39:22,190
Von, ja

842
00:39:22,190 --> 00:39:23,530
Rusty

843
00:39:23,550 --> 00:39:25,550
Slip

844
00:39:25,550 --> 00:39:27,550
Will ich aufrufen

845
00:39:27,550 --> 00:39:29,550
Eine Funktion, die

846
00:39:29,550 --> 00:39:31,550
Boah, DLL Import Syntax

847
00:39:31,550 --> 00:39:32,550
Moment

848
00:39:32,550 --> 00:39:33,550
Muss ich mir abgucken

849
00:39:33,550 --> 00:39:37,550
Ich glaube Static Extern oder irgendwie so muss das aussehen

850
00:39:37,550 --> 00:39:40,550
Public Static Extern

851
00:39:40,550 --> 00:39:41,550
Genau

852
00:39:41,550 --> 00:39:46,270
So, Public Static Extern

853
00:39:46,270 --> 00:39:48,270
Das heißt ja auch hier irgendwie

854
00:39:48,270 --> 00:39:50,270
Call me, so

855
00:39:50,270 --> 00:39:52,270
Einfach nur Call heißt das Ding

856
00:39:52,270 --> 00:39:54,270
Also, was das macht

857
00:39:54,270 --> 00:39:56,270
Das ist was noch nicht geht, weil es ist noch nicht da

858
00:39:56,270 --> 00:39:58,270
Damit kann ich jetzt aus C-Sharp

859
00:39:58,270 --> 00:40:00,270
Eine Funktion aufrufen, die in Rust

860
00:40:00,270 --> 00:40:02,270
In einer Library

861
00:40:02,270 --> 00:40:05,780
In einer

862
00:40:05,780 --> 00:40:07,780
In einer Rust Library, die mit C-Interface

863
00:40:07,780 --> 00:40:09,780
Kompiliert wurde, existiert

864
00:40:09,780 --> 00:40:11,780
Aufrufen

865
00:40:11,780 --> 00:40:13,780
Void fehlt noch

866
00:40:13,780 --> 00:40:15,780
Und hiermit

867
00:40:15,780 --> 00:40:17,780
Kann ich, achso die sollte ich vielleicht

868
00:40:17,780 --> 00:40:19,780
Ein bisschen anders nennen

869
00:40:19,780 --> 00:40:21,780
Call me Rust

870
00:40:21,780 --> 00:40:23,780
Call oder einfach nur Call

871
00:40:23,780 --> 00:40:27,220
Go und

872
00:40:27,220 --> 00:40:29,220
Ich muss nur gucken, dass die Libraries

873
00:40:29,220 --> 00:40:31,220
Am Ende dann richtig heißen

874
00:40:31,220 --> 00:40:33,220
Also das sucht jetzt nach einer Library

875
00:40:33,220 --> 00:40:35,220
Die Rustlib heißt, irgendwo hier im Verzeichnis

876
00:40:35,220 --> 00:40:37,220
Oder Golib, die gibt es noch nicht

877
00:40:37,220 --> 00:40:39,220
Die müssen wir anlegen

878
00:40:39,220 --> 00:40:41,220
Und dort drinnen ruft es dann eine Funktion auf

879
00:40:41,220 --> 00:40:43,220
Die heißt Call Go

880
00:40:43,220 --> 00:40:45,220
Und Call Rust

881
00:40:45,220 --> 00:40:47,220
Das wird erstmal eine leere Funktion sein

882
00:40:47,220 --> 00:40:49,220
Man kann mit C-Sharp DLLs erstellen

883
00:40:49,220 --> 00:40:51,220
Nein, man kann aber

884
00:40:51,220 --> 00:40:53,220
Native Funktionen

885
00:40:53,220 --> 00:40:55,220
Importieren, beziehungsweise aufrufen

886
00:40:55,220 --> 00:40:57,220
In DLLs

887
00:40:57,220 --> 00:40:59,220
Oder in unter Linux sind das

888
00:40:59,220 --> 00:41:01,220
.so Dateien vorhanden sind

889
00:41:01,220 --> 00:41:03,220
Also Dynamic Loading

890
00:41:03,220 --> 00:41:07,680
So und mein Ziel

891
00:41:07,680 --> 00:41:09,680
Ist dann sowas zu machen hier

892
00:41:09,680 --> 00:41:11,680
Interop

893
00:41:11,680 --> 00:41:13,680
Punkt Call

894
00:41:13,680 --> 00:41:15,680
Interop

895
00:41:15,680 --> 00:41:17,680
Call Rust

896
00:41:17,680 --> 00:41:19,680
Wenn ich das jetzt aufrufe, wird folgendes passieren

897
00:41:19,680 --> 00:41:21,680
Bam

898
00:41:21,680 --> 00:41:23,680
Er findet nämlich Golib

899
00:41:23,680 --> 00:41:25,680
Und ähm

900
00:41:25,680 --> 00:41:27,680
Rustlib nicht

901
00:41:27,680 --> 00:41:29,680
Aber auch klar, die haben wir noch nicht angelegt

902
00:41:29,680 --> 00:41:31,680
Die gibt es schlicht und ergreifend noch gar nicht

903
00:41:31,680 --> 00:41:33,680
Ich würde sagen, wir fangen mal mit dem Go Teil an

904
00:41:33,680 --> 00:41:35,680
Da weiß ich noch

905
00:41:35,680 --> 00:41:37,680
Ungefähr, so ganz grob

906
00:41:37,680 --> 00:41:39,680
Wie es aussehen muss

907
00:41:39,680 --> 00:41:41,680
Dass das funktioniert

908
00:41:41,680 --> 00:41:43,680
Und zwar, wenn ich das richtig in Erinnerung habe

909
00:41:43,680 --> 00:41:45,680
Muss man jetzt folgendes machen

910
00:41:45,680 --> 00:41:47,680
Also wir legen jetzt mal in Go was an

911
00:41:47,680 --> 00:41:49,680
Die Main Funktion brauchen wir nicht

912
00:41:49,680 --> 00:41:51,680
Weil wir starten ja

913
00:41:51,680 --> 00:41:53,680
Kein Binary, sondern

914
00:41:53,680 --> 00:41:55,680
Wir callen von C-Sharp in was rein

915
00:41:55,680 --> 00:41:57,680
Was in Go definiert ist

916
00:41:57,680 --> 00:41:59,680
Ist natürlich auch der Einstiegspunkt

917
00:41:59,680 --> 00:42:01,680
Nicht Main, sondern der Einstiegspunkt in dem Fall ist

918
00:42:01,680 --> 00:42:03,680
Call Go, weil das ist das was wir aufrufen

919
00:42:03,680 --> 00:42:05,680
So, wenn ich das noch richtig im Kopf habe

920
00:42:05,680 --> 00:42:07,680
Wie das funktioniert in Go

921
00:42:07,680 --> 00:42:09,680
Dann sagt man hier Function

922
00:42:09,680 --> 00:42:11,680
Die muss heißen Call Go

923
00:42:11,680 --> 00:42:13,680
So wie hier

924
00:42:13,680 --> 00:42:15,680
Also so wie da

925
00:42:15,680 --> 00:42:17,680
Und dann muss man glaube ich drüber schreiben

926
00:42:17,680 --> 00:42:19,680
Export

927
00:42:19,680 --> 00:42:21,680
Call Go

928
00:42:21,680 --> 00:42:23,680
Entweder mit Leerzeichen, ne ohne Leerzeichen

929
00:42:23,680 --> 00:42:25,680
Und ich glaube

930
00:42:25,680 --> 00:42:27,680
So muss man das machen

931
00:42:27,680 --> 00:42:29,680
Man muss das als C-Interface exportieren

932
00:42:29,680 --> 00:42:31,680
Aber das war noch nicht alles

933
00:42:31,680 --> 00:42:35,180
Go run

934
00:42:35,180 --> 00:42:37,180
Ne das geht natürlich nicht

935
00:42:37,180 --> 00:42:41,520
Oh shit

936
00:42:41,520 --> 00:42:43,520
Go kompilieren

937
00:42:43,520 --> 00:42:45,520
Als C-Library

938
00:42:45,520 --> 00:42:47,520
Beziehungsweise mit C-Interface

939
00:42:47,520 --> 00:42:49,520
Wie ging das jetzt nochmal

940
00:42:49,520 --> 00:42:51,520
Oh meine Güte

941
00:42:51,520 --> 00:42:53,520
Muss ich nachgucken

942
00:42:53,520 --> 00:42:58,750
C-Go-Compile

943
00:42:58,750 --> 00:43:00,750
Ach Import C musste man auch noch machen

944
00:43:00,750 --> 00:43:02,750
Ja ja ok

945
00:43:02,750 --> 00:43:04,750
Das musste man auch noch machen

946
00:43:04,750 --> 00:43:06,750
Am Anfang

947
00:43:06,750 --> 00:43:08,750
Also das braucht man

948
00:43:08,750 --> 00:43:10,750
Das braucht man in Go

949
00:43:10,750 --> 00:43:12,750
Damit man aus Go C-Libraries aufrufen kann

950
00:43:12,750 --> 00:43:14,750
Und das hier braucht man

951
00:43:14,750 --> 00:43:16,750
Damit man aus anderen Sprachen

952
00:43:16,750 --> 00:43:18,750
Go Sachen aufrufen kann

953
00:43:18,750 --> 00:43:20,750
Über ein C-Interface was generiert wird

954
00:43:22,750 --> 00:43:24,750
Ich glaube man braucht beides oder

955
00:43:24,750 --> 00:43:26,750
Egal schadet auf jeden Fall nichts

956
00:43:26,750 --> 00:43:31,860
Was auch immer

957
00:43:31,860 --> 00:43:33,860
Das da jetzt ist

958
00:43:33,860 --> 00:43:46,960
Keine Ahnung

959
00:43:46,960 --> 00:43:48,960
Äh

960
00:43:48,960 --> 00:43:50,960
What the

961
00:43:50,960 --> 00:43:52,960
Ich such den Go-Build Aufruf dafür

962
00:43:52,960 --> 00:43:57,940
Go-Build

963
00:43:57,940 --> 00:43:59,940
Man muss irgendwie C-Go-Enable oder sowas machen

964
00:43:59,940 --> 00:44:07,660
Ich hab das noch

965
00:44:07,660 --> 00:44:09,660
Ich hab das noch im Hinterkopf irgendwie

966
00:44:09,660 --> 00:44:11,660
Go-Build

967
00:44:11,660 --> 00:44:13,660
Ich weiß aber nur nicht mehr

968
00:44:13,660 --> 00:44:15,660
Hab ich das vielleicht hier irgendwo

969
00:44:15,660 --> 00:44:17,660
Ne

970
00:44:17,660 --> 00:44:19,660
Hab ich das vielleicht in der anderen VM

971
00:44:19,660 --> 00:44:21,660
Noch als History

972
00:44:21,660 --> 00:44:23,660
Kann GCC auch Go kompilieren

973
00:44:23,660 --> 00:44:25,660
Ja

974
00:44:25,660 --> 00:44:27,660
Es gibt ein GCC Plugin für Go

975
00:44:27,660 --> 00:44:29,660
Aber das verwendet glaube ich

976
00:44:29,660 --> 00:44:31,660
Meines Wissens nach so gut wie niemand

977
00:44:31,660 --> 00:44:33,660
C-Go

978
00:44:35,660 --> 00:44:37,660
Gleich

979
00:44:37,660 --> 00:44:39,660
Ah Shit haben wir es auch nicht

980
00:44:39,660 --> 00:44:43,300
In der History mal drin

981
00:44:43,300 --> 00:44:45,300
Oh wie war das denn jetzt nochmal

982
00:44:45,300 --> 00:44:47,300
Hier C-Go-Enable genau

983
00:44:47,300 --> 00:44:51,060
Ganz ehrlich ich versteh auch gar nicht

984
00:44:51,060 --> 00:44:53,060
Wozu das gut sein soll

985
00:44:53,060 --> 00:44:55,060
Ja C-Go-Enable genau das such ich

986
00:44:55,060 --> 00:44:57,060
C-Go-Enable

987
00:44:57,060 --> 00:44:59,060
Aber die Frage ist wie man es jetzt nochmal aufruft

988
00:44:59,060 --> 00:45:01,060
Env

989
00:45:01,060 --> 00:45:04,370
Go-OS-Linux

990
00:45:04,370 --> 00:45:07,740
C-Go-Enable

991
00:45:07,740 --> 00:45:12,020
Ok

992
00:45:12,020 --> 00:45:14,020
Das ging irgendwie so

993
00:45:14,020 --> 00:45:16,020
Ne es ist auf jeden Fall Env

994
00:45:16,020 --> 00:45:18,020
Da unter C

995
00:45:18,020 --> 00:45:20,020
C-Go-Enable

996
00:45:20,020 --> 00:45:22,020
Gleich 1

997
00:45:22,020 --> 00:45:24,020
Und dann sagt man glaube ich einfach Go-Build

998
00:45:24,020 --> 00:45:27,970
Ne

999
00:45:27,970 --> 00:45:29,970
Aber ich bin ja auch falsch hier

1000
00:45:29,970 --> 00:45:31,970
Ich muss ja auch in mein Go-Projekt

1001
00:45:31,970 --> 00:45:33,970
Ja das wird jetzt ein bisschen abartig bei mir

1002
00:45:33,970 --> 00:45:38,880
Bis das funktioniert

1003
00:45:38,880 --> 00:45:40,880
Ne im Moment hat er einfach funktioniert gerade

1004
00:45:40,880 --> 00:45:45,980
Äh

1005
00:45:45,980 --> 00:45:47,980
Nein das ist falsch

1006
00:45:47,980 --> 00:45:49,980
Der soll das als Library kompilieren

1007
00:45:49,980 --> 00:45:51,980
Äh

1008
00:45:51,980 --> 00:45:53,980
Build Mode

1009
00:45:53,980 --> 00:45:55,980
Oh meine Güte wie geht das Go

1010
00:45:55,980 --> 00:45:57,980
Shared

1011
00:45:57,980 --> 00:45:59,980
Shared Library

1012
00:45:59,980 --> 00:46:05,280
Shared Libraries in Go

1013
00:46:05,280 --> 00:46:07,280
How to use Go Shared Library

1014
00:46:07,280 --> 00:46:09,280
Ne ne ne ne

1015
00:46:09,280 --> 00:46:11,280
Building Shared Libraries in Go

1016
00:46:11,280 --> 00:46:13,280
Shared Libraries in Go

1017
00:46:13,280 --> 00:46:17,550
Genau wie ging das nochmal

1018
00:46:17,550 --> 00:46:19,550
Ich hab das

1019
00:46:19,550 --> 00:46:21,550
Manchmal ist Brain in der History gar nicht so gut

1020
00:46:21,550 --> 00:46:23,550
Weil

1021
00:46:23,550 --> 00:46:25,550
Wenn man dann seine History nicht hat

1022
00:46:25,550 --> 00:46:27,550
Hier

1023
00:46:27,550 --> 00:46:29,550
Build Mode gleich C Shared

1024
00:46:29,550 --> 00:46:31,550
Minus O Preload

1025
00:46:31,550 --> 00:46:33,550
Ich hab keine Ahnung was das bedeuten soll

1026
00:46:33,550 --> 00:46:35,550
Ich lass das einfach mal weg

1027
00:46:35,550 --> 00:46:44,430
Was

1028
00:46:44,430 --> 00:46:46,430
Ok was auch immer

1029
00:46:46,430 --> 00:46:48,430
Also wahrscheinlich brauchen wir jetzt noch

1030
00:46:48,430 --> 00:46:50,430
Das hier dabei

1031
00:46:50,430 --> 00:46:57,460
Go Build hin

1032
00:46:57,460 --> 00:46:59,460
Ja schon besser schon besser

1033
00:46:59,460 --> 00:47:03,090
Aber wo ist meine Library

1034
00:47:03,090 --> 00:47:07,170
Ach Go App ist die Library

1035
00:47:07,170 --> 00:47:09,170
Ok das Ding soll heißen

1036
00:47:09,170 --> 00:47:11,170
Nach dem es ja

1037
00:47:11,170 --> 00:47:13,170
Ok also

1038
00:47:13,170 --> 00:47:20,030
Äh

1039
00:47:20,030 --> 00:47:25,010
Bin ich

1040
00:47:25,010 --> 00:47:27,010
Moment warum ist der Aufruf nicht mehr in meiner History drin

1041
00:47:27,010 --> 00:47:29,010
What the

1042
00:47:31,010 --> 00:47:33,010
Achso weil ein Leerzeichen davor war

1043
00:47:33,010 --> 00:47:35,010
Lul

1044
00:47:35,010 --> 00:47:37,010
Ja dann ist klar das das nicht drin steht

1045
00:47:37,010 --> 00:47:39,010
Ok Minus O

1046
00:47:39,010 --> 00:47:41,010
Minus O

1047
00:47:41,010 --> 00:47:43,010
Der Output soll sein

1048
00:47:43,010 --> 00:47:45,010
Wie hab ich das genannt in .NET

1049
00:47:45,010 --> 00:47:51,460
GoLib

1050
00:47:51,460 --> 00:47:53,460
GoLib.so

1051
00:47:53,460 --> 00:47:57,920
Ja sehr schön

1052
00:47:57,920 --> 00:47:59,920
Genau genau genau

1053
00:47:59,920 --> 00:48:01,920
So will ich das haben

1054
00:48:01,920 --> 00:48:03,920
Ok GoLib.so

1055
00:48:03,920 --> 00:48:05,920
Soll er bauen

1056
00:48:05,920 --> 00:48:07,920
Und dann soll er das ganze Moven

1057
00:48:07,920 --> 00:48:09,920
GoLib.so

1058
00:48:09,920 --> 00:48:11,920
Moven hoch in das

1059
00:48:11,920 --> 00:48:16,770
Sharp Projekt

1060
00:48:16,770 --> 00:48:18,770
GoLib.so ok

1061
00:48:18,770 --> 00:48:20,770
Nice

1062
00:48:20,770 --> 00:48:22,770
So wenn ich Glück hab klappt das jetzt schon

1063
00:48:22,770 --> 00:48:24,770
Fuck

1064
00:48:24,770 --> 00:48:26,770
Cannot open

1065
00:48:26,770 --> 00:48:30,660
Ah ich weiß warum

1066
00:48:30,660 --> 00:48:32,660
Weil ich

1067
00:48:32,660 --> 00:48:34,660
Ppega bin

1068
00:48:34,660 --> 00:48:36,660
Ich muss die Build Action auch umstellen

1069
00:48:36,660 --> 00:48:38,660
Das der das ins Output Directory kopiert

1070
00:48:38,660 --> 00:48:40,660
Und jetzt kommt

1071
00:48:40,660 --> 00:48:42,660
Pregge Leute Pregge

1072
00:48:42,660 --> 00:48:44,660
Ey es funzt

1073
00:48:44,660 --> 00:48:46,660
Ich kann euch auch beweisen das es funzt

1074
00:48:46,660 --> 00:48:48,660
Guckt mal

1075
00:48:48,660 --> 00:48:50,660
Wir schreiben jetzt hier was in Go rein

1076
00:48:50,660 --> 00:48:52,660
Ok

1077
00:48:52,660 --> 00:48:54,660
Fmt printeln Lul

1078
00:48:54,660 --> 00:48:56,660
Kompilieren das

1079
00:48:56,660 --> 00:48:58,660
Und jetzt rufe ich es aus C Sharp auf

1080
00:48:58,660 --> 00:49:00,660
Lul

1081
00:49:00,660 --> 00:49:02,660
Und ihr seht hier nirgends wo in C Sharp ist Lul definiert

1082
00:49:02,660 --> 00:49:04,660
Oder Lul die Ausgabe die kommt aus Go

1083
00:49:04,660 --> 00:49:06,660
Also jetzt callt

1084
00:49:06,660 --> 00:49:12,400
Jetzt callt C Sharp nach Go rein

1085
00:49:12,400 --> 00:49:16,540
Das ist nice

1086
00:49:16,540 --> 00:49:18,540
Ähm

1087
00:49:18,540 --> 00:49:20,540
Wie mach ich denn

1088
00:49:20,540 --> 00:49:22,540
Ein Release Build

1089
00:49:22,540 --> 00:49:24,540
Ist das standardmäßig ein Release Build

1090
00:49:24,540 --> 00:49:35,340
Ne ne C

1091
00:49:35,340 --> 00:49:37,340
Go brauche ich auf jeden Fall

1092
00:49:37,340 --> 00:49:39,340
Weil ich will gleich noch versuchen

1093
00:49:39,340 --> 00:49:41,340
Wie das ist ob man auch ein Struct returnen kann

1094
00:49:41,340 --> 00:49:46,380
Und sowas

1095
00:49:46,380 --> 00:49:49,760
Ähm was habe ich gerade gesagt

1096
00:49:49,760 --> 00:49:51,760
Was wollte ich gerade machen

1097
00:49:51,760 --> 00:49:53,760
Jetzt habe ich gerade an was anderes gedacht Lul

1098
00:49:53,760 --> 00:49:55,760
Jetzt weiß ich was ich gerade machen wollte

1099
00:49:55,760 --> 00:50:00,160
Ähm Chat was habe ich vor 2 Sekunden gesagt

1100
00:50:00,160 --> 00:50:02,160
Lolo alle Boomer hier

1101
00:50:02,160 --> 00:50:04,160
Achso Release Build ja

1102
00:50:04,160 --> 00:50:06,160
Go Build Release

1103
00:50:06,160 --> 00:50:08,160
House of Build

1104
00:50:08,160 --> 00:50:10,160
Achso

1105
00:50:10,160 --> 00:50:23,360
Strip Debug Symbols

1106
00:50:23,360 --> 00:50:25,360
Nö nö nö

1107
00:50:25,360 --> 00:50:28,990
Ach ok es gibt gar kein Debug und Release Build

1108
00:50:28,990 --> 00:50:30,990
Bei Go gibt es nur

1109
00:50:30,990 --> 00:50:32,990
Gibt es nur Release Builds quasi

1110
00:50:32,990 --> 00:50:38,610
Was für eine Linungsdistribution ist das

1111
00:50:38,610 --> 00:50:40,610
Arch by the way

1112
00:50:40,610 --> 00:50:42,610
Wenn du es genau wissen willst

1113
00:50:42,610 --> 00:50:44,610
Dafür habe ich natürlich nochmal mein Neo Fetch vorbereitet

1114
00:50:44,610 --> 00:50:46,610
Damit ich euch regelmäßig sagen kann

1115
00:50:46,610 --> 00:50:48,610
Dass ich Arch Linungs verwende

1116
00:50:48,610 --> 00:50:50,610
Das ist Arch Linungs allerdings in der Form

1117
00:50:50,610 --> 00:50:52,610
UVM

1118
00:50:52,610 --> 00:50:54,610
Und das Terminal ist West Term

1119
00:50:54,610 --> 00:50:56,610
Das ist E3 als

1120
00:50:56,610 --> 00:50:58,610
Window Manager und ZSH

1121
00:50:58,610 --> 00:51:00,610
Als Shell

1122
00:51:00,610 --> 00:51:02,610
Wenn es dich

1123
00:51:02,610 --> 00:51:04,610
Genau interessiert wie das alles konfiguriert

1124
00:51:04,610 --> 00:51:06,610
Ist und funktioniert kannst du auf

1125
00:51:06,610 --> 00:51:08,610
Github gucken hier ist meine ganze

1126
00:51:08,610 --> 00:51:12,110
Config und wenn du gerade dabei bist

1127
00:51:12,110 --> 00:51:14,110
Kann ich dir empfehlen

1128
00:51:14,110 --> 00:51:16,110
Schnapp dir auch noch gleich die passenden Desktop Hintergründe

1129
00:51:18,110 --> 00:51:20,110
Das du auch

1130
00:51:20,110 --> 00:51:22,110
White Paper Happy hast

1131
00:51:22,110 --> 00:51:34,900
Im Hintergrund so wie ich

1132
00:51:34,900 --> 00:51:36,900
Was ist One Fetch

1133
00:51:36,900 --> 00:51:38,900
Ist One Fetch die coolere Neo

1134
00:51:38,900 --> 00:51:40,900
Neo Fetch Variante

1135
00:51:40,900 --> 00:51:42,900
Oder was

1136
00:51:42,900 --> 00:51:44,900
Command Line Git Information Tool

1137
00:51:44,900 --> 00:51:53,360
Was ist das

1138
00:51:53,360 --> 00:51:55,360
Written in Rust

1139
00:51:55,360 --> 00:51:57,360
Natürlich die Krustentiere sind wieder am Start

1140
00:51:57,360 --> 00:52:03,490
Ach da kriegt man

1141
00:52:03,490 --> 00:52:05,490
Infos über das Repo angezeigt

1142
00:52:05,490 --> 00:52:07,490
Ja das ist doch eigentlich auch ganz cool

1143
00:52:07,490 --> 00:52:13,550
So

1144
00:52:13,550 --> 00:52:15,550
Also das Call nach

1145
00:52:15,550 --> 00:52:17,550
Go Code funktioniert schon einmal

1146
00:52:17,550 --> 00:52:19,550
So

1147
00:52:19,550 --> 00:52:21,550
Wir können jetzt natürlich noch sagen

1148
00:52:21,550 --> 00:52:23,550
.NET Run Minus

1149
00:52:23,550 --> 00:52:25,550
C Release

1150
00:52:25,550 --> 00:52:27,550
Das es auch im Release Mode läuft

1151
00:52:27,550 --> 00:52:29,550
Gut also erster

1152
00:52:29,550 --> 00:52:31,550
Part ist geschafft

1153
00:52:31,550 --> 00:52:33,550
Jetzt könnt ihr euch aussuchen

1154
00:52:33,550 --> 00:52:35,550
Chat ob wir als erstes

1155
00:52:35,550 --> 00:52:37,550
Den Go Part

1156
00:52:37,550 --> 00:52:39,550
Vollständig bauen also vollständig

1157
00:52:39,550 --> 00:52:41,550
Bauen bedeutet zwei Sachen

1158
00:52:41,550 --> 00:52:43,550
Leider nicht aus Go die nächste

1159
00:52:43,550 --> 00:52:45,550
Programmiersprache Callen

1160
00:52:45,550 --> 00:52:47,550
Die nächste Programmiersprache Callen

1161
00:52:47,550 --> 00:52:49,550
Also was ich in den

1162
00:52:49,550 --> 00:52:51,550
Sprachen machen will

1163
00:52:51,550 --> 00:52:53,550
Ich will zwei Sachen jeweils in den Sprachen einbauen

1164
00:52:53,550 --> 00:52:55,550
Und zwar das erste ist

1165
00:52:55,550 --> 00:52:57,550
Eine leere Funktion die wir aufrufen können

1166
00:52:57,550 --> 00:52:59,550
In dem Fall kommt das mit dem 0 wieder raus

1167
00:52:59,550 --> 00:53:01,550
Weil ich will nicht 500 mal 0 ausgeben

1168
00:53:01,550 --> 00:53:03,550
Und

1169
00:53:03,550 --> 00:53:05,550
Das zweite ist eine Funktion

1170
00:53:05,550 --> 00:53:07,550
Die nennen wir einfach hier irgendwie Call Go 2

1171
00:53:07,550 --> 00:53:09,550
Und die soll ein Struct

1172
00:53:09,550 --> 00:53:11,550
Returnen

1173
00:53:11,550 --> 00:53:13,550
Und da bin ich mal gespannt wie ich das

1174
00:53:13,550 --> 00:53:15,550
Mache ein Struct

1175
00:53:15,550 --> 00:53:17,550
Von Go zu Return in C Sharp

1176
00:53:17,550 --> 00:53:19,550
Was man dann da dort

1177
00:53:19,550 --> 00:53:21,550
Auch als Struct quasi

1178
00:53:21,550 --> 00:53:23,550
Deserialisieren kann und benutzen kann

1179
00:53:23,550 --> 00:53:25,550
Das einfachste wäre natürlich alle seine Daten

1180
00:53:25,550 --> 00:53:27,550
Irgendwie als JSON String zu Returnen

1181
00:53:27,550 --> 00:53:29,550
Und dann Parse aber das ist ja langweilig

1182
00:53:29,550 --> 00:53:31,550
Wir wollen das ja richtig auf C Ebene machen

1183
00:53:31,550 --> 00:53:33,550
Also quasi Memory Bytes

1184
00:53:33,550 --> 00:53:36,860
Dann

1185
00:53:36,860 --> 00:53:38,860
Casten zu irgendeinem Struct

1186
00:53:38,860 --> 00:53:40,860
Da bin ich mal gespannt wie das geht ich hab kein Plan

1187
00:53:40,860 --> 00:53:42,860
Ne auch nicht GRPC

1188
00:53:42,860 --> 00:53:44,860
Das ist wirklich richtig richtig Low Level

1189
00:53:44,860 --> 00:53:46,860
Soll das sein

1190
00:53:46,860 --> 00:53:48,860
So

1191
00:53:48,860 --> 00:53:50,860
Also ihr könnt euch jetzt aussuchen

1192
00:53:50,860 --> 00:53:52,860
Wollen wir jetzt den Go Part noch implementieren

1193
00:53:52,860 --> 00:53:54,860
Also sprich die Funktion in Go

1194
00:53:54,860 --> 00:53:56,860
Die in den Struct zurück liefert an C Sharp

1195
00:53:56,860 --> 00:53:58,860
Oder wollen wir jetzt erstmal gucken

1196
00:53:58,860 --> 00:54:00,860
Wie man Rust

1197
00:54:00,860 --> 00:54:02,860
Callen kann von C Sharp aus

1198
00:54:02,860 --> 00:54:04,860
Könnt ihr euch aussuchen

1199
00:54:04,860 --> 00:54:12,850
Ich trink mal was

1200
00:54:12,850 --> 00:54:16,800
Rust erstmal Go fertig

1201
00:54:16,800 --> 00:54:18,800
Go fertig

1202
00:54:18,800 --> 00:54:20,800
Okay

1203
00:54:20,800 --> 00:54:22,800
Also

1204
00:54:22,800 --> 00:54:24,800
Die meisten Leute wollen Go haben

1205
00:54:24,800 --> 00:54:26,800
Ich denke dass es nicht so lange dauert

1206
00:54:26,800 --> 00:54:28,800
Wobei ich das noch nicht gemacht habe

1207
00:54:28,800 --> 00:54:30,800
Structs Returnen

1208
00:54:30,800 --> 00:54:32,800
Von Go nach C Sharp

1209
00:54:32,800 --> 00:54:34,800
Ich würde sagen wir fangen mal easy an

1210
00:54:34,800 --> 00:54:36,800
Okay wir fangen mal easy an

1211
00:54:36,800 --> 00:54:38,800
Easy heißt

1212
00:54:38,800 --> 00:54:40,800
Wir returnen hier jetzt ein

1213
00:54:40,800 --> 00:54:42,800
Moment wie

1214
00:54:42,800 --> 00:54:44,800
Ach shit wie ging das nochmal

1215
00:54:44,800 --> 00:54:46,800
Ich glaube einfach

1216
00:54:46,800 --> 00:54:48,800
Sagen wir mal

1217
00:54:48,800 --> 00:54:50,800
In den UN64

1218
00:54:50,800 --> 00:54:55,970
Returnen wir jetzt hier mal

1219
00:54:55,970 --> 00:54:57,970
So

1220
00:54:57,970 --> 00:54:59,970
Und jetzt sagen wir hier

1221
00:54:59,970 --> 00:55:01,970
Return 1

1222
00:55:01,970 --> 00:55:03,970
Mein einfacher geht es nicht mehr

1223
00:55:03,970 --> 00:55:05,970
Return 1

1224
00:55:05,970 --> 00:55:07,970
Kompiliert auch ohne Fehler

1225
00:55:07,970 --> 00:55:09,970
Und jetzt ist die Frage

1226
00:55:09,970 --> 00:55:11,970
Das dürfte ziemlich easy sein

1227
00:55:11,970 --> 00:55:13,970
Jetzt gehe ich hier einfach hin

1228
00:55:13,970 --> 00:55:15,970
Ich kommentiere mal das Rust aus

1229
00:55:15,970 --> 00:55:17,970
Jetzt ist der Return Typ nicht void

1230
00:55:17,970 --> 00:55:19,970
Sondern der Return Typ ist UN64

1231
00:55:19,970 --> 00:55:21,970
Das Ding ist nur

1232
00:55:21,970 --> 00:55:23,970
Ich habe keine Ahnung

1233
00:55:23,970 --> 00:55:25,970
Ich glaube das ist ein

1234
00:55:25,970 --> 00:55:27,970
C aus Go

1235
00:55:27,970 --> 00:55:29,970
Exportiert ein C UNt

1236
00:55:29,970 --> 00:55:31,970
Die gleiche ist

1237
00:55:31,970 --> 00:55:33,970
Moment geht das überhaupt so

1238
00:55:33,970 --> 00:55:35,970
Das geht doch eigentlich gar nicht

1239
00:55:35,970 --> 00:55:37,970
Ich will ja kein Rust UNt

1240
00:55:37,970 --> 00:55:39,970
Exportieren

1241
00:55:39,970 --> 00:55:41,970
Sondern ein C UNt

1242
00:55:41,970 --> 00:55:43,970
UN64

1243
00:55:43,970 --> 00:55:45,970
Also es könnte sein dass das funktioniert

1244
00:55:45,970 --> 00:55:47,970
Wenn die Implementierung einfach überall

1245
00:55:47,970 --> 00:55:49,970
Gleich sind

1246
00:55:49,970 --> 00:55:51,970
Probieren wir das mal aus

1247
00:55:51,970 --> 00:55:53,970
Aber ich glaube nicht dass das funktioniert

1248
00:55:53,970 --> 00:55:55,970
Ups

1249
00:55:55,970 --> 00:55:59,540
Da sollte jetzt 1 rauskommen

1250
00:55:59,540 --> 00:56:01,540
1

1251
00:56:01,540 --> 00:56:03,540
Das funktioniert aber ich glaube ganz

1252
00:56:03,540 --> 00:56:05,540
Korrekt ist das nicht

1253
00:56:05,540 --> 00:56:07,540
Das funktioniert wirklich nur

1254
00:56:07,540 --> 00:56:09,540
Weil das Memory Layout

1255
00:56:09,540 --> 00:56:11,540
Von einem UN64 einfach in C Sharp

1256
00:56:11,540 --> 00:56:13,540
Und Go gleich ist

1257
00:56:13,540 --> 00:56:15,540
Ich glaube korrekter wäre

1258
00:56:15,540 --> 00:56:17,540
Hier gewesen zu returnen ein

1259
00:56:17,540 --> 00:56:19,540
C.UN64

1260
00:56:19,540 --> 00:56:21,540
Oder sowas

1261
00:56:21,540 --> 00:56:23,540
Gibt es

1262
00:56:23,540 --> 00:56:25,540
Wie heißt das T oder so

1263
00:56:25,540 --> 00:56:27,540
Ist das so

1264
00:56:27,540 --> 00:56:29,540
Uint64C

1265
00:56:29,540 --> 00:56:31,540
Wie heißt das Kram

1266
00:56:31,540 --> 00:56:36,190
Uint64T

1267
00:56:36,190 --> 00:56:38,190
Habe ich doch

1268
00:56:38,190 --> 00:56:44,640
Gibt es nicht

1269
00:56:44,640 --> 00:56:46,640
Was muss ich denn da

1270
00:56:46,640 --> 00:56:48,640
Includen dafür

1271
00:56:48,640 --> 00:56:53,620
Standard

1272
00:56:53,620 --> 00:56:55,620
Stdint.h

1273
00:56:55,620 --> 00:57:00,340
Stdint.h

1274
00:57:00,340 --> 00:57:02,340
Stdint.h

1275
00:57:02,340 --> 00:57:04,340
Hey Funst

1276
00:57:04,340 --> 00:57:06,340
Nice

1277
00:57:06,340 --> 00:57:10,030
Ok also einzelne ins return

1278
00:57:10,030 --> 00:57:12,030
Von Go nach C

1279
00:57:12,030 --> 00:57:14,030
Von Go

1280
00:57:14,030 --> 00:57:16,030
Über C nach C Sharp

1281
00:57:16,030 --> 00:57:18,030
Funst

1282
00:57:18,030 --> 00:57:22,820
Jetzt ist die Frage

1283
00:57:22,820 --> 00:57:24,820
Wie machen wir das mit einem Struct

1284
00:57:24,820 --> 00:57:26,820
Das wird bestimmt etwas komplizierter

1285
00:57:26,820 --> 00:57:28,820
Könnte ich mir vorstellen

1286
00:57:28,820 --> 00:57:30,820
Weil wir brauchen ja

1287
00:57:30,820 --> 00:57:32,820
Wir brauchen ja einen C Struct

1288
00:57:32,820 --> 00:57:34,820
Kein Go Struct

1289
00:57:34,820 --> 00:57:36,820
Ok Go Struct

1290
00:57:36,820 --> 00:57:38,820
To C

1291
00:57:38,820 --> 00:57:40,820
Struct

1292
00:57:40,820 --> 00:57:45,410
Layouts sind in C Sharp

1293
00:57:45,410 --> 00:57:47,410
Recht easy

1294
00:57:47,410 --> 00:57:49,410
Wenn du dem sagst das er

1295
00:57:51,410 --> 00:57:53,410
Wie heißt das

1296
00:57:53,410 --> 00:57:55,410
Sequenziell serialisieren soll

1297
00:57:55,410 --> 00:57:57,410
Dann ist es das gleiche Layout wie von C

1298
00:57:57,410 --> 00:57:59,410
Dann ist das eigentlich kein Ding

1299
00:57:59,410 --> 00:58:05,660
Hoff ich mal

1300
00:58:05,660 --> 00:58:07,660
Ja genau genau das meine ich

1301
00:58:07,660 --> 00:58:09,660
Ja damit ist das

1302
00:58:09,660 --> 00:58:11,660
Meistens nicht so ein großes Problem

1303
00:58:11,660 --> 00:58:13,660
Go lang Struct

1304
00:58:13,660 --> 00:58:15,660
With C Struct

1305
00:58:15,660 --> 00:58:30,880
Ok ok ok

1306
00:58:30,880 --> 00:58:32,880
Ne der hat nen

1307
00:58:32,880 --> 00:58:34,880
Go Struct

1308
00:58:34,880 --> 00:58:36,880
Mit C Types drinnen

1309
00:58:36,880 --> 00:58:38,880
Das will ich nicht

1310
00:58:38,880 --> 00:58:40,880
Ok C Go

1311
00:58:40,880 --> 00:58:45,920
Return Struct

1312
00:58:45,920 --> 00:58:47,920
How to return Struct

1313
00:58:47,920 --> 00:58:49,920
Vom C Go

1314
00:58:49,920 --> 00:58:51,920
Ja genau das will ich haben

1315
00:58:51,920 --> 00:58:56,130
I have found a solution

1316
00:58:56,130 --> 00:59:02,060
In C

1317
00:59:02,060 --> 00:59:07,040
Ok der definiert ein Struct in C

1318
00:59:07,040 --> 00:59:09,040
Gibt es nicht C Pack Unpack

1319
00:59:09,040 --> 00:59:11,040
Ich hab keine Ahnung

1320
00:59:11,040 --> 00:59:26,960
Pack?

1321
00:59:26,960 --> 00:59:28,960
How to return a C Struct from a Go Function

1322
00:59:28,960 --> 00:59:30,960
Genau das will ich wissen

1323
00:59:30,960 --> 00:59:32,960
Ok Struct Point

1324
00:59:32,960 --> 00:59:34,960
Man muss das in C definieren

1325
00:59:34,960 --> 00:59:41,020
Auf jeden Fall

1326
00:59:41,020 --> 00:59:43,020
To access a Struct

1327
00:59:43,020 --> 00:59:45,020
Type directly

1328
00:59:45,020 --> 00:59:47,020
Prefix it with Struct

1329
00:59:47,020 --> 00:59:49,020
Underscore

1330
00:59:49,020 --> 00:59:51,020
Ok C Punkt Struct

1331
00:59:51,020 --> 00:59:53,020
Underscore

1332
00:59:53,020 --> 00:59:57,100
Oh meine Güte

1333
00:59:57,100 --> 00:59:59,100
Also ich glaube das wird in Rust

1334
00:59:59,100 --> 01:00:01,100
Eigentlich angenehmer sein

1335
01:00:01,100 --> 01:00:03,100
Als in Go

1336
01:00:03,100 --> 01:00:05,100
Also sprich wir brauchen jetzt

1337
01:00:05,100 --> 01:00:07,100
Ne Moment das muss man

1338
01:00:07,100 --> 01:00:09,100
So

1339
01:00:09,100 --> 01:00:11,100
Und das muss soweit ich weiß

1340
01:00:11,100 --> 01:00:13,100
Dann auch direkt über Import C stehen

1341
01:00:13,100 --> 01:00:15,100
Sonst mag er nicht

1342
01:00:15,100 --> 01:00:20,270
So die Includes können wir dann hier rein machen

1343
01:00:20,270 --> 01:00:28,190
Massive Pepega

1344
01:00:28,190 --> 01:00:30,190
So jetzt haben wir nen Struct Point

1345
01:00:30,190 --> 01:00:32,190
Wir wollen allerdings nicht Point Return

1346
01:00:32,190 --> 01:00:34,190
Wir wollen ein Struct

1347
01:00:34,190 --> 01:00:36,190
Ok machen wir einfach mal sowas hier

1348
01:00:36,190 --> 01:00:38,190
Struct Session

1349
01:00:38,190 --> 01:00:40,190
Hat eine

1350
01:00:40,190 --> 01:00:42,190
Wir machen mal was was man später auch irgendwie

1351
01:00:42,190 --> 01:00:44,190
Sinnvoll irgendwie

1352
01:00:44,190 --> 01:00:46,190
So das einmal gibt es hier ein

1353
01:00:46,190 --> 01:00:49,630
Int

1354
01:00:49,630 --> 01:00:51,630
Oder ein

1355
01:00:51,630 --> 01:00:53,630
U

1356
01:00:53,630 --> 01:00:55,630
Int machen wir es mal so

1357
01:00:55,630 --> 01:00:57,630
Ein Uint64T

1358
01:00:57,630 --> 01:01:01,200
Client ID

1359
01:01:01,200 --> 01:01:04,900
Und

1360
01:01:04,900 --> 01:01:06,900
Dann gibt es oh jetzt wird es interessant

1361
01:01:06,900 --> 01:01:08,900
Jetzt gibt es nen String

1362
01:01:08,900 --> 01:01:10,900
Den nennen wir

1363
01:01:10,900 --> 01:01:12,900
Keine Ahnung Name oder so

1364
01:01:12,900 --> 01:01:14,900
Ja Client Name

1365
01:01:14,900 --> 01:01:16,900
Jetzt bin ich mal gespannt

1366
01:01:16,900 --> 01:01:18,900
Wie ich ein Struct

1367
01:01:18,900 --> 01:01:20,900
Mit nem

1368
01:01:20,900 --> 01:01:22,900
Sharp Pointer

1369
01:01:22,900 --> 01:01:24,900
Irgendwie rüber kriege ins die Sharp

1370
01:01:24,900 --> 01:01:26,900
Ohne

1371
01:01:26,900 --> 01:01:28,900
Wohlgemerkt

1372
01:01:28,900 --> 01:01:33,230
Ohne Memory Leaks zu verursachen

1373
01:01:33,230 --> 01:01:35,230
Das wird

1374
01:01:35,230 --> 01:01:37,230
Oje

1375
01:01:37,230 --> 01:01:39,230
Ich weiß ja nicht einmal

1376
01:01:39,230 --> 01:01:41,230
Wie ich das über ok Return

1377
01:01:41,230 --> 01:01:43,230
Also wie ging das jetzt

1378
01:01:43,230 --> 01:01:45,230
C Punkt Struct Underscore

1379
01:01:45,230 --> 01:01:47,230
Und dann Session

1380
01:01:47,230 --> 01:01:49,230
Und jetzt durfte ich

1381
01:01:49,230 --> 01:01:51,230
Das so benennen mit

1382
01:01:51,230 --> 01:01:53,230
Ehm

1383
01:01:53,230 --> 01:01:55,230
Client Name

1384
01:01:55,230 --> 01:01:57,230
Ich weiß überhaupt nicht wie ist die Syntax

1385
01:01:57,230 --> 01:02:01,180
X

1386
01:02:01,180 --> 01:02:03,180
Variable Variable zuerst

1387
01:02:03,180 --> 01:02:07,140
Ok

1388
01:02:07,140 --> 01:02:09,140
Also Client ID

1389
01:02:09,140 --> 01:02:11,140
So das ist jetzt ein C Char

1390
01:02:11,140 --> 01:02:13,140
Array oder so

1391
01:02:13,140 --> 01:02:15,140
Ich hoffe

1392
01:02:15,140 --> 01:02:17,140
Das

1393
01:02:17,140 --> 01:02:19,140
Ne ne das funktioniert schon mal nicht

1394
01:02:19,140 --> 01:02:21,140
Oje

1395
01:02:21,140 --> 01:02:23,140
Wie ist das syntaktisch denn richtig

1396
01:02:23,140 --> 01:02:25,140
Ne das ist eigentlich ok so

1397
01:02:25,140 --> 01:02:29,340
Und dann haben wir noch was

1398
01:02:29,340 --> 01:02:31,340
Ich weiß einen Moment Client ID

1399
01:02:31,340 --> 01:02:33,340
Client ID ist 123

1400
01:02:33,340 --> 01:02:35,340
Und dann haben wir noch Client Name

1401
01:02:35,340 --> 01:02:37,340
Client Name ist dann 0w

1402
01:02:37,340 --> 01:02:39,340
Das wird so definitiv nicht funktionieren

1403
01:02:39,340 --> 01:02:41,340
Leute das kann ich euch sagen

1404
01:02:41,340 --> 01:02:43,340
Das wird nicht funktionieren

1405
01:02:43,340 --> 01:02:50,560
Ok das funktioniert schon mal nicht

1406
01:02:50,560 --> 01:02:52,560
Also

1407
01:02:52,560 --> 01:02:54,560
Das ist falsch weil das ist ja auch

1408
01:02:54,560 --> 01:02:56,560
Ein Uint

1409
01:02:56,560 --> 01:02:58,560
Also das hier muss ja auch

1410
01:02:58,560 --> 01:03:00,560
Ein sowas hier sein

1411
01:03:00,560 --> 01:03:02,560
Moment meine Go

1412
01:03:02,560 --> 01:03:04,560
Skills verlassen mich ich glaube das geht so

1413
01:03:04,560 --> 01:03:06,560
Das das funktioniert

1414
01:03:06,560 --> 01:03:08,560
Ja

1415
01:03:08,560 --> 01:03:10,560
Ne

1416
01:03:10,560 --> 01:03:12,560
Achso Moment

1417
01:03:12,560 --> 01:03:14,560
Ich return ja gar kein Struct

1418
01:03:14,560 --> 01:03:16,560
Ich will das hier return

1419
01:03:16,560 --> 01:03:21,790
Ok schon besser

1420
01:03:21,790 --> 01:03:23,790
Schon besser hätte ich es auch einfach so

1421
01:03:23,790 --> 01:03:25,790
Returnen können ohne das der rummeckert

1422
01:03:25,790 --> 01:03:27,790
Anscheinend

1423
01:03:27,790 --> 01:03:29,790
So also das funktioniert nicht

1424
01:03:29,790 --> 01:03:31,790
Ich muss jetzt einen

1425
01:03:31,790 --> 01:03:33,790
Charakter Array

1426
01:03:33,790 --> 01:03:35,790
In Go mach ok

1427
01:03:35,790 --> 01:03:37,790
Äh

1428
01:03:37,790 --> 01:03:39,790
C String

1429
01:03:39,790 --> 01:03:41,790
C Go return wie fandst du das

1430
01:03:41,790 --> 01:03:43,790
Return String

1431
01:03:43,790 --> 01:03:45,790
C Function in Go legen

1432
01:03:45,790 --> 01:03:47,790
C Punkt

1433
01:03:47,790 --> 01:03:49,790
C String

1434
01:03:49,790 --> 01:03:51,790
Was ich mache

1435
01:03:51,790 --> 01:03:53,790
Ich rufe aus C Sharp Go

1436
01:03:53,790 --> 01:03:55,790
Code auf über ein C Interface

1437
01:03:55,790 --> 01:03:57,790
Also

1438
01:03:57,790 --> 01:03:59,790
Irgendwie sowas wie

1439
01:03:59,790 --> 01:04:01,790
C String

1440
01:04:01,790 --> 01:04:03,790
C String

1441
01:04:03,790 --> 01:04:05,790
Ne Moment

1442
01:04:05,790 --> 01:04:07,790
Wir sind

1443
01:04:07,790 --> 01:04:09,790
Ne

1444
01:04:09,790 --> 01:04:11,790
Go

1445
01:04:11,790 --> 01:04:13,790
Ne Moment

1446
01:04:13,790 --> 01:04:15,790
Zu viele Programmiersprachen auf einmal

1447
01:04:15,790 --> 01:04:23,650
So oder

1448
01:04:23,650 --> 01:04:25,650
Ok

1449
01:04:25,650 --> 01:04:27,650
Leute es

1450
01:04:27,650 --> 01:04:29,650
Es kompiliert

1451
01:04:29,650 --> 01:04:31,650
Client Name ist

1452
01:04:31,650 --> 01:04:33,650
HDXYZ123

1453
01:04:33,650 --> 01:04:35,650
Ok

1454
01:04:35,650 --> 01:04:37,650
Könnte ein geiles Passwort sein

1455
01:04:37,650 --> 01:04:41,660
Ist es aber nicht

1456
01:04:41,660 --> 01:04:43,660
Ok jetzt returne ich ein Struct aus Go

1457
01:04:43,660 --> 01:04:45,660
Heißt im Endeffekt

1458
01:04:45,660 --> 01:04:47,660
Wenn ich das hier aufrufe das sollte noch funktionieren

1459
01:04:47,660 --> 01:04:49,660
Weil das erst

1460
01:04:49,660 --> 01:04:51,660
Ok das ist schon mal gut

1461
01:04:51,660 --> 01:04:53,660
123 ist die Client ID die ich hier gesetzt habe

1462
01:04:53,660 --> 01:04:55,660
Das funzt weil in meinem Struct

1463
01:04:55,660 --> 01:04:57,660
Vorne immer noch

1464
01:04:57,660 --> 01:04:59,660
Die Client ID ist

1465
01:04:59,660 --> 01:05:01,660
Jetzt ist die große Preisfrage

1466
01:05:01,660 --> 01:05:03,660
Wie kriege ich hier raus ein Struct

1467
01:05:03,660 --> 01:05:05,660
Also machen wir mal in C Sharp ein Struct

1468
01:05:05,660 --> 01:05:07,660
Das nennen wir auch Session

1469
01:05:07,660 --> 01:05:09,660
Public

1470
01:05:09,660 --> 01:05:11,660
Uint64

1471
01:05:11,660 --> 01:05:13,660
Tja

1472
01:05:13,660 --> 01:05:15,660
Client ID nennen wir es mal genauso

1473
01:05:15,660 --> 01:05:17,660
Public

1474
01:05:17,660 --> 01:05:19,660
String

1475
01:05:19,660 --> 01:05:21,660
Kann ich mir so nicht vorstellen

1476
01:05:21,660 --> 01:05:23,660
Dass das funktioniert

1477
01:05:23,660 --> 01:05:25,660
Und selbst wenn es funktioniert

1478
01:05:25,660 --> 01:05:27,660
Hat es garantiert Memory Leaks

1479
01:05:27,660 --> 01:05:29,660
Das werden wir jetzt mal ausprobieren

1480
01:05:29,660 --> 01:05:31,660
Mal gucken

1481
01:05:31,660 --> 01:05:33,660
Ob das C Sharp Interoption

1482
01:05:33,660 --> 01:05:35,660
Zeug so schlau ist

1483
01:05:35,660 --> 01:05:37,660
Und erkennt das man ja aus einem

1484
01:05:37,660 --> 01:05:39,660
C String

1485
01:05:39,660 --> 01:05:43,360
Ein C Sharp String machen kann

1486
01:05:43,360 --> 01:05:45,360
Automatisch

1487
01:05:45,360 --> 01:05:47,360
Da bin ich mal gespannt

1488
01:05:47,360 --> 01:05:49,360
So und das Ding soll heißen Client Name

1489
01:05:49,360 --> 01:05:51,360
Übrigens die Namen hier sind vollkommen egal

1490
01:05:51,360 --> 01:05:53,360
Die Namen sind vollkommen wurscht

1491
01:05:53,360 --> 01:05:55,360
Die müssen nicht die gleichen sein wie hier

1492
01:05:55,360 --> 01:05:57,360
Wichtig ist die Byte Anzahl

1493
01:05:57,360 --> 01:05:59,360
Also dass das hier

1494
01:05:59,360 --> 01:06:01,360
Quasi so lang ist

1495
01:06:01,360 --> 01:06:03,360
Und das hier so lang ist

1496
01:06:03,360 --> 01:06:05,360
Dass es dann passt im Endeffekt

1497
01:06:05,360 --> 01:06:07,360
Wie das hier heißt ist vollkommen egal

1498
01:06:07,360 --> 01:06:09,360
Also das Layout im Speicher muss das gleiche sein

1499
01:06:09,360 --> 01:06:11,360
So und jetzt

1500
01:06:11,360 --> 01:06:13,360
Returnen wir hiervon kein Uint

1501
01:06:13,360 --> 01:06:15,360
Sondern eine Session

1502
01:06:15,360 --> 01:06:17,360
Das funktioniert nicht weil es nicht Public ist

1503
01:06:17,360 --> 01:06:22,400
Ok Session

1504
01:06:22,400 --> 01:06:26,350
Jetzt bin ich mal gespannt

1505
01:06:26,350 --> 01:06:28,350
Jetzt bin ich mal gespannt

1506
01:06:28,350 --> 01:06:30,350
So Session Client ID

1507
01:06:30,350 --> 01:06:32,350
Ich hoffe das geht noch

1508
01:06:32,350 --> 01:06:34,350
Ok das funzt

1509
01:06:34,350 --> 01:06:36,350
Was ist hier

1510
01:06:36,350 --> 01:06:38,350
Client Name

1511
01:06:38,350 --> 01:06:40,350
Client Name

1512
01:06:40,350 --> 01:06:44,690
Client Name

1513
01:06:44,690 --> 01:06:50,110
Funktioniert einfach

1514
01:06:50,110 --> 01:06:52,110
Funktioniert einfach

1515
01:06:52,110 --> 01:06:54,110
Moment der erkennt automatisch

1516
01:06:54,110 --> 01:06:56,110
Der weiß automatisch wie man ein C String

1517
01:06:56,110 --> 01:06:58,110
In ein C Sharp String

1518
01:06:58,110 --> 01:07:00,110
Aber das hat 100 pro Memory Leaks

1519
01:07:00,110 --> 01:07:02,110
Das hat sowas von Memory Leaks

1520
01:07:02,110 --> 01:07:04,110
Leute ich sags euch

1521
01:07:04,110 --> 01:07:06,110
100 pro hat das Memory Leaks

1522
01:07:06,110 --> 01:07:08,110
Moment Moment

1523
01:07:08,110 --> 01:07:10,110
Watch Free minus H

1524
01:07:10,110 --> 01:07:12,110
Wir machen jetzt die

1525
01:07:12,110 --> 01:07:14,110
Erkenntnis

1526
01:07:14,110 --> 01:07:16,110
Wir machen jetzt folgendes

1527
01:07:16,110 --> 01:07:18,110
Wir gucken jetzt mal

1528
01:07:18,110 --> 01:07:20,110
Ob es Memory Leaks hat

1529
01:07:20,110 --> 01:07:22,110
While True

1530
01:07:22,110 --> 01:07:24,110
While 0w

1531
01:07:24,110 --> 01:07:27,490
Ok so

1532
01:07:27,490 --> 01:07:29,490
Wir gucken ob es Memory Leaks hat

1533
01:07:29,490 --> 01:07:31,490
Wir rufen es einfach in der Schleife auf

1534
01:07:31,490 --> 01:07:33,490
Und gucken ob

1535
01:07:33,490 --> 01:07:37,630
Free runter geht

1536
01:07:37,630 --> 01:07:41,460
Run

1537
01:07:41,460 --> 01:07:43,460
Oh Shit

1538
01:07:43,460 --> 01:07:45,460
Ich glaube es hat

1539
01:07:45,460 --> 01:07:49,090
Naja nö oder doch

1540
01:07:49,090 --> 01:07:51,090
Ah

1541
01:07:51,090 --> 01:08:03,100
Das ist jetzt aktuell so gar nicht mal zu

1542
01:08:03,100 --> 01:08:05,100
Das ist jetzt echt schwer

1543
01:08:05,100 --> 01:08:07,100
Der GC

1544
01:08:07,100 --> 01:08:09,100
Kann das nicht freen

1545
01:08:09,100 --> 01:08:17,090
Weil der GC wahrscheinlich kein free

1546
01:08:17,090 --> 01:08:19,090
Ne ne das hat ein Memory Leak

1547
01:08:19,090 --> 01:08:27,620
Oder?

1548
01:08:27,620 --> 01:08:29,620
Oder nicht

1549
01:08:29,620 --> 01:08:31,620
Also wenn das kein Memory Leak hat

1550
01:08:31,620 --> 01:08:49,780
Dann wundert es mich extrem

1551
01:08:49,780 --> 01:08:51,780
Warum verursacht es nicht mehr CPU Last

1552
01:08:51,780 --> 01:08:55,410
Ne macht es doch

1553
01:08:55,410 --> 01:08:59,680
Memory

1554
01:08:59,680 --> 01:09:01,680
Wir könnten doch einfach mal mit einem Debugger starten

1555
01:09:01,680 --> 01:09:21,820
Schwer zu sagen

1556
01:09:21,820 --> 01:09:23,820
Also das könnte auch einfach

1557
01:09:23,820 --> 01:09:25,820
Kein Memory Leak

1558
01:09:25,820 --> 01:09:29,580
Aber das wundert mich

1559
01:09:29,580 --> 01:09:31,580
Woher will es die Sharp wissen

1560
01:09:31,580 --> 01:09:33,580
Wie man das

1561
01:09:33,580 --> 01:09:39,840
Eigibt

1562
01:09:39,840 --> 01:09:41,840
Moment Moment Moment

1563
01:09:41,840 --> 01:09:43,840
Habe ich das überhaupt schon kompiliert jetzt

1564
01:09:43,840 --> 01:10:05,390
Und dahin geschoben

1565
01:10:05,390 --> 01:10:16,260
Wie kann das sein dass das kein Memory Leak gibt

1566
01:10:16,260 --> 01:10:18,260
Warum das .NET nicht freeen können soll

1567
01:10:18,260 --> 01:10:20,260
Weil .NET nicht zuständig ist dafür

1568
01:10:20,260 --> 01:10:22,260
Das zu freeen

1569
01:10:22,260 --> 01:10:24,260
Woher möchte .NET wissen

1570
01:10:24,260 --> 01:10:26,260
An der Stelle

1571
01:10:26,260 --> 01:10:28,260
Dass ich den eigentlichen Pointer auf dem das passiert

1572
01:10:28,260 --> 01:10:30,260
Das im Ursprungsprogramm nicht mehr verwende

1573
01:10:30,260 --> 01:10:32,260
Wenn ich das selbst

1574
01:10:32,260 --> 01:10:34,260
Aufrufen würde dann ist okay

1575
01:10:34,260 --> 01:10:36,260
Aber dass das

1576
01:10:36,260 --> 01:10:38,260
Automatisch freed wird

1577
01:10:38,260 --> 01:10:42,270
Ergibt eigentlich keinen Sinn

1578
01:10:42,270 --> 01:10:44,270
Aber anscheinend

1579
01:10:44,270 --> 01:10:46,270
Anscheinend funktioniert

1580
01:10:46,270 --> 01:10:54,450
Das

1581
01:10:54,450 --> 01:10:57,820
Also das ist

1582
01:10:57,820 --> 01:10:59,820
Mache ich irgendwas falsch

1583
01:10:59,820 --> 01:11:01,820
Interop

1584
01:11:01,820 --> 01:11:03,820
Hall

1585
01:11:03,820 --> 01:11:14,210
Go

1586
01:11:14,210 --> 01:11:16,210
Nö

1587
01:11:16,210 --> 01:11:18,210
Wir müssen mal kurz was checken

1588
01:11:18,210 --> 01:11:20,210
Steht da überhaupt was drin

1589
01:11:20,210 --> 01:11:22,210
Session

1590
01:11:22,210 --> 01:11:24,210
Name

1591
01:11:24,210 --> 01:11:31,420
Ja

1592
01:11:31,420 --> 01:11:33,420
Ich bin Leute

1593
01:11:33,420 --> 01:11:35,420
Ich bin hochgradig verwirrt

1594
01:11:35,420 --> 01:11:37,420
Kann das sein

1595
01:11:37,420 --> 01:11:52,580
Dass das einfach rausoptimiert wird

1596
01:11:52,580 --> 01:11:54,580
Ich bin echt

1597
01:11:54,580 --> 01:11:56,580
Verwirrt und begeistert

1598
01:11:56,580 --> 01:11:58,580
Gleichzeitig dass es wohl anscheinend

1599
01:11:58,580 --> 01:12:00,580
Memory Leak

1600
01:12:00,580 --> 01:12:02,580
Ergibt

1601
01:12:02,580 --> 01:12:04,580
Können wir das hier nicht mit dem Debugger starten

1602
01:12:04,580 --> 01:12:06,580
Und sehen dann die RAM Auslastung

1603
01:12:06,580 --> 01:12:08,580
Also in Visual Studio gibt es

1604
01:12:08,580 --> 01:12:10,580
In Visual Studio gibt es einen Debugger mit RAM Auslastung

1605
01:12:10,580 --> 01:12:12,580
Ich weiß nicht wie das hier in

1606
01:12:12,580 --> 01:12:18,260
In Rider aussieht

1607
01:12:18,260 --> 01:12:26,940
Was

1608
01:12:26,940 --> 01:12:42,670
Was genau möchte Rider von mir

1609
01:12:42,670 --> 01:12:46,620
Wo ist das Problem

1610
01:12:46,620 --> 01:12:54,610
Ach hier

1611
01:12:54,610 --> 01:13:05,660
Hey Rider was willst du von mir

1612
01:13:05,660 --> 01:13:07,660
Was hat der für Schmerzen

1613
01:13:07,660 --> 01:13:09,660
Der weiß doch wo mein .NET Zeug liegt

1614
01:13:09,660 --> 01:13:16,750
Keine Ahnung

1615
01:13:16,750 --> 01:13:29,340
Also ich würde gerne

1616
01:13:29,340 --> 01:13:31,340
Das kann man

1617
01:13:31,340 --> 01:13:33,340
Das muss doch hier irgendwie funktionieren

1618
01:13:33,340 --> 01:13:35,340
Benchmark

1619
01:13:35,340 --> 01:13:37,340
Wo ist das Problem

1620
01:13:37,340 --> 01:13:39,340
Ja richtig Runtime korrekt

1621
01:13:39,340 --> 01:13:42,720
Exec Path korrekt

1622
01:13:42,720 --> 01:13:49,970
Der

1623
01:13:49,970 --> 01:13:51,970
Ja aber das hier ist doch .NET 8

1624
01:13:51,970 --> 01:13:58,100
Stimmt doch eigentlich

1625
01:13:58,100 --> 01:14:00,100
Jaja der ruft das nicht

1626
01:14:00,100 --> 01:14:02,100
Mit dem richtigen

1627
01:14:02,100 --> 01:14:04,100
Mit der richtigen

1628
01:14:04,100 --> 01:14:06,100
.NET Installation auf

1629
01:14:06,100 --> 01:14:08,100
Was aber äußerst pepega ist

1630
01:14:08,100 --> 01:14:14,930
Weil hier checkt das

1631
01:14:14,930 --> 01:14:19,140
Hier checkt das

1632
01:14:19,140 --> 01:14:21,140
Da ist irgendwas falsch

1633
01:14:21,140 --> 01:14:28,420
Jaja

1634
01:14:28,420 --> 01:14:30,420
Der benutzt meine System Runtime

1635
01:14:30,420 --> 01:14:32,420
Was aber keinen Sinn ergibt

1636
01:14:32,420 --> 01:14:34,420
Weil ich überall hier

1637
01:14:34,420 --> 01:14:36,420
Überall hier das richtige eingestellt ist

1638
01:14:36,420 --> 01:14:42,100
Auch hier 8 guck

1639
01:14:42,100 --> 01:14:44,100
Ich glaub irgendwie das bugt rum

1640
01:14:44,100 --> 01:14:46,100
Ok

1641
01:14:46,100 --> 01:14:48,100
Wir probieren jetzt mal was anderes

1642
01:14:48,100 --> 01:14:50,100
Nur um sicherzustellen dass das irgendwie an mir liegt

1643
01:14:50,100 --> 01:14:52,100
Und zwar

1644
01:14:52,100 --> 01:14:54,100
Guck mal was wir jetzt machen

1645
01:14:54,100 --> 01:14:56,100
Das hier ist jetzt einfach kein String

1646
01:14:56,100 --> 01:14:58,100
Sondern ein Inpointer

1647
01:14:58,100 --> 01:15:00,100
Und spätestens jetzt sollte er es ja nicht aufräumen

1648
01:15:00,100 --> 01:15:02,100
So mal gucken ob es jetzt Memory Leaks gibt

1649
01:15:02,100 --> 01:15:15,520
Also ich würde sagen

1650
01:15:15,520 --> 01:15:32,140
Es gibt Memory Leaks

1651
01:15:32,140 --> 01:15:37,380
Jaja

1652
01:15:37,380 --> 01:15:39,380
Guck das geht

1653
01:15:39,380 --> 01:15:44,420
Das geht steil

1654
01:15:44,420 --> 01:15:48,560
Also im Inpointer gibt es Memory Leaks

1655
01:15:48,560 --> 01:15:50,560
Aber wenn es ein String ist

1656
01:15:50,560 --> 01:15:52,560
Dann gibt das

1657
01:15:52,560 --> 01:15:54,560
Automatisch frei geben kann

1658
01:15:54,560 --> 01:16:01,840
Das ergibt für mich eigentlich überhaupt keinen Sinn

1659
01:16:01,840 --> 01:16:03,840
Ne guck mal im String checkt er das

1660
01:16:03,840 --> 01:16:05,840
Ich hab keine Ahnung wie

1661
01:16:05,840 --> 01:16:07,840
Warum die Runtime so 6 Header ist

1662
01:16:07,840 --> 01:16:09,840
Aber

1663
01:16:09,840 --> 01:16:11,840
Wenn man ihm sagt es ist ein String

1664
01:16:11,840 --> 01:16:13,840
Dann freet er das automatisch

1665
01:16:13,840 --> 01:16:15,840
Ich bin begeistert

1666
01:16:15,840 --> 01:16:17,840
Ich hätte nicht damit gerechnet

1667
01:16:17,840 --> 01:16:23,650
Dass das .NET so schlau ist

1668
01:16:23,650 --> 01:16:25,650
Und das kapiert

1669
01:16:25,650 --> 01:16:27,650
Macht der da unter der Haube irgendwie einen Free drauf

1670
01:16:27,650 --> 01:16:29,650
Aber woher weiß er überhaupt

1671
01:16:29,650 --> 01:16:31,650
Also das finde ich äußerst

1672
01:16:31,650 --> 01:16:33,650
Spannend

1673
01:16:33,650 --> 01:16:37,790
Dass das funktioniert

1674
01:16:37,790 --> 01:16:39,790
Der checkt das

1675
01:16:39,790 --> 01:16:41,790
Hätte ich nicht gedacht

1676
01:16:41,790 --> 01:16:43,790
Ich hätte gedacht ich muss das von Hand machen

1677
01:16:43,790 --> 01:16:47,300
Also das ist schlau

1678
01:16:47,300 --> 01:16:49,300
Also das ist von der Runtime wirklich schlau

1679
01:16:49,300 --> 01:16:51,300
Dass der den String hier automatisch freeen kann

1680
01:16:51,300 --> 01:16:53,300
Das Ding ist nur

1681
01:16:53,300 --> 01:16:55,300
Das Ding ist nur

1682
01:16:55,300 --> 01:16:57,300
Das eigentlich er das

1683
01:16:57,300 --> 01:16:59,300
Eher nicht machen sollte

1684
01:16:59,300 --> 01:17:01,300
Weil

1685
01:17:01,300 --> 01:17:03,300
Er hat keine Ahnung

1686
01:17:03,300 --> 01:17:05,300
Was ich verwende

1687
01:17:05,300 --> 01:17:07,300
Zum Beispiel machen wir doch mal was

1688
01:17:07,300 --> 01:17:09,300
Machen wir mal folgendes

1689
01:17:09,300 --> 01:17:11,300
Machen wir mal hier

1690
01:17:11,300 --> 01:17:14,670
Das muss man jetzt mit war machen

1691
01:17:14,670 --> 01:17:20,480
Irgendwie so

1692
01:17:20,480 --> 01:17:24,750
Und der wird jetzt gefreed

1693
01:17:24,750 --> 01:17:26,750
Wobei ne dann ist er wahrscheinlich so schlau

1694
01:17:26,750 --> 01:17:28,750
Das ist eine gute Frage

1695
01:17:28,750 --> 01:17:36,540
Aha

1696
01:17:36,540 --> 01:17:38,540
Entdeckt

1697
01:17:38,540 --> 01:17:40,540
Exposed

1698
01:17:40,540 --> 01:17:42,540
Ja

1699
01:17:42,540 --> 01:17:44,540
Die Runtime ist so schlau

1700
01:17:44,540 --> 01:17:46,540
Und ruft wirklich free unter der Haube auf

1701
01:17:46,540 --> 01:17:48,540
Für den

1702
01:17:48,540 --> 01:17:50,540
Pointer den sie kriegt

1703
01:17:50,540 --> 01:17:52,540
Hä

1704
01:17:52,540 --> 01:17:54,540
Das hätte ich

1705
01:17:54,540 --> 01:17:56,540
Nicht gedacht

1706
01:17:56,540 --> 01:17:58,540
Aber da sieht man auch schon

1707
01:17:58,540 --> 01:18:00,540
Das kann echt zu Problemen führen

1708
01:18:00,540 --> 01:18:02,540
Wenn ich den String noch weiter verwende

1709
01:18:02,540 --> 01:18:04,540
In dem drunterliegenden Go Programm

1710
01:18:04,540 --> 01:18:06,540
Ich bin mir nicht so sicher

1711
01:18:06,540 --> 01:18:08,540
Ob das ein sinnvolles Default Verhalten ist

1712
01:18:08,540 --> 01:18:10,540
Dass das immer automatisch

1713
01:18:10,540 --> 01:18:12,540
Den Pointer freeet

1714
01:18:12,540 --> 01:18:14,540
Da bin ich mir nicht so sicher

1715
01:18:14,540 --> 01:18:16,540
Wie hast du das rausgefunden

1716
01:18:16,540 --> 01:18:18,540
Indem ich das einfach

1717
01:18:18,540 --> 01:18:20,540
Einmal global angelegt hab den String

1718
01:18:20,540 --> 01:18:22,540
Und immer den gleichen returne

1719
01:18:22,540 --> 01:18:24,540
Und jetzt versucht ihr ihn zum zweiten mal zu freeen

1720
01:18:24,540 --> 01:18:26,540
Und

1721
01:18:26,540 --> 01:18:28,540
Das geht natürlich nicht

1722
01:18:28,540 --> 01:18:30,540
Also ihr habt

1723
01:18:30,540 --> 01:18:32,540
.NET versucht

1724
01:18:32,540 --> 01:18:34,540
Also ich mein okay

1725
01:18:34,540 --> 01:18:36,540
In gewisser Logik hat das

1726
01:18:36,540 --> 01:18:38,540
.NET erkennt wir bekommen nen Character Pointer

1727
01:18:38,540 --> 01:18:40,540
Und

1728
01:18:40,540 --> 01:18:42,540
Wandeln den Character Pointer um

1729
01:18:42,540 --> 01:18:44,540
Kopieren quasi den Inhalt in den .NET String

1730
01:18:44,540 --> 01:18:46,540
Und dann freeen wir den ursprünglichen Pointer

1731
01:18:46,540 --> 01:18:48,540
Das ist aber eigentlich gar nicht so ungefährlich

1732
01:18:48,540 --> 01:18:50,540
Weil .NET

1733
01:18:50,540 --> 01:18:52,540
Weil es das automatisch macht

1734
01:18:52,540 --> 01:18:54,540
Weiß doch überhaupt nicht

1735
01:18:54,540 --> 01:18:56,540
Ob ich den darunterliegenden Character Pointer

1736
01:18:56,540 --> 01:18:58,540
Noch weiter verwende

1737
01:18:58,540 --> 01:19:00,540
Hier beispielsweise

1738
01:19:00,540 --> 01:19:02,540
Also

1739
01:19:02,540 --> 01:19:04,540
Weiß nicht

1740
01:19:04,540 --> 01:19:06,540
Da bin ich

1741
01:19:06,540 --> 01:19:08,540
Da gehe ich nicht so dacor mit

1742
01:19:08,540 --> 01:19:13,070
Was das da macht

1743
01:19:13,070 --> 01:19:17,980
Aber soll mir recht sein

1744
01:19:17,980 --> 01:19:19,980
In dem Fall funzt es einfach ohne mein zutun

1745
01:19:19,980 --> 01:19:24,190
Ja wenn man es nicht direkt als String macht

1746
01:19:24,190 --> 01:19:26,190
Das kann man garantiert unterbinden

1747
01:19:26,190 --> 01:19:28,190
Wir haben es ja gesehen man kann es schon unterbinden

1748
01:19:28,190 --> 01:19:30,190
Indem ich hier einfach nen Inpointer draus mache

1749
01:19:30,190 --> 01:19:32,190
Sobald ich hier nen

1750
01:19:32,190 --> 01:19:34,190
Inpointer draus mache

1751
01:19:34,190 --> 01:19:36,190
Dann wird Memory geleaked as fuck

1752
01:19:36,190 --> 01:19:38,190
Guck

1753
01:19:38,190 --> 01:19:42,140
Ja 700 MB

1754
01:19:42,140 --> 01:19:44,140
960 MB

1755
01:19:44,140 --> 01:19:46,140
1,2 Gig

1756
01:19:46,140 --> 01:19:48,140
1,4 Gig

1757
01:19:48,140 --> 01:19:51,520
1,7 Gig

1758
01:19:51,520 --> 01:19:53,520
Also eigentlich hätte ich damit gerechnet

1759
01:19:53,520 --> 01:19:55,520
Das ich das eh so machen muss

1760
01:19:55,520 --> 01:19:57,520
Das ich den Pointer selbst deserialisieren

1761
01:19:57,520 --> 01:19:59,520
Und dann freeen

1762
01:19:59,520 --> 01:20:01,520
Also eigentlich dachte ich

1763
01:20:01,520 --> 01:20:03,520
Ich muss sowas hier machen sinngemäß

1764
01:20:03,520 --> 01:20:06,900
Session

1765
01:20:06,900 --> 01:20:08,900
Inpoint

1766
01:20:08,900 --> 01:20:10,900
Das ist ja im Prinzip nur nen Pointer

1767
01:20:10,900 --> 01:20:12,900
An die Stelle wo das Character Array steht

1768
01:20:12,900 --> 01:20:14,900
So und ich dachte mir

1769
01:20:14,900 --> 01:20:16,900
Ich muss da jetzt sowas hier machen

1770
01:20:16,900 --> 01:20:18,900
Zum Beispiel

1771
01:20:18,900 --> 01:20:20,900
UTF-8

1772
01:20:20,900 --> 01:20:22,900
Pointer to String UTF-8

1773
01:20:22,900 --> 01:20:32,420
Client Name

1774
01:20:32,420 --> 01:20:34,420
So wenn ich das mache sollte es auch Memory Leaks geben

1775
01:20:34,420 --> 01:20:36,420
Achso

1776
01:20:36,420 --> 01:20:38,420
Semicolon

1777
01:20:38,420 --> 01:20:42,940
Das sollte auch Memory Leaks geben

1778
01:20:42,940 --> 01:20:44,940
Ja ja ja fette fette Memory Leaks

1779
01:20:44,940 --> 01:20:46,940
250 MB

1780
01:20:46,940 --> 01:20:48,940
Memory Leak pro Sekunde

1781
01:20:48,940 --> 01:20:50,940
Ja so und jetzt dachte ich eigentlich

1782
01:20:50,940 --> 01:20:52,940
Ich

1783
01:20:52,940 --> 01:20:54,940
Kopiere mir das hier in .NET String

1784
01:20:54,940 --> 01:20:56,940
Und danach sage ich

1785
01:20:56,940 --> 01:20:58,940
Native Memory Free

1786
01:20:58,940 --> 01:21:00,940
Das ist was neues

1787
01:21:00,940 --> 01:21:02,940
Das gibt es noch nicht so lange in C Sharp

1788
01:21:02,940 --> 01:21:04,940
Das ist um die Standard

1789
01:21:04,940 --> 01:21:06,940
C Free Funktion aufzurufen in der Hoffnung

1790
01:21:06,940 --> 01:21:08,940
Dass der Code von dem ich den Pointer bekomme

1791
01:21:08,940 --> 01:21:10,940
Das mit der Standard C Free

1792
01:21:10,940 --> 01:21:12,940
Geschichte

1793
01:21:12,940 --> 01:21:14,940
Mit der Standard C Alloc

1794
01:21:14,940 --> 01:21:16,940
Geschichte allockiert hat

1795
01:21:16,940 --> 01:21:18,940
Den Speicher

1796
01:21:18,940 --> 01:21:20,940
Also hoffen wir einfach mal

1797
01:21:20,940 --> 01:21:22,940
Und jetzt sagen wir hier Session Client Name

1798
01:21:22,940 --> 01:21:24,940
Und jetzt sollte ich

1799
01:21:24,940 --> 01:21:26,940
Warum nicht

1800
01:21:26,940 --> 01:21:32,180
Ach unsave

1801
01:21:32,180 --> 01:21:34,180
Geht nicht weil

1802
01:21:34,180 --> 01:21:36,180
Muss ein Void Pointer sein

1803
01:21:36,180 --> 01:21:38,180
Ok

1804
01:21:38,180 --> 01:21:40,180
Jetzt sollte ich auch keine Memory Leaks mehr haben

1805
01:21:40,180 --> 01:21:42,180
Weil jetzt mache ich das von Hand

1806
01:21:42,180 --> 01:21:44,180
Ich schnappe mir den Pointer

1807
01:21:44,180 --> 01:21:46,180
Kopiere den in .NET String

1808
01:21:46,180 --> 01:21:48,180
Und dann Free ich den Pointer

1809
01:21:48,180 --> 01:21:51,940
So müsste das eigentlich sein

1810
01:21:51,940 --> 01:21:53,940
Und siehe da es gibt auch keine Memory Leaks mehr

1811
01:21:53,940 --> 01:22:00,260
Also das macht anscheinend

1812
01:22:00,260 --> 01:22:02,260
Ernsthaft .NET unter der Haube

1813
01:22:02,260 --> 01:22:04,260
Das finde ich ehrlich gesagt

1814
01:22:04,260 --> 01:22:08,460
Ein bisschen

1815
01:22:08,460 --> 01:22:14,080
Merkwürdig

1816
01:22:14,080 --> 01:22:25,650
Das es das macht

1817
01:22:25,650 --> 01:22:27,650
Sehr komisch

1818
01:22:27,650 --> 01:22:29,650
Wir probieren nochmal was

1819
01:22:29,650 --> 01:22:31,650
Wir machen jetzt hier nochmal einen String draus

1820
01:22:31,650 --> 01:22:33,650
Und dann machen wir das was der Chat sagt

1821
01:22:33,650 --> 01:22:35,650
Das interessiert mich nämlich echt

1822
01:22:35,650 --> 01:22:40,430
S

1823
01:22:40,430 --> 01:22:42,430
Unmanaged

1824
01:22:42,430 --> 01:22:44,430
Unmanaged Type nicht Bool

1825
01:22:44,430 --> 01:22:46,430
Äh

1826
01:22:46,430 --> 01:22:48,430
Char

1827
01:22:48,430 --> 01:22:50,430
Ne Moment was gibt es denn da überhaupt

1828
01:22:50,430 --> 01:22:52,430
Str

1829
01:22:52,430 --> 01:22:54,430
Oh das ist Windows Shit

1830
01:22:54,430 --> 01:22:56,430
LP String

1831
01:22:56,430 --> 01:22:58,430
A Single By 0 Terminated on the Character Single

1832
01:22:58,430 --> 01:23:02,260
Dann haben wir

1833
01:23:02,260 --> 01:23:04,260
LPT String

1834
01:23:04,260 --> 01:23:06,260
Unicode Character String

1835
01:23:06,260 --> 01:23:12,190
What

1836
01:23:12,190 --> 01:23:14,190
LPW String

1837
01:23:14,190 --> 01:23:16,190
2 Byte

1838
01:23:16,190 --> 01:23:26,160
Alles klar

1839
01:23:26,160 --> 01:23:32,030
B String

1840
01:23:32,030 --> 01:23:34,030
BVAL T String

1841
01:23:34,030 --> 01:23:36,030
Alter Microsoft es ist ja gut

1842
01:23:36,030 --> 01:23:38,030
Man übertreibt es halt nicht

1843
01:23:38,030 --> 01:23:40,030
LP

1844
01:23:40,030 --> 01:23:42,030
UTF8 String

1845
01:23:42,030 --> 01:23:44,030
A Pointer to UTF8 Encoder String

1846
01:23:44,030 --> 01:23:46,030
Okay das klingt

1847
01:23:46,030 --> 01:23:48,030
Das klingt schonmal ganz gut

1848
01:23:48,030 --> 01:23:50,030
Way to dank

1849
01:23:50,030 --> 01:23:54,240
Auch keine Memory

1850
01:23:54,240 --> 01:23:56,240
Okay das muss man wissen

1851
01:23:56,240 --> 01:23:58,240
Das muss man echt wissen

1852
01:23:58,240 --> 01:24:06,670
Das

1853
01:24:06,670 --> 01:24:08,670
Das es ein automatisches Free macht

1854
01:24:08,670 --> 01:24:13,260
Weiß nicht nach was ich suchen muss

1855
01:24:13,260 --> 01:24:17,600
Das ist interessant

1856
01:24:17,600 --> 01:24:19,600
Also

1857
01:24:19,600 --> 01:24:21,600
Damit hätte ich nicht gerechnet

1858
01:24:21,600 --> 01:24:23,600
Guck kein

1859
01:24:23,600 --> 01:24:27,300
Memory Leak

1860
01:24:27,300 --> 01:24:29,300
Das muss man in dem Fall wirklich wissen

1861
01:24:29,300 --> 01:24:31,300
Weil damit rechnet man eigentlich nicht

1862
01:24:31,300 --> 01:24:33,300
Gut also hätten wir den Part ich muss sagen

1863
01:24:33,300 --> 01:24:35,300
Das ging einfacher als gedacht

1864
01:24:35,300 --> 01:24:37,300
Jetzt benchmarken wir das ganze mal

1865
01:24:37,300 --> 01:24:39,300
So auf die schnelle

1866
01:24:39,300 --> 01:24:41,300
Wir können danach noch ein ordentliches

1867
01:24:41,300 --> 01:24:43,300
Benchmark dot net Projekt drum rum machen

1868
01:24:43,300 --> 01:24:45,300
Um das beides zu vergleichen

1869
01:24:45,300 --> 01:24:47,300
Aber

1870
01:24:47,300 --> 01:24:49,300
Probieren wir das mal aus

1871
01:24:49,300 --> 01:24:51,300
Übrigens das da

1872
01:24:51,300 --> 01:24:53,300
Auch PPGar

1873
01:24:53,300 --> 01:24:55,300
Das hier soll eigentlich die Funktion sein

1874
01:24:55,300 --> 01:24:57,300
Die nichts returnt

1875
01:24:57,300 --> 01:24:59,300
Und Go Call 2 soll die Funktion sein

1876
01:24:59,300 --> 01:25:04,210
Die was returnt

1877
01:25:04,210 --> 01:25:06,210
Sonst wird das nix

1878
01:25:06,210 --> 01:25:08,210
Jetzt müssen wir das hier anlegen

1879
01:25:08,210 --> 01:25:10,210
Interop

1880
01:25:10,210 --> 01:25:12,210
Kopieren wir das mal Call Go 2

1881
01:25:12,210 --> 01:25:14,210
Und Call Go ist einfach nur Void

1882
01:25:14,210 --> 01:25:16,210
Okay

1883
01:25:16,210 --> 01:25:18,210
Jetzt benchmarken wir das ganze mal

1884
01:25:18,210 --> 01:25:20,210
Ganz kurz

1885
01:25:20,210 --> 01:25:22,210
Auf die Schnelle also

1886
01:25:22,210 --> 01:25:24,210
Stop Watch

1887
01:25:24,210 --> 01:25:28,220
Start

1888
01:25:28,220 --> 01:25:30,220
Okay aus irgendwelchen Stunden

1889
01:25:30,220 --> 01:25:32,220
Alter aus irgendwelchen Gründen funzt mein

1890
01:25:32,220 --> 01:25:34,220
Console Rightline Makro nicht

1891
01:25:34,220 --> 01:25:36,220
Elapsed

1892
01:25:36,220 --> 01:25:38,220
Total

1893
01:25:38,220 --> 01:25:40,220
30 Seconds

1894
01:25:40,220 --> 01:25:42,220
Stop Watch Stop

1895
01:25:42,220 --> 01:25:44,220
Und hier darunter hier dazwischen rufen wir mal auf

1896
01:25:44,220 --> 01:25:46,220
Interop

1897
01:25:46,220 --> 01:25:48,220
So das hier sollte so gering sein

1898
01:25:48,220 --> 01:25:50,220
Ein einfacher Function Call das das gar nicht auffällt

1899
01:25:50,220 --> 01:25:52,220
Im Endeffekt ja

1900
01:25:52,220 --> 01:25:54,220
Das ist jetzt weil er zum ersten mal aufgerufen wird

1901
01:25:54,220 --> 01:25:56,220
Da wird ja nix drauf geben

1902
01:25:56,220 --> 01:25:58,220
Wir machen da mal ne Schleife drum

1903
01:25:58,220 --> 01:26:00,220
So machen wir mal

1904
01:26:00,220 --> 01:26:02,220
100 Aufrufe davon

1905
01:26:02,220 --> 01:26:04,220
Und gucken wie schnell das ist

1906
01:26:04,220 --> 01:26:06,220
Und einmal rufen wir es vor der Stop Watch auf

1907
01:26:06,220 --> 01:26:11,070
Damit es nicht mitgezählt wird

1908
01:26:11,070 --> 01:26:13,070
Wo bist du überrascht das es Pointer gibt

1909
01:26:13,070 --> 01:26:16,510
Okay ja das ist sehr schnell jetzt

1910
01:26:16,510 --> 01:26:22,060
Gibt es in C Sharp auch

1911
01:26:22,060 --> 01:26:24,060
Einen Typ für String Pointer

1912
01:26:24,060 --> 01:26:26,060
Ähm in

1913
01:26:26,060 --> 01:26:28,060
In C Sharp sind Strings immer Pointer

1914
01:26:28,060 --> 01:26:30,060
String ist ein

1915
01:26:30,060 --> 01:26:36,190
Raph Type

1916
01:26:36,190 --> 01:26:38,190
In C Sharp ist ein String unter der Haube immer ein Pointer

1917
01:26:38,190 --> 01:26:40,190
Ohne das du explizit

1918
01:26:40,190 --> 01:26:42,190
Was hinschreibst

1919
01:26:42,190 --> 01:26:44,190
In C Sharp ist eigentlich 90% der Sachen

1920
01:26:44,190 --> 01:26:46,190
Die du verwendest Pointer

1921
01:26:46,190 --> 01:26:48,190
Ohne Pointer Syntax

1922
01:26:48,190 --> 01:26:59,060
Ich glaube er meint aber über der

1923
01:26:59,060 --> 01:27:13,820
Was wie jetzt

1924
01:27:13,820 --> 01:27:15,820
Achso ne das ist jetzt in dem Falle

1925
01:27:15,820 --> 01:27:17,820
Von Interop mit wirklich

1926
01:27:17,820 --> 01:27:19,820
Raw C Pointer

1927
01:27:19,820 --> 01:27:21,820
Zu Managed String Objekten

1928
01:27:21,820 --> 01:27:23,820
Damit geht er echt nicht so um wie erwartet

1929
01:27:23,820 --> 01:27:30,080
Ja das

1930
01:27:30,080 --> 01:27:32,080
Als dumm gibts das nur wenn ich anscheinend

1931
01:27:32,080 --> 01:27:34,080
Nicht explizit sage

1932
01:27:34,080 --> 01:27:36,080
Was ich vermute was hier passiert

1933
01:27:36,080 --> 01:27:38,080
Sobald ich hier hinschreibe

1934
01:27:38,080 --> 01:27:40,080
Sobald ich hier hinschreibe

1935
01:27:40,080 --> 01:27:42,080
String dann checkt er

1936
01:27:42,080 --> 01:27:44,080
Wenn das ein

1937
01:27:44,080 --> 01:27:46,080
Oder

1938
01:27:46,080 --> 01:27:48,080
Dann erwartet er einen Character Pointer

1939
01:27:48,080 --> 01:27:50,080
Kopiert sich

1940
01:27:50,080 --> 01:27:52,080
Den bis zu einem Null

1941
01:27:52,080 --> 01:27:54,080
Terminator in einen .NET String

1942
01:27:54,080 --> 01:27:56,080
Und macht dann einen Free auf den ursprünglichen

1943
01:27:56,080 --> 01:27:58,080
Pointer

1944
01:27:58,080 --> 01:28:00,080
Das ist Ultra Magic unter der Haube

1945
01:28:00,080 --> 01:28:03,970
Was da passiert

1946
01:28:03,970 --> 01:28:05,970
Und wenn du das nicht haben willst

1947
01:28:05,970 --> 01:28:07,970
Dann musst du einfach sagen mach kein String draus

1948
01:28:07,970 --> 01:28:09,970
Sondern nimm den Raw Pointer

1949
01:28:09,970 --> 01:28:11,970
Und dann kannst du den selbst auslesen und freen

1950
01:28:11,970 --> 01:28:13,970
Das muss ich echt sagen

1951
01:28:13,970 --> 01:28:17,280
Wenn du das in dumm haben willst

1952
01:28:17,280 --> 01:28:19,280
Okay dann was du machen kannst ist

1953
01:28:19,280 --> 01:28:21,280
Ach das meinst du

1954
01:28:21,280 --> 01:28:23,280
Du kannst auch sowas machen

1955
01:28:23,280 --> 01:28:25,280
Das funktioniert auch

1956
01:28:25,280 --> 01:28:27,280
Unsafe Character Pointer

1957
01:28:27,280 --> 01:28:29,280
Das funktioniert auch

1958
01:28:29,280 --> 01:28:31,280
Moment

1959
01:28:31,280 --> 01:28:33,280
Haha

1960
01:28:33,280 --> 01:28:35,280
Nein das ist nicht das gleiche

1961
01:28:35,280 --> 01:28:37,280
Du musst einen Byte Pointer

1962
01:28:37,280 --> 01:28:39,280
Pointer auf Start von einem Byte Array setzen

1963
01:28:39,280 --> 01:28:41,280
Weil

1964
01:28:41,280 --> 01:28:43,280
Das ist auch ein bisschen Verarschung

1965
01:28:43,280 --> 01:28:45,280
Da müssten wir aufpassen

1966
01:28:45,280 --> 01:28:47,280
Wenn man einen Character Pointer macht

1967
01:28:47,280 --> 01:28:49,280
In C Sharp ist das nicht das gleiche

1968
01:28:49,280 --> 01:28:51,280
Wie ein Character Pointer in C

1969
01:28:51,280 --> 01:28:53,280
Und ein Byte ist in C das gleiche

1970
01:28:53,280 --> 01:28:55,280
In C Sharp ist ein Character 2 Byte

1971
01:28:55,280 --> 01:28:57,280
Weil

1972
01:28:57,280 --> 01:28:59,280
C Sharp Strings intern als UTF 16 speichert

1973
01:28:59,280 --> 01:29:01,280
Deswegen ist quasi

1974
01:29:01,280 --> 01:29:03,280
In C

1975
01:29:03,280 --> 01:29:05,280
In C ist das da

1976
01:29:05,280 --> 01:29:07,280
Quasi mehr oder weniger

1977
01:29:07,280 --> 01:29:09,280
Das gleiche wie das da

1978
01:29:09,280 --> 01:29:11,280
Und das da auch in C Sharp

1979
01:29:11,280 --> 01:29:13,280
Aber in C Sharp ist Character Pointer was anderes

1980
01:29:13,280 --> 01:29:15,280
Also das könntest du auch machen

1981
01:29:15,280 --> 01:29:17,280
Das geht allerdings nur mit Unsafe davor

1982
01:29:17,280 --> 01:29:19,280
Weil sobald du Pointer Magic machst

1983
01:29:19,280 --> 01:29:21,280
Sagt C Sharp

1984
01:29:21,280 --> 01:29:23,280
Könnt auch in die Hose gehen

1985
01:29:23,280 --> 01:29:25,280
Aber muss man in dem Fall gar nicht

1986
01:29:25,280 --> 01:29:27,280
Weil tatsächlich die Managed Implementierung

1987
01:29:27,280 --> 01:29:29,280
Von diesem

1988
01:29:29,280 --> 01:29:31,280
Also unter der Haube machen die schon das richtige

1989
01:29:31,280 --> 01:29:33,280
In dem einen Fall

1990
01:29:33,280 --> 01:29:35,280
Ja

1991
01:29:35,280 --> 01:29:37,280
Umwandeln, kopieren in den .NET String

1992
01:29:37,280 --> 01:29:39,280
Und da unten drunter Free Callen

1993
01:29:39,280 --> 01:29:41,280
Das ist schon sehr Magic mäßig

1994
01:29:41,280 --> 01:29:46,510
Ne ne das ist egal

1995
01:29:46,510 --> 01:29:48,510
Unter der Haube ist das alles das gleiche

1996
01:29:48,510 --> 01:29:50,510
Die Interpretation

1997
01:29:50,510 --> 01:29:52,510
Der Daten ist dann ein bisschen anders

1998
01:29:52,510 --> 01:29:54,510
Zum Beispiel das du bei einem

1999
01:29:54,510 --> 01:29:59,170
Byte

2000
01:29:59,170 --> 01:30:01,170
Kein Minus drinstehen haben kannst

2001
01:30:01,170 --> 01:30:03,170
Aber bei einem S Byte

2002
01:30:03,170 --> 01:30:05,170
Bei einem signed Byte

2003
01:30:05,170 --> 01:30:07,170
Aber das ist reine Interpretationsfrage

2004
01:30:07,170 --> 01:30:09,170
Es ist alles in C

2005
01:30:09,170 --> 01:30:11,170
Ein Byte

2006
01:30:11,170 --> 01:30:13,170
Egal ob es ein Character ein Byte

2007
01:30:13,170 --> 01:30:15,170
Ne ein Short ist 16 glaube ich

2008
01:30:15,170 --> 01:30:17,170
Ist ein Short nicht in C 2 Byte

2009
01:30:17,170 --> 01:30:19,170
Also

2010
01:30:19,170 --> 01:30:21,170
1 bis 16.000 noch etwas

2011
01:30:21,170 --> 01:30:23,170
Da bin ich mir jetzt aus dem Kopf nicht sicher

2012
01:30:23,170 --> 01:30:25,170
So

2013
01:30:25,170 --> 01:30:28,860
Aber jetzt haben wir uns

2014
01:30:28,860 --> 01:30:30,860
Jetzt haben wir uns etwas

2015
01:30:30,860 --> 01:30:32,860
Side Tracken lassen

2016
01:30:32,860 --> 01:30:34,860
Anscheinend ist .NET mittlerweile so

2017
01:30:34,860 --> 01:30:36,860
Five Head schlau

2018
01:30:36,860 --> 01:30:38,860
Das ist wenn man so komische Dinger

2019
01:30:38,860 --> 01:30:40,860
Macht wie ich

2020
01:30:40,860 --> 01:30:42,860
Von denen ich nicht geahnt hätte

2021
01:30:42,860 --> 01:30:44,860
Dass sie funktionieren

2022
01:30:44,860 --> 01:30:46,860
Tatsächlich funktioniert

2023
01:30:46,860 --> 01:30:48,860
Ohne Memory Leaks zu verursachen

2024
01:30:48,860 --> 01:30:50,860
Das hätte ich wirklich nicht gedacht

2025
01:30:50,860 --> 01:30:52,860
Ok

2026
01:30:52,860 --> 01:30:54,860
Jetzt wollte ich das mal ganz kurz Benchmarken

2027
01:30:54,860 --> 01:31:03,620
Wie schnell ist denn das ganze

2028
01:31:03,620 --> 01:31:05,620
Ok ein paar Nanosekunden

2029
01:31:05,620 --> 01:31:07,620
Aber 100 ist ja auch nichts

2030
01:31:07,620 --> 01:31:09,620
Machen wir mal 1000

2031
01:31:09,620 --> 01:31:11,620
Oder machen wir mal eine Million

2032
01:31:11,620 --> 01:31:13,620
Es gibt übrigens ein nice Feature

2033
01:31:13,620 --> 01:31:15,620
Von Seiten Passy Sharp Version

2034
01:31:15,620 --> 01:31:19,440
Kennt ihr das hier

2035
01:31:19,440 --> 01:31:21,440
Das man Underscores in die Zahlen machen kann

2036
01:31:21,440 --> 01:31:23,440
Die eigentlich nichts ändern da dran

2037
01:31:23,440 --> 01:31:25,440
Aber viel viel besser lesbar sind

2038
01:31:25,440 --> 01:31:27,440
Ja jetzt erkennt jeder das hier

2039
01:31:27,440 --> 01:31:29,440
Dass das hier

2040
01:31:29,440 --> 01:31:31,440
Das ist eine Million

2041
01:31:31,440 --> 01:31:33,440
Also das ist quasi 10 Millionen

2042
01:31:33,440 --> 01:31:35,440
Machen wir das mal weg

2043
01:31:35,440 --> 01:31:37,440
Dass das eine Million ist

2044
01:31:37,440 --> 01:31:39,440
Das kann man viel besser lesen

2045
01:31:39,440 --> 01:31:41,440
Man darf übrigens nicht auf die Idee kommen

2046
01:31:41,440 --> 01:31:43,440
So zu versuchen

2047
01:31:43,440 --> 01:31:46,750
Weil dann ist das ein Float

2048
01:31:46,750 --> 01:31:48,750
Beziehungsweise ein Double

2049
01:31:48,750 --> 01:31:50,750
Also mit 2 Punkten geht es dann auch gar nicht

2050
01:31:50,750 --> 01:31:52,750
Aber das hier ist nice

2051
01:31:52,750 --> 01:31:54,750
Das andere wären 10 Millionen gewesen

2052
01:31:54,750 --> 01:31:56,750
Es ist kein Unterschied

2053
01:31:56,750 --> 01:31:58,750
Aber man kann es auch so schreiben

2054
01:31:58,750 --> 01:32:00,750
Das ist ein bisschen pepega

2055
01:32:00,750 --> 01:32:02,750
Aber es würde auch funktionieren

2056
01:32:02,750 --> 01:32:04,750
Oder so oder so

2057
01:32:04,750 --> 01:32:06,750
Aber das macht eigentlich keiner

2058
01:32:06,750 --> 01:32:08,750
Also das finde ich ganz nice

2059
01:32:08,750 --> 01:32:10,750
Dass einfach Underscores in Zahlen ignoriert werden

2060
01:32:10,750 --> 01:32:12,750
So eine Million Aufrufe

2061
01:32:12,750 --> 01:32:14,750
Oh das ist schon recht langsam

2062
01:32:14,750 --> 01:32:16,750
90 Millisekunden

2063
01:32:16,750 --> 01:32:24,290
Für eine Million Function Aufrufe

2064
01:32:24,290 --> 01:32:26,290
Ist das ein Callback Function

2065
01:32:26,290 --> 01:32:28,290
Zu einer Go Funktion

2066
01:32:28,290 --> 01:32:30,290
Das ist kein Callback

2067
01:32:30,290 --> 01:32:32,290
Wir haben eine Funktion in Go

2068
01:32:32,290 --> 01:32:34,290
Und zwar der hier

2069
01:32:34,290 --> 01:32:36,290
Guck

2070
01:32:36,290 --> 01:32:38,290
Wir haben eine leere Funktion in Go

2071
01:32:38,290 --> 01:32:40,290
Die einfach nur Call Go heißt

2072
01:32:40,290 --> 01:32:42,290
Die in die Library reinkompiliert wird

2073
01:32:42,290 --> 01:32:44,290
Die Library wird in .NET

2074
01:32:44,290 --> 01:32:46,290
Geladen

2075
01:32:46,290 --> 01:32:48,290
Definiert dass es darin eine Funktion

2076
01:32:48,290 --> 01:32:50,290
Call Go gibt

2077
01:32:50,290 --> 01:32:56,290
Und dann wird die aufgerufen

2078
01:32:56,290 --> 01:32:58,290
Unter welchen Umständen merkt man das

2079
01:32:58,290 --> 01:33:00,290
Naja ganz ehrlich

2080
01:33:00,290 --> 01:33:02,290
Eine Million Function Calls

2081
01:33:02,290 --> 01:33:04,290
Sind schon ganz schön viel

2082
01:33:04,290 --> 01:33:06,290
Nicht wirklich merken

2083
01:33:06,290 --> 01:33:08,290
Es sei denn

2084
01:33:08,290 --> 01:33:10,290
Man hat wirklich irgendwie so

2085
01:33:10,290 --> 01:33:12,290
Irgendeinen Parser oder so

2086
01:33:12,290 --> 01:33:14,290
Wo das millionenfach aufgerufen wird

2087
01:33:14,290 --> 01:33:16,290
Pro Durchgang

2088
01:33:16,290 --> 01:33:18,290
Dann macht es schon Performance

2089
01:33:18,290 --> 01:33:20,290
Ich zeige euch jetzt mal den Unterschied

2090
01:33:20,290 --> 01:33:22,290
Wir machen jetzt mal eine

2091
01:33:22,290 --> 01:33:24,290
Static

2092
01:33:24,290 --> 01:33:26,290
Public

2093
01:33:26,290 --> 01:33:28,290
Nennen wir es mal

2094
01:33:28,290 --> 01:33:30,290
Call

2095
01:33:30,290 --> 01:33:32,290
.NET

2096
01:33:32,290 --> 01:33:34,290
Nennen wir das jetzt mal

2097
01:33:34,290 --> 01:33:36,290
Also das ist jetzt eine .NET Funktion

2098
01:33:36,290 --> 01:33:38,290
Mix irgendwie über Library

2099
01:33:38,290 --> 01:33:40,290
Ist eine ganz normale .NET Funktion

2100
01:33:40,290 --> 01:33:42,290
Ist das

2101
01:33:42,290 --> 01:33:44,290
Und wenn ich die jetzt mal aufrufe hier

2102
01:33:44,290 --> 01:33:46,290
Call.NET

2103
01:33:46,290 --> 01:33:48,290
Dann werden wir sehen

2104
01:33:48,290 --> 01:33:50,290
Bam 1,2 Millisekunden

2105
01:33:50,290 --> 01:33:52,290
Und mit Release Modus

2106
01:33:52,290 --> 01:33:54,290
Wahrscheinlich sogar noch ein bisschen weniger

2107
01:33:54,290 --> 01:33:56,290
Ja

2108
01:33:56,290 --> 01:33:58,290
Also 500

2109
01:33:58,290 --> 01:34:00,290
Nanosekunden

2110
01:34:00,290 --> 01:34:02,290
Versus

2111
01:34:02,290 --> 01:34:06,110
500 Nanosekunden

2112
01:34:06,110 --> 01:34:08,110
Versus

2113
01:34:08,110 --> 01:34:10,110
80 Millisekunden

2114
01:34:10,110 --> 01:34:12,110
Ok also

2115
01:34:12,110 --> 01:34:14,110
Cinterop ist immer noch nicht das

2116
01:34:14,110 --> 01:34:18,450
Allerschnellste was man machen kann

2117
01:34:18,450 --> 01:34:20,450
Das ist echt lahm

2118
01:34:20,450 --> 01:34:22,450
Das ist wirklich lahm

2119
01:34:22,450 --> 01:34:24,450
80 Millisekunden für eine Million

2120
01:34:24,450 --> 01:34:26,450
Funktionsaufrufe

2121
01:34:26,450 --> 01:34:28,450
Also von .NET nach .NET

2122
01:34:28,450 --> 01:34:30,450
Braucht das ganze

2123
01:34:30,450 --> 01:34:32,450
500 Nanosekunden

2124
01:34:32,450 --> 01:34:34,450
Also hier 0,5 Millisekunden

2125
01:34:34,450 --> 01:34:36,450
Und

2126
01:34:36,450 --> 01:34:38,450
Von .NET nach Go

2127
01:34:38,450 --> 01:34:40,450
80 Millisekunden

2128
01:34:40,450 --> 01:34:42,450
In normalen Anwendungen wo das nicht oft aufgerufen wird

2129
01:34:42,450 --> 01:34:44,450
Ist das überhaupt gar kein Problem

2130
01:34:44,450 --> 01:34:46,450
Ja

2131
01:34:46,450 --> 01:34:48,450
Aber so

2132
01:34:48,450 --> 01:34:50,450
Ist schon ordentlich

2133
01:34:50,450 --> 01:34:52,450
Overhead

2134
01:34:52,450 --> 01:34:54,450
Ich mein selbst bei meiner WebRTC Anwendung

2135
01:34:54,450 --> 01:34:56,450
Wenn man 30 FPS

2136
01:34:56,450 --> 01:34:58,450
Hat pro Kamera

2137
01:34:58,450 --> 01:35:00,450
Und 100 Kameras drin dann sind das 3000

2138
01:35:00,450 --> 01:35:02,450
3000 Function Calls

2139
01:35:02,450 --> 01:35:04,450
Pro

2140
01:35:04,450 --> 01:35:06,450
Sekunde

2141
01:35:06,450 --> 01:35:08,450
Ist halt nix im Endeffekt

2142
01:35:08,450 --> 01:35:10,450
Nix

2143
01:35:10,450 --> 01:35:12,450
Das ist egal ob ich Function

2144
01:35:12,450 --> 01:35:14,450
Ob ich hier C Go Overhead habe

2145
01:35:14,450 --> 01:35:21,470
Das juckt einfach nicht

2146
01:35:21,470 --> 01:35:23,470
Für jeden Function Call einen neuen Thread starten

2147
01:35:23,470 --> 01:35:25,470
Ist vielleicht ein bisschen Overkill

2148
01:35:25,470 --> 01:35:27,470
Aber das würde

2149
01:35:27,470 --> 01:35:29,470
Zumindest teilweise die ganze Sache

2150
01:35:29,470 --> 01:35:34,190
Schneller machen

2151
01:35:34,190 --> 01:35:36,190
Also besser parallel

2152
01:35:36,190 --> 01:35:40,850
Also es ist schon

2153
01:35:40,850 --> 01:35:42,850
Ja

2154
01:35:42,850 --> 01:35:46,800
Schon ein bisschen langsamer

2155
01:35:46,800 --> 01:35:48,800
Ich glaube in dem Fall macht .NET gar nicht

2156
01:35:48,800 --> 01:35:50,800
Magie sondern es ist eher Go was die Magie macht

2157
01:35:50,800 --> 01:35:52,800
.NET macht in dem Fall

2158
01:35:52,800 --> 01:35:54,800
Ein relativ straight

2159
01:35:54,800 --> 01:35:56,800
Call wie man halt eine C Funktion

2160
01:35:56,800 --> 01:35:58,800
Callt bisschen Magic

2161
01:35:58,800 --> 01:36:00,800
Bestimmt aber Go macht halt extrem

2162
01:36:00,800 --> 01:36:02,800
Viel Magic für ihren Thread

2163
01:36:02,800 --> 01:36:04,800
Und Runtime Scheduler

2164
01:36:04,800 --> 01:36:06,800
Das sich das nicht in die Quere kommt

2165
01:36:06,800 --> 01:36:08,800
Also C Go ist

2166
01:36:08,800 --> 01:36:10,800
Berüchtigt oder Go ist berüchtigt dafür

2167
01:36:10,800 --> 01:36:12,800
Das der Interop mit anderen Sprachen

2168
01:36:12,800 --> 01:36:29,170
Echt langsam ist

2169
01:36:29,170 --> 01:36:31,170
Du hast Recht du hast Recht

2170
01:36:31,170 --> 01:36:33,170
Deswegen machen wir das jetzt mal

2171
01:36:33,170 --> 01:36:35,170
Im Debug Modus

2172
01:36:35,170 --> 01:36:37,170
Du hast Recht

2173
01:36:37,170 --> 01:36:39,170
Also im Debug Modus brauchen wir ungefähr

2174
01:36:39,170 --> 01:36:41,170
82 Millisekunden 85 Millisekunden

2175
01:36:41,170 --> 01:36:43,170
Go und Call .NET

2176
01:36:43,170 --> 01:36:45,170
Brauchen wir

2177
01:36:45,170 --> 01:36:47,170
Eine Millisekunde

2178
01:36:47,170 --> 01:36:49,170
Ja du hast Recht

2179
01:36:49,170 --> 01:36:51,170
Das könnte durchaus sein

2180
01:36:51,170 --> 01:36:53,170
Das die Sharp schlau genug ist

2181
01:36:53,170 --> 01:36:55,170
Und die Funktion rausschmeißt im Release Modus

2182
01:36:55,170 --> 01:36:57,170
Weil es feststellt okay

2183
01:36:57,170 --> 01:36:59,170
Das ist eine Schleife mit nichts drin

2184
01:36:59,170 --> 01:37:04,720
Also scheiß drauf mach weg

2185
01:37:04,720 --> 01:37:06,720
Test mit einem Print

2186
01:37:06,720 --> 01:37:08,720
Print ist immer ganz ganz mies

2187
01:37:08,720 --> 01:37:10,720
Print ist auf die Konsole

2188
01:37:10,720 --> 01:37:12,720
Und Single Output und so

2189
01:37:12,720 --> 01:37:14,720
Ne der überspringt

2190
01:37:14,720 --> 01:37:16,720
Ich habs jetzt im Debug Modus

2191
01:37:16,720 --> 01:37:18,720
Da wird nichts geskippt

2192
01:37:18,720 --> 01:37:22,420
Da wird nichts geskippt

2193
01:37:22,420 --> 01:37:24,420
Der ruft die wirklich auf

2194
01:37:24,420 --> 01:37:30,540
Aber ganz ehrlich

2195
01:37:30,540 --> 01:37:32,540
Das ist auch zu erwarten

2196
01:37:32,540 --> 01:37:34,540
Das ein Function Call von .NET

2197
01:37:34,540 --> 01:37:36,540
Nach .NET nahezu kein Overhead hat

2198
01:37:36,540 --> 01:37:38,540
Wäre ja auch schlimm wenn nicht

2199
01:37:38,540 --> 01:37:40,540
Okay also

2200
01:37:40,540 --> 01:37:42,540
Dann haben wir das jetzt ausprobiert für Go

2201
01:37:42,540 --> 01:37:44,540
Wollen wir mal gucken wie schnell

2202
01:37:44,540 --> 01:37:46,540
Das mit dem Struct ist

2203
01:37:46,540 --> 01:37:50,370
Oh das ist natürlich noch mal

2204
01:37:50,370 --> 01:37:52,370
Eine ganze Ecke langsamer

2205
01:37:52,370 --> 01:37:58,430
Haha

2206
01:37:58,430 --> 01:38:00,430
Ja es schwankt ein bisschen

2207
01:38:00,430 --> 01:38:02,430
Wir machen gleich mal

2208
01:38:02,430 --> 01:38:04,430
Wir machen gleich mal ein Benchmark

2209
01:38:04,430 --> 01:38:06,430
Komm wir machen jetzt schon ein Benchmark draus

2210
01:38:06,430 --> 01:38:08,430
Wir machen jetzt schon ein Benchmark draus

2211
01:38:08,430 --> 01:38:10,430
Bevor wir die Rust Sache basteln

2212
01:38:10,430 --> 01:38:12,430
Nougat

2213
01:38:12,430 --> 01:38:14,430
Benchmark

2214
01:38:14,430 --> 01:38:16,430
.NET

2215
01:38:16,430 --> 01:38:21,540
Bam

2216
01:38:21,540 --> 01:38:31,540
.NET

2217
01:38:31,540 --> 01:38:33,540
.NET

2218
01:38:33,540 --> 01:38:35,540
.NET

2219
01:38:35,540 --> 01:38:39,360
.NET

2220
01:38:39,360 --> 01:38:41,360
.NET

2221
01:38:41,360 --> 01:38:43,360
.NET

2222
01:38:43,360 --> 01:38:45,360
.NET

2223
01:38:45,360 --> 01:38:47,360
.ăn

2224
01:38:47,360 --> 01:38:49,360
. маш

2225
01:38:49,360 --> 01:38:51,360
.NET

2226
01:38:51,360 --> 01:38:52,880
.NET

2227
01:38:53,360 --> 01:39:18,040
Wie geht, Moment, Moment, wie ging das jetzt nochmal, Moment, Moment, irgendwie Benchmark, Runner, ne, ne, ne, Benchmark, Runner, Runner, Benchmark, Runner, Run, Benchmark, okay, das hier oben kommt weg, das, ein Aufruf hier oben ist okay,

2228
01:39:18,040 --> 01:39:56,100
okay, das kommt da rein, Public, Void, das nennen wir jetzt einfach mal irgendwie Run, Run, Go oder so, dann kommt das hier rein, machen wir, machen wir aber mal nur, nur, ja doch, na komm, 1000, 1000 Aufrufe ist vielleicht besser, da kann das mehrfach, mehrfach die Funktion aufrufen, okay, Go, Run, äh, und jetzt, ich glaube, jetzt muss man hier noch Benchmark drüber schreiben, ne, okay,

2229
01:39:56,660 --> 01:39:58,100
so, und jetzt sollte der in Ordnung sein,

2230
01:39:58,120 --> 01:40:43,820
dass wir eine ordentliche Ausgabe haben, wie schnell der ist, zack, wow, what, there are not any result runs, warum, failed, der erkennt wieder mein .NET nicht, man, was ist das für ein Abfuck, okay, Export, hier, Path, Export, .NET, kann man hier drinnen, kann man hier drinnen relative Fade verwenden, gar nicht sicher, .NET,

2231
01:40:46,300 --> 01:41:19,660
version, minus, minus, version, 7, ne, also, Home, Max, jetzt ist es 8, okay, mach doch in die Bash RC, eigentlich will ich meine System.NET Version nicht überschreiben, so, und jetzt sagen wir Run Release, jetzt soll es hoffentlich gehen, ja, jetzt wird ordentlich gebenchmarked, fast wie in einem Nick Chapsas Video hier,

2232
01:41:21,420 --> 01:41:57,580
da wird auch immer, 50 mal, falls dir jemand guckt, da wird auch immer bis zum Umkippen gebenchmarked, wenn du eine Variable für die Anzahl machst, kannst du die Anzahl der Durchläufe testen, so, also, Go hat im Durchschnitt 182 Mikrosekunden,

2233
01:41:57,580 --> 01:42:02,580
also für 1000 Aufrufe,

2234
01:42:03,540 --> 01:42:35,220
und das ist jetzt halt nicht, nicht so schnell, äh, warum, warum, ich brauch ja keine Parameter, oder, hast du dir mal das Video angeguckt, da muss ich nicht das Video angucken, das hab ich oft genug erzählt, dass die .NET Versionierung beschissen ist,

2235
01:42:35,220 --> 01:42:58,790
da hab ich ja schon, hab ich ja schon selbst oft genug gesagt, also, ach, komm, machen wir einfach, machen wir nur 100, komm, so, und wir callen jetzt das ohne Overhead, also das, das nix macht,

2236
01:42:59,270 --> 01:43:42,100
so, und jetzt das Ganze nochmal für Rust, auf geht's, Krustentiere versammeln, ah, ja, ja, danke schön für den Sub, Bolgi19, huge Subscription,

2237
01:43:42,100 --> 01:44:00,150
sorry, falls ich irgendjemanden übersehen hab, ich guck mal kurz rein, Creator Dashboard, der Karlsson, danke für den Sub, hab ich den Zappcon,

2238
01:44:02,070 --> 01:44:10,930
Schifter, und Stripes, der Razer hat auch Subscribed vorhin noch, der Alfred auch, gar nicht richtig gesehen alles hier,

2239
01:44:10,930 --> 01:44:43,120
so, also, es wird Zeit für Go, wir kommentieren das hier gerade mal aus, und ich sag jetzt mal, call, wir brauchen jetzt, wir brauchen jetzt, call, call Rust,

2240
01:44:43,300 --> 01:44:55,110
das wird nicht funktionieren, weil es das auch nicht gibt, ja, bam, Crash, gibt es nicht, so, also, ich muss jetzt in Rust eine Library erzeugen, die Rustlib heißt,

2241
01:44:55,110 --> 01:45:06,070
jetzt geht's los, ich hab keine Ahnung, wirklich absolut keinen blassen Schimmer, wie ich das jetzt machen soll, okay, also, müssen wir, müssen wir mal suchen, Rust, ähm, FFI,

2242
01:45:06,070 --> 01:45:15,070
The Rustonomicon, okay, jetzt kriegen wir, jetzt kriegen wir es erklärt, also, Calling Foreign Functions,

2243
01:45:15,190 --> 01:45:44,360
ah, oh, Rust ist so eklig, Alter, wenn ich das hier schon sehe, ich dreh, dreh aber, Crate Type, äh, wie, wie macht man das überhaupt, da gab's doch mal irgendein GitHub, Rust FFI Examples,

2244
01:45:44,360 --> 01:45:57,560
guck mal mal, hat er denn, C Sharp to Rust, das ist doch schon mal ein gutes Beispiel, ja, Cargo Tommel, also, das braucht man,

2245
01:45:57,900 --> 01:46:12,060
Lip, okay, also, let's go, wir müssen in unsere Cargo Tommel gehen, und da jetzt ein Lip hinzufügen, Lip, äh, Name ist einfach, äh, Rustlib,

2246
01:46:12,060 --> 01:46:29,910
oh, Rustlib, so, wahrscheinlich wie der Output heißen soll, CD Lip klingt gut, und jetzt ist die Frage, wie funzt das Source, Lipass, ja, Copy-Pasten wir uns mal hier rein,

2247
01:46:30,170 --> 01:46:51,460
und nennen es Call Rust, aber wir haben kein Input und wir haben kein Output erstmal, no Mängel, extern, FN, Call Rust, okay, das hier bedeutet, glaube ich, dass er die Namen genauso lässt, wie die Funktion heißt, sodass sie später aufgerufen werden kann,

2248
01:46:51,460 --> 01:46:57,460
und Main können wir eigentlich rausmachen, no Main Function found, ja, ist doch klar, will ich auch nicht mehr,

2249
01:47:02,060 --> 01:47:14,580
okay, Source, Main, in Lip.js, achso, Cargo Run geht natürlich, Cargo Build, ohne Fehler hat es gebildet, ich weiß es nicht,

2250
01:47:14,580 --> 01:47:31,280
hm, und jetzt, wo ist das Ganze, Target, Debug, Lip, Lip, Rust, Lip, hört sich ein bisschen kacke vielleicht an, oder, wie habe ich es genannt,

2251
01:47:32,060 --> 01:47:50,120
einfach nur Rust Lip genannt, also, dann heißt es hier einfach nur Rust, Build, Lip, Rust.so, ja, meinetwegen, dann heißt es halt nicht Rust Lip, sondern Lip Rust, auch gut, kann ich auch mitleben, okay,

2252
01:47:50,120 --> 01:48:07,070
und jetzt Build, okay, Minus, Minus, Release, wobei eigentlich wurscht es, wie ich das nenne, wir können auch sagen, Build Release, dann sagen wir CP, oder MV, ähm, Target, Build,

2253
01:48:07,530 --> 01:48:28,350
Release, Lip, Rust.so, hoch zu, ähm, Benchmark, und dann soll das einfach heißen, Rust Lip.so, ich benenne es einfach um, doch, doch, das ist eigentlich schon richtig, ich habe es nur falschrum benannt,

2254
01:48:28,350 --> 01:48:43,280
ich habe es falschrum benannt, Lip, das ist auf jeden Fall, so, so ist richtiger als meins, mit Lip zuerst, okay, so, jetzt haben wir in unserem .NET Projekt noch eine Rust Lip, die fügen wir hinzu in den Output,

2255
01:48:44,540 --> 01:48:57,340
dass er die auch findet, wenn er dann später, später läuft, ja, so, also, Build Action, äh, Copy, hier, zack, so, und wenn wir Glück haben, funktioniert das jetzt schon,

2256
01:48:57,340 --> 01:49:14,140
hey, es läuft, Rasteraufruf, Funst, so, Beweis, Moment, Beweis, dass es funktioniert, Source, äh, Print, was, Module, Declaration, Reload, immer, Restart, hilft immer,

2257
01:49:14,540 --> 01:49:30,540
okay, nice, so, jetzt bringen wir mal, das, Brindeln, Keg W, Build, und jetzt Aufrufen von .NET aus, Moment, oh, zu viele Fenster, Aufrufen von .NET auf, Keg W, nice, Funst, sehr gut, exzellent,

2258
01:49:30,540 --> 01:49:43,540
okay, jetzt können wir mal testen, wie schnell das ist, in Godas, in, in, in, in Rust das Ganze zu machen, und danach bauen wir das noch mit Rust und Struct zurückgeben, also, wir sagen jetzt Interopt,

2259
01:49:44,540 --> 01:50:17,480
Call, Go, und zwar mein Benchmark, Interopt, Call, Net, wir machen jetzt alle drei Sachen, so, also, wir kopieren uns den Benchmark, und den Benchmark, sagen wir Run, Go, Run, Rust, und Run, Run.NET, das sollte ja eigentlich das schnellste sein, Call, Net, und hier, Rust, jetzt bin ich mal auf die Ergebnisse gespannt, was da rauskommt,

2260
01:50:19,620 --> 01:50:49,620
C, Release, wir machen es auch so schnell wie geht, zack, lassen wir das mal kurz laufen, und ich gucke in den Chat, Moin, bin aktuell auf Windows, ich würde gerne auf Linux rüber wechseln, OS gefällt mir sehr, jedoch zweifle ich noch, dass ich, da ich gerne zocke, und ich weiß, wie gut das unter Linux funktioniert, ganz ehrlich, wenn du viel spielst, und je nachdem, was du spielst, wenn du Spiele beispielsweise mit Anti-Cheat spielst, also, wobei, CS ja wohl mittlerweile ganz gut funktioniert, aber wenn du sowas wie, sagen wir mal, Rainbow Six, Fortnite, und so, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das ist, das

2261
01:50:49,620 --> 01:50:52,900
oder sowas spielst, dann hast du eigentlich verloren unter Linux.

2262
01:50:54,920 --> 01:51:09,740
Ich würde dir empfehlen, mach das so wie ich erstmal, benutze Windows als Host, und auf dem zweiten Windows-Desktop eine Linux-VRM im Fullscreen, wo du zwischendrin hin und her schalten kannst, du machst in der Linux-VRM alles, was du machen willst, was gut unter Linux ist,

2263
01:51:09,740 --> 01:51:19,960
und für Sachen wie Videos gucken, streamen, Videobearbeitung, irgendwelche Games,

2264
01:51:20,360 --> 01:51:21,640
dann machst du es unter Windows.

2265
01:51:21,760 --> 01:51:23,700
Da hast du, finde ich, das Beste aus beiden Welten.

2266
01:51:23,700 --> 01:51:27,880
Und das Gute ist, du kannst dich ein bisschen an Linux gewöhnen,

2267
01:51:28,140 --> 01:51:32,680
ohne dass du irgendwie Dualboot machen musst oder direkt ins kalte Wasser geworfen wirst.

2268
01:51:33,160 --> 01:51:37,980
Also zum Anfang einfach nur eine VM und gut ist.

2269
01:51:37,980 --> 01:51:43,960
Und so, was sagt denn meine Benchmarks hier?

2270
01:51:52,060 --> 01:51:53,560
Meine Benchmarks benchmarken noch.

2271
01:51:59,490 --> 01:52:00,870
Ich bin mal gespannt, was rauskommt.

2272
01:52:01,050 --> 01:52:02,890
Also ich meine, eigentlich kann ich es mir schon denken.

2273
01:52:03,270 --> 01:52:07,550
.NET am schnellsten, gefolgt von Rust und dann Go hintendran.

2274
01:52:07,890 --> 01:52:10,370
Also in diesem einen speziellen Fall jetzt.

2275
01:52:10,730 --> 01:52:16,240
Was macht der da eigentlich so lang?

2276
01:52:18,180 --> 01:52:19,100
So, ja.

2277
01:52:19,940 --> 01:52:21,440
Guck mal, boah.

2278
01:52:22,020 --> 01:52:23,760
Alter, was ein Unterschied, Mann.

2279
01:52:26,220 --> 01:52:27,360
Guckt euch das mal an.

2280
01:52:27,560 --> 01:52:32,740
Okay, also unser Benchmark ist 100 Funktionsaufrufe, die nichts machen.

2281
01:52:33,320 --> 01:52:39,320
Ja, also von einem Funktionsaufruf 100, nicht einer.

2282
01:52:40,220 --> 01:52:45,280
100 Funktionsaufrufe von .NET nach .NET sind natürlich abfackschnell.

2283
01:52:45,940 --> 01:52:48,240
28,8 für Nanosekunden.

2284
01:52:49,120 --> 01:52:50,520
Das ist megaschnell, ja.

2285
01:52:51,680 --> 01:52:52,440
Das ist aber auch klar.

2286
01:52:53,020 --> 01:52:54,440
Gefolgt von Rust.

2287
01:52:55,120 --> 01:52:55,960
Call in Rust.

2288
01:52:55,960 --> 01:52:56,960
Also die haben einen super, super...

2289
01:52:57,560 --> 01:53:00,920
C-Interface, was einfach funktioniert, ohne viel Overhead.

2290
01:53:01,980 --> 01:53:05,100
Nur 125 Nanosekunden für 100 Aufrufe.

2291
01:53:05,160 --> 01:53:08,100
Das ist auch im Prinzip nix, eigentlich.

2292
01:53:08,720 --> 01:53:09,740
Und jetzt kommt Go.

2293
01:53:10,240 --> 01:53:14,380
Go braucht einfach mal, sehe ich das richtig, 8 Millisekunden.

2294
01:53:15,100 --> 01:53:17,940
Also 8.114 Nanosekunden.

2295
01:53:21,910 --> 01:53:24,670
Jetzt muss ich ein Video machen auf YouTube, dass Go stirbt, ja.

2296
01:53:27,050 --> 01:53:27,990
Placingly fast.

2297
01:53:28,470 --> 01:53:30,330
Rust is destroying Go.

2298
01:53:31,330 --> 01:53:31,690
Ähm.

2299
01:53:32,170 --> 01:53:35,210
Go will be dead soon.

2300
01:53:35,490 --> 01:53:36,410
Oder irgendwas in der...

2301
01:53:36,410 --> 01:53:38,670
Wir brauchen noch ein bisschen mehr Klick...

2302
01:53:38,670 --> 01:53:39,570
Ne, wir brauchen...

2303
01:53:39,570 --> 01:53:40,750
Wir brauchen Clickbait.

2304
01:53:41,290 --> 01:53:42,390
Go is dead.

2305
01:53:43,170 --> 01:53:43,990
Here is why.

2306
01:53:45,130 --> 01:53:46,890
Oder irgendwie sowas.

2307
01:53:54,280 --> 01:53:55,500
Äh, Mikrosekunden.

2308
01:53:55,760 --> 01:53:56,760
Jaja, Mikrosekunden.

2309
01:53:56,820 --> 01:53:57,980
Wir sind hier in Bananosekunden.

2310
01:53:59,900 --> 01:54:02,820
How Go-Lang is destroying your performance.

2311
01:54:03,060 --> 01:54:03,320
Genau.

2312
01:54:04,700 --> 01:54:06,020
Mikrosekunden, nicht Millisekunden.

2313
01:54:06,020 --> 01:54:06,840
Ja, ich hab mich vertan.

2314
01:54:07,380 --> 01:54:08,520
Kann man auch mal durcheinander kommen.

2315
01:54:08,640 --> 01:54:12,260
Also, .NET, logischerweise in dem Fall das schnellste.

2316
01:54:12,340 --> 01:54:13,460
28 Nanosekunden.

2317
01:54:13,560 --> 01:54:14,980
Rust, 125 Nanosekunden.

2318
01:54:15,260 --> 01:54:16,480
Würde ich sagen, das ist so wirklich...

2319
01:54:16,480 --> 01:54:18,080
Da kannst du ohne Probleme nach Rust callen.

2320
01:54:18,560 --> 01:54:20,520
Und hier 8 Mikrosekunden.

2321
01:54:21,260 --> 01:54:26,880
Nicht, dass 8 Mikrosekunden schnell wäre, aber es ist um Größenordnungen langsamer als Rust.

2322
01:54:30,100 --> 01:54:35,940
.NET steht ja eigentlich gar nicht zur Auswahl, weil die WebRTC-Libraries für .NET...

2323
01:54:36,640 --> 01:54:39,460
Es gibt Zip-Sourcery für .NET, das ist auch nicht schlecht.

2324
01:54:40,060 --> 01:54:40,780
Aber ich finde...

2325
01:54:40,780 --> 01:54:49,020
Ich finde, dem fehlen noch ein paar Features, dass man sie komplett so gut benutzen kann, wie die Go-Library zum Beispiel.

2326
01:54:49,100 --> 01:54:50,740
Und die Rust-Library weiß ich noch nicht.

2327
01:54:51,180 --> 01:54:56,280
Das ist ein Nachbau von der Go-Library, die ich verwenden will, aber ich weiß nicht, wie Feature-Complete die schon ist.

2328
01:55:10,280 --> 01:55:12,800
Macht die Übung mal anders, von Rust als Base und Import C-Sharp.

2329
01:55:17,950 --> 01:55:21,810
Also, von Rust nach Go wird mehr oder weniger genauso sein.

2330
01:55:23,490 --> 01:55:27,450
Aber von Rust nach C-Sharp ist gar nicht so einfach möglich.

2331
01:55:28,190 --> 01:55:32,650
Weil C-Sharp braucht eine .NET-Runtime, die läuft.

2332
01:55:33,590 --> 01:55:36,270
Das heißt, ich müsste quasi eine .NET-Runtime in Rust hosten.

2333
01:55:36,590 --> 01:55:37,610
Was sicherlich geht.

2334
01:55:38,390 --> 01:55:41,730
Ja, du kannst AOT machen, aber ich erzähle euch, wie es die ganze Zeit gewesen ist.

2335
01:55:42,570 --> 01:55:43,610
Du brauchst quasi...

2336
01:55:43,610 --> 01:55:45,590
Du musst quasi eine .NET-Runtime in Rust hosten.

2337
01:55:45,630 --> 01:55:46,730
Ich glaube, das will man nicht machen.

2338
01:55:47,470 --> 01:55:49,430
Seit den letzten...

2339
01:55:49,430 --> 01:55:54,210
Seit .NET 6, aber eher seit .NET 7 und noch spannender wird es mit .NET 8.

2340
01:55:54,210 --> 01:55:57,210
.NET 8 kommt ja demnächst raus.

2341
01:55:58,190 --> 01:56:01,690
Da unterstützen die ja auch Ahead-of-Time-Compilation.

2342
01:56:02,110 --> 01:56:05,110
Also im Prinzip das, was so ein Compiler macht.

2343
01:56:06,130 --> 01:56:08,970
Normalerweise halt irgendwas Native-Ausführbares rauswerfen.

2344
01:56:09,790 --> 01:56:12,110
Dann kann man auch...

2345
01:56:12,110 --> 01:56:13,250
Moment, da gibt es wirklich was.

2346
01:56:13,910 --> 01:56:17,290
Da kann man dann auch direkt Funktionen draus aufrufen.

2347
01:56:20,530 --> 01:56:21,510
Ne, das ist was anderes.

2348
01:56:22,350 --> 01:56:23,110
Das ist was anderes.

2349
01:56:23,770 --> 01:56:28,950
Das ist Rust zu IR kompilieren, was dann in .NET laufen kann.

2350
01:56:29,230 --> 01:56:29,950
Das ist auch Sixhead.

2351
01:56:30,590 --> 01:56:31,490
Das ist sowas gibt.

2352
01:56:32,830 --> 01:56:34,050
Aber das ist andersrum.

2353
01:56:36,490 --> 01:56:37,470
Also ist Rust in .NET.

2354
01:56:37,790 --> 01:56:40,530
Wir wollen ja .NET von echtem Rust aufrufen.

2355
01:56:41,830 --> 01:56:44,190
So, jetzt müssen wir aber nochmal...

2356
01:56:44,190 --> 01:56:45,730
Was ist IR Intermediate?

2357
01:56:46,110 --> 01:56:47,310
Also das ist quasi IL.

2358
01:56:49,970 --> 01:56:51,810
IL und IR ist das...

2359
01:56:51,810 --> 01:56:52,550
Ist das...

2360
01:56:52,550 --> 01:56:54,270
Ist das gleiche quasi.

2361
01:56:56,830 --> 01:56:58,030
Hä, bin ich jetzt blöd?

2362
01:56:58,030 --> 01:56:58,850
So hier.

2363
01:57:01,270 --> 01:57:01,830
Ja, IR.

2364
01:57:02,210 --> 01:57:03,770
Also IR und IL ist das gleiche.

2365
01:57:03,790 --> 01:57:04,450
Im Endeffekt.

2366
01:57:04,910 --> 01:57:07,970
Das ist nicht direkt ausführbar von deinem Rechner,

2367
01:57:08,090 --> 01:57:09,910
aber ausführbar von der .NET Runtime.

2368
01:57:10,430 --> 01:57:14,850
Also C-Sharp kompiliert ja auch nicht direkt in ein Binary,

2369
01:57:14,970 --> 01:57:15,950
was du ausführen kannst,

2370
01:57:16,050 --> 01:57:18,990
sondern C-Sharp kompiliert in Bytecode,

2371
01:57:19,470 --> 01:57:21,010
den .NET ausführen kann.

2372
01:57:21,410 --> 01:57:23,150
Und wenn du in den C-Sharp Binary startest,

2373
01:57:23,250 --> 01:57:24,390
dann ist es in Wirklichkeit so,

2374
01:57:25,050 --> 01:57:29,380
dass erstmal .NET gestartet wird

2375
01:57:29,380 --> 01:57:31,860
und .NET startet dann deine C-Sharp...

2376
01:57:31,860 --> 01:57:35,460
liest dann das CLRIR und so weiter.

2377
01:57:35,480 --> 01:57:36,400
Oder IL ein.

2378
01:57:37,100 --> 01:57:39,200
Je nachdem wie man es nennt und führt das aus.

2379
01:57:40,320 --> 01:57:42,320
Und dort ist es so,

2380
01:57:42,440 --> 01:57:46,560
dass quasi Rust zu IL umgewandelt wird

2381
01:57:46,560 --> 01:57:49,280
und IL kann dann von der .NET Runtime ausgeführt werden.

2382
01:57:49,900 --> 01:57:51,640
Das ist halt echt schon richtig Sixthead.

2383
01:57:51,740 --> 01:57:54,760
Ich wüsste nicht genau wozu das...

2384
01:57:54,760 --> 01:57:57,620
Ich meine, ja um Rust Libraries in C-Sharp zu verwenden.

2385
01:58:03,220 --> 01:58:04,940
Aber es funktioniert noch nicht alles.

2386
01:58:06,160 --> 01:58:07,460
Aber cool, dass das funktioniert.

2387
01:58:08,840 --> 01:58:10,300
So, jetzt haben wir unser Benchmarker.

2388
01:58:10,320 --> 01:58:11,560
Das Benchmarkzeug hier am Start.

2389
01:58:12,040 --> 01:58:15,040
Das werde ich jetzt gerade einfach mal wieder auskommentieren.

2390
01:58:16,660 --> 01:58:18,280
Und wir gucken uns mal an,

2391
01:58:18,980 --> 01:58:21,680
wie man in Rust ein Struct baut

2392
01:58:21,680 --> 01:58:26,400
und das Struct zurückgibt an C-Sharp.

2393
01:58:26,720 --> 01:58:29,060
Also Call Rust 2 brauchen wir jetzt noch.

2394
01:58:29,520 --> 01:58:33,380
So, das legen wir jetzt hier auch mal an.

2395
01:58:36,390 --> 01:58:40,070
Ich prophezeie, dass es etwas einfacher wird als in Go,

2396
01:58:40,210 --> 01:58:43,550
weil Rust C-Interop ist ziemlich gut in der Regel.

2397
01:58:43,710 --> 01:58:56,720
Aber Rust hat schon .NET Libraries, oder nicht?

2398
01:58:57,340 --> 01:58:57,560
Nee.

2399
01:58:58,360 --> 01:59:00,820
Rust ist Rust und Rust ist nicht .NET normalerweise.

2400
01:59:07,510 --> 01:59:09,870
Hast du einen coolen, vielleicht auch leichten Weg mit Rust?

2401
01:59:10,170 --> 01:59:11,490
Ich habe keine Ahnung.

2402
01:59:13,170 --> 01:59:15,370
Aber ich glaube, man muss ganz schön masochistisch sein,

2403
01:59:15,450 --> 01:59:18,910
veranlagt sein, mit Rust Windows UI Anwendungen bauen zu wollen.

2404
01:59:20,370 --> 01:59:22,430
Das ist einfach nur so mein Bauchgefühl dazu.

2405
01:59:28,800 --> 01:59:29,700
Ja, nice.

2406
01:59:31,540 --> 01:59:33,420
Blazingly fast written in Rust.

2407
01:59:33,740 --> 01:59:34,680
Muss jetzt aber auch bei allen anderen Anwendungen, die ich hier habe,

2408
01:59:34,680 --> 01:59:34,840
bei allen anderen Anwendungen, die ich hier habe,

2409
01:59:34,960 --> 01:59:36,220
bei allen anderen Projekten dabei schreiben.

2410
01:59:40,530 --> 01:59:41,310
Also, okay.

2411
01:59:41,590 --> 01:59:43,870
Wie macht man, es geht ja schon mal los, Leute,

2412
01:59:44,350 --> 01:59:46,830
wie man überhaupt einen Struct in Rust macht.

2413
01:59:47,250 --> 01:59:47,650
Struct.

2414
01:59:48,230 --> 01:59:49,310
Okay, so schön.

2415
01:59:50,030 --> 01:59:51,650
Nice, Max, super.

2416
01:59:53,050 --> 01:59:56,750
Ich glaube, so weit wären wir wahrscheinlich auch schon gekommen, oder?

2417
01:59:57,750 --> 02:00:00,170
Okay, aber wie geht es weiter?

2418
02:00:00,430 --> 02:00:01,470
Rust, Struct.

2419
02:00:02,410 --> 02:00:03,890
FFI, suchen wir mal danach.

2420
02:00:05,410 --> 02:00:07,830
Complex Data Tabs and Rust FFI.

2421
02:00:07,830 --> 02:00:39,240
Genau, okay, also, Inamstruct, hier, Rebr, Rebr, Rebr, C, okay, das ist so ein, das ist so ein typisches Rust-Ding, das können wir Copy-Pasten, das ist eines der Gründe, warum Rust echt nicht schön zu lesen ist, Pup, Pup, ist quasi was wie Public, Public Ausschreiben ist outdated, overrated, also machen wir hier mal das gleiche, Session, Name, okay, wir fangen einfach an, wir machen wieder das gleiche,

2422
02:00:39,840 --> 02:01:08,960
ähm, hier, Client-ID und, ne, komm, wir sind, wir sind, A, B heißt es jetzt, so, Uint, ne, Moment, Int, Moment, es ist Rust, da ist es U64 einfach nur, gell, ja, es ist Rust und hier nochmal, hier noch ein Bool oder so, ja, okay, Build, es bildet noch und jetzt Return,

2423
02:01:12,880 --> 02:01:53,730
tja, das ist eine gute Frage, ich weiß gar nicht, wie ich das, so, A, 1, 2, 3, B, Moment, B, True, ne, das ist ein B-Kolon vielleicht, hä, Juch, äh, so, hm, was hat er denn für Schmerzen,

2424
02:01:55,430 --> 02:02:32,060
oh, weil ich keinen Return-Type angegeben hab, ähm, Rust-Return-Type ist so, gell, ja, okay, ist schon besser, schon besser, übrigens, ich hab's verkackt, ich hab's in der falschen Funktion gemacht, das muss hier unten rein, Format, okay, und das funktioniert jetzt, Moment, das funzt, okay, jetzt bin ich mal gespannt, wie das, wie das zurückkommt in, in .NET, wir brauchen, wir müssen das mal kurz ein bisschen ändern, hier, Session, Rename,

2425
02:02:37,520 --> 02:03:08,750
Session, äh, Go, Session, Rust, so, Uint, und dann haben wir hier einen Bool, und, ja, A, B, wie's heißt, ist egal, jetzt bin ich, jetzt bin ich mal gespannt, ob das, das ist ja die Basics, das sind einfach nur Values zurückgeben, und, unser Ziel ist ja hier auch noch einen String zurückzugeben und sowas, das wird dann schon noch ein bisschen komplizierter, Call Rust 2 zurück, bekommen wir eine Session, okay, Call Rust 2,

2426
02:03:09,350 --> 02:03:42,000
Session, gleich, Session, A, und, Session, B, und jetzt gucken wir mal, ob das funzt, was da rauskommt, 1, 2, 3, und True, True, 0, W, ja, das funzt, okay, das, das war schon ein bisschen einfacher als in Go, an der Stelle, weil Rust ist deutlich besser, also, wir brauchen kein C, Go, und C, Struct definieren, und sowas,

2427
02:03:42,800 --> 02:04:02,160
das ist einfacher, so, und jetzt kommt ein String, jetzt bin ich mal gespannt, wie das funzt, kann ich, kann ich einfach sagen, String, das geht doch im Leben nicht, oder, wenn ich hier einfach sage, ich return einen String, oh, keck, weh, okay, jetzt kommt Rust gedöhnt,

2428
02:04:02,160 --> 02:04:12,160
jetzt, warum kann ich einem Struct String keinen String zuweisen, weil man irgendwie sagen muss, pass as String, oder sowas, ich erinnere mich dunkel,

2429
02:04:12,800 --> 02:04:53,820
from String, from, to String, wo ist der Unterschied dazwischen, aber das habe ich schon mal, das habe ich schon mal gesehen in Rust, ja, das kompiliert zwar, aber das wird nicht funktionieren, das wird, das wird so nicht funktionieren, weil die Rust String Repräsentation ganz anders ist, als das, was sich C Sharp vorstellt, aber wir können es mal ausprobieren, wir stellen, wir stellen uns einfach mal wieder doof, und sagen, das ist ein String,

2430
02:04:53,840 --> 02:05:29,580
okay, so, das wird nicht funzen, nein, es crasht sogar, crasht es, crasht es wirklich, ja, es crasht, okay, es crasht, es crasht komplett, macht einfach gar nichts, also, das funzt so definitiv nicht, aber das habe ich auch schon gedacht, ich brauche, ich brauche einen C, C String, oder sowas, oder einen, oder einen Character Array, oder sowas,

2431
02:05:32,360 --> 02:06:10,780
wir gucken mal eine Hilfe von Rust, ach hier, guck mal, Const C, Const C Char, hat er importiert, Const C, das geht natürlich nicht, kann man sowas wie, kann man sowas machen wie Pointer, S Pointer, aber das, das ist kein nullterminierter String, das, das, das, äh, kann man sagen wie Into Pointer, oder so, weil so Rust, Rust Magic,

2432
02:06:11,220 --> 02:06:45,280
das funzt nicht, ne, da sagt, was ist Const, okay, Const U8, das ist jetzt ja quasi ein Byte Array, kompiliert, es kompiliert, ich bin mal, ich bin mal gespannt, was jetzt in C Sharp rauskommt, es crasht einfach wieder, okay, es, es crasht, okay, dann probieren wir mal was anderes, dann probieren wir mal was anderes, Int Pointer, Int Pointer, das sollte jetzt nicht mal crashen,

2433
02:06:47,080 --> 02:07:47,770
es crasht immer noch, was, Double, ich hab die Go Session bearbeitet, ah, ich bin ein Kack Noob, okay, das funzt, also hier gibt's, hier gibt's den Int Pointer, hier, hier krieg ich den Int Pointer zurück, und was kann ich mit dem Int Pointer jetzt machen, sicherlich nicht als String parsen, oder, Marshall, Pointer, to String,

2434
02:07:49,880 --> 02:08:23,130
Bam, geht nicht, Pointer, to String, ey, das funzt nicht, das ergibt aber auch Sinn, dass das nicht funktioniert, weil Rust Strings sind ja nicht Null Terminated, und, und sonst wie das, das, das, das klappt nicht, jetzt haben wir noch Mut, Mut U8, haben wir auch noch, nicht, dass das was ändert, oder so, ups, ne, ne, das funzt nicht, okay, also, ich muss da irgendwie mit C String hantieren,

2435
02:08:26,110 --> 02:08:30,730
C String, New, A, B, C, Unwrap, das klingt,

2436
02:08:30,950 --> 02:09:01,660
sehr Rust Style, machen wir's mal sowas hier, Let Str gleich, C String, was, New, und jetzt hier sowas wie, Kek W, oder so, ja, und an der Stelle dann, hier machen wir auch wieder Cha, C Cha, und an der Stelle dann Str, okay, ne, funzt nicht, warum,

2437
02:09:04,080 --> 02:09:05,580
Expected Const C Cha,

2438
02:09:05,940 --> 02:09:45,500
Found, Result, ah, nochmal Unwrap, hä, Unwrap, äh, Unwrap muss da oben hin, Unwrap, was, Unwrap into Raw, what, into Raw, S Pointer, klingt doch, klingt doch sinnvoll, oder, S Pointer, zack, kompiliert, Run, oh, das lookt nicht korrekt,

2439
02:09:45,500 --> 02:09:53,690
das lookt gar nicht korrekt,

2440
02:09:54,690 --> 02:09:57,490
das sieht nach, wurde gefreed aus,

2441
02:09:58,790 --> 02:10:02,110
das ergibt auch Sinn, dass das nicht funktioniert, weil, Rust,

2442
02:10:02,750 --> 02:10:06,830
wird das hier wahrscheinlich verwerfen, sobald die Funktion zu Ende ist,

2443
02:10:07,430 --> 02:10:09,170
jetzt ist die große Preisfrage,

2444
02:10:15,020 --> 02:10:17,200
wie krieg ich Rust dazu, dass es das,

2445
02:10:17,740 --> 02:10:18,860
dass es überlebt,

2446
02:10:20,080 --> 02:10:23,300
wir gucken uns mal die Hilfe von C String in Rust an,

2447
02:10:27,440 --> 02:10:28,660
ja, Global Definition,

2448
02:10:28,660 --> 02:10:29,100
Global Definition,

2449
02:10:29,100 --> 02:10:29,720
nee, nee, nee, nee,

2450
02:10:29,720 --> 02:10:32,740
Extracting a Raw Pointer,

2451
02:10:32,960 --> 02:10:33,880
Äste, was,

2452
02:10:35,800 --> 02:10:36,480
S Pointer,

2453
02:10:42,210 --> 02:10:44,330
also eins kann man Rust ja meistens nicht vorwerfen,

2454
02:10:44,430 --> 02:10:45,670
lassen zu wenig Docks haben,

2455
02:10:47,250 --> 02:10:48,490
aber, dass ich nicht durchblicke,

2456
02:10:48,570 --> 02:10:49,250
ist schon wieder,

2457
02:10:51,830 --> 02:10:55,170
S Pointer, ja, so schlau bin ich auch,

2458
02:10:56,490 --> 02:10:57,110
Safety,

2459
02:11:16,700 --> 02:11:16,960
ähm,

2460
02:11:18,780 --> 02:11:20,380
ich muss, ich muss dem Ding jetzt,

2461
02:11:20,520 --> 02:11:22,300
also, bei Rust ist es so,

2462
02:11:22,300 --> 02:11:24,180
Rust ist super pingelig,

2463
02:11:24,340 --> 02:11:26,340
was Lifetime von Objekten angeht,

2464
02:11:27,000 --> 02:11:28,740
und Rust ist schlau genug und weiß,

2465
02:11:28,840 --> 02:11:30,340
am Ende dieses Dings,

2466
02:11:30,620 --> 02:11:32,780
normalerweise müsste ich jetzt sowas machen,

2467
02:11:32,860 --> 02:11:33,820
ja, irgendwie und,

2468
02:11:34,080 --> 02:11:38,040
also Rust Logik, da muss man dann und Mut oder so komisches Zeug da vormachen,

2469
02:11:40,160 --> 02:11:40,660
aber das,

2470
02:11:40,960 --> 02:11:43,020
also, da, da, da, dass ich Rust sage,

2471
02:11:43,560 --> 02:11:44,480
ich möchte,

2472
02:11:45,880 --> 02:11:46,440
quasi,

2473
02:11:46,840 --> 02:11:50,460
das Ownership, heißt das bei Rust, übertragen, an den der aufruft,

2474
02:11:50,820 --> 02:11:52,460
aber ich weiß nicht, wie das funktioniert,

2475
02:11:54,710 --> 02:11:56,110
geht mit nem Apostroph, mit,

2476
02:11:56,110 --> 02:11:57,110
was,

2477
02:11:58,870 --> 02:11:59,370
so,

2478
02:12:00,070 --> 02:12:01,490
alter, Rust macht mich fertig,

2479
02:12:10,320 --> 02:12:11,720
ne, ne, das kann's nicht sein, oder,

2480
02:12:13,960 --> 02:12:14,740
Examples,

2481
02:12:14,820 --> 02:12:17,890
den hatten wir schon,

2482
02:12:18,170 --> 02:12:18,870
S Point,

2483
02:12:20,770 --> 02:12:21,490
from, weg,

2484
02:12:27,020 --> 02:12:30,700
wenn du willst, übergibst du einfach noch den C-String nochmal als Feldinstrukt,

2485
02:12:33,020 --> 02:12:36,060
ich übergebe doch den, das Feldinstrukt,

2486
02:12:37,920 --> 02:12:38,420
hier,

2487
02:12:40,640 --> 02:12:42,640
oder, oder du meinst hier C-String,

2488
02:12:44,140 --> 02:12:47,500
ja, aber das wird doch da nicht so funktionieren, wie ich mir das gedacht habe, oder,

2489
02:12:47,620 --> 02:12:53,820
so,

2490
02:12:54,660 --> 02:12:56,660
ne, ist not FFI safe,

2491
02:12:57,660 --> 02:12:59,660
das, das wird nicht funktionieren, so,

2492
02:13:06,060 --> 02:13:06,860
siehste,

2493
02:13:09,020 --> 02:13:11,020
crasht einfach direkt, ne, ne, ne, ne,

2494
02:13:11,980 --> 02:13:13,480
so, so funzt das nicht,

2495
02:13:14,580 --> 02:13:15,080
ähm,

2496
02:13:15,940 --> 02:13:18,320
wir, wir, wir sind, glaub ich, auf'm richtigen Weg,

2497
02:13:19,260 --> 02:13:21,260
das ist, das ist, glaub ich, gar nicht so verkehrt,

2498
02:13:21,940 --> 02:13:23,940
vielleicht muss ich einfach sagen, Mut,

2499
02:13:24,820 --> 02:13:26,820
hier oben, anstatt Const,

2500
02:13:33,710 --> 02:13:36,210
in C-Sharp muss das in den Session-Daten zu String geändert werden,

2501
02:13:36,330 --> 02:13:37,130
ne, muss es nicht,

2502
02:13:38,390 --> 02:13:39,870
ich bekomm den In-Pointer,

2503
02:13:40,350 --> 02:13:43,710
und den wandle ich dann selbst in den String um, das muss auch funktionieren,

2504
02:13:49,860 --> 02:13:51,860
ok, das geht nicht, warum, weil,

2505
02:13:53,220 --> 02:13:54,480
Type differs in,

2506
02:13:55,100 --> 02:13:59,260
Expected Raw Pointer, Mut, Found Raw Pointer, Const,

2507
02:14:04,160 --> 02:14:05,460
brauchst exter-, Alter,

2508
02:14:05,760 --> 02:14:08,760
jetzt kommt richtig krasses, nices Backseating hier an den Start,

2509
02:14:09,300 --> 02:14:11,060
so, und das, und das soll jetzt funktionieren,

2510
02:14:11,560 --> 02:14:13,320
da hab ich so meine Zweifel, dass das funzt,

2511
02:14:14,780 --> 02:14:15,720
Chatge, und,

2512
02:14:16,400 --> 02:14:17,080
funzt nicht,

2513
02:14:17,700 --> 02:14:17,900
bam,

2514
02:14:28,290 --> 02:14:31,650
ich will dem sagen, dass das, dass er hier Ownership übertragen soll,

2515
02:14:32,090 --> 02:14:33,670
ok, wie, wie geht das,

2516
02:14:34,310 --> 02:14:35,590
was haben wir denn sonst noch hier,

2517
02:14:37,490 --> 02:14:38,450
From Raw,

2518
02:14:39,370 --> 02:14:41,250
Into Raw,

2519
02:14:42,890 --> 02:14:47,330
Consumes the C-String and transfer Ownership of the String to the C-Caller,

2520
02:14:47,490 --> 02:14:48,830
das ist das,

2521
02:14:49,390 --> 02:14:54,410
was ich wahrscheinlich will,

2522
02:15:02,960 --> 02:15:03,320
Into,

2523
02:15:03,740 --> 02:15:05,580
Into Raw,

2524
02:15:05,580 --> 02:15:08,560
das gibt ein Mut-C-Char,

2525
02:15:09,700 --> 02:15:14,220
ja, was ja auch durchaus ok ist, ich kann ja da drin rumsauen, wie ich will, mach ich aber nicht, aber könnte ich,

2526
02:15:15,260 --> 02:15:17,520
ok, lässt sich kompilieren, und jetzt, und jetzt,

2527
02:15:17,840 --> 02:15:19,420
Pause Champ, Leute, Pause Champ,

2528
02:15:23,380 --> 02:15:23,980
Pause Champ,

2529
02:15:28,030 --> 02:15:29,690
ich, ich finde meine Emotes grad nicht,

2530
02:15:30,210 --> 02:15:30,930
Pause Champ, Time,

2531
02:15:32,970 --> 02:15:33,370
Funzt,

2532
02:15:34,210 --> 02:15:34,530
Easy,

2533
02:15:35,530 --> 02:15:36,530
kaum macht man's richtig,

2534
02:15:37,250 --> 02:15:38,290
Easy as fuck,

2535
02:15:38,510 --> 02:15:38,750
Easy,

2536
02:15:39,650 --> 02:15:40,010
Easy,

2537
02:15:40,010 --> 02:15:40,090
Easy,

2538
02:15:40,090 --> 02:15:41,170
Easy,

2539
02:15:41,170 --> 02:15:41,270
Easy,

2540
02:15:41,270 --> 02:15:42,370
Easy,

2541
02:15:42,370 --> 02:15:42,510
Easy,

2542
02:15:42,510 --> 02:15:43,910
Easy as fuck,

2543
02:15:43,910 --> 02:15:48,880
hat funktioniert,

2544
02:15:49,240 --> 02:15:52,560
also, so funzt das in Rust,

2545
02:15:55,240 --> 02:15:55,980
C-String,

2546
02:15:57,780 --> 02:16:00,040
äh, Moment, und dann, und dann sagt man,

2547
02:16:00,900 --> 02:16:02,840
Moment, das ist Go,

2548
02:16:03,360 --> 02:16:03,580
Null,

2549
02:16:04,360 --> 02:16:05,480
äh, und dann sagt man,

2550
02:16:07,740 --> 02:16:08,820
Into Raw,

2551
02:16:19,790 --> 02:16:21,270
so, was haben wir denn sonst noch,

2552
02:16:22,750 --> 02:16:25,130
The Pointer, which this function returns,

2553
02:16:25,650 --> 02:16:27,850
must be returned to Rust,

2554
02:16:27,850 --> 02:16:27,910
must,

2555
02:16:29,010 --> 02:16:31,590
and reconstituted using,

2556
02:16:32,010 --> 02:16:34,190
C-String from Raw,

2557
02:16:34,410 --> 02:16:36,990
oh jetzt, das wär auch zu einfach gewesen,

2558
02:16:37,470 --> 02:16:40,250
das wär auch zu einfach gewesen, wenn das jetzt schon fertig ist,

2559
02:16:40,550 --> 02:16:42,770
passt mal auf, jetzt haben wir Memory Leaks, oder?

2560
02:16:43,190 --> 02:16:45,390
Jetzt haben wir Memory Leaks as fuck wieder,

2561
02:16:46,150 --> 02:16:47,510
Sekunde, while,

2562
02:16:48,390 --> 02:16:48,990
true,

2563
02:16:51,790 --> 02:16:53,850
passt auf, jetzt haben wir, jetzt haben wir wieder richtig Memory,

2564
02:16:54,950 --> 02:16:57,590
Ultramemory, Memory Leaks haben wir jetzt.

2565
02:17:06,660 --> 02:17:07,700
Oh, ho, ho, ho,

2566
02:17:07,940 --> 02:17:12,770
Alter, der hat sich in 3 Sekunden,

2567
02:17:12,770 --> 02:17:25,560
vier gigabyte ram geschnappt monke ist vier sekunden zwei sekunden vier gigabyte ram weg

2568
02:17:25,560 --> 02:17:32,760
das ist schon kein memory league mehr was kommt was kommt nach was kommt nach einem league das

2569
02:17:32,760 --> 02:17:38,640
liegt davon liegt zu sprechen ist eindeutig schon viel zu wenig das ist das ist das ist kein league

2570
02:17:38,640 --> 02:17:43,600
da ist einfach schon nichts mehr nichts mehr offen da gibt es noch nicht mal einen damm dazwischen

2571
02:17:43,600 --> 02:17:49,900
das ist einfach da ist einfach nichts dazwischen das ist alles alles das ist schon ein see quasi

2572
02:17:49,900 --> 02:17:57,220
ohne was dazwischen 22 sekunden vier gigabyte ram mich würde nicht wundern wenn irgendeine idee

2573
02:17:57,220 --> 02:18:03,640
abgekackt ist jetzt weil er zu viel ram sich geschnappt hat halbe forkbombe ist das schon

2574
02:18:03,640 --> 02:18:12,490
ohne sich zu folgen gut also was muss man was muss man machen the point which is fun must be

2575
02:18:12,490 --> 02:18:15,470
return to rust and krieg konnte using c-string

2576
02:18:15,470 --> 02:18:23,630
from raw to be properly deallocated da bin ich mal gespannt ob das stimmt was die da sagen wir

2577
02:18:23,630 --> 02:18:33,780
machen jetzt da einfach mal ein string draus weil dann wissen wir ja dass der automatisch fried und

2578
02:18:33,780 --> 02:18:47,990
jetzt sollten wir kein memory league mehr haben wir haben kein memory league mehr alles perfectly

2579
02:18:47,990 --> 02:18:57,760
fine na oder vielleicht doch so ein kleines memory league vielleicht wir haben kein memory league aber

2580
02:18:58,660 --> 02:19:06,400
auch ein kleines genau die sharp macht wieder free profile ist doch ich weiß ehrlich gesagt gerade

2581
02:19:06,400 --> 02:19:13,480
nicht wie gescheit weil mein rider ist irgendwie der meinung debugger funktioniert nicht warum auch

2582
02:19:13,480 --> 02:19:21,900
immer vielleicht jeder jetzt obwohl es mit dort versucht man jedoch netz location ergibt überhaupt

2583
02:19:21,900 --> 02:19:28,450
keinen sinn da sollen meinen dort nett verwenden und nicht das falsche dort nicht der ist es nicht

2584
02:19:32,620 --> 02:19:34,760
nicht. Das Ganze ist ein .NET 8

2585
02:19:34,760 --> 02:19:36,620
Projekt und er zeigt es auch hier an, dass es

2586
02:19:36,620 --> 02:19:38,720
.NET 8 ist, aber Ryder

2587
02:19:38,720 --> 02:19:39,800
ist der Meinung, nee,

2588
02:19:40,640 --> 02:19:42,720
ist es nicht. Guck hier, .NET 8, .NET

2589
02:19:42,720 --> 02:19:46,830
Version 8. Ich

2590
02:19:46,830 --> 02:19:48,350
weiß es nicht. Keine Ahnung. Er gibt

2591
02:19:48,350 --> 02:19:50,770
keinen Sinn. Ich glaube, fast

2592
02:19:50,770 --> 02:19:52,750
das ist ein Bug in Ryder, was wir hier haben.

2593
02:19:59,880 --> 02:20:00,540
.Memory.

2594
02:20:03,200 --> 02:20:05,040
So, und jetzt lesen wir mal weiter, was

2595
02:20:05,040 --> 02:20:05,680
hier steht.

2596
02:20:07,400 --> 02:20:08,800
Ja, okay, hier.

2597
02:20:10,840 --> 02:20:11,280
Specifically

2598
02:20:11,280 --> 02:20:13,220
one should not

2599
02:20:13,220 --> 02:20:15,100
use the standard

2600
02:20:15,100 --> 02:20:17,080
C free function to

2601
02:20:17,080 --> 02:20:19,040
deallocate the string. Das ist schon

2602
02:20:19,040 --> 02:20:21,020
mal falsch, was wir da gerade machen.

2603
02:20:21,900 --> 02:20:23,120
Failure to call

2604
02:20:23,120 --> 02:20:25,020
C string

2605
02:20:25,020 --> 02:20:27,040
from raw will lead to a memory leak.

2606
02:20:29,100 --> 02:20:31,040
The C side must not modify the

2607
02:20:31,040 --> 02:20:32,420
length of the string. Ja, okay.

2608
02:20:43,400 --> 02:20:45,100
Also müssen wir noch das hier machen.

2609
02:20:45,840 --> 02:20:47,360
Bedeutet im Endeffekt auch,

2610
02:20:47,760 --> 02:20:49,100
so dass wir kein Memory

2611
02:20:49,100 --> 02:20:51,340
leaken, brauche ich noch eine Funktion,

2612
02:20:51,360 --> 02:20:52,520
die nennen, ups,

2613
02:20:54,020 --> 02:20:55,120
brauche ich noch eine Funktion,

2614
02:20:55,620 --> 02:20:57,360
die nennen wir jetzt einfach mal hier

2615
02:20:57,360 --> 02:20:59,380
free str

2616
02:20:59,380 --> 02:20:59,980
oder so.

2617
02:21:01,560 --> 02:21:03,220
Und da rufen wir jetzt auf

2618
02:21:03,220 --> 02:21:05,400
C string

2619
02:21:05,400 --> 02:21:06,980
from raw, okay, hier

2620
02:21:06,980 --> 02:21:07,920
Pointer rein.

2621
02:21:09,160 --> 02:21:11,120
Und dann wahrscheinlich,

2622
02:21:11,480 --> 02:21:13,200
wahrscheinlich, okay,

2623
02:21:13,440 --> 02:21:15,020
rust, rust, geht das so?

2624
02:21:22,300 --> 02:21:24,060
Achso, das muss in den unsave Block.

2625
02:21:24,840 --> 02:21:25,960
Ist ja fast wie in .NET hier.

2626
02:21:25,960 --> 02:21:37,320
Bäh.

2627
02:21:39,760 --> 02:21:45,660
Ich will das so haben.

2628
02:21:48,830 --> 02:21:54,240
Warum, warum sieht der unsave Block

2629
02:21:54,240 --> 02:21:56,180
hier so kacke aus? Ah, dann machen wir es so.

2630
02:21:59,180 --> 02:22:00,600
Okay, und jetzt ist das, jetzt ist

2631
02:22:00,600 --> 02:22:01,160
das safe.

2632
02:22:02,360 --> 02:22:04,460
Da muss ich das aber noch dazu aufrufen.

2633
02:22:04,940 --> 02:22:05,720
Und zwar

2634
02:22:05,720 --> 02:22:08,440
würde ich

2635
02:22:08,440 --> 02:22:09,080
sagen,

2636
02:22:09,940 --> 02:22:12,300
muss ich dann hier noch

2637
02:22:12,300 --> 02:22:14,740
was reinpacken.

2638
02:22:14,740 --> 02:22:16,360
Und zwar, nicht

2639
02:22:16,360 --> 02:22:17,720
call rust, sondern

2640
02:22:17,720 --> 02:22:19,520
free str

2641
02:22:19,520 --> 02:22:21,740
int Pointer.

2642
02:22:21,860 --> 02:22:26,380
Äh.

2643
02:22:26,380 --> 02:22:28,420
So, und wenn ich jetzt das MemoryLeague

2644
02:22:28,420 --> 02:22:30,500
vermeiden will, sage

2645
02:22:30,500 --> 02:22:31,820
ich interop

2646
02:22:31,820 --> 02:22:34,620
free str

2647
02:22:34,620 --> 02:22:37,380
und gebe da session

2648
02:22:37,380 --> 02:22:38,360
meinen

2649
02:22:38,360 --> 02:22:41,520
ne, nein, ich meine string, das

2650
02:22:41,520 --> 02:22:43,600
funktioniert ja so jetzt nicht. Ja, okay, jetzt

2651
02:22:43,600 --> 02:22:45,440
ergibt das den, jetzt müssen wir es nämlich wirklich

2652
02:22:45,440 --> 02:22:47,480
selbst machen. Int Pointer,

2653
02:22:51,120 --> 02:22:52,260
ich hab schon wieder das falsche

2654
02:22:52,260 --> 02:22:55,680
editiert, Mann. Ich hab schon wieder die

2655
02:22:55,680 --> 02:22:56,820
Go session editiert, ja.

2656
02:22:59,420 --> 02:23:01,020
Int Pointer, wir benennen das

2657
02:23:01,020 --> 02:23:02,820
übrigens mal gescheit, sonst kann ich's

2658
02:23:02,820 --> 02:23:03,900
gar nicht mehr nicht merken.

2659
02:23:03,900 --> 02:23:06,480
ClientName, so.

2660
02:23:06,960 --> 02:23:09,220
Und jetzt sollte das MemoryLeague

2661
02:23:09,220 --> 02:23:10,440
auch wieder weg sein.

2662
02:23:13,860 --> 02:23:15,280
Ja, ja, ja, ja.

2663
02:23:16,280 --> 02:23:17,180
Da liegt nix mehr.

2664
02:23:18,860 --> 02:23:19,580
Ich meine, es ist

2665
02:23:19,580 --> 02:23:21,460
offensichtlich, vorher hatten wir vier

2666
02:23:21,460 --> 02:23:23,460
Gigabyte pro, pro zwei

2667
02:23:23,460 --> 02:23:24,700
Sekunden und jetzt haben wir nix.

2668
02:23:26,080 --> 02:23:27,560
Okay. DotMemory

2669
02:23:27,560 --> 02:23:29,800
hab ich noch nie ausprobiert. Kann man DotMemory

2670
02:23:29,800 --> 02:23:31,860
vielleicht installieren über die Toolbox?

2671
02:23:35,740 --> 02:23:36,040
Dot.

2672
02:23:36,660 --> 02:23:38,540
Trace haben wir. Dotnet

2673
02:23:38,540 --> 02:23:40,360
Dotnet Performance

2674
02:23:40,360 --> 02:23:42,020
Profiler.

2675
02:23:42,940 --> 02:23:44,020
Geht das damit auch?

2676
02:23:45,240 --> 02:23:46,380
Hab ich noch nie, hab ich noch nie

2677
02:23:46,380 --> 02:23:47,360
verwendet.

2678
02:23:49,100 --> 02:23:50,560
Zeigt der mir, zeigt der mir auch

2679
02:23:50,560 --> 02:23:51,500
die Memory Usage?

2680
02:23:54,130 --> 02:23:55,550
Eigentlich, ohne Scheiß,

2681
02:23:56,010 --> 02:23:58,030
eigentlich fuckt's mich jubelst ab, dass der, dass der

2682
02:23:58,030 --> 02:23:59,430
Rider Debugger nicht geht.

2683
02:24:02,010 --> 02:24:04,010
Warum geht der Rider? Okay, ich hab ne Idee, woran

2684
02:24:04,010 --> 02:24:05,570
das liegt. Wir gehen jetzt mal hier auf

2685
02:24:05,570 --> 02:24:07,350
Build and Toolsets.

2686
02:24:08,830 --> 02:24:10,050
Es ist automatisch, es ist,

2687
02:24:10,110 --> 02:24:12,110
eindeutig richtig eingestellt.

2688
02:24:21,460 --> 02:24:22,540
Kann ich das, kann ich das

2689
02:24:22,540 --> 02:24:24,120
systemweit speichern einfach?

2690
02:24:30,620 --> 02:24:31,400
Und jetzt funzt's?

2691
02:24:33,200 --> 02:24:34,740
Shit. Warum benutzt

2692
02:24:34,740 --> 02:24:36,100
der? Alter, was ist das für ein Kack?

2693
02:24:36,420 --> 02:24:38,160
Warum benutzt der so ein olles, so ein

2694
02:24:38,160 --> 02:24:40,040
olles outdatedes Dotnet?

2695
02:24:41,880 --> 02:24:42,720
Versteh ich nicht.

2696
02:24:46,560 --> 02:24:47,500
Es ist irgendein Bug.

2697
02:24:48,140 --> 02:24:49,740
Hier ist alles richtig eingestellt.

2698
02:24:50,560 --> 02:24:51,600
Ne, ne, der Rider

2699
02:24:51,600 --> 02:24:52,060
benutzt

2700
02:24:52,060 --> 02:24:55,540
die Runtime, die ich ja ausgewählt hab normalerweise.

2701
02:24:55,540 --> 02:24:57,260
Aber anscheinend macht's das in dem Fall

2702
02:24:57,260 --> 02:24:59,260
nicht, weil's irgendwie verbuggt ist.

2703
02:24:59,260 --> 02:25:01,140
Was ziemlich

2704
02:25:01,140 --> 02:25:19,360
suckt? Ich weiß es nicht.

2705
02:25:23,890 --> 02:25:25,610
Das sind doch die richtigen Settings, oder was?

2706
02:25:25,910 --> 02:25:32,260
Ich wüsste nicht, was hier dran...

2707
02:25:33,360 --> 02:25:34,180
Weil die Runtime

2708
02:25:34,180 --> 02:25:39,960
auch stimmt. Wir können hier nochmal die

2709
02:25:39,960 --> 02:25:41,080
Runtime hinzufügen.

2710
02:25:41,680 --> 02:25:43,640
MaxHome.net

2711
02:25:43,640 --> 02:25:48,100
Dotnet.

2712
02:25:49,060 --> 02:25:50,540
Custom. So, Apply.

2713
02:25:55,210 --> 02:25:56,090
Ah, jetzt geht's!

2714
02:26:00,850 --> 02:26:06,700
Jetzt geht's. Glaub ich zumindest.

2715
02:26:07,280 --> 02:26:08,340
Oder? Ja.

2716
02:26:09,200 --> 02:26:09,600
Memory.

2717
02:26:09,600 --> 02:26:09,680
Memory.

2718
02:26:14,020 --> 02:26:15,460
Nicht so was? Chatgear.

2719
02:26:15,880 --> 02:26:18,080
Ich benutze den Debugger in Rider sehr selten.

2720
02:26:19,500 --> 02:26:20,060
Haben die nicht so

2721
02:26:20,060 --> 02:26:21,940
eine Anzeige wie in Visual Studio Code, wo man

2722
02:26:21,940 --> 02:26:23,880
einfach sehen kann, live, was das für

2723
02:26:23,880 --> 02:26:32,410
Memory verwendet? Anscheinend

2724
02:26:32,410 --> 02:26:40,080
nicht, oder? Ja, stimmt auch wieder.

2725
02:26:44,860 --> 02:26:45,820
Aber es war blöd, dass das nicht

2726
02:26:45,820 --> 02:26:48,040
eingebaut ist, oder? Das ist dann tatsächlich

2727
02:26:48,040 --> 02:26:49,560
eine Sache, wo ich sagen würde,

2728
02:26:51,780 --> 02:26:53,260
da ist Visual Studio Code

2729
02:26:53,260 --> 02:26:55,180
angenehmer. Äh, nicht Visual Studio Code,

2730
02:26:55,280 --> 02:26:56,580
Visual Studio angenehmer.

2731
02:27:02,600 --> 02:27:08,550
Auf die drei Dots bei Debuggen.

2732
02:27:08,550 --> 02:27:09,690
Um eins hier, oder wo?

2733
02:27:10,190 --> 02:27:14,660
Da, da. Profile with Sampling.

2734
02:27:14,660 --> 02:27:22,190
Ah.

2735
02:27:22,190 --> 02:27:27,040
Excellent.

2736
02:27:27,040 --> 02:27:29,040
So, und wo sehe ich jetzt den,

2737
02:27:29,040 --> 02:27:31,040
den RAM-Verbrauch? Erst, wenn ich's

2738
02:27:31,040 --> 02:27:33,040
wieder geschlossen hab, oder

2739
02:27:33,040 --> 02:27:44,740
sehe ich das live?

2740
02:27:44,740 --> 02:27:46,740
Da gibt's noch eins für Memory. Echt?

2741
02:27:46,740 --> 02:28:01,280
Snapshot?

2742
02:28:01,280 --> 02:28:03,280
Ey, das ist aber nicht die Memory-Size, oder?

2743
02:28:03,280 --> 02:28:11,900
Boah, da blick ich nicht durch. Das ist mir

2744
02:28:11,900 --> 02:28:15,470
zu high IQ jetzt.

2745
02:28:15,470 --> 02:28:17,470
Das ist mir massified.

2746
02:28:17,470 --> 02:28:22,190
Zu high IQ. Was ist jetzt

2747
02:28:22,190 --> 02:28:28,600
CPU? Ja, ich hätte gerne Memory.

2748
02:28:28,640 --> 02:28:30,640
Das massified IQ Zeug hier.

2749
02:28:30,640 --> 02:28:34,340
Hier stoppen wir mal.

2750
02:28:34,340 --> 02:28:39,180
Profile with? Profile running

2751
02:28:39,180 --> 02:28:41,180
Process? Profile...

2752
02:28:41,180 --> 02:28:43,180
Sampling? Memory!

2753
02:28:43,180 --> 02:28:56,100
Ja, sowas

2754
02:28:56,100 --> 02:28:58,100
suche ich. Genau.

2755
02:28:58,100 --> 02:29:00,100
Excellent.

2756
02:29:00,100 --> 02:29:02,100
Genau das habe ich gesucht.

2757
02:29:02,100 --> 02:29:06,430
Dass man sieht, wie viel Speicher

2758
02:29:06,430 --> 02:29:08,430
das Ding verbraucht. Man sieht,

2759
02:29:08,430 --> 02:29:10,430
wir haben absolut null

2760
02:29:10,430 --> 02:29:12,430
Memory-Leaks. Gar nix.

2761
02:29:12,430 --> 02:29:18,240
Null Memory-Leaks.

2762
02:29:18,240 --> 02:29:20,240
Das ist einfach die ganze Zeit

2763
02:29:20,240 --> 02:29:22,240
immer auf 43,59.

2764
02:29:22,240 --> 02:29:24,240
So, wir

2765
02:29:24,240 --> 02:29:26,240
können das Ganze nochmal

2766
02:29:26,240 --> 02:29:29,550
checken, indem wir

2767
02:29:29,550 --> 02:29:31,550
sagen...

2768
02:29:31,550 --> 02:29:33,550
Wir lassen das Free mal weg, aber

2769
02:29:33,550 --> 02:29:35,550
wir machen...

2770
02:29:35,550 --> 02:29:37,550
Wir machen mal nen Sleep kurz rein

2771
02:29:37,550 --> 02:29:39,550
von

2772
02:29:39,550 --> 02:29:41,550
einer Millisekunde,

2773
02:29:41,550 --> 02:29:43,550
dass es...

2774
02:29:43,550 --> 02:29:45,550
Jetzt hatten wir's mehrfach gelaufen.

2775
02:29:45,550 --> 02:29:48,990
Dass es nicht sich komplett in die

2776
02:29:48,990 --> 02:29:50,990
in die Quere kommt,

2777
02:29:50,990 --> 02:29:52,990
ja. So, und jetzt sagen wir

2778
02:29:52,990 --> 02:29:54,990
Profile with Memory.

2779
02:30:05,920 --> 02:30:07,920
Ich hätte jetzt eigentlich erwartet...

2780
02:30:07,920 --> 02:30:16,350
Ich hätte jetzt eigentlich erwartet, dass

2781
02:30:16,350 --> 02:30:21,460
das irgendwie...

2782
02:30:21,460 --> 02:30:26,110
Es geht hoch! Ja, es geht hoch.

2783
02:30:26,110 --> 02:30:28,110
Guckt, Leute. Es geht hoch.

2784
02:30:28,110 --> 02:30:30,110
Langsam, weil ne Millisekunde

2785
02:30:30,110 --> 02:30:32,110
Sleep dazwischen... Und ne Millisekunde

2786
02:30:32,110 --> 02:30:34,110
ist verdammt viel, wenn der Millionen

2787
02:30:34,110 --> 02:30:36,110
Aufrufe pro Sekunde macht normalerweise.

2788
02:30:36,110 --> 02:30:38,110
Ja. Jetzt sieht man,

2789
02:30:38,110 --> 02:30:40,110
dass ein Memory-Leak drin ist. Guckt, es geht immer ein bisschen.

2790
02:30:40,110 --> 02:30:47,260
weiter hoch. Nice, nice.

2791
02:30:47,260 --> 02:30:49,260
Okay, heute... Das ist

2792
02:30:49,260 --> 02:30:51,260
wirklich nice, dass ihr

2793
02:30:51,260 --> 02:30:53,260
wusstet, wo das ist, weil...

2794
02:30:53,260 --> 02:30:55,260
Ähm...

2795
02:30:55,260 --> 02:30:57,260
Wir können aber sagen, Timespan

2796
02:30:57,260 --> 02:30:59,260
from

2797
02:30:59,260 --> 02:31:01,260
Microseconds

2798
02:31:01,260 --> 02:31:03,260
Jede Microsekunde

2799
02:31:03,260 --> 02:31:08,240
einfach... Bam.

2800
02:31:08,240 --> 02:31:14,180
Profile Memory. Oh ja,

2801
02:31:14,180 --> 02:31:16,180
guckt, Leute. Jetzt geht's

2802
02:31:16,180 --> 02:31:18,180
steil. Jetzt geht's steil.

2803
02:31:18,180 --> 02:31:20,180
Die Speichern aus Gigabyte.

2804
02:31:20,180 --> 02:31:22,180
1,2 Gigabyte.

2805
02:31:22,180 --> 02:31:24,180
1,4, 1,6, 1,7.

2806
02:31:24,180 --> 02:31:26,180
Ja, jetzt wird Memory-Leaked as fuck.

2807
02:31:26,180 --> 02:31:32,240
Jetzt hat man's...

2808
02:31:32,240 --> 02:31:34,240
Jetzt hat man's wirklich gut gesehen.

2809
02:31:34,240 --> 02:31:36,240
So, und jetzt machen wir das free rein.

2810
02:31:36,240 --> 02:31:38,240
Jetzt machen wir das free rein. Aber Chat,

2811
02:31:38,240 --> 02:31:40,240
da habt ihr mal was Gutes gezeigt.

2812
02:31:40,240 --> 02:31:42,240
Das wusste ich gar nicht, dass es das gibt.

2813
02:31:42,240 --> 02:31:44,240
Das ist mega praktisch dafür.

2814
02:31:44,240 --> 02:31:47,810
Rider ist einfach echt beste.

2815
02:31:47,810 --> 02:31:53,870
So, guckt. Und jetzt

2816
02:31:53,870 --> 02:31:55,870
kein Memory-Leak mehr. Es bleibt einfach mal

2817
02:31:55,870 --> 02:31:57,870
44 MB Memory total used.

2818
02:31:57,870 --> 02:32:04,960
Excellent, Leute.

2819
02:32:04,960 --> 02:32:06,960
Excellent, excellent.

2820
02:32:06,960 --> 02:32:08,960
Okay.

2821
02:32:08,960 --> 02:32:10,960
So, und was lernen wir daraus?

2822
02:32:10,960 --> 02:32:12,960
Okay, wir machen jetzt nochmal einen abschließenden...

2823
02:32:12,960 --> 02:32:14,960
Wie kriege ich denn das hier minimiert?

2824
02:32:14,960 --> 02:32:19,100
So, jetzt machen wir nochmal einen abschließenden Vergleich zu diesem ganzen Cample.

2825
02:32:19,100 --> 02:32:21,100
Wir schmeißen das hier raus.

2826
02:32:21,100 --> 02:32:27,550
Wir sagen...

2827
02:32:27,550 --> 02:32:29,550
Das da wird einmal aufgerufen.

2828
02:32:29,550 --> 02:32:33,440
Dann wird

2829
02:32:33,440 --> 02:32:35,440
interop

2830
02:32:35,440 --> 02:32:37,440
call

2831
02:32:37,440 --> 02:32:39,440
rust einmal aufgerufen.

2832
02:32:39,440 --> 02:32:41,440
interop call

2833
02:32:41,440 --> 02:32:45,140
rust 2

2834
02:32:45,140 --> 02:32:49,470
und

2835
02:32:49,470 --> 02:32:51,470
call go. So, jetzt lassen wir uns einmal noch

2836
02:32:51,470 --> 02:32:53,470
Benchmark-Ergebnisse generaten.

2837
02:32:55,470 --> 02:32:59,420
Zum Vergleich.

2838
02:32:59,420 --> 02:33:01,420
Das kommt weg. Also, den .NET

2839
02:33:01,420 --> 02:33:03,420
Vergleich, den machen wir mal wieder raus. Den braucht

2840
02:33:03,420 --> 02:33:05,420
eigentlich niemand an der Stelle. Wir wissen,

2841
02:33:05,420 --> 02:33:07,420
dass .NET schnell ist. Von .NET

2842
02:33:07,420 --> 02:33:09,420
zu .NET. Ja, also hier run.

2843
02:33:09,420 --> 02:33:11,420
Gucken wir uns das nochmal abschließend

2844
02:33:11,420 --> 02:33:13,420
an. Go 2.

2845
02:33:13,420 --> 02:33:15,420
Und

2846
02:33:15,420 --> 02:33:19,700
run rust

2847
02:33:19,700 --> 02:33:21,700
rust 2. Wobei

2848
02:33:21,700 --> 02:33:23,700
da tatsächlich

2849
02:33:23,700 --> 02:33:25,700
noch einen free machen müssen.

2850
02:33:25,700 --> 02:33:27,700
Der in go unter der Haube passiert.

2851
02:33:27,700 --> 02:33:29,700
Aber das ist ja nicht

2852
02:33:29,700 --> 02:33:34,540
schlimm. So.

2853
02:33:34,540 --> 02:33:36,540
Und jetzt können wir nochmal den Benchmark laufen

2854
02:33:36,540 --> 02:33:38,540
lassen. Und uns

2855
02:33:38,540 --> 02:33:40,540
freuen, dass wir eine tolle Benchmark-

2856
02:33:40,540 --> 02:33:55,120
Ausgabe kriegen.

2857
02:33:55,120 --> 02:33:57,120
Glaube ich zumindest, dass ich nichts falsch

2858
02:33:57,120 --> 02:34:02,740
gemacht habe. Oh, doch.

2859
02:34:02,740 --> 02:34:04,740
Run, run

2860
02:34:04,740 --> 02:34:06,740
rust.

2861
02:34:06,740 --> 02:34:08,740
Fehlt noch das normale

2862
02:34:08,740 --> 02:34:10,740
Call, rust.

2863
02:34:10,740 --> 02:34:15,840
So. Okay.

2864
02:34:15,840 --> 02:34:17,840
Wenn man jetzt noch richtig schreiben könnte, wäre perfekt.

2865
02:34:17,840 --> 02:34:25,890
Gibt es überhaupt go 2, ja?

2866
02:34:25,890 --> 02:34:27,890
Gibt es? Go 2 macht

2867
02:34:27,890 --> 02:34:29,890
das mit dem struct.

2868
02:34:29,890 --> 02:34:31,890
So. Ich bin mal gespannt.

2869
02:34:31,890 --> 02:34:33,890
Absoluter high-IQ-Stream, Leute.

2870
02:34:33,890 --> 02:34:35,890
Ja, stimmt schon. Übrigens schön, dass so

2871
02:34:35,890 --> 02:34:37,890
viele Leute wieder am Start sind. Ich meine,

2872
02:34:37,890 --> 02:34:39,890
das ist ja nicht selbstverständlich, dass

2873
02:34:39,890 --> 02:34:41,890
quasi die ganze Zeit über 200

2874
02:34:41,890 --> 02:34:43,890
Leute zugucken bei so einem Kram

2875
02:34:43,890 --> 02:34:50,530
hier, ja. Muss man beim

2876
02:34:50,530 --> 02:34:52,530
struct in rust nicht auch die

2877
02:34:52,530 --> 02:34:54,530
Namen anpassen? Oder hattest du das schon

2878
02:34:54,530 --> 02:34:56,530
gemacht?

2879
02:34:56,530 --> 02:34:58,530
Nee, warum brauche ich die Namen anpassen?

2880
02:34:58,530 --> 02:35:00,530
Was meinst du? Du meinst, weil das in

2881
02:35:00,530 --> 02:35:02,530
C-Sharp heißt

2882
02:35:02,530 --> 02:35:04,530
session rust und session go?

2883
02:35:04,530 --> 02:35:06,530
Das ist wurscht.

2884
02:35:06,530 --> 02:35:08,530
Wichtig ist einfach

2885
02:35:08,530 --> 02:35:10,530
nur, dass die, das Speicherlayout

2886
02:35:10,530 --> 02:35:12,530
das gleiche ist. Ich könnte es auch

2887
02:35:12,530 --> 02:35:14,530
kequate, qchat,

2888
02:35:14,530 --> 02:35:16,530
ayaya nennen, das struct.

2889
02:35:16,530 --> 02:35:18,530
Vollkommen egal, wie das in C-Sharp heißt.

2890
02:35:18,530 --> 02:35:20,530
Client ID ist der Name

2891
02:35:20,530 --> 02:35:22,530
auch egal. Der Typ ist das wichtige.

2892
02:35:22,530 --> 02:35:24,530
Also Hauptsache, dass das

2893
02:35:24,530 --> 02:35:26,530
struct das richtige Memory

2894
02:35:26,530 --> 02:35:28,530
Also, dass es in Rust A und B heißt, ist

2895
02:35:28,530 --> 02:35:30,530
vollkommen egal.

2896
02:35:30,530 --> 02:35:32,530
Wichtig ist, dass es ein struct ist,

2897
02:35:32,530 --> 02:35:34,530
dass als erstes ein bool kommt, als zweites

2898
02:35:34,530 --> 02:35:36,530
ein int, als drittes ein string oder sowas.

2899
02:35:36,530 --> 02:35:38,530
Das muss stimmen in beiden Sprachen.

2900
02:35:38,530 --> 02:35:40,530
Wie das heißt, ist vollkommen egal.

2901
02:35:40,530 --> 02:35:42,530
Weil

2902
02:35:42,530 --> 02:35:44,530
die Namen stehen da nirgendswo drinnen.

2903
02:35:44,530 --> 02:35:46,530
Was der sich einfach merkt, ist

2904
02:35:46,530 --> 02:35:48,530
die size von dem struct

2905
02:35:48,530 --> 02:35:50,530
und wie er das dann quasi

2906
02:35:50,530 --> 02:35:52,530
casten muss in den eigentlichen

2907
02:35:52,530 --> 02:35:54,530
Managetyp

2908
02:35:54,530 --> 02:35:56,530
von der Speicheraufteilung her.

2909
02:35:56,530 --> 02:36:03,870
Ja, ich mag die Streams auch.

2910
02:36:03,870 --> 02:36:05,870
Ich meine, ich kann natürlich nicht immer

2911
02:36:05,870 --> 02:36:07,870
so Sachen aus dem Ärmel schütteln.

2912
02:36:07,870 --> 02:36:09,870
Immer nur, wenn was ansteht.

2913
02:36:11,870 --> 02:36:13,870
Ich bin mal gespannt, was bei den Benchmarks rauskommt.

2914
02:36:13,870 --> 02:36:15,870
Wobei, eigentlich bin ich nicht gespannt.

2915
02:36:15,870 --> 02:36:17,870
Wir wissen alle, was rauskommt.

2916
02:36:17,870 --> 02:36:19,870
Rust schneller.

2917
02:36:19,870 --> 02:36:21,870
Um Längen schneller.

2918
02:36:21,870 --> 02:36:23,870
Guckt mal.

2919
02:36:23,870 --> 02:36:25,870
Die Funktion, hier,

2920
02:36:25,870 --> 02:36:27,870
die pure Rust Funktion aufrufen

2921
02:36:27,870 --> 02:36:29,870
ist einfach

2922
02:36:29,870 --> 02:36:31,870
124 Nanosekunden zu

2923
02:36:31,870 --> 02:36:33,870
8,5 Mikrosekunden.

2924
02:36:33,870 --> 02:36:35,870
Und

2925
02:36:35,870 --> 02:36:37,870
hier ist, Go braucht

2926
02:36:37,870 --> 02:36:39,870
für die Geschichten mit dem struct

2927
02:36:39,870 --> 02:36:41,870
18 Nanosekunden

2928
02:36:41,870 --> 02:36:43,870
18.000 Nanosekunden

2929
02:36:43,870 --> 02:36:45,870
Ne, ne Moment.

2930
02:36:45,870 --> 02:36:47,870
18.000 Nanosekunden, also 18

2931
02:36:47,870 --> 02:36:49,870
Millisekunden, sehe ich das richtig?

2932
02:36:49,870 --> 02:36:51,870
Chat? Ne, Mikrosekunden.

2933
02:36:51,870 --> 02:36:53,870
Mikrosekunden, nicht Millisekunden. Meine Güte!

2934
02:36:53,870 --> 02:36:55,870
Boah!

2935
02:36:55,870 --> 02:36:57,870
Einheiten!

2936
02:36:57,870 --> 02:36:59,870
18 Mikrosekunden und

2937
02:36:59,870 --> 02:37:01,870
Rust braucht einfach nur 2.

2938
02:37:01,870 --> 02:37:06,020
Ist schon ne ganze Ecke

2939
02:37:06,020 --> 02:37:15,920
schneller. Und hier

2940
02:37:15,920 --> 02:37:17,920
haben wir, und das dürfen wir nicht vergessen,

2941
02:37:17,920 --> 02:37:19,920
hier haben wir 2 Calls

2942
02:37:19,920 --> 02:37:23,360
drinne.

2943
02:37:23,360 --> 02:37:25,360
Wir haben, und es sind trotzdem

2944
02:37:25,360 --> 02:37:27,360
schneller, wir haben 2 Calls.

2945
02:37:27,360 --> 02:37:29,360
Wir haben den

2946
02:37:29,360 --> 02:37:31,360
eigentlichen Call zum

2947
02:37:31,360 --> 02:37:33,360
struct erzeugen und

2948
02:37:33,360 --> 02:37:35,360
wir haben den Call zum Free noch

2949
02:37:35,360 --> 02:37:42,320
drinne.

2950
02:37:42,320 --> 02:37:44,320
Nimm mal String als Type und nicht Pointer, lass ihn Free

2951
02:37:44,320 --> 02:37:46,320
Callen, sollt schneller sein. Ne.

2952
02:37:46,320 --> 02:37:48,320
Also ja, vielleicht

2953
02:37:48,320 --> 02:37:50,320
ist das ein Ticken schneller,

2954
02:37:50,320 --> 02:37:52,320
weil .NET das Free macht und nicht

2955
02:37:52,320 --> 02:37:54,320
Rust gecallt wird, aber

2956
02:37:54,320 --> 02:37:56,320
die Rust Docs sagen

2957
02:37:56,320 --> 02:37:58,320
explizit, man soll nicht

2958
02:37:58,320 --> 02:38:00,320
Free Callen, sondern soll das

2959
02:38:00,320 --> 02:38:02,320
zurück an Rust geben und Rust soll es

2960
02:38:02,320 --> 02:38:04,320
Freeen.

2961
02:38:04,320 --> 02:38:06,320
Sonst Memory Leak.

2962
02:38:06,320 --> 02:38:08,320
Es ist, also du hast Recht, das ist schnell, aber wir

2963
02:38:08,320 --> 02:38:10,320
können das ausprobieren.

2964
02:38:10,320 --> 02:38:12,320
Schade nix, wir können das ausprobieren.

2965
02:38:12,320 --> 02:38:14,320
Ich lass das, ich lass das mal weg.

2966
02:38:14,320 --> 02:38:16,320
Und wir ändern den hier zu String.

2967
02:38:16,320 --> 02:38:18,320
Wir haben ja gesehen, wir haben auch nahezu kein Memory Leak

2968
02:38:18,320 --> 02:38:20,320
und führen das ganze nochmal.

2969
02:38:20,320 --> 02:38:26,000
Ja.

2970
02:38:26,000 --> 02:38:28,000
Jetzt sollte er schneller sein, aber wir haben

2971
02:38:28,000 --> 02:38:30,000
potenziell ein Memory Leak. Zumindest

2972
02:38:30,000 --> 02:38:32,000
sagen die Rusts,

2973
02:38:32,000 --> 02:38:34,000
sagt die Rust Doku das, dass

2974
02:38:34,000 --> 02:38:36,000
wir dann einen Memory Leak haben.

2975
02:38:36,000 --> 02:38:38,000
Wenn wir das nicht so machen.

2976
02:38:38,000 --> 02:38:45,340
Also Arduino

2977
02:38:45,340 --> 02:38:47,340
plus Rust habe ich noch nie gemacht.

2978
02:38:47,340 --> 02:38:49,340
Ich bin eher der

2979
02:38:49,340 --> 02:38:51,340
ESP32 Enjoyer

2980
02:38:51,340 --> 02:38:53,340
und da ist Rust ja auch

2981
02:38:53,340 --> 02:38:55,340
nur, sagen wir mal so, sehr rudimentär.

2982
02:38:55,340 --> 02:38:57,340
Vieles geht ja dem Rust noch nicht. Ich glaube Rust und

2983
02:38:57,340 --> 02:38:59,340
Wifi geht glaube ich auch noch nicht

2984
02:38:59,340 --> 02:39:01,340
auf dem ESP32.

2985
02:39:01,340 --> 02:39:10,610
Genau, das

2986
02:39:10,610 --> 02:39:12,610
genau deshalb denke ich auch.

2987
02:39:12,610 --> 02:39:14,610
Es kann ja auch möglich sein,

2988
02:39:14,610 --> 02:39:16,610
dass Rust nicht einfach

2989
02:39:16,610 --> 02:39:18,610
das Memory

2990
02:39:18,610 --> 02:39:20,610
allocated über

2991
02:39:20,610 --> 02:39:22,610
das normale C Maloc,

2992
02:39:22,610 --> 02:39:24,610
sondern irgendwas eigenes macht.

2993
02:39:24,610 --> 02:39:26,610
Da bringt ja normales C Free an der Stelle

2994
02:39:26,610 --> 02:39:28,610
ja auch wenig, wenn da noch Sachen

2995
02:39:28,610 --> 02:39:30,610
nestet, irgendwie anderweitig allockiert sind,

2996
02:39:30,610 --> 02:39:32,610
von denen nur Rust was weiß.

2997
02:39:32,610 --> 02:39:34,610
Also das ergibt schon Sinn.

2998
02:39:34,610 --> 02:39:36,610
Und dass das auch ein Memory Leak hat,

2999
02:39:36,610 --> 02:39:38,610
gehe ich auch von aus, aber es dürften

3000
02:39:38,610 --> 02:40:00,540
wahrscheinlich nur ein paar Bytes sein.

3001
02:40:00,540 --> 02:40:02,540
Über Unsafe sollte WLAN gehen.

3002
02:40:02,540 --> 02:40:04,540
Sofern man die

3003
02:40:04,540 --> 02:40:06,540
eingebauten

3004
02:40:06,540 --> 02:40:08,540
ESP C Sachen aufrufen kann

3005
02:40:08,540 --> 02:40:10,540
aus Rust, dann vielleicht, ja.

3006
02:40:10,540 --> 02:40:17,380
Aber ehrlich gesagt muss ich sagen,

3007
02:40:17,380 --> 02:40:19,380
Plattform IO

3008
02:40:19,380 --> 02:40:21,380
und auch wenn da unter der Haube

3009
02:40:21,380 --> 02:40:23,380
C++ für ein ESP32 ist, ist

3010
02:40:23,380 --> 02:40:32,770
recht angenehm.

3011
02:40:32,770 --> 02:40:34,770
Ich glaube ehrlich gesagt, dass in dem Fall C++

3012
02:40:34,770 --> 02:40:36,770
und ich sag's nur ungern, ja,

3013
02:40:36,770 --> 02:40:38,770
aber C++ für solche Sachen angenehmer ist.

3014
02:40:38,770 --> 02:40:40,770
Rust plus Arduino, gibt's

3015
02:40:40,770 --> 02:40:42,770
da denn ein gutes Projekt für?

3016
02:40:42,770 --> 02:40:44,770
Wir hatten das geschrieben.

3017
02:40:44,770 --> 02:40:46,770
Gibt's da ein gutes Projekt für?

3018
02:40:46,770 --> 02:40:48,770
Kannst mal schicken, vielleicht können wir uns das wirklich angucken.

3019
02:40:48,770 --> 02:40:50,770
So.

3020
02:40:50,770 --> 02:40:55,100
Leute, ich weiß nicht

3021
02:40:55,100 --> 02:40:57,100
warum, aber das Ganze ist jetzt langsamer geworden.

3022
02:40:57,100 --> 02:41:04,770
Wenn wir C Sharp

3023
02:41:04,770 --> 02:41:12,660
freeen lassen. Okay?

3024
02:41:12,660 --> 02:41:14,660
Also es ist schneller,

3025
02:41:14,660 --> 02:41:16,660
es ist schneller Rust freeen zu lassen

3026
02:41:16,660 --> 02:41:18,660
als, als

3027
02:41:18,660 --> 02:41:20,660
C Sharp freeen zu lassen.

3028
02:41:20,660 --> 02:41:26,910
Okay.

3029
02:41:26,910 --> 02:41:30,220
Ah ja.

3030
02:41:30,220 --> 02:41:32,220
Meinetwegen, soll mir recht sein.

3031
02:41:32,220 --> 02:41:39,180
Okay. Der Benchmark

3032
02:41:39,180 --> 02:41:41,180
hier unten ist aber für meine Sachen

3033
02:41:41,180 --> 02:41:43,180
eh nicht sonderlich relevant,

3034
02:41:43,180 --> 02:41:45,180
weil die Funktion, die ich wirklich schnell

3035
02:41:45,180 --> 02:41:47,180
in der Schleife aufrufe, ist nicht

3036
02:41:47,180 --> 02:41:49,180
was Strings oder so returnt,

3037
02:41:49,180 --> 02:41:51,180
sondern das returnt gar nichts.

3038
02:41:51,180 --> 02:41:53,180
Bekommt einfach nur einen

3039
02:41:53,180 --> 02:41:55,180
Pointer als Parameter übergeben,

3040
02:41:55,180 --> 02:41:58,940
den es auch nicht selbst freeen muss.

3041
02:41:58,940 --> 02:42:00,940
Also insofern ist das hier

3042
02:42:00,940 --> 02:42:02,940
eigentlich für mich der relevantere

3043
02:42:02,940 --> 02:42:04,940
Benchmark. Und da ist Rust

3044
02:42:04,940 --> 02:42:06,940
meilenweit schneller. .NET ist noch

3045
02:42:06,940 --> 02:42:08,940
einen Ticken schneller, also .NET zu

3046
02:42:08,940 --> 02:42:10,940
.NET ist logischerweise schneller als .NET

3047
02:42:10,940 --> 02:42:12,940
zu Rust, aber Rust ist um

3048
02:42:12,940 --> 02:42:14,940
Welten schneller als Go.

3049
02:42:14,940 --> 02:42:16,940
Überrascht mich

3050
02:42:16,940 --> 02:42:18,940
aber auch nicht, weil ich wusste, dass C Go

3051
02:42:18,940 --> 02:42:20,940
langsam ist und ich wollte einfach mal gucken,

3052
02:42:20,940 --> 02:42:22,940
ob es

3053
02:42:22,940 --> 02:42:24,940
mittlerweile besser geworden ist.

3054
02:42:24,940 --> 02:42:26,940
Ich würde sagen, es ist besser geworden, aber

3055
02:42:26,940 --> 02:42:28,940
es ist immer noch ziemlich lahm,

3056
02:42:28,940 --> 02:42:30,940
wenn man millionenfach das aufruft.

3057
02:42:30,940 --> 02:42:32,940
Wenn man das jetzt einfach nur ein paar tausend Mal

3058
02:42:32,940 --> 02:42:34,940
aufruft oder so, pff, drauf geschissen,

3059
02:42:34,940 --> 02:42:36,940
dann macht es ein bisschen Overhead auch nicht aus.

3060
02:42:38,940 --> 02:42:40,940
Aber wenn man das millionenfach pro Sekunde aufruft,

3061
02:42:40,940 --> 02:42:42,940
dann macht es schon einiges aus.

3062
02:42:42,940 --> 02:42:44,940
Was ich übrigens auch nicht machen werde.

3063
02:42:44,940 --> 02:42:46,940
Also.

3064
02:42:46,940 --> 02:42:48,940
Jetzt könnte ich auch einfach

3065
02:42:48,940 --> 02:42:50,940
die Go Library verwenden.

3066
02:42:50,940 --> 02:42:52,940
Aber warum? Ich meine,

3067
02:42:52,940 --> 02:42:54,940
wir können, das machen wir dann in einem

3068
02:42:54,940 --> 02:42:56,940
der nächsten Streams, da machen wir dann

3069
02:42:56,940 --> 02:42:58,940
WebRTC in Rust.

3070
02:42:58,940 --> 02:43:03,920
Sind auch Aufrufe von

3071
02:43:03,920 --> 02:43:05,920
Go nach C langsam?

3072
02:43:05,920 --> 02:43:09,300
Ja, ja, auch.

3073
02:43:09,300 --> 02:43:11,300
Theoretisch sind die einen Ticken schneller.

3074
02:43:11,300 --> 02:43:13,300
Also früher war es so, Aufrufe von

3075
02:43:13,300 --> 02:43:15,300
Go nach C waren langsam.

3076
02:43:15,300 --> 02:43:17,300
Also auch

3077
02:43:17,300 --> 02:43:19,300
langsamer als von anderen Sprachen.

3078
02:43:19,300 --> 02:43:21,300
Von anderer Sprache nach C.

3079
02:43:21,300 --> 02:43:23,300
Aber

3080
02:43:23,300 --> 02:43:25,300
in Go rein callen

3081
02:43:25,300 --> 02:43:27,300
von C aus, war noch mal

3082
02:43:27,300 --> 02:43:29,300
eine Ecke langsamer.

3083
02:43:29,300 --> 02:43:31,300
Mittlerweile, mittlerweile ist es glaube ich

3084
02:43:31,300 --> 02:43:33,300
ungefähr gleich langsam.

3085
02:43:33,300 --> 02:43:35,300
Aber das ist auch langsam.

3086
02:43:35,300 --> 02:43:37,300
Es ist vielleicht nicht ganz so langsam

3087
02:43:37,300 --> 02:43:39,300
wie von anderer Sprache zu Go.

3088
02:43:39,300 --> 02:43:41,300
Aber auch langsam.

3089
02:43:41,300 --> 02:43:43,300
Go hat mit,

3090
02:43:43,300 --> 02:43:45,300
mit den langsamsten Interop

3091
02:43:45,300 --> 02:43:47,300
mit anderen Sprachen

3092
02:43:47,300 --> 02:43:49,300
von allen Programmiersprachen, die es gibt.

3093
02:43:49,300 --> 02:43:51,300
Go an sich ist relativ flott.

3094
02:43:51,300 --> 02:43:53,300
Aber sobald du quasi aus

3095
02:43:53,300 --> 02:43:55,300
Go raus musst oder rein musst

3096
02:43:55,300 --> 02:43:57,300
in Go von anderen Sprachen,

3097
02:43:57,300 --> 02:43:59,300
was ja alles immer über irgendein C-Interface

3098
02:43:59,300 --> 02:44:01,300
geht, da ist Go richtig langsam.

3099
02:44:01,300 --> 02:44:03,300
Was auch ein Problem ist,

3100
02:44:03,300 --> 02:44:05,300
weil die ganzen

3101
02:44:05,300 --> 02:44:07,300
Wrapper-Libraries für SQLite

3102
02:44:07,300 --> 02:44:09,300
oder für irgendwelche anderen

3103
02:44:09,300 --> 02:44:11,300
Low-Level-Sachen, die sind

3104
02:44:11,300 --> 02:44:13,300
potenziell in Go einfach arschlangsam.

3105
02:44:13,300 --> 02:44:15,300
Weil

3106
02:44:15,300 --> 02:44:17,300
C-Go langsam ist.

3107
02:44:17,300 --> 02:44:19,300
Also wenn man ordentlich Load drauf hat.

3108
02:44:19,300 --> 02:44:23,500
Deswegen gibt es beispielsweise

3109
02:44:23,500 --> 02:44:25,500
für SQLite

3110
02:44:25,500 --> 02:44:27,500
ein Projekt, das SQLite

3111
02:44:27,500 --> 02:44:29,500
transpilt

3112
02:44:29,500 --> 02:44:31,500
nach Go,

3113
02:44:31,500 --> 02:44:33,500
damit es native Go

3114
02:44:33,500 --> 02:44:35,500
kompiliert werden kann und nicht

3115
02:44:35,500 --> 02:44:37,500
mit C-Function-Calls.

3116
02:44:37,500 --> 02:44:39,500
Weil SQLite unter

3117
02:44:39,500 --> 02:44:41,500
ordentlich Last wohl

3118
02:44:41,500 --> 02:44:43,500
eine nicht zu unterschätzende

3119
02:44:43,500 --> 02:44:45,500
Overhead hat, weil es sehr viele

3120
02:44:45,500 --> 02:44:47,500
C-Calls macht in Go.

3121
02:44:47,500 --> 02:44:49,500
Weil SQLite halt eine C-Library ist.

3122
02:44:49,500 --> 02:44:51,500
Ja.

3123
02:44:51,500 --> 02:44:53,500
Also macht Probleme.

3124
02:44:53,500 --> 02:44:55,500
Go ist schnell, solange man sich

3125
02:44:55,500 --> 02:45:05,980
innerhalb von Go bewegt.

3126
02:45:05,980 --> 02:45:07,980
Und gibt es noch ein paar Examples?

3127
02:45:07,980 --> 02:45:18,020
Examples?

3128
02:45:18,020 --> 02:45:21,330
Plattform-IO. Nice.

3129
02:45:21,330 --> 02:45:23,330
Haben die das jetzt offiziell in

3130
02:45:23,330 --> 02:45:25,330
Plattform-IO drinne?

3131
02:45:25,330 --> 02:45:27,330
Ne, das ist das ganz normale

3132
02:45:27,330 --> 02:45:35,410
ESP-IDF.

3133
02:45:35,410 --> 02:45:39,100
Source. Main-AS.

3134
02:45:39,100 --> 02:45:41,100
Ok, ja, da haben sie Wrapper um Sachen

3135
02:45:41,100 --> 02:45:43,100
gebaut. Ok. Ja, also anscheinend

3136
02:45:43,100 --> 02:45:48,460
kann man...

3137
02:45:48,460 --> 02:45:50,460
Also anscheinend kann man auch

3138
02:45:50,460 --> 02:45:52,460
das programmieren. Aber ganz im Ernst, das

3139
02:45:52,460 --> 02:46:05,310
tu ich mir dann an.

3140
02:46:05,310 --> 02:46:07,310
Ja. Nice Chat.

3141
02:46:07,310 --> 02:46:09,310
Fast 3 Stunden. Heute ganz schön lang

3142
02:46:09,310 --> 02:46:11,310
gestreamt worden. Morgen 3 Stunden, jetzt 3 Stunden.

3143
02:46:11,310 --> 02:46:27,490
Ist Moris Video.

3144
02:46:27,490 --> 02:46:34,060
Ja. Chat.

3145
02:46:34,060 --> 02:46:36,060
Wir sind fertig für heute.

3146
02:46:36,060 --> 02:46:38,060
Schön, dass ihr am

3147
02:46:38,060 --> 02:46:40,060
Start wart.

3148
02:46:40,060 --> 02:46:42,060
Guckt mal kurz, ob wir irgendjemand

3149
02:46:42,060 --> 02:46:47,300
hosten können.

3150
02:46:47,300 --> 02:47:11,920
Ich hoffe euch hat der Stream heute gefallen.

3151
02:47:11,920 --> 02:47:16,510
Wir haben... Ok.

3152
02:47:16,510 --> 02:47:18,510
Hier haben wir einen am Start.

3153
02:47:18,510 --> 02:47:20,510
Vielleicht hoste ich den. Zeigt mal.

3154
02:47:20,510 --> 02:47:24,270
Der macht...

3155
02:47:24,270 --> 02:47:26,270
Jaja, Fake E-Mail.

3156
02:47:26,270 --> 02:47:28,270
Der macht Defop plus

3157
02:47:28,270 --> 02:47:30,270
Kubernetes.

3158
02:47:34,270 --> 02:47:36,270
Oh. Der...

3159
02:47:36,270 --> 02:47:38,270
Ich glaube der macht auch gerade seinen Stream aus,

3160
02:47:38,270 --> 02:47:40,270
weil er eben Stream Manager ist.

3161
02:47:40,270 --> 02:47:42,270
Na gut. Dann nicht.

3162
02:47:42,270 --> 02:47:44,270
Ok. Chat.

3163
02:47:44,270 --> 02:47:46,270
Dann gehe ich auf. Bis dann. Macht's gut.

3164
02:47:46,270 --> 02:47:49,780
See you. Winke, winke.
