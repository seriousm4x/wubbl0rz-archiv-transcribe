ist ja eigentlich dass ich die letzten die letzte woche ja doch die letzte woche habe
ich 600 euro tierarzt rechnung ausgegeben aber ich will ja dass es gut geht aber das
ist schon echt ordentlich wenn man hier ist nicht so wild ja die kohle muss irgendwo hin
aber schon ganz schön heftig wenn man sich überlegt wie macht man das wenn man jetzt
nicht so viel geld zum fenster rausschmeißen kann wenn es war nicht so fenster raus geschmeißt war
für die katze zu sagen aber 600 euro tierarzt kostet schon krass ich war ich habe einmal
einmal habe ich das will keine neue katze einmal waren die hier haben sich chico angeguckt dann
war ich beim augenarzt mit chico moment die musik ist zu laut
dann war ich dann war ich beim augenarzt mit chico also also das ding war ich habe letzte
woche hat chico hier auf dem schrank war nicht vor allem an letzte woche hat chico letztes letzte
wochenende hat chico hier auf dem schrank gehockt dann hat so ein bisschen habe ich gesehen jetzt
ein bisschen blut im auge gehabt denkt man sich ja erst mal nichts großartiges dabei man kann
sich gekratzt haben oder irgendwie sonst was also und rechts bisschen blut im auge aber nachdem
chico ja bekanntermaßen bisschen nierenprobleme hatten auch nur diätfutter und alles
kriegt chico ist ja 13 mittlerweile schon ist jetzt zwar kein alter wirklich für katzen aber
schon alt also sind alte können durchaus älter werden aber auf jeden fall schon schon oma ja
und zumindest dann habe ich im internet geguckt dass gerade katzen mit nierenerkrankungen oftmals
auch unser bluthochdruck leiden und bluthochdruck bei katzen sehr oft auf das auge geht und dass das
auge blutet und manchmal löst sich auch tatsächlich die netzhaut aus richtig krass zumindest habe ich
dann war ich beim tierarzt wo wir sonst hingehen und habe gesagt hier katzen blut im auge und
blutdruck messen haben die irgendwie gesagt doch nur wir können gar keinen blutdruck messen fand
ich schon sehr pepega dass sie das so alles überhaupt nicht interessiert hat habe ich mir
gesagt so gut dann neuen tierarzt suchen habe ich mir neuen tierarzt gesucht und die sind tatsächlich
alle schon da und das ist ja schon bei mir so an erster anstelle das blutdruck messen ist am besten
wenn die katz halt entspannt ist leider war chico sehr unkooperativ was blutdruck messen angeht da
mussten sie die erst mal in ihr auto hocken und dann haben sie da gemessen und chico hat halt
richtig krass hohen blutdruck schickte hat er schickte hat über 250 blutdruck normalerweise
ist 150 gerade so noch okay schickte super krass hohen blutdruck jetzt kriegt chico zusätzlich zu ihren schilddrüsen und Nierenmedikamenten
noch Blutdrucksenkende Mittel.
Und für das Blut im Auge war ich mit der Katze beim Augenarzt.
Ja, es gibt Augenärzte für Katzen.
Die hat das Auge untersucht und hat gemeint,
oh ja, also da ist schon ein bisschen blutig
und hat auch nochmal Blutdruck gemessen, war auch wieder viel zu hoch.
Und jetzt muss sie noch ein paar Kortison-Tabletten schlucken,
dass das alles wieder schön abschwillt im Auge
und die Netzhaut auf jeden Fall dran bleibt und sie nicht blind wird.
Und jetzt kriegt die halt Blutdrucksenkende Mittel.
Und morgen gehe ich schon wieder zum Tierarzt.
Und Mittwoch wieder zum Augenarzt.
Also ich habe wahrscheinlich innerhalb von 14 Tagen
bin ich 1000 Euro los, was Tierarzt angeht.
Keck-Weight.
Wie alt ist die? Die ist 13.
Die ist schon älter.
Da haben die ja öfters mal die ein oder anderen Probleme.
Oh nee, C++, geh mal weg.
Ich mach, ich mach, don't save, ich mach weg.
Gibt es eine Krankenversicherung?
Ey, keine.
Keine Ahnung, ob es das gibt, aber wenn, ist es wahrscheinlich so unsinnig teuer.
Ich bezahle das selbst.
Irgendwo muss die Kohle ja hin.
Also ich hoffe, dass am, also das ist morgen, wenn Blutdruck gemessen wird,
dass, also wir waren ja da nochmal letzte Woche Blutdruck messen, Blutdruck messen
und zwar am, am Freitag, da war er schon runter, ein bisschen, aber noch nicht genug.
Aber das dauert immer ein bisschen, bis das Blutdruckmedikament bei der Katze im Blut ist.
Bei Menschen übrigens nicht anders.
Bis das alles ordentlich wirkt.
Chico bewegt sich auch viel zu wenig, ja.
Chico hängt immer nur rum.
Und ich hoffe, der Blutdruck ist da noch ein bisschen runtergegangen
und beim Augenrat stellen sie fest, dass alles wieder, alles wieder soweit okay ist.
Und, weil, ganz ehrlich, die Katze kriegt halt sehr viele Medikamente
und die Katze hat keinen Bock da drauf, die zu nehmen.
Ja, du hast aber sicherlich nicht einmal 80 Euro bezahlt, oder?
Ist er Freigänger?
Nee, es ist eine Sie, auch wenn sie Chico heißt.
Das ergibt keinen Sinn, aber was weiß ich, was die Vorbesitzer sich dabei geben.
Ich weiß nicht, ob sie das gedacht haben.
Kann man aber wahrscheinlich auch nur für die junge, für eine junge Katze abschließen,
wenn du das für eine 13-jährige Katze abschließt.
Da wollen die fast Versicht dafür haben, Alter.
Das ist so, wie wenn du mit 70 sagst, ich möchte eine Krankenversicherung abschließen.
Nee, ist sie nicht.
Das einzige, was Chico kann, ist, die kann hier auf die Terrasse, aber die Terrasse hat so ein Netz drumherum.
Ich bin ganz schön kaputt heute.
Gestern Abend, ähm, ja, wie gesagt, ich bin ganz schön kaputt, gestern Abend Fahrrad gefahren.
Ich bin ganz schön kaputt, gestern Abend Fahrrad gefahren.
45 Minuten volle Pulle.
Heute Morgen, zehn Kilometer gerannt, ich merke es echt in den Beinen.
Es reicht erst, morgen mache ich nix.
Morgen mache ich gar nix.
Reicht echt ...
Ich merke es auch voll im Schienbein.
Du warst heute Morgen nicht da, gell.
Heute Morgen hat mich die Waage übelst jebaitet.
Ich bin, ich bin rüber gegangen, hab mich auf die Waage gestellt, hatte noch Socken und Unterhose an.
Da hat die Waage 90 Kilo angeosaurs.
gezeigt. Dann bin ich
weg, hab das Handy geholt, zum
Fotografieren, hab Socken und Unterhose ausgezogen
und hab 90,2.
90,3.
Das heißt, ich hatte weniger an, hab mehr gewogen. Null.
War nix. Es war
ganz knapp. Es war ganz knapp über
90. Das heißt, noch ein paar
Wochen, also bis Ende des Jahres
sollte ich dieses Mal unter 90
auf jeden Fall schaffen, wenn das so weiter geht.
Ja, wird's ja auch.
Zwar nicht so krass wie zu
Corona-Zeiten, wo ich
angefangen hab mit allem.
Ja.
Man darf nicht vergessen, dass wenn man
sich ordentlich bewegt,
man kriegt ja auch Muskel.
Man tradet ja, sag mal, man tradet
ja auch ein bisschen Speck gegen Muskel.
Ja, kenn ich. Hab ich aber noch
nie großartig was mitgemacht.
Excellent. So.
Dann. Erstmal
Finger aufwärmen. Für krasse
Progress-Action.
So. Finger aufgewärmt.
Auf geht's.
Ich zeige euch mal, für alle, die nicht
dabei waren, war jemand beim letzten Rust-Stream
dabei und hat mir
zugeguckt, wie ich nix gecheckt hab.
Ähm.
Ich zeige euch
kurz, was Sache ist und
heute wird's nicht so super
kompliziert, weil erstens bin ich ziemlich kaputt
und hab wahrscheinlich auch jetzt 19 Uhr
nicht mehr die größten
Brain-Resources übrig.
Heute versuchen wir das mal ein bisschen
aufzuräumen. Dazu
braucht man aber auch Rust.
Spezialitäten.
Und dementsprechend
schauen wir mal.
So. Also. Hab ich denn jetzt, hab ich jetzt
Package-Updates gemacht. Arch-Linux
by the way, falls jemand Fragen hat.
Schon wieder Package-Updates. Meine Güte.
Hast du mal zwei Minuten keine Package-Updates
gemacht? Ja.
Arch use ich, by the way.
Packages. 171.
Ich weiß wahrscheinlich von gerade mal
20 oder so, dass ich die
wirklich wissentlich jetzt zerlegt hab.
Übrigens, Leute. Jetzt wo ich
TTF-Trimojis sehe.
Pock. Pass mal auf. Wisst ihr, was ich gesehen hab?
Es gibt bald eine neue Trimoji-Version
auf Github. Endlich
neue, endlich neue
Unicode 15 Emojis.
Trimoji Github.
Und zwar Discord
macht Giga-Chat-Move.
Ja.
Discord macht Giga-Chat-Move
und addet
den Großteil der fehlenden Unicode
15 Emojis.
Steven from Discord
ist am Start.
Steven from Discord
und sagt, ihr Inhouse-Artist
der Kevin
VKudam
geiler Name
VKudam
hat Emojis
open sourced für Trimoji.
Also, wer sich fragt,
was das Problem ist eigentlich.
Das Ding ist, Trimoji ist eigentlich
der Twitter-Emoji-Fond.
Das Dumme ist nur, seit Elon Musk
von Twitter übernommen hat,
wurde jegliches
Open Sourcing
von ihrem Emoji-Fond eingestellt.
Und dementsprechend können
die neuesten Emojis nicht einfach kopiert
werden von Twitter, weil die halt copyrighted
sind bei Twitter oder bei X.
Dementsprechend haben das Leute
das gewonnen. Witzigerweise, der Fork
auf Github
ist von alten Github, äh nicht Github,
der Fork auf Github
von Trimoji ist von
alten Twitter-Mitarbeitern,
die rausgeschmissen wurden von Twitter
und sich damals um den
Emoji-Fond gekümmert haben.
So, und die Discord-Leute
haben neue Emojis beigesteuert.
Das sind nahezu, ich glaube, das sind jetzt nahezu alle
Unicode 15 Emojis.
Das heißt, sie müssen jetzt nur noch einen neuen Fond bauen.
Das Merchen und neuen Fond bauen.
Und dann gibt es endlich
eine neue Version von Trimoji,
die Unicode
15 kompatibel ist. Wie sieht's eigentlich
mit Unicode 16 aus? Nur mal so.
...
...
Okay, kommt September 2024 raus?
Aha, es gibt neue,
guck mal, Unicode 2024 gibt's
neue, gibt's neue Emojis,
gucken wir mal, ob's da schon welche gibt, zum angucken.
Fingerprint Emoji
gibt's noch kein Beispiel für.
Emoji 16, gibt's noch nicht.
Face with Bags
under Eyes gibt's dann.
Aha, alles klar, gibt's auch noch keine Implementierung.
Splatter. Okay.
Leafless Tree.
Harp,
eine Schaufel
und irgendwelche
Veganer-Sachen.
Das hat unbedingt Unicode 16
braucht das. Alles klar.
Da bin ich wirklich froh, dass hier
Discord-Leute den
Giga-Chat-Modus gezündet haben
und neue Emojis
beisteuern. Ich meine, dann heißt das Ding zwar
Twimoji, hat aber nicht die
Emojis von Twitter, wobei Twitter auch nicht mehr
Twitter, sondern X heißt, deswegen ist es eigentlich okay so.
Naja, wie dem auch
sei. Also Chat, weiter geht's.
Hier sind wir stehen geblieben. Ich zeige euch,
wie wir stehen geblieben sind und zwar das Ziel ist,
weil das immer die Frage ist, was machen wir heute.
Das Ziel ist, eine WebRTC-Anwendung
zu bauen mit Low-Level
WebRTC in Rust.
Frontend ist ein bisschen
HTML-JavaScript.
Backend, weil ein bisschen mehr Backend
erforderlich ist, als nur Seite ausliefern,
ist eine .NET-Anwendung und die .NET-Anwendung
macht Interop mit
Rust.
So, und ich zeige euch
das Ganze mal. Wir machen
hier mal Rust auf.
Mal kurz
in die JetBrains-Toolbox
looken, ob
es neue
Versionen von den IDEs
gibt. Massive.
Es gibt neue Versionen von PyCharm und
Golan. Ja.
Brauche ich jetzt ehrlich
gesagt. Ja, komm, wir machen Update.
So, dann müssen
wir Rider starten.
Frontend mit dem Framework.
Oder Plain. In dem Fall Plain,
weil das Frontend irgendwie gerade 30
Zeichen ist. Äh, 30 Zeilen
oder so ist. Da ist nicht viel zu sehen.
Ich zeige dir gleich, wie das aussieht.
Äh, Backend.
Also das ist, das hier ist aktuell
alles, was das Frontend beinhaltet.
Das macht zur Zeit nichts anderes wie
WebRTC-Verbindungsaufbau. Und dann
auf die Webseite schreiben.
Oh, laggy.
Alter, wie das...
What the f...
Das Update...
Alter!
Jetbrains.
Java. Keg-Java.
Was ist da los?
Die brauchen beim Updaten der IDEs einfach mal
alle 8 CPU-Cores.
So gehört sich das.
Ich hab das All-Products-Pack, ja.
Was genau macht das da jetzt? 3 Stunden
beim Updaten der... Oh, es gibt eine neue
C-Line. Interesting.
So.
Update ist gelaufen.
Gut. Also, ich zeige
euch mal, wie das aktuelle aussieht. Das Frontend
ist äußerst unspektakulär.
Da sieht man nicht viel, aber ich zeige es euch
mal trotzdem.
.NET run.
Aktuell sieht das...
Äh, Moment. Moment.
Moment. Es geht ja gerade gar nicht.
Geht ja gerade gar nicht, weil ich gestern
in weiser Voraussicht die Hälfte
auskommentiert habe.
Kegwait. Die wir jetzt wieder einkommentieren
müssen. Wait a minute. Ich glaube,
es ist gerade kaputt. Wir haben doch gestern
noch mit UIDs rumgewurschtelt, oder?
Ja, es ist gar kein
UIN64 mehr. Moment. Das wird jetzt gar nicht...
gar nicht funktionieren. Lull.
Pass mal auf, das crasht jetzt.
Okay. Wir haben das
etwas unfertig hinterlassen gestern.
Das Ganze.
Wir haben so halb... Wir haben so halb aufgehört.
Zwischendrin.
Zumindest, dass das Frontend...
Oh, das müssen wir...
Wir müssen gerade mal kurz eine Sache im Frontend
machen. Das ist mir viel zu hell.
Ähm, Style.
Wie macht man das? Background,
Color.
Und jetzt...
Keine Ahnung.
Cray oder sowas.
Okay, schon besser.
Okay, ja, ja, okay. Ein bisschen...
Nicht ganz so anstrengend.
Okay.
Also das Frontend ist äußerst simpel.
Das ist alles an JavaScript.
Der baut eine WebRTC-Verbindung
auf. Im Detail werdet ihr es
wahrscheinlich gleich sehen. Dann ist das
hier das .NET-Backend.
Moment, das hier ist das .NET-Backend. Da passiert auch nicht viel.
Und das hier ist die Rasteranwendung.
Das ist da, wo wir heutzutage rumbauen werden.
Und ich glaube, ich glaube, Chat, wir müssen das erst mal wieder funktional machen, bevor wir jetzt weitermachen.
Deswegen ich schmeiß diesen Krempel hier mit mit der UID schmeiß ich wieder raus.
Wir machen da wieder ein U64 draus, sodass, sodass er erst mal erst mal kurz machen, dass es wieder funktioniert.
Okay, ja, wozu brauchst du das denn?
Erstens, um bisschen Rust zu lernen.
Und zweitens, weil ich vorhabe, alle meine...
meine Webcams Realtime zu streamen auf der Webseite.
ID, ID kommt hierher.
ID ist einfach 1, jetzt hardcoded, kekwait.
Gucken, ob's, ob's noch, ob's compiled.
Cargo.
Nope.
UID mal wieder rausschmeißen.
1.
Und wo hat er jetzt noch Schmerzen?
Client ID.
Äh?
Pound.
Die.
Wie kommt er da drauf, dass es ein U128 sein soll?
Will er mich jibäden?
Ach so, weil hier oben die Collections noch U128 sind, gell?
Ja, okay, alles klar.
Nice.
Und jetzt, okay, was ist jetzt für ein Problem?
Und?
71.
Pound.
128, ah, U64.
U64.
So.
Ich glaube, wir sollten nirgendswo mal U128 benutzen.
So, und wenn das jetzt funktioniert, dann sollte auch alles wieder klappen und das sollte laufen.
Zwar nicht perfekt, aber laufe ich sein?
Oh Mann!
Alter, ich hab's kaputt gemacht gestern.
Jetzt müssen wir das, jetzt müssen wir...
Jetzt müssen wir das erst mal fixen wieder.
Okay, also.
Na geil, na geil.
Jetzt haben wir es, jetzt haben wir es irgendwie zerstört.
Warum?
Was haben wir hier zerstört?
Was will er eigentlich von mir, Mann?
Ach so, ah, ich weiß warum, weil ich das falsche, falsche returne.
Wir returnen jetzt kein U128 mehr, sondern ein 46.
U in 46.
So, jetzt geht's wieder.
Nice.
Guck, passt wieder.
Also.
Folgendermaßen.
Frontend.
Das, das...
Cray.
Gibt das, gibt das nicht irgendwie Light Cray oder sowas?
Azure.
Azure.
Näh.
Okay, wir können einfach, wir können einfach, äh, wie geht das, RGB?
Hatte, hatte, ich wollte gerade sagen, Visual Studio hat doch da so einen, so einen Selektor irgendwie.
Oh, perfekt.
Nee, schön ist es.
Hä?
Das ist doch, das ist doch im Leben ja die gleiche Farbe, oder?
Hä?
Wo ist das?
Was, Moment, was?
Was zum...
Hat da Visual Studio Code gerade draus gemacht?
Okay, ja, so ist es okay, so lasse ich mir das gefallen.
Also, das Frontend, da werden wir heute übrigens nichts dran machen.
Das ist ganz, äh, es ist wirklich easy, es macht nicht viel.
Es versucht eine WebRTC-Verbindung aufzubauen.
Dazu holt es sich vom Backend die Informationen, was der Server für Codex und alle möglichen Sachen unterstützt.
Dann, ähm, subscribt es zu dem Connection State Event und ändert hier ein bisschen die Farbe und den Text auf der Webseite, wenn sich da was ändert.
Dann schickt es eine Antwort an den Server zurück, was der Browser selbst für Codex unterstützt.
Und, ja, das war's.
Mehr macht das Frontend nicht.
Das Ganze wird quasi mehr oder weniger durch, durch die .NET-Anwendung durchgeschleift.
Das ist alles.
Das ist, das ist alles, was einen hier großartig interessieren muss.
Und das landet dann in der jeweiligen Rust, in der jeweiligen Rust, ähm, Endpunkt.
So.
Rust ist deutlich komplizierter gewesen gestern, als ich mir das vorgestellt hab.
Und zwar, äh, die Main-Funktion brauchen wir nicht.
Und zwar ist das asynchrones Rust.
Das heißt, das läuft mit Tokio.
Und damit Tokio funktioniert, muss man, braucht man eine Tokio Runtime.
Leute, ich hab bis heute nicht gecheckt, was es genau macht und wofür das Ganze gut ist.
Aber, es hat funktioniert, nachdem, nachdem wir gestern sehr viel Try and Error rumgefuddelt haben.
Ja, und jetzt, jetzt funktioniert's.
So, und man sieht hier die, die entsprechenden Sachen, die in C Sharp aufgerufen werden.
Hier wird beispielsweise aufgerufen, Get Offer.
Hier wird aufgerufen.
Äh, ich, wird Create, hier wird, äh, Create Connection aufgerufen.
Hier wird Set Answer aufgerufen.
Wenn man sich das hier in Rust anguckt, sieht man das auch.
Das, das ist, das ist eigentlich das Einzige, hier passiert eigentlich das meiste, ja.
Der erstellt eine neue WebRTC Connection.
Hier, der erstellt eine neue WebRTC Connection.
Warum hab ich hier Tracks?
Das ergibt doch überhaupt keinen Sinn.
Ah, Tracks, weil ich die, ja, okay, ergibt, ergibt doch Sinn.
Also, WebRTC, hier erstelle ich eine WebRTC Connection.
Und, hol mir dann raus.
Was, was der Server für Codecs unterstützt.
Was für Codecs unterstützt werden, stelle ich hier ein.
Es wird genau ein Codec unterstützt.
Und zwar, ähm, H264.
Mit 90.000 Clockrate, das ist alles.
Hier wird die WebRTC Verbindung aufgebaut.
Und hier wird die Sache, die der Browser antwortet, gesetzt.
Ist aber alles nicht so wild, weil heute geht's um syntaktische Rust-Geschichte.
Weniger um die WebRTC Sache an sich.
Denn, was ich mir überlegt hab, ist, das hier ist ja kein schönes Rust.
Hier oben.
Also, schön, schön ist hier vieles nicht dran.
Beispielsweise diese ganzen Calls mit GetUnwrap, ReadUnwrap.
Das sieht schon abartig aus.
Was willst du da absichern?
Es macht keinen Sinn, die abzusichern, weil es, es darf durchaus crashen, wenn, also, wenn das hier nicht funktioniert, was soll er machen?
Dann darf er, dann muss er ja crashen, im Endeffekt.
Ach so, gut.
Ja, doch, du hast insofern recht.
Stimmt schon.
Man könnte gucken, wenn es aus irgendwelchen Gründen nicht klappt, dass das Main-Programm,
nicht crasht.
Aber ganz ehrlich, das sind solche Dinger, die sollten eigentlich nicht crashen.
Also, die sollten eigentlich nicht fehlschlagen.
Wenn sie doch fehlschlagen, ist irgendwas kaputt, dann soll's halt, dann soll's halt crashen, ja.
Schon, ist schon okay.
Dass hier eine hardcoded ID drin ist, ist übrigens auch nicht, übrigens auch nicht so sinnvoll.
Java ist gigalangsam, das stimmt überhaupt nicht.
Java ist gar nicht so lahm.
Java ist, sagen wir mal so, aus, historisch, ja, wurde gerne über Java geflamed und,
gerade,
Memory-Consumption.
Aber die reine CPU-Performance ist Java gar nicht so schlecht, genauso wie C-Sharp und .NET.
.NET ist sogar ziemlich schnell, sogar einen Ticken schneller als Java, je nachdem, was man sich für Benchmarks anguckt.
So, und zwar, wir haben hier ganz viele globale Variablen.
Das ist nicht, das ist nicht gerne gesehen in Rust, mal ganz davon abgesehen,
dass mich das nicht wirklich interessiert, ob das irgendwelche Rust-Experten als schön oder nicht schön empfinden.
Das Ding ist, es geht nicht anders als globale Variablen, denn,
es ist ja nicht, es liegt ja hier nicht in der Hand, von Rust das alles zu machen, sondern ich call ja in den Rust-Code von außen rein.
Das heißt, ich brauche irgendwie den State vom letzten Call und den kann Rust nicht tracken für mich.
Wie soll es das machen?
Das wird aufgerufen von C aus und geht dann zurück mit ein paar Sachen zu dem C-Interface zurück.
Das heißt, wir brauchen ein paar statische Variablen.
Was ich mir jetzt überlegt habe, und da bin ich mal gespannt, ob ich, ob ich das hinkriege,
was ich, also was mir hier persönlich am allerwenigsten gefällt, sind diese, sind diese ganzen Unwrap-Orgien.
Das sieht einfach total unreadable und eklig aus.
Und was mir auch nicht gefällt, sind diese ultra deep-nested Typen.
Ich meine, guckt euch das mal an, da rast es da aus.
Once-Log, FW-Log, Hashmap, Arc, Track, also im Prinzip will ich einfach nicht,
ich will einfach nicht, ich will einfach nicht, ich will einfach nicht, ich will einfach nicht, ich will einfach nicht,
ich will einfach nur einen Dictionary haben mit N64 als Key und dieser Klasse hier oder diesem Struct hier als Value.
Und damit das funktioniert, musst du das in diesen ganzen Krempel reinwrappen.
Das ist echt nicht normal.
Deswegen habe ich mir überlegt, wir machen folgendes.
Wir haben nämlich aktuell da so einen kleinen Bug drin, der daraus resultiert, dass ich gestern nicht besser darüber wusste, was ich machen soll.
Heute.
Heute immer noch nicht.
Und zwar jede Connection und jeder Track, der angelegt wird.
Also mit Track ist in Video gemeint.
Also das Ziel ist ja im Endeffekt mit FFmpeg Webcams auslesen, Webcams dann auf Serverseite, RTSP Webcams auslesen
und dann auf Serverseite das Ganze in einen Stream schreiben, rüber streamen an Browser
und der Browser rendert die Videos dann in einem Canvas oder einem Video-Element.
Das Ding damit das funktioniert ist, es braucht jeder Track.
Und jede Connection eine eindeutige ID.
Und aktuell ist es halt kaputt, weil jeder Track hardcoded die ID 2 bekommt.
Das kann ja schon mal gar nicht funktionieren.
Und jede neue Connection hardcoded die ID 1 bekommt.
Das kann auch schon mal nicht richtig funktionieren.
Also insofern.
Und diese Unwraps und Read und Get und Unwrap.
Das ist auch eklig.
Deswegen habe ich mir überlegt, wir machen folgendes.
Wir probieren das mal zumindest.
Wir legen heute in Rust zwei neue Typen an.
Und zwar einmal so eine Art AppState.
Hier sowas wie AppState.
Und da fassen wir diese ganzen Dinger hier drinnen zusammen.
Gucken wie das funktioniert.
Und dann würde ich gerne noch ein Struct, sowas wie zum Beispiel Registry bauen.
Und das Generic machen.
Ich habe keine Ahnung, wie das in Rust funktioniert.
Geht das vielleicht sogar so?
Moment.
Geht das etwa so?
Das ist die gleiche, das ist die Sharp Syntax für Generics.
Und dann will ich eine Generic Collection machen, die ich jetzt mal Registry nenne.
Wir können sie auch einfach List nennen oder so.
Letztendlich ist es egal, wie das Ding heißt.
Die folgendes macht.
Die folgendes macht.
Ich nenne es lieber Registry.
Das ist deutlich sinniger in dem Fall.
Die Tracks und Connections sammelt.
Also dass man quasi eine Collection machen kann.
Entweder auf Tracks oder auf Pair Connections.
Und die automatisch eine ID sucht, die frei ist.
Und eine freie ID für die jeweilige Connection und für den jeweiligen Track vergibt.
Gestern habe ich mir kurzzeitig überlegt.
Man könnte einfach eine UUID generieren.
Für alles.
Das Problem ist, dass eine UUID.
Ein 128-Bit-Int ist.
Und man das interop-technisch nicht gescheit hinbekommt.
Man muss das ja über ein C-Interface quasi mit C-Sharp dann scheren.
Und es geht.
Haben wir gestern gebaut.
Aber schön ist was anderes.
Oh ne.
Da habe ich.
Also.
Ich setze mich jetzt erstmal mit Rust auseinander.
Und wenn mich Rust irgendwann so abfuckt.
Dass ich Erholung brauche.
Dann gehe ich nicht zu Java.
Dann baue ich.
Irgendwas in irgendeiner Sprache, auf die ich Bock drauf habe.
Oder wir bauen mal wieder Microcontroller.
Löten irgendwelche Sachen.
Spielen mal wieder Battlefield oder sonst was.
Gibt es irgendwo ein FAQ mit Setup und so weiter?
Ne.
Aber es gibt ein Archiv, falls du alte Streams angucken willst.
Und das Archiv ist absolut gigachat-nice gebaut hier.
Mit AI-generated Thumbnails für die Streams.
Ja, ihr habt Whisper ein bisschen gefailt, oder?
Whisper hat es ja prinzipiell nicht so gut gemacht.
Und mit Text.
Rrrrrrriiii.
Ne, ne, ne.
Kein Java.
Ja, da wurde wahrscheinlich keins für generated.
Ja.
Ja.
Steht auch noch aus.
Neo-Wim-Stream steht hier auch noch drin.
Guck.
Irgendwo, glaube ich.
Neo-Wim mit Plugins.
Pimp mein Neo-Wim.
Ja.
Das ist auf GitHub.
Du kannst ja das klonen, wenn du willst.
Okay.
So.
Das ist der Plan heute.
Ich auch.
Es ist nicht so.
Als hätte ich super Ahnung von Neo-Wim.
Ich habe früher halt meinen Wim auch mega aufgebohrt mit Plugins.
Aber das war alles Wim-Skript.
Und Neo-Wim ist ja zum größten Teil Lua.
Okay.
Also, das ist der Plan.
So stelle ich mir das vor.
Ja.
Das heißt, wir fangen jetzt mal an.
Mit was fangen wir jetzt an?
Kompiliert das jetzt eigentlich gerade?
Wenn ich das auskommentiere?
Compile das?
Ja.
Okay, nice.
Also, ich würde sagen, wir machen erstmal einen Struct.
Struct Upstate.
Okay.
Und wir hauen jetzt mal diesen ganzen Krempel, der hier aktuell so in global Sachen hängt.
Wobei, wir machen es mal testweise.
Nehmen wir einfach mal die API.
Die hauen wir hier rein.
So, Static brauchen wir nicht.
Nehmen wir mal API.
Wir brauchen auch kein Once-Log mehr, sondern einfach nur API, oder?
Sonst nichts?
Glaube ich.
Das Ding müsste Thread-Safe sein.
Das könnte Thread-Safe sein.
So, heißt im Endeffekt, wir brauchen jetzt einmal noch das hier für den App-State.
App-State.
So.
Machen wir mal hier die API weg, um zu checken, ob noch alles funktioniert.
Da sollte es ein paar rote Sachen geben.
So, jetzt müssen wir das Ganze noch initialisieren.
Let App-State set App-State.
Okay, gut.
So.
Okay, gut.
Was hat er hier?
Use Shorthand.
Alles klar.
So, hoffen wir mal, ob das jetzt funzt.
Nein, funktioniert nicht, weil Zeile 95.
Obviously, Zeile 95.
Ach so, ja.
Das brauchen wir jetzt gar nicht mehr, oder?
Wir brauchen jetzt App-State.
Get.
Unwrap-API.
Ne, das wäre jetzt, das wäre jetzt auch zu einfach, wenn das einfach funktionieren würde,
oder?
Keck-Wait.
Das wäre deutlich way too easy, wenn das in Rust, wenn das irgendwie auf first try irgendwie
klappen würde.
Was ist denn das Problem, was er jetzt schon wieder hat?
Das ist doch, da fehlt der Borrow-Operator.
Das heißt, ich muss da, muss da nennen.
Ach wie.
Okay.
Der Chat weiß Bescheid.
Der Chat ist wirklich schlau.
Ne, die sind teilweise nicht wirklich useful.
Aber es funktioniert.
Ich meine, findest du das useful?
Move occurs because value has type api, which does not implement a copy trade.
Eindeutiger Hinweis, dass man ein und nehmen soll.
Oh, okay.
Ach ja.
Okay, ich habe nichts gesagt.
Ihr habt recht.
Steht ja wirklich da.
Es steht wirklich drunter.
Okay, ich gebe zu, die Rust-Fehlermeldung in dem Fall war hilfreich.
Alles klar.
Gut.
Gut.
Keck-G.
Mann.
Ja, ist okay.
Ich gebe zu, die war wirklich hilfreich.
Also, das hat schon mal funktioniert.
Das in App-State zu moven.
Jetzt brauchen wir noch eins.
So, jetzt packen wir die Runtime.
Kannst du nochmal das Back-Inserter-Meme machen?
Wie?
Das Back-Inserter-Meme?
Du meinst das auf Stack-Overflow, das C++ Zeug?
Ja, hab ich jetzt keinen Bock.
Das kann ich jeden Stream zeigen.
Welche Idee hast du?
Ich habe noch eine Idee.
Ich habe noch eine Idee.
Ich habe noch eine Idee.
Ich habe noch eine Idee.
Ich habe noch eine Idee.
Ich habe noch eine Idee.
Ich habe noch eine Idee.
Ich habe noch eine Idee.
Ich habe noch eine Idee.
Ich habe noch eine Idee.
Das ist Rust-Rover.
Das ist die Idee von Jetbrains für Rust.
Die hat aber noch so ein paar etwas, naja, vielleicht etwas unrunde, ist doch etwas unrund
an manchen Stellen.
So, die API haben wir jetzt da rein gepackt.
Jetzt packen wir noch die Runtime.
noch die Runtime da rein.
Wobei, Leute, ich hab
ne Idee. Passt mal auf. Sixheadtime.
Wenn das klappt in Rusts,
dann hab ich Rusts verstanden.
Ja, da dauert's noch ein bisschen hin.
Gucke mal, guckte mal, guckte mal.
Ich sag doch jedes Mal
hier, wenn ich
diese A-Sync-Runtime starte,
ich sag jedes Mal, Runtime
get unwrapped, block on.
Ich hab ne Idee.
Ich hab ne Idee. Und zwar,
und zwar, passt mal auf.
Wir gucken uns
die Funktionsdefinition von
block on an.
Kopieren die uns.
Und jetzt, und jetzt
geben wir unserer,
unserem API-State eine Funktion,
die block on heißt.
Das funktioniert, ach Moment, das ist ja Rust.
Moment, das ist ja Rust. Das ging doch irgendwie so,
oder? App-State?
Ich will kein Makro, ne.
So, das kriegt jetzt ne Funktion,
blocks on.
Dann braucht das
hier, API-State,
dann braucht das hier noch
Runtime als,
ja, für Klassenvariable, wie auch immer
das heißt in Rust.
Als Instanzvariable,
kein Schimmer, wie man das korrekt in Rust nennt.
Trade-Variable, Struct-Variable,
Struct-Feld,
weiß nicht.
So.
Und
jetzt sagen wir, Moment,
selbst,
passt doch, ja, und jetzt sagen wir
self-runtime
und jetzt kopieren wir das, was ich
hier immer mache.
Block on, wobei, ne, muss ich auch
gar nichts machen. Block
on und
da schieben wir das jetzt rein.
Und hoffen, dass es noch kompiliert.
Ne, shit.
Ah, ne, Moment, missing, missing runtime.
Hier, missing, missing runtime.
Runtime.
So.
Äh.
Achso.
Ich muss, hä?
Wait, wait a minute.
Ah.
Moment.
Das beißt sich jetzt ein bisschen
in den Schwanz, Gatschi.
Was?
Äh.
Die Runtime setze ich hier oben.
Und
hier unten lege ich
erst den App-State
an.
Ich mein, das muss
aber nicht so sein.
Kann ich nicht einfach den ganzen Krempel
hier rauskopieren?
Und da rein?
Und dann... Ja?
Okay. Äh, und dann brauche ich
das hier, dann brauche ich das doch eigentlich
gar nicht. Ach, doch!
Ach, Moment, Moment, Moment, Moment.
Doch, doch, das muss in der Runtime gecallt werden.
Sonst wird, ne, sonst hab ich wieder so diesen
komischen Bug. Ne, ne, ne, ne, ne, ne.
Nopos.
Das Rust-Buch. Ja, soll ich jetzt das Rust-Buch
im Stream lesen, oder wie?
Aber was wir machen können,
ist... Kann man?
Okay, jetzt bin ich mal gespannt.
Kann ich das hier einfach die Runtime
als Parameter übergeben?
Runtime?
Runtime?
Alter, ich bin zu pepega,
das zu schreiben. Und jetzt
Runtime?
Da reinschreiben? Ne, weil?
Achso, äh,
ist missing.
Runtime?
Used after move.
Okay, dann muss das hier...
MonkaS, Alter.
Ich hab mir das so einfach vorgestellt, ist es aber nicht.
Ich...
Okay, wir lassen das. Wir lassen das sein, ja?
Wir lassen, wir lassen das sein.
Wir lassen das, wir lassen das sein.
Weil...
Ich will ja Runtime get...
Ich will das ja wegschmeißen.
Ich will das ja gar nicht mehr haben.
Okay, wir lassen das mal kurz hier
weg. Das ist eigentlich gar nicht das...
Vielleicht fällt mir später noch was zu ein.
Das darf jetzt so bleiben.
Und das hier,
fliegt jetzt erstmal wieder weg, okay?
Und das, das hier auch.
Da bin ich grad noch nicht
High-IQ-Rust-mäßig genug für.
Das muss ich mal schauen, wie man das
wie man das später macht.
Weil das beißt sich. Ich kann nicht
die Runtime hier anlegen.
Das ist, das ist halt echt blöd.
Egal, das machen wir jetzt nicht.
Vielleicht fällt mir da später was zu ein.
Wir, wir... Also was mich
viel mehr interessiert ist, wie man ein Custom
Custom Type implementiert in Rust.
Eine Custom
Collection, wohlgemerkt, in Rust implementiert.
Eine Generic Custom Collection
in Rust. Ich würde mal
vorschlagen, wir
kopieren das Ganze in
ein eigenes
in ein eigenes File.
Kann man das nicht kopieren?
Refactor move
to
ähm
registry.rs
So, ja ja, add.
Jetzt bin ich mal gespannt.
Jetzt, jetzt bin ich mal gespannt.
Also, warte nicht, Runtime.
Moment.
Äh, registry.rs
Also, was ich haben will.
Ich will ein Generic
Ich will ein Generic Type
in Rust. Ich hab keine Ahnung, wie man Generic
Rust, Rust
Generic Type. Wie geht das?
Generic Data Types
Strukt
äh
Ja, T
Also im Prinzip ein bisschen wie in .NET
Registry
T. Okay? So.
Dann nennen wir, machen wir hier mal
eine Variable drin. Die nennen wir einfach Storage
oder Store.
Storage. Keine Ahnung.
Store. Wir nennen es Store.
Und
das wird eine Hash Map.
Das wird
eine Hash Map vom
Typ, ähm, tja. Wie viele
IDs brauche ich?
Wahrscheinlich reicht ein U32 Log
da aus. U32 Max.
Nicht Z32.
Was auch immer ich da gerade gegoogelt hab.
U32 Max
ist, ja, ja, so
ich glaube, das reicht.
Ich glaube, ich werde nie
so viele Connections gleichzeitig haben,
dass das irgendwie Probleme macht.
So, also
wir brauchen eine extra ID pro
Connection. Wenn das
Compile, das wird auf jeden Fall nicht Compilen
auf First Trial. So.
Ähm, und dann
ein Value auf Type T.
Okay? So weit, so weit, so weit.
Sollte es noch kompilieren. Da haben wir noch nichts
gemacht.
So, aber, aber generic das Ganze.
So, und jetzt?
Im,
kann das mal machen, was ich will.
Registry of
Type T.
Moment, jetzt geht das nicht.
Warum?
Unresolved Reference.
Ach, hier muss T vorne noch hin.
Imple, okay.
Implement T.
Implement Type T.
Registry of Type T.
So, also, was wir
jetzt brauchen, ist folgendes. Function.
Muss man da Public eigentlich
davor schreiben? Ja, ne? Ich muss,
ich muss da Pub davor schreiben,
damit das exportiert
wird nachher, dass ich das benutzen kann.
Glaube ich.
Oder muss ich,
muss ich nur hier Pub davor
schreiben?
Also nicht genau. So, Fn.
Also, was brauchen wir
in so einer Collection? Wir brauchen
einmal New.
Wenn man das macht, wie Go.
So, wir machen, wir machen das mal so ein bisschen
wie in Go. Also,
es, boah, ich hab keine Ahnung, wie das geht.
Rust New Constructor.
Ja, jawoll.
Genau das will ich haben.
Excellent Copy Paste.
So, wir wollen kein Value. Wir returnen
Self, okay.
Und Self ist im, okay,
Store ist eine
Hash Map, eine neue,
ein neues Dictionary im Endeffekt.
Okay,
Funst, nice. Was hat der für Schmerzen?
New Function is never used.
Kompiliert, alles gut.
Das heißt, wir können jetzt
das Ganze neu anlegen.
Übrigens, um das zu testen,
machen wir hier einfach mal eine Funktion
und rufen das, und rufen das auf.
Wir tun einfach mal so.
Registry new.
Achso, Registry of Type.
Ah,
Int oder so.
Ähm,
wie schreibt man das jetzt?
Int?
Int?
Muss man das hier vorne irgendwie
schreiben?
Type Annotation Needed.
Ah, ja.
Okay, das muss man hier machen. Das ist auch ein bisschen
gewöhnungsbedürftig.
Auf, ja, hier
U32.
Oder machen wir Local Static
Track
Sample. So, perfekt.
Kompiliert noch? Kompiliert noch.
So.
Also,
was braucht man für eine Collection?
Wir brauchen im Prinzip
ähm, wir brauchen im Prinzip
drei Methoden, vier, vier Methoden.
Wir brauchen Add-Elemente,
Get-Elemente,
Delete-Elemente und
Loop
oder sowas, ja.
Alles klar.
Also,
Pup, fangen wir mal an.
Pup, Fn, machen wir mal Add.
Add dürfte ja noch relativ easy sein.
Add,
und jetzt, ne, Moment.
Wo kommt jetzt hier der
der Type hin?
Also, bei .NET kommt er da hin, glaube ich.
Ja, okay, kommt den Rust auch da hin.
So, Add.
So, und dann kriegen wir als Parameter
ein
ein Element.
Oh, fuck, wie war man das jetzt?
Also, wir kriegen ein Element
auf T im Endeffekt. So.
Was hat er hier für Schmerzen?
Name T is already used.
Hä?
Ach, brauche ich das hier gar nicht mehr?
Ah, ich brauche das gar nicht mehr.
Ähm, so, und dann brauchen wir aber noch
irgendwie unself.
Das ist das, übrigens das gleiche wie
this in C-Sharp oder self in Python
oder me, glaube ich,
in Lua oder sowas.
So.
Das heißt, jetzt sagen wir
self
store
insert. Das fand's doch
so im Leben nicht. Jetzt brauchen wir, ach, so, Moment,
eine ID brauchen wir noch.
Eine ID, die muss ich generieren.
Let ID gleich 1,
die generiere ich. ID
und dann fügen wir das Element
ein.
Das geht natürlich nicht, weil das nicht
Mutt ist.
Ich glaube, in Lua heißt es me.
Leute, das kann so nicht funktionieren.
Das ist
verkehrt, was ich mache.
Also, okay, das würde funktionieren, Chat.
Das würde funktionieren, aber
spätestens, spätestens
wie will Rust das handeln,
wenn ich das von verschiedenen Threads
aufrufe? Moment, Moment, Moment.
Das testen wir jetzt mal, ja.
Weil ich glaube schon,
dass man das hier locken muss.
HashMap ist ja sicherlich nicht Threadsafe.
Probieren wir das mal. Add.
Jetzt irgendwie 1 oder so.
Moment.
Let Mutt, R, Mutt.
Ja, gut.
Hier weiß er ja, dass es nicht
Multithreaded ist, weil das in der gleichen Funktion ist.
Der wird mich das schlichten,
vergreifend nicht anlegen lassen,
vermute ich einfach mal.
Ne, ne, ich glaube, wir brauchen da
einen Lock drum. Ich glaube,
damit ersparen wir uns schon einige,
einige Probleme.
Wir brauchen da einen Lock drum.
Lassen wir das mal so.
Also Ziel muss sein, dass die Registry
selbst nicht mutable ist, aber
Add trotzdem funktioniert.
So, heißt im Endeffekt,
wir brauchen hier wahrscheinlich einen RwLock.
Ne, oder wie ist das Ding, was wir hier hatten?
Doch, RwLock.
RwLock
HashMap
und jetzt ist es RwLock
New. Du könntest auch
nur Self machen und dann versuchen mit GetMutt
die Referenz zu
holen. Was?
Wie jetzt?
Das kann aber doch auch Multithreaded nicht funktionieren.
Was soll ich machen?
Add, also quasi
das muss übrigens
weg hier. Self.
GetMutt.
Okay, was ist das für
schwarze Magie?
Returns a mutable reference
to the value. The key may be
any borrowed form of the map
key to partition.
Wie soll
das funktionieren?
GetMutt?
Geht auch nicht, ne?
Ach, Moment!
Das ist,
das ist, ähm,
jetzt aus der HashMap
raus. Das ist was anderes.
Das, ne, ne, das, das,
ich check's auch nicht, was?
Ne, ne, das, das gibt's
überhaupt nicht.
Try? Ne, das muss in den
Lock, das muss in den Lock rein, sonst
funzt das nicht.
Wir hatten's doch eben grad hier schon.
Lock.
RwLock.
Also, Self,
Store, so.
Store ist jetzt allerdings
nicht mehr direkt eine HashMap, sondern
ein
Thread,
Thread, Save, Lock.
Das holen wir jetzt. Write, die Reference
raus, Unwrap.
Okay, und jetzt sagen wir
Map, Insert,
ID und Element E.
So, und das funzt jetzt wahrscheinlich.
Ja, ach, shit, was ist das?
Cannot borrow mutable, make mutable. Ja, sehr schön.
Fuck!
Cannot borrow
as mutable.
Ach so, weil dann, weil dann noch, das brauchen wir
doch jetzt gar nicht mehr, oder?
Ah, nice, funzt.
Sehr schön.
Also, jetzt müssen wir die Registry
selbst nicht mutable machen,
können aber trotzdem Sachen einfügen.
Boah, meine Güte.
Der fliegt
jetzt auf die Schnauze, wenn es von einem anderen gelockt
ist. Ich hab ehrlich gesagt keine Ahnung,
wie sich, wie sich das verhält.
Ob das, ob das
einfach nur hängt an der Stelle?
Oder ob das...
Oh.
Nee.
Okay.
Locks das RwLock with
exclusive write access blocking the current thread until it can be acquired.
Nee, nee, nee, nee, nee, hier.
Blocking the current thread until it can be acquired.
This function will not return while other writers or other readers currently have access to the lock.
Okay, das, das hängt einfach an der Stelle.
Das ist aber auch okay, dass das hängt.
Weil wir wollen ja,
die einzige mutable reference haben,
dass wir was einfügen können.
Rust 5 hat, ja.
So, also jetzt haben wir unsere
Add-Methode. Das war erstaunlich einfach.
Das war erstaunlich,
erstaunlich einfach bis jetzt.
So.
Als nächstes brauchen wir
einen Get. Muss ich hier überhaupt
public davor schreiben?
Pub fn
get
und self.
Jetzt brauche ich eine ID.
Jetzt brauche ich eine ID.
Moment, wait a minute.
Wait a minute. Ich hab doch die ID gar nicht.
Moment, hier muss die
to do
generate ID.
Das funktioniert nicht so wie gedacht gerade.
Wobei, muss ich jemals
überhaupt einzelne Elemente
daraus getten? Ja klar,
für die Connections.
Das heißt, mein Add muss
eigentlich die ID returnen,
dass das funktioniert.
Return ID.
Jetzt weiß ich
die ID.
So, jetzt habe ich,
jetzt habe ich die ID und jetzt kann ich
wahrscheinlich sagen
self
store read
reicht jetzt. Unwrap
get Element
oder sowas. Get Key Value.
Was?
Get?
What?
Get.
Und jetzt ID.
Und das Ganze dann returnen.
Return Funst.
Okay, was?
Unwrap. Unwrap. Nochmal hinten
drauf. Bam.
Was? Founds?
Was willst du, Rust?
Expected und
found und T.
Ach so, der Return Type
fehlt. Der Return
Type. Was hat er hier unten für Schmerzen?
Ah!
Moment, Moment.
Get muss eine Referenz sein dahin.
Okay, okay.
Und jetzt
kann ich auch eine Reference
returnen.
Dazu.
Geht aber immer noch nicht.
Cannot return value reference
und Tab. Oh je, oh je.
Was? Was will er von mir?
Ne, was soll ich denn sonst machen außer
unwrap? Moment, Moment.
Das kann ja nicht funktionieren.
Wobei, warum eigentlich nicht?
Das ist
eine Referenz. Ach so,
ich weiß, warum das nicht funktionieren
kann. Das ist eine Referenz
und ich könnte ja jederzeit
den Inhalt löschen
hier drin zum Beispiel.
Heißt im Endeffekt, dann würde, wäre die Referenz
ungültig und das mag Rust ja nicht.
Also, was muss ich jetzt machen?
Cannot return. Was schlägt
mir denn der Compiler vor?
Returns the value
referencing data owned by
the current function.
Okay, ich habe was gelernt. Ich glaube, ich weiß,
wie wir das fixen können.
Ich glaube, ich weiß, wie wir das fixen können.
Genauso wie wir es hier gefixt haben.
Ein ARK
drumherum rappen.
Also es ist jetzt nicht...
es ist jetzt nicht type t sondern es ist type arc of t und dann hier ist es arc new ergibt das so
sinn und jetzt und jetzt krieg ich nen arc zurück und den können wir klonen was den referenz counter
erhöht und dann sollte es funktionieren hey es kommt bald five head time es funktioniert ob es
genau das macht was ich haben will chat hat irgendjemanden plan was der unterschied ist
zwischen box und arc also arc ist ein referenz counter das weiß ich genauso wie rc warum es
unterschiedliche sachen gibt habe ich auch noch nicht gecheckt
aber ich vermute mal dass box keine ahnung ich wollte gerade sagen ich vermute würde das auch
so funktioniert mit box box of t ja arc ist atomic aber was ist das in dem fall bedeuten soll keine
ahnung okay das funktioniert expected box found und box und box das ist das gleiche problem wir
müssen das mit arc machen weil es reds
threat safety genau so wunderbar also wenn ich das richtig verstehe passiert jetzt folgendes
der speichert jetzt also der
arc also das ist ein atomic referenz counter der arc übernimmt ownership of t das ist so rust logik
für gibt es eigentlich in anderen sprachen oftmals nichts direkt vergleichbares also t gehört dem arc und arc selbst ist ein referenct counter oder auch einfach statisch
gehört dem Arc. Und Arc
selbst ist ein Reference-Counter. Und jedes Mal,
wenn ich den klone,
wird der Reference-Counter um 1
hochgezählt. Und erst, wenn der Reference-Counter
bei 0 ist, wird
das freigegeben. Das heißt, jetzt
kann ich safe
das returnen, weil dadurch, dass
es in einem Arc ist, immer sichergestellt
ist, solange ich noch irgendwo
eine gültige Referenz habe, ein bisschen wie der
Garbage-Collector in C-Sharp,
naja, ganz, ganz
light, ja.
Ähm,
sobald ich quasi noch irgendwie
den Reference-Counter habe, dann
ist das
quasi sicher und kann nie out of
scope gehen. Oh man, die Musik
ist vorbei. Sack.
Tüm, tüm, tüm.
Gut. So, jetzt haben wir,
jetzt können wir das Element getten. Auch
schon mal nice. RC
cannot be shared between threads.
Ja, deswegen braucht man wahrscheinlich
Arc, dass der Reference-Counter
irgendwie
atomic-mäßig erhöht wird und damit
thread-safe ist. Rate ich jetzt
einfach mal. So, so weit,
so gut. Was hat er hier? Registry is never
constructed. Die IDE
ist auch schon ein bisschen pepeger, oder?
Ja gut, die Funktion wird nicht aufgerufen.
Ja, okay. Okay, okay. Lass ich mir gefallen.
So, das brauchen wir als nächstes
delete. Delete
brauchen wir als nächstes.
Fn, nennen wir einfach
del
U32, die ID und jetzt,
das dürfte relativ easy sein.
Das dürfte relativ easy sein.
Self, Moment, das kann ich doch eigentlich so lassen.
Self-Store, jetzt wahrscheinlich
write, jetzt wahrscheinlich write.
Ähm,
wie löscht man, wie löscht man da was?
Get, insert,
ether, clear, ne.
Ich will sowas wie erase, delete oder sowas.
Remove.
Remove.
Remove entry.
Oh. Was ist der
Unterschied?
What?
Remove the key from the map returning the stored key and the
value of the key was previously in the map.
Okay.
Und, und.
Remove is?
Remove the key from the map returning the value
at the key. Achso, das eine
returned key value und das andere returned
nur den value. Ich will überhaupt nichts
return.
Gibt sowas wie drop oder so? Hey!
Moment, ist wieder was anderes.
Was zum Teufel macht drop?
Drop ist
so Nische, das hat auch nicht mal
irgendeinen Hilfetext.
Also, remove.
Einfach nur remove.
ID.
Ha? Und da muss auch gar nichts
returned werden. Einfach so.
Easy. Eats. Eats.
Easy as fuck.
Easy as fuck.
Moment, es funzt wieder nicht. Warum?
Achso, und.
Mit was? Mit Steuerung Q
kannst du. Meinst
du hier? Ne.
Ich hab Visual Studio Key Mappings.
Keine Ahnung. Ich glaube, das war keine gute Idee.
Okay.
Ja, das war's
doch im Großen und Ganzen schon.
Und jetzt, jetzt eigentlich nur noch sowas
wie
public function
Ja.
Nenn ich mal, weiß ich, all
oder so. All.
Irgendwas, irgendwas
in der Richtung.
All.
Und jetzt quasi return
self. Ach, Moment.
Self.
Store.
Ähm.
Read. Vermutlich.
Vermutlich read.
Unwrap.
Ether. Klingt gut.
Und das jetzt einfach zurückgeben, oder?
Das müsste doch sein.
Ne, ist es nicht.
Warum nicht?
Oh Gott, Rust. Warum ist das
wieder kompliziert?
Returns a value referencing
data owned by the current function.
Was ist
das eigentlich für ein ultrahässlicher
return-Wert?
Ether?
Single quotes?
Underscore?
What?
Kann man das nicht einfach löschen?
Naja, bringt nichts.
Okay, Rust. Ich habe
legit keine Ahnung, wie das
funktioniert. Ich hätte, Leute,
ich hab, ich hab absolute
pepega Idee, was wir machen könnten.
Wir können sagen,
unwrap, clone,
und wir returnen eine neue
Hashmap jedes Mal, wenn wir all.
Aber das kann es ja nicht sein, oder?
Ich will, ich will einfach nur
außerhalb eine Schleife machen
können über alle Elemente in der
Registry. Wie funktioniert das?
Ich will sagen können,
for,
äh, Moment,
äh, for,
er,
all,
äh, ja,
blub, oh.
Das, das will ich sagen können.
Das funzt jetzt an der Stelle, klar,
weil ich eine neue Map mache,
aber ich will ja, ich will ja nicht
wirklich die Map einmal komplett
klonen, bei,
bei jedem Aufruf. Das ist ja nicht Sinn
und Zweck der Sache.
Okay, Stackoverflow, Rust,
return Iterator,
oh.
Returning Iter, oh, was?
Returning Rust Iterators.
Depth first.
Returning an Iterator.
Ja, genau, das, genau das will ich
machen und das habe ich auch gerade gemacht, aber
das funzt nicht.
The compiler produces an error.
The type is
contained within the error messages. Ja, genau
das, genau das habe ich
gerade gemacht.
Genau das habe ich gerade gemacht.
Beifettige
Webseite,
aber,
Moment,
Moment, das funzt.
Ne, das funzt nicht.
Das ist nicht das, was ich haben will.
Oh, Mann.
IDE, please.
So.
Genau das habe ich gemacht, aber das funzt nicht.
Gibt es da nicht Intuita?
Ja, aber ich will ja nicht Ownership zurückgeben.
Ich will ja nicht Ownership
zurückgeben, sondern
einfach nur eine,
ja,
jede Menge,
die Referenzen auf die Elemente
in diesem,
in dieser Hashmap.
So, also, das, was die Seite vorschlägt,
funzt nicht, weil dann
returns a value
referencing data owned by the
current function.
Und da bin ich mir nicht sicher, was es mir sagen möchte,
ehrlich gesagt. Muss ich vielleicht
das hier erst nochmal, Moment, muss ich sagen
let m irgendwie so
und dann, ne, das funktioniert natürlich
auch nicht. Okay.
Geht das, also, das habe ich probiert.
Laut der Seite geht das
so. Ist das irgendwie,
ist das irgendwie so eine AI
generierte Webseite, aber von 2020
eher nicht. Irgendeine AI
generierte Webseite.
Das ist gut. How to implement
iterator
over wrapped vector
in Rust. Genau.
Hier, wrapped.
Und jetzt will der, dass man das
iteraten kann. Genau das will ich.
Genau so was will ich haben.
Actual to call it as you described,
you don't need to implement iterator.
For it, you just
need to return the iterator
of the inner vec.
Ja, ich habe das schon gesehen, den Link.
Okay, six hat time.
Okay, probieren wir das doch mal so aus.
Das, das sollte doch nicht
allzu kompliziert sein.
So, self, jetzt brauchen wir erstmal
hier den, den, mal probieren,
blenden wir das mal aus hier, so, zack.
M.
M. Iter.
Funzt nicht, weil
unelide
lifetimes.
What?
Weiß nicht mehr, was es will von mir.
Ich lass mal hier den.
Okay, und jetzt, jetzt geht das?
Method
not found. Achso.
Moment. Ne.
Returns the value referencing data
owned by the current function. Okay.
Das funzt schon mal nicht.
So, das geht nicht.
Also, stackoverflow fail.
Ne, da fehlt
kein return. Wenn man
das Semikolon weglässt,
wird die letzte Zeile
automatisch als return verwendet.
Ist auch ein bisschen,
weiß nicht, bisschen pepeger irgendwie, dass es
dafür was extra gibt. Aber
das funktioniert nicht.
Also, stackoverflow Antwort
three hat.
Okay, nächste Antwort.
Accepted Antwort. Accepted Antwort.
Weck it self,
does not implement iterator. However, it
implements into iterator in three ways.
You probably wanted
to implement these for your wrapper as
well. Ne, into iterator
will ich schon mal net.
Deref.
We deref to slice
so that we can. Ich,
was, was bin
ich überhaupt sehend hier grade?
Implementier doch den iterator für
arg iterator, oder bin ich grad dumm?
Ja, wie denn?
Alter, was?
Okay, implement iterator.
So, so,
okay. Also so einfach wie stackoverflow
das macht, geht das schon mal net.
Also implement iterator
for registry
of, äh, t.
So. Ähm,
was? Okay,
item type, type
item gleich u32.
Äh,
ne, mein item type
ist t. Und dementsprechend
ist es auch einfach option of t.
Und das da oben lass ich
weg. Und was?
Ich check's nicht, was der hier macht.
Was soll das, was soll das,
was soll das, was soll das heißen?
Oh, ach, man muss
das? Moment, man braucht das hier?
Okay, das ist, das ist
erforderlich. Das geht nicht.
Hast du Tipps, wie man am besten
anfangen kann zu programmieren? Ja,
der beste Tipp ist, du hast irgendwie
ne coole Idee, was du schon immer mal
machen wolltest, und suchst dir die beste
Technologie dafür raus und fängst damit an.
Weil dann hast du auch immer Motivation, was, äh,
was zu machen, weil das ja was ist, was du
letztendlich schon immer mal machen wolltest.
Also wenn du sagst, ich würd gerne
Microcontroller programmieren, ne eigene Webseite
machen, meinen Rollladen hoch
und runter fahren automatisch,
das ist natürlich am besten, wenn du so ein Ziel schon im Kopf
hast. Das ist motivierend.
Wenn du gar keine Ahnung hast, wie du anfangen
sollst und einfach nur gucken willst,
ob das was für dich ist, kann ich dir
nur empfehlen, lad dir Visual
Studio Code runter und fang mit JavaScript an.
JavaScript,
ein bisschen HTML, CSS, hat
die mit Abstand niedrigste Einstiegshürde.
Du brauchst einen ordentlichen Texteditor,
wie gesagt, nimm Visual Studio Code, ist
alles out of the box für JavaScript dabei,
und du brauchst nen Browser.
Und nen Browser hast du, sonst wärst du ja nicht im Twitch-Chat.
Und dann legst du los.
Ich check nicht, was ich
machen muss, Chat. Was will, was will das hier
von mir?
Here we define a sequence using current und next.
fn next.
Okay, Option will ich doch gar nicht.
Oder?
Ich will einfach t return.
Ne, das geht nicht.
Es muss ne Option, es muss ne Option sein.
So, also, Moment.
Kann ich nicht...
Current, next?
Self, current?
What? Kann ich nicht das
einfach re-usen?
Store?
Kann ich das nicht einfach re-usen?
Von...
Read. Kann ich das nicht einfach re-usen?
Von dem anderen?
Und so.
Die, die
Referenzen, wobei, brauchen wir
eigentlich nicht. Dass ich jetzt sagen kann,
irgendwie, return m
next.
Ja, das kann man doch einfach rappen, oder?
Return n.
Wobei, ne, ne,
Moment, Moment.
Was muss man returnen?
Hier return, was? Option?
Option of
u32t.
Oh man, was ist denn jetzt?
Was? Method next?
Compar...
Expected...
Achso, ah, ah, Moment,
Moment, Moment.
Was muss ich sagen?
Wie haben die gesagt? Self?
Item? Item?
Ne, wie haben die das hier gemacht?
Oh man, shit, das ist,
das ist ja super komplizierter Shit wieder.
Self, self,
cross, okay.
Item.
Und Item ist quasi
u32t.
Okay,
ist nicht, weil...
Achso, weil es und,
es ist und u32
aus irgendwelchen Gründen
und ak...
Alter, what the fuck,
man.
Pounds, was? Okay,
u32. What the hell?
Alter, Rust,
man, ich will einfach ne Schleife
drüber machen. Was will das denn
von mir?
Was will das
von mir, man?
Oh, fucking shit.
Ich mein, okay, würde das dann
prinzipiell überhaupt funktionieren?
Würde das...
Ne, all ist auskommentiert.
Meine Güte. Okay, also,
was, was, was will das von mir?
Und.
Okay, und und ist nicht erlaubt.
Warum ist und nicht erlaubt? Weil...
Missing lifetime
specifier. Okay, Rust,
hilf mir, Rust, please.
Was?
Und not a.
Monka W.
Oh.
So. Okay.
Okay. Ich habe absolut
keine Ahnung, was ich da gerade mache.
Okay, okay. Moment.
Moment, Leute. Ne, was ist jetzt?
Leute, man,
es kann doch nicht so schwer sein.
Ich habe absolut keine Ahnung, was
Rust von mir will, man.
Nehmen wir mal oben das a raus. Hab ich.
Aber das, das
geht nicht.
Dann will er, dann will er nicht, weil
lifetime specifier
missing.
So, und jetzt sagt er mir hier,
Lifetime a is not constrained by
the infiltrate self type
or predicates.
Alles klar, jetzt
sofort. Muss man vielleicht so machen?
Hier so?
Ne. Ich habe keine
Ahnung, man. Alter, Rust.
Ich mache Fuck teilweise ja so krass ab, ey.
Also, ich habe, ich habe wirklich,
ich habe absolut keine Ahnung, was das Ding von mir
will, man. Du musst es auch
embracen, naja.
Massive Embracing am Start.
Okay, keine Ahnung.
Wir gucken mal, wir gucken mal weiter.
Also, das funzt ja schon mal nett.
Wie das hier.
Was haben wir denn sonst noch so zur Auswahl?
Impel deref
for binary. Okay, dann probier, okay.
Wenn das mit dem iterator nicht funktioniert, dann probieren wir
einfach was anderes.
For registry
T. Probier mal, Moment,
was? Moment, wo soll ich
das, wo soll ich das probieren?
Wir kommentieren das mal aus, weil, vielleicht brauchen wir
das gleich nochmal. Probier mal
self next
map. What?
Was, Zeile 26?
Fifetime.
Ist ja nicht self, ist ja nur M.
C++ Level Types würde ich
sagen, ey.
So, so, das wird jetzt auskommentiert.
Okay, next.
Also, probier mal das mit dem deref.
Implement deref
for, okay, T
registry
T
output.
Moment.
Das sind die Elemente.
Das sind, das sind die Elemente.
Also, mein Element ist
Output ist
dann ein
U32
Vector of T.
Self?
Warum hat er hier noch ein
und davor? Warum ist hier, warum ist hier
nochmal ein und davor?
Ich check's nicht.
Okay, self
store?
Achso, ja, Moment, Moment,
Hä? Moment,
deref ist gar nicht importiert.
Okay, nice. Das gibt's
überhaupt nicht.
Output is not member.
Implement members. Ja, ganz
toll. Target.
Heißt das jetzt Target? Wurde das, wurde das
unbenannt, oder wie? Moment,
was, was macht deref eigentlich?
Deref. Rust.
Was zum?
Alter.
Ich will einfach nur ne Schleife
da drüber machen können, Mann.
Ist das so kompliziert
in fucking Rust ne Schleife zu machen?
Type targets.
Sized.
Target self.
Okay, okay.
Type T. Type T.
Okay. Type T. Sehr gut.
Excellent.
Deref
self target.
Aus welchen Gründen auch
immer, ähm,
reference. Und jetzt
self store.
Was ich programmiere? Eine Schleife
in Rust für nen eigenen
Typ, aber aus irgendwelchen
Gründen mag Rust das,
das nicht wirklich.
Also.
Und, und jetzt
Ether oder so? Ne, ne, ne, Moment. Store.
Unwrap. Ah, ne, Moment, Moment. Self
store get. Hä?
Sekunde. Bin verwirrt.
Self store.
Read. Ach, read. Read.
Read. Unwrap.
Oh, das wird so nicht funktionieren.
Expected but
found it.
Mann! Wie,
wofür machst du das überhaupt? Lass die Wrapper-Funktion
weg. Ich will ne Schleife
machen da drüber, Mann.
Oh, das geht ja nicht. Irgendwo hier, irgendwie
hier, muss der Kram
mehr da dran kommen. Am liebsten,
am liebsten hätte ich
ne Funktion, die, die irgendwie
all oder so heißt.
DREF hat nix mit ner Schleife zu tun. Laut
StackOverflow schon. Hier will auch
ein Typ ne Schleife machen.
Und er schlägt vor, dass man das
entweder so macht, so macht oder so
macht. Moment.
Der Typ transferiert.
Ne, der Typ, der Typ, ähm.
Wartet mal. Was hatten
wir da vor? Moment, wie
lang war das gerade nochmal hier unten?
Iterator next?
Ne! Hab ich doch!
Das ist doch das allererste, was ich gemacht hab hier unten.
Das funktioniert nicht.
Das funktioniert nicht.
Das ist das allererste, was ich probiert hab.
Das, das klappt nicht.
Ich mein, kann ich nicht, kann ich nicht einfach sowas
hier machen? Oh.
Wir klauen das jetzt einfach von hier.
Der sagt ja bestimmt, dass es nicht
matcht, oder? Er ist ein
incompatible Type.
Was ist das da vorne überhaupt? Kann das mal weg?
Äh, er ist incompatible.
Okay. Moment. T?
Moment, Moment, Moment, Moment.
Target T ergibt ja auch überhaupt keinen Sinn.
Target
ist was? Target?
Ne, Output. Was?
Das stimmt doch nicht einmal überhaupt hier.
Target ist was?
Target ist das, was man zurückgibt, oder?
Also, im Prinzip
ein
Okay, was haben wir denn hier bei?
Bei Keys?
Ja, fuck man.
Was ist beim ersten Ansatz mit der Hashmap?
Du meinst das da unten?
Was, den Iterator muss ich klonen?
Man kann den klonen? Okay.
Nice.
Ne, ne, ne, ne.
Cannot return values
referencing local variable m returns
value. Nope.
Du musst die Referenz zur
Hashmap klonen. Die was
bitte? Die Referenz?
Was soll ich klonen?
m.clone
Ja, Moment. Dann klone ich
die Hashmap. Das will ich doch nicht.
Ich will doch nicht die
Das ist doch das allererste, was ich gemacht
hab. Das ist doch das
allererste, was ich gemacht hab.
Dass das geht ist klar, aber dann erstellt er doch
ne neue Hashmap. Das ist doch komplett für'n Arsch.
Der soll keine neue Hashmap erstellen?
Das ist doch das allererste, was
ich gemacht hab. Das hat auch funktioniert.
Aber
das ist doch bescheuert. Ich will doch nicht ne komplett
neue Hashmap anlegen, wenn ich einfach nur die
Elemente durchlaufen will von der schon bestehenden
Hashmap. Warum soll ich das machen?
Das funktioniert.
Das hab ich schon ausprobiert. Das funktioniert.
Das ist überhaupt kein Problem. Guck, das
geht. Das ist das allererste, was
ich gemacht hab.
Ich will ne Schleife machen, Mann.
Ne Schleife. Eine
stinknormale Schleife über nen Custom
Typ. Und ich hab keine Ahnung, wie man das
in Rust gescheit macht.
Also das ist schon mal nix.
Ja, genau. Ich will ne Schleife machen. Guck,
ich will vor...
Ja, keine Ahnung. Vor Blub
in... Alter.
Oh, das will ich machen können.
Okay?
So, und das geht nicht, weil
it's not a Iterator.
Okay, alles klar. Iterator
implementieren. Hab ich absolut
keine Ahnung gehabt, was der von mir will.
Und was sie
hier auch immer mit DREF wollen, ich hab auch
keine Ahnung. Okay, wir machen jetzt einfach
mal... Wir suchen jetzt
Rust DREF Vector
Wrapped.
Was
hast du lieber? C++ oder Rust?
Ey, auf keinen Fall
C++, aber Rust in dem Fall jetzt gerade
auch nicht. How to create a
new instance of Wrapped Vector
in Rust. Oh, was
ist das? Pfeifertime.
After the creation of such an object
you can use the object somewhat
transparently by implementing
DREF.
Moment, hier ist Target?
Wait a minute.
Hier ist Target nicht T,
sondern... Moment.
Return self
store. Ne, und.
Und self store.
Moin, Kirolo.
Was für ein Typ ist das jetzt?
Alter, kann der nicht mal den Typ davon
ordentlich ableiten, oder was?
Das ist ein hier
LWLog, Hashmap, irgendwas.
Aber und? Und?
Okay. Ja, ja.
So.
So. Shit. Fast.
Fast.
LWLog
Hashmap?
Ah, ne. Und self.
Kann ich nicht einfach
so das ganze Ding returnen?
Ne, das geht
nicht. Über den internen,
über meine interne Hashmap.
Ich habe eine interne Hashmap
gerapped quasi
in einem eigenen Struct und ich will
über meinen Struct iteraten.
Angeblich stimmt das so.
Ne, natürlich. Was?
Man.
Ey, super, jetzt kompiliert er so eine Fehler, aber
gehen, gehen
tut es trotzdem nicht.
Und die Funktion gibt es hier nicht.
Okay, und was war jetzt der Sinn
davon? Gibt es wenigstens DREF?
Ah, DREF gibt es, okay.
Wait a minute. Was?
Ich weiß nicht, ob ich DREF brauche.
Das hat irgendjemand aus der Gamerflow vorgeschlagen.
Und jetzt?
Ey, Leute, ich habe keine Ahnung, was ist das für ein Scheiß.
Übrigens die Rotzsprache, Alter.
A read? Was?
Read?
Und was will der hier von mir? Read?
Log result?
Ach so.
Moment, Moment, weil ich
Wait a minute.
Weil ich ja das
returne mit dem Log.
Sag bloß, wenn das hier
Wait a minute. Ich wollte mir jetzt erzählen,
das funktioniert, oder was?
What the fuck, Alter?
Ich habe, Alter.
Was bin ich
sehend überhaupt, Mann?
Das geht auf jeden Fall besser.
Ich habe keine Ahnung, was es überhaupt,
was mir das überhaupt sagen soll, Mann.
What the fuck?
What?
Was ist der Hashmap Iter?
Naja, ein Iterator über den Typ in der Hashmap.
Also der Typ ist das hier, guck.
Das da.
Ich habe keine Ahnung, was ich hier gemacht habe,
warum es kompiliert und was ich jetzt,
was das überhaupt tut unter der Haube.
Okay.
What the fuck, Alter?
Ich verstehe es auch nicht.
Mach dir nichts draus.
Okay, Chatgear ist pfeifert.
Ich glaube im Next von dem Iterator implementiert
musst du nur argsref
Okay, dann.
Wenn ich das nur, nur das machen muss.
Easy.
Es holt den RW-Log
umwrapt den Read Access Iterator.
Ja, ja, ja. Im Prinzip habe ich damit
die Hashtag...
Im Prinzip könnte ich auch so...
Das ist nichts anderes, Mann.
Wie direkt auf die
auf die Struct-Variable zugreifen
im Endeffekt. Also
eigentlich komplett unsinnig.
Okay. Implement Iterator for Registry.
So, was muss ich?
Was? Moment, was muss ich machen?
argsref
Was? Wo? Wie?
Wo muss ich hier was machen?
Musst du nur argsref
Hashmap fällt vom Struct.
Okay, args... Alles klar, alles klar. Easy, easy.
argsref
sref
self
store
ähm
read
unwrap
Das ist der...
Das funktioniert nicht.
Chat, ich bin froh, dass ihr auch nicht schlauer seid
wie ich, was das angeht.
Also hier weiß er noch nicht mal
was die Referenz überhaupt ist.
Es ist B auf
unknown. Alles klar.
Ich mein,
es kann doch nicht so schwer
sein.
Das hier ist die Hashmap, doch.
Ah ne, das ist das
Varmalett-Map gleich.
Ah ne, es ist die
LW-Lockguard.
ähm
Das da ist die Hashmap. Zumindest
eine Referenz auf die Hashmap.
Aber das checkt er trotzdem nicht.
mismatch
expected
arg
Was, was, was, was expectet er?
Expected und...
Ne, ne, ne. Okay, so funktioniert das schon mal nicht.
Chat, ne, ne, ne.
Klappt das nicht. So klappt das nicht.
Ich hab wirklich keine Ahnung, wie es funktioniert.
Echt nicht. Kein, kein
Schimmer. Okay, wir suchen
wieso noch mal stack... rust
iterator
implement iterator
rust
iterators. Rust by example.
Ja, das, Moment. Das, das
example habe ich ja schon
wrapped Hashmap.
Okay, genau das. Hier.
Der hat ne Hashmap
in nem struct.
Und jetzt will er für sein struct
Jetzt will er für sein struct
äh
response
ah, response headers
will er, will er das... Okay, genau das.
Im Prinzip, im Prinzip genau das
was ähm
was ich auch machen will.
You are doing right, was
was you are doing right now is
delegating to the into iterator
implement, but you need to delegate
to the into iterator
implementation of
und Hashmap string.
Because you can't get
an own version
Ja, ja, ja. This is easy
to fix. Thankfully.
Leute. Easy.
Es ist easy to fix.
Alles klar.
Easy to fix.
Dann machen wir das doch mal.
Easy to fix. Let's go.
Easy.
For
ähm
Wait a minute. For
registry of
T
Okay.
Was ist das eigentlich für hässliche Sachen wieder?
Irgendwelche Lifetime
Sachen. Okay.
Item type. Ach, hier oben.
Header map.
Item type ist
Hash. Okay.
Ich kopiere das mal.
U32 of T. Ja gut. Das ähm
Das funktioniert so nicht.
Not member of
Okay.
Kann man das vielleicht hier irgendwie reinpappen?
Nein.
Kann man das irgendwie
hier reinpappen? Nein.
Okay.
Es ist ja auch wurscht. Wir können das copy-pasten.
Was ich da mache, das frage ich mich auch.
Header map.
Okay. Okay. Das ist das. Okay.
Alles klar.
Okay. Ja.
Nice. Nice. Nice. Okay. Ja.
Mhm. Mhm.
Und self
Okay. Self. Store.
Read.
Unwrap.
Ey, das wäre jetzt zu einfach, wenn es funktioniert.
Moment. Ist das hier überhaupt
die Map?
Let map gleich.
Ey, wir brauchen wieder hier.
Und jetzt. Moment.
Was brauche ich da eigentlich?
Das wäre jetzt viel zu einfach, wenn das funktioniert.
Item
mismatch.
Ne, ne. Der Store ist nicht die
Hashmap. Der Store ist ein Rw-Log.
Was?
Expected Type Parameter T. Found Arc T.
Ah.
Siehste?
Habe es ja auch verkehrt
gemacht.
Aber.
Aber warum geht das jetzt nicht?
Wieder
genau der gleiche Scheiß
wie vorher, Mann.
Was will er hier jetzt?
Temporary value created here.
Ja und?
Das kann doch nicht
so schwer sein.
Meine Fresse,
Alter.
Ich will eine Schleife machen.
Ich bin ja froh,
dass es easy to fix ist.
Glücklicherweise ist es easy to fix.
Ich weiß,
was das von mir will, Mann.
Es ist ja noch nicht mal async.
Rust.
Echt.
Ich habe kein blassen Schimmer.
Cursor of Hashmap.
I'm trying a simple
thread-safe memory key values
My code looks like this.
Ja, der macht.
Obviously. Simple.
Implement. Cursor.
Okay, jetzt vielleicht.
Ich will die Werte nicht klonen, Mann.
Ich check die Antwort.
Noch nicht mal.
Die Antwort ist mir schon zu sick.
Oh, jetzt habe ich meinen Browser gekillt.
Leute, mein Browser ist kaputt.
Ah, da geht er wieder.
Er lebt wieder.
Das ist wirklich
Pains champ, Mann.
D-Ref.
Also ich habe keine Ahnung,
warum das bei denen funktioniert.
Aber mir funktioniert das nicht.
Kein LW-Lock.
Vielleicht ist das das Problem.
Keine Ahnung.
Ich meine, das ist doch ein Witz, oder?
Ich meine, wie scheiße kann eine Sprache sein,
dass man eine probliche
Schleife über seinen eigenen Typ
nicht hinbekommt.
Wofür brauchst du das LW-Lock,
dass es thread-safe ist?
Ich habe keine Ahnung.
Wir klonen das jetzt einfach,
weil mir nichts anderes einfällt.
Wir machen das erste,
das erstbeste, was mir eingefallen ist.
Return, self,
store,
read, unwrap,
clone.
Das ist halt echt nicht schön.
Der
kopiert jetzt alles.
Ich meine, es ist nicht viel, es ist trotzdem schnell.
Aber es ist scheiße.
Okay, Chat, ich habe jetzt mal eine ernste Frage.
Wie genau?
Was soll mir
sowas sagen?
Ich meine, du hast mich gefragt,
wofür ich LW-Lock brauche.
Ich habe dir gesagt, damit es thread-safe ist.
Es gibt eine Menge thread-safe Datentypen.
Max, es gibt übrigens viele Autos.
Welcher
Datentyp wäre deiner Meinung nach besser geeignet
an der Stelle als LW-Lock?
Von den vielen thread-safe Datentypen.
So, jetzt können wir hier sagen,
oh,
jetzt findest du es. Ja, das ist klar.
Aber jetzt kopiert er das auch.
Das fuckt mich ultra ab, Mann.
Ich will wissen, wie das funktioniert.
Wir machen jetzt aber damit nicht weiter.
Sonst drehe ich echt am Rad.
Hier, returning wrapped,
okay, Moment mal.
Chat, das ist genau das, was ich machen will.
A, B, D...
What?
What the f...
Ich verstehe noch nicht mal, was er fragte.
You can't solve
this with naming your
lifetimes, as this isn't
really a lifetime problem, but a problem with
ownership. You can provide
access to the HashMap and make the call
values.
So was in der Richtung habe ich ja auch schon gebaut.
Ich meine, das soll mir auch recht sein.
Trivial.
Trivial.
Because
gut-like FN-Trades don't exist.
Ah, obviously. Jetzt weiß ich,
Leute, jetzt weiß ich, warum es nicht funktioniert,
Mann. Weil gut-like FN-Trades
not existen.
Hätte es mal gleich einer gesagt, Mensch.
Ich hoffe, euch ist jetzt auch alles klar.
Jetzt
obviously, jetzt ist alles logisch.
Yep, easy.
So, ich mach mal hier.
Mapped, log, guard, HashMap,
string, size, user.
Map, self, item,
read, what?
Leuchtet ein, ne? Es leuchtet
komplett ein.
Achso, Moment. Item ist
die HashMap.
Self, store,
read,
äh,
Alter.
Use parking lot? What?
Guck mal, die, hier,
Rust weiß noch nicht, was will ich hier? Map, Map.
It's not an iterator. Ja, ach,
okay. Nice.
Sehr gut, sehr gut. Excellent.
Jetzt weiß ich Bescheid, ja, Mann.
Cannot find. Moment, das gibt es überhaupt nicht?
Das gibt es einfach überhaupt nicht, was die hier vorschlagen.
Alter, was ist das für ein pepega post, Mann?
Lw, log, guard,
gibt es überhaupt? Ach, Moment, das ist von parking lot.
Was auch immer parking lot ist.
Was ist die parking lot?
Lw, guard, Mensch. Ja, dann,
ja, dann ist klar.
Ich glaube, ich weiß, wo...
Weißt du was? Scheiß drauf.
Jetzt nicht, jetzt nicht, Leute.
Jetzt, jetzt nicht. Wir lassen,
wir lassen es jetzt nicht. Da dreh ich, da dreh ich ab,
weil... Also, ich bin,
ich bin erstaunt,
dass das so krass
kompliziert ist.
Okay, was? Playground?
Ich, ich mach jetzt nicht weiter.
Das, das, da dreh ich.
Reicht dir das? Ja, Moment, Moment, mal gucken.
Moment. Excellent, excellent. Chatgear macht
mit. Ich bin froh. Chat ist, Chat ist schlau.
Äh...
Wo, wo ist der Unterschied
zu mir? Ah, hier!
Okay, was, was, was, was macht das jetzt?
Anders als, als
meins?
Zwei, okay.
Store, read,
unwrap. Ah, okay, wirklich
schön ist... Aber dann, da muss
ich zumindest nicht klonen.
Das finde ich eigentlich ganz, ganz gut.
Da muss ich, da muss ich zumindest
nicht...
Da muss ich nicht klonen.
Und es funktioniert, oder?
Das ist gut.
Das ist, das reicht mir.
Also, ich würde sagen, das reicht mir.
Das ist, das ist im Prinzip
das einfach nochmal gerappt.
Das ist die bisschen schönere Variante
wie von meinem geklonten.
Wo, wofür ist denn
hier vorne das Ding? Kann man das wegmachen?
Äh, anscheinend, okay.
Ich weiß nicht, wofür das da ist.
Wofür, es ist irgendwie Lifetime. Aber Lifetime
für was? Lifetime, die ich
sonst nirgendswo benutze, oder?
Lassen wir einfach mal weg.
Ja, das finde ich, das finde ich gut.
Alter, was ein
Akt, man! Ich raste aus, ey.
Eieiei.
Boah.
MonkaS.
MonkaS, man.
Okay, können wir jetzt
eigentlich, Moment, Moment, ja,
okay, ja, wir machen weiter, aber jetzt
kommt ja noch was anderes, was das Ding können soll.
Und zwar, ja, und zwar
es soll
ja noch IDs berechnen können.
Wie, wie könnte man das mit der ID-Berechnung machen,
Chat? Wie könnte man
das, habt ihr irgendeine klare Idee? Also,
wir könnten, wir könnten einfach random was
generieren. Das ist aber nicht schön.
Ich meine, die Chance, dass was doppelt generiert wird
bei meiner kleinen Anzahl, also,
UID ist raus,
weil, ja, weil ich UID
nur etwas komplizierter
hin- und herschieben kann über ein C-Interface.
Aber, wir könnten,
ich habe
eine Idee, Leute. Ich habe
eine Idee, was wir machen können.
Force Champ.
Was ist mit random oder einem Hash?
Ich hätte gerne lieber was, irgendeinen simplen Counter.
Okay, ich habe,
ich habe nämlich eine Idee, wie wir das ganz
einfach machen können. Ich meine, unsere Keys
sind U32, also, wir haben
4 Trillionen, was auch immer,
Milliarden, sonst was,
möglicher,
ich weiß nicht, was U32-Max ist. Irgendwas mit
einer 4 vorne.
Ah, das läuft.
Mögliche, mögliche
IDs. So, also, was wir jetzt machen
können, ist,
wir machen mal, wir machen mal so eine Function,
wobei, brauchen wir nicht mal für,
also, den Store.
Er ist hier, so.
Also,
die ID, wir generieren die ID
folgendermaßen,
und zwar,
wir checken einfach,
ich habe eine Idee, ich habe eine Idee,
ich muss mir kurz, nur kurz Gedanken drüber machen.
Wir machen eine Schleife,
wir machen eine Schleife,
und
wir lassen eine Schleife laufen,
von 0
bis U32-Max.
Und die erste freie ID,
die noch nicht vergeben ist, nehmen wir.
Das müsste doch eigentlich gut funktionieren.
Nee? Warum nicht?
Warum ist das kacke?
Dann kannst du auch random
nehmen. Nee.
Die erste freie bedeutet immer, dass ich
eine unique ID finde. Bei random
habe ich im Zweifelsfall, bei einem
32-Bit-Random habe ich im Zweifelsfall
doppelte Werte. Die Chancen sind gering,
ja? Die Chancen sind
gering, aber
sie sind da.
Und mit einem Counter nicht.
Also,
bei einem 32-Bit,
das ist nicht impossible.
Bei einem 32-Bit-Int
hast du, Moment,
U32-Max.
Also,
guck mal, wir haben, was ist denn das?
Das ist gar nicht mal
so viel, das sind 4 Milliarden nur.
Guck mal.
4 Milliarden. Wir haben nur
4 Milliarden
mögliche
IDs.
Ich meine, 4 Milliarden bei,
was weiß ich, 5 gleichzeitigen Connections
ist die Chance auch sehr gering, okay?
Gebe ich zu. Aber, nur mal von der Idee
her, die Chancen sind gar nicht
so klein. Wir haben 5 Milliarden
zufällige IDs und
ab der
Hälfte, ab 2 Milliarden
ab 2 Milliarden IDs
ist die Chance über
50 Prozent,
dass die nächste generierte Random-ID
schon mal vorhanden ist.
Es sind einfach,
es sind einfach in einem U32 zu wenig,
zu wenig Platz.
UNIX-Timestamp ist, äh, selbst
in Millisekunden nicht unbedingt so, so sinnvoll
an der Stelle.
Komm, wir machen mal das, wir machen mal das, was ich,
was ich gesagt hab.
Also, wir machen eine Schleife.
Wir machen
eine Schleife von,
oh, kann man nicht einfach zählen hier irgendwie mit einer
Schleife, 4i?
4i in, okay.
4i in, äh,
U32
max. So, und jetzt
if, ähm,
wir müssen das hier mal kurz an,
anwrappen, hier oben schon.
If
map, da gibt's noch irgendwie so contains,
contains key
i,
if not contains
key i,
dann, Moment, das muss bestimmt,
dann, return i.
Das ist alles, was wir machen müssen.
Schon kriegen wir die erste freie ID.
Nee, das ist doch eigentlich gar nicht schlecht.
Weil, das Schöne ist,
die Verbindung, wir,
das ist ja nicht nur, das ist ja nicht nur add,
add, append only.
Es können ja auch Sachen gelöscht werden.
Mal angenommen, der erzeugt 5 Verbindungen.
So, irgendwann schließt,
irgendwann macht einer den Browser zu,
und die ersten 5
Verbindungen werden gelöscht.
Dann sind die IDs 0 bis 5 wieder frei.
Und wenn das nächste Mal die Schleife läuft,
dann gibt er IDs 0 bis 5 neu.
Das dürfte immer ziemlich
schnell laufen.
Übrigens, return i ist an der Stelle
für Pegatime.
Leute, wie würde man das, wie würde man das
jetzt rust, ich hab ne Idee, pass auf, wir machen jetzt,
wir machen jetzt, wir machen jetzt
rust idiomatic way,
das Ganze, match.
Nee, ich weiß nicht, wie das funktioniert.
Hahaha.
Ich hab keine Ahnung.
Okay.
Ähm.
Dann wissen wir.
Connectest du vielleicht dann so mit dem selben
Ähm.
Nee.
Weil einmal geschlossene
Connections können glaube ich nicht mal neu aufgebaut werden.
So.
Moin für die nicht Programmierer unter uns sind.
Was wird programmiert?
Wir programmieren eine,
ein rust WebRTC
Backend, mit dem du alle deine
Webcams im Browser in Echtzeit
rein streamen kannst.
Also, wenn's denn dann funktioniert.
So, also.
Und wir lernen rust dabei.
Also, guck mal.
Kann man hier so ne Art range draus machen?
Ist, Moment. Range rust.
Ranges.
Aha, einfach klammern.
Also, sowas hier.
Klammern.
Und jetzt sagen wir eater.
Moment, das gibt's nicht.
Into eater. Ja, soll mir auch recht sein.
Select. Nee.
Where. Filter.
Filter?
Nee, Filter will ich nicht.
Moment, Moment.
Rust. Ähm.
Find first
Currents in Vector.
In Array.
Position.
Der Chat sagt find.
Gibt es find?
Find.
Find.
Filter next. Okay.
Find takes the
Closure.
Okay.
Ah, yeah. Find is short circuiting.
In other words, it will stop processing
as soon as the closure returns true.
Ja, das ist das, was ich haben will. Okay.
Find. Ähm.
Closure in rust. Das ist so,
glaub ich. Wie in Ruby ist das.
So. Ja.
Oder sagen wir mal
ID. Und jetzt so.
Nee. Und jetzt?
Okay, jetzt weiß ich nicht weiter.
Doch wahrscheinlich
einfach. Einfach
Klammer auf, Klammer zu.
Oder kann man. Moment.
Oder kann man vielleicht
sogar
sagen map
contains key
ID
und dann not.
Ah.
Und da jetzt. Moment. Das jetzt.
Da jetzt ein Match drauf. Da jetzt
ein Match drauf. Dass wir eine Fehlermeldung
schmeißen, wenn er keine freien IDs
findet. Wie funsten das jetzt?
Match. Jawoll.
Die Idee hat mal was gebracht. None.
Okay, wenn er keine freien gefunden
hat, dann
würde ich sagen, paniken wir.
Panic. Äh.
No free ID found.
So. Bam.
Und wenn er was gefunden hat,
dann soll er
die ID returnen. Macht das
so Sinn? Du kannst auch expect machen.
Mit panic
killst du den Prozess. Ja, das ist gut so.
Soll er. Soll er ruhig.
Also wenn ich es schaffe 4 Milliarden IDs voll zu bekommen,
ist irgendwas verkehrt.
Auf der anderen Seite. Ihr habt recht.
Das macht überhaupt keinen Sinn mit match.
Sondern wir sagen einfach let ID
expect
und dann machen wir eine custom Fehlermeldung.
No free
ID found.
Zack. Easy.
Das gefällt mir.
Das finde ich schick.
Kompiliert. Kompiliert auch noch. Okay.
So und jetzt haben wir.
Und jetzt haben wir jedes Mal eine frische ID.
Sehr gut. Nice.
Jetzt können wir doch gleich mal testen ob das funktioniert
was wir gebaut haben.
Ich glaube mehr brauchen wir in dieser custom
custom Klasse nicht.
So dann lasst uns doch mal gucken ob sich
die Aufregung heute gelohnt hat.
Gehen wir mal
in unsere Lipp. So.
Api State.
Da gibt es jetzt ein Feld für
Connections. Das reicht erstmal.
Connections.
Ich habe jetzt schon öfters gesehen
dass die Leute gerne in Rust die Sachen
abkürzen. Rust
Fifads. Wie würdet ihr das schreiben an der
Stelle? Würdet ihr die Variable
Connections nennen?
Mojojojo. Danke schön für den
Sub. Würdet ihr die Variable
an der Stelle Connections nennen?
Con?
Cons?
C?
Oder wie ich?
Connections.
Der Sensitive Aal hat auch Subscribed.
Gar nicht gesehen. Danke für den Sub.
Verbindungen. Ja genau.
Prime Sub für die Krustentiere.
Sehr schön. Pogu.
Von Aqua.
Dankeschön für den Sub.
Und für die Fifad Unterstützung
vorhin.
Okay. Connections. Also.
Registry of Tea.
Kann das sein dass ich schon mal Registry
irgendwie habe hier?
Registry.
Das habe ich schon mal importiert. Was ist das?
Oh.
Shit.
Ne. AppState.
Registry of
So. Was brauchen wir jetzt? Testweise
Connections haben wir gesagt.
Track local static sample.
Ne.
Alter. Wo ist das Problem
jetzt? Ach ist das nicht public
vielleicht? Ach ist private.
Ah.
Excellent.
Wie will ich importieren?
Card Collector. Moin.
Pluska. Ja auch wieder am Start.
Pogu.
Der Name kommt mir zumindest bekannt vor.
Ich weiß nicht genau woher.
Aber der Name kommt mir bekannt vor.
Also hier aus dem Chat auf jeden Fall.
Aber ich weiß nicht
mehr mit was ich
in Verbindung. Zumindest warst du schon öfters hier.
So.
Connections. Registry. Track local static sample.
So. Das müsste doch immer noch
kompilieren oder? Nein. Natürlich nicht.
Ach so. Weil ich es da unten vergessen habe.
Ist okay.
Registry. New.
Alles klar.
Es kompiliert. Yeah.
Top. Dann können wir das ja auch jetzt
mal ausprobieren. Connections.
Dann schmeißen wir das hier mal weg.
Also das Ziel ist, dass dieses ganze Zeug hier
reinwandert in AppState.
Check mal ob die Funktionen
alle public sind. Aber
sonst alle. So.
Und jetzt.
Wo verwenden wir denn jetzt
Connections? Ich lösche das hier einfach mal.
Genau. Da wo es rot geworden ist.
Connections gleich.
Also im Prinzip brauchen wir bloß noch self.
AppState. Nicht self.
AppState. Get.
Unwrap Connections.
Also aus irgendwelchen Gründen
nicht funktioniert.
Cannot move.
Ach so. Muss ich wieder
und davor machen. Ja.
Ok. Registry.
Pair Connections. Connections.
Get.
Ne. Moment. Erst mal
da unten das ganze fixen.
AppState. Get.
Unwrap.
Connections. Und wieder und.
Soll ich nicht? Ja komm.
Wir lassen es jetzt mal so.
So. Insert.
Insert gibt es nicht. Es gibt
Add.
Und es wird einfach nur
die Pair Connection hinzugefügt.
Ach so.
Ja. Wenn man es mal richtig macht, dann wird es auch
funktionieren. Das hier unten
brauche ich gar nicht mehr.
Weil es schon
initialisiert ist.
Ja.
Bleibt im Endeffekt nur noch
das hier. Pair Connections.
Get ID.
Das hier bleibt jetzt noch zu fixen.
So. Und
wir getten jetzt.
Ok. Das sind U32.
Muss es nur noch sein.
Wir sind mal hart drauf
und casten mal schnell das U64
runter zu einem U32.
Und get ist bei mir
ein U32. Ja.
Moment. Kann man in Rust
das irgendwie casten?
Dass ich sage U32 ID?
Ne.
Ok. Ich meine das ist unsafe.
Das wird wahrscheinlich. S. Geht das? Ok.
S.
Ach ne. S U32.
Ah.
Unwrap.
Jetzt brauchen wir gar nichts unwrappen.
Ja doch. Ist doch gut. Passt doch alles.
Ok.
Ich glaube das war es schon.
Das ist übrigens blöd.
Das müssen wir. Wir machen das mal richtig.
Ja. Das ist ein U32 hier.
Und das ist ein U32 hier.
Und das ist ein
U32 hier.
U64.
Das ist ein U32 hier. Wir machen das mal richtig.
Sonst habe ich nachher irgendwelche
merkwürdigen random Bugs.
Und in .net
ist das auch ein Uint
32. Ok.
So.
So. Und jetzt können wir mal sehen ob der Bug
gefixt ist. Das nur einmal
nur einmalig funktioniert.
Das sollte jetzt mehrmalig mit reloaden funktionieren.
Starten.
Ok.
Shit. Irgendwo habe ich
was verkehrt gemacht.
Ok. 44.
Zeile 44. Ok.
Let's go. Zeile 44.
Hast du die
lip kopiert? Ja.
Zeile 44.
Die ID gibt
es nicht. Ok. Die ID
gibt es nicht. Warum gibt es die ID nicht?
Weil ich irgendwo, irgendwo
Mist mache hier.
ID gleich.
Ok. ID.
Ach hier. ID gleich 1.
0. Ja. Hier.
ID gleich.
Und jetzt gibt es die ID auch.
Wenn da immer 1
drin steht.
Ne Option return. Das ist gut, dass
das gecrashed ist. Der konnte
schlicht und ergreifend nicht weitermachen.
Ich finde das gut.
Da weißt du allerdings, dass es kaputt ist.
So. Nochmal.
Fuck. Ne.
Es geht. Der Browser
war einfach nur pepega gerade.
Kann das sein,
dass mein JavaScript
ein bisschen weirdchamp ist?
Ich glaube mein JavaScript war ein bisschen weirdchamp.
gerade.
Aber es funktioniert. Der Bug ist behoben.
WebRTC funktioniert.
Und er funktioniert
mehrfach.
Auch wenn man refresht.
Aber wenn man
zu schnell refresht, dann
Moment. Wenn er irgendwas reused,
dann funktioniert es nicht. Ok. Das müssen wir
nochmal überprüfen. Ja.
Der baut aber gar nicht die
Verbindung auf.
Nun ja. Der versucht
irgendwas zu re-usen, was er nicht
re-usen soll.
Da stimmt irgendwas doch nicht ganz in der Logik,
würde ich sagen.
Wir geben nochmal kurz aus
die Connection ID.
Weil das sollte immer eine neue ID sein.
Es sollte immer
log
jasonclientid.
Es sollte immer eine neue ID sein.
35, 36,
37. Es ist auch immer eine neue.
38,
39. Ja.
Der Browser denkt nur,
er kann die Sache cachen aus irgendwelchen Gründen.
Und das funktioniert nicht.
Guck. Manchmal
cache das und manchmal nicht.
Keine Ahnung, was mein Browser da für
pepegasachen macht.
Aber ich bin mir relativ sicher,
hier, weil es auch immer neu ist,
dass das nicht an meinem Backend liegt.
Weil, weil,
wenn ich ohne cache refreshe,
guckt,
wenn ich ohne cache refreshe,
dann funzt es immer.
Bis es nicht funktioniert.
Kommt das nicht irgendwie in die
Quere? Das sieht ein bisschen
so nach Thread-Problemen aus, oder?
Aber ihr seht, es ist immer eine neue
Connection. Also daran kann es ja eigentlich
nicht liegen. Und nachdem ich immer
alles schön unwrappe und hier nichts abkackt,
ich schieb das wirklich
aktuell auf meinen Browser.
Dass der da nicht so genau
weiß,
was er macht.
Ich schieb's auch auf JavaScript.
Versuch mal Firefox.
About WebRTC.
Ja. True.
Nö.
Firefox hat das gleiche.
Failed. Aber ihr
seht, er hat die.
Er bekommt die Offer hier.
Hat der Probleme mit den Multiplexen
beim Port oder so?
Wir machen noch mal ganz kurz den Debug
rein.
Das ändert daran doch
jetzt auch nichts.
An Rust nirgendwo Error-Handling.
Also an Rust wird's in dem Fall echt nicht liegen.
An der Rust-Seite.
Irgendwie liegt's glaube ich an
PPGA JavaScript. Ist meine Vermutung.
Irgendwie.
Das ist übrigens auch
da waren sie lustig bei Firefox.
Das steht in jeder dieser
Meldungen drinne.
Das ist SDP.
Weil das halt das Session Description
Protokoll ist, weil einer lustig hat geschrieben.
Das ist Superachter.
Wenn man das mal sieht, da war Mozilla Mitarbeiter.
Wollten witzig sein.
Lull.
Also das hat funktioniert offensichtlich.
Sonst hätte er hier ja
nix geantwortet.
Wir machen noch mal hier
Keckel.
Wintel.
So.
Jetzt können wir mal gucken.
Was? Also das sieht nicht so aus
als liegt das
Hä?
Ich glaube eher das liegt am JavaScript Zeug.
Ok.
Zweites ist kaputt gegangen.
Keckel.
Bei mir ist alles durchgegangen.
Also ich vermute das liegt.
Es ist auch immer ne neue ID
am Start.
ID 2.
Wir können mal gucken ob es in neuen Tabs
irgendwann auftritt.
Wenn es nämlich nicht in neuen Tabs auftritt.
Dann liegt das.
Ok es tritt auch in neuen Tabs auf.
Dann ist tatsächlich irgendwas
kaputt.
Aber das werden wir nicht jetzt fixen.
Warte der Browser nicht lang genug?
Ne das glaube ich nicht so schnell wie das immer geht.
Aber auf jeden Fall wenn es jeden
zehntes mal loaden oder so nicht funktioniert
dann ist schon PP egal.
Ah hier. Failed.
Clear History.
Clear History.
Clear History juckt dies nicht.
Clear History.
Ja das geht.
Doch in nicht unerheblichen Teil
der Fälle.
Geht es kaputt.
Er bekommt aber den Handshake.
Ja er bekommt auch Candidates.
Also ich tippe
drauf dass das ein Problem der
Rust Library vielleicht ist.
Weil ich mache
hier so Port Multiplexing.
Ich mache hier so Port Multiplexing
und das ist
meine letzte Amtshandlung heute.
Ich lass das mal weg.
Das Port Multiplexing und guck mal ob es
dann weg ist.
Ohne Port Multiplexing will ich das nicht betreiben.
Was bedeuten die
Abkürzungen in Rust?
Welche Abkürzungen?
Also unspezifischer Fragen
hättest du auch nicht mehr können oder?
Oh du meinst für was Rust steht.
Rust ist gar keine Abkürzung.
Rust ist ne Programmiersprache.
Was ist Port Multiplexing?
Der macht mehrere Connections über den gleichen Port
anstatt für jeden Port was eigenes auf.
Ah.
Chatge.
Ich glaube das liegt am Port Multiplexing.
Guckt mal.
Seht ihr das?
Jetzt kackt nix ab.
Das liegt am Port Multiplexing von der Library.
Aber ohne Port Multiplexing werde ich das nicht
betreiben.
Guckt das wäre schon längst abgekackt.
Normalerweise.
Ich kann noch ein paar mal refreshen.
Passt mal auf.
Ich hab halt ein paar Ports offen jetzt.
Was kann man da jetzt machen?
Ehrlich gesagt vermutlich
nicht viel.
Was ich jetzt machen würde
ist.
Ich würde nen Retry im Javascript einbauen.
Also guck mal.
Zum Beispiel.
Also sagen wir mal das hier.
Das ist ja relativ offensichtlich der Bug.
Der irgendwie im Port Multiplexing liegt.
Und nachdem ich hier nix großartig einstellen kann.
Ja wird.
Man kann ja auch keine großartigen Settings
sonst einstellen.
Unip Multiplexing Default.
Man kann da nicht wirklich viel einstellen.
Closed.
Gibt keine großartigen Settings.
Ich würde nen Retry einbauen.
Im Javascript.
Ne da kann man nicht viel.
Option.
Warum nicht TCP?
Würde ich gerne machen.
Unterstützt die Library nicht.
Und ist für Echtzeit Video jetzt auch nicht so wichtig.
Also ich würde nen Retry einbauen.
Ehrlich gesagt.
Und zwar.
Mal.
Kompilieren das nochmal.
Dann gehen wir in C Sharp.
Führen das nochmal aus.
Machen wir sogar Minus C Release.
Hier auch mal.
Gucken ob das Problem noch auftritt.
Ja Problem tritt immer noch auf.
Also es liegt echt.
Es liegt echt am Port Multiplexing.
Guckt das das manchmal nicht geht.
Kaum ist das eingeschaltet.
Bugts wieder rum.
So was ich jetzt machen würde ist. Ganz ehrlich.
Retry hier im Javascript einbauen.
So nach dem Motto.
Ey.
Wenn das.
Innerhalb von.
Nicht connected hat.
Dann Retry.
Das kann ich mir jetzt.
Das kann ich mir jetzt nicht aus dem Ärmel schütteln.
Aber ich schreib mir das mal als To Do rein.
To Do Retry.
Oder vielleicht kann man das.
Ich mein 5 Minuten haben wir noch Zeit.
Vielleicht kann man das sogar relativ einfach machen.
Der legt hier die Verbindung an.
So und.
Okay ich weiß was wir machen. Easy. Easy.
Ich weiß was wir machen. Guck mal.
Z Intervall. Es ist Javascript.
Da können wir auch eklige Sachen machen.
Z Intervall. Nach einer Sekunde.
Ja.
Das wird jetzt.
Richtig eklig.
Das wird so eklig.
Da werdet ihr den Stream ausschalten wollen.
Also wenn nach einer Sekunde.
Der Connection State.
Ähm.
Der Connection State ungleich.
Ungleich.
Connected ist.
Dann.
Passt auf.
Dann.
Window. Location.
Reload.
Oh.
Das ist ein bisschen schnell.
Das ist ein bisschen. Okay.
Vielleicht 2 Sekunden.
Vielleicht 2 Sekunden.
Okay 2 Sekunden.
Jetzt hab ich es gebrokent.
Jetzt ist es kaputt Leute.
Ah. Geht doch. Geht doch. Easy.
Vielleicht sollte man.
Okay. Vielleicht machen wir auch 3 Sekunden.
Easy.
Eventuell noch Clear Intervall im Else Case.
Äh.
Moment. Ich will ja auch nicht
Z Intervall. Ich will Z Timeout.
Ich will ja Z Timeout. Ich will ja gar nicht
Z Intervall.
Ich will ja, dass es nur einmal ausgeführt wird.
Guck. Und es funzt.
Ha. Connection Probleme.
3 Sekunden später. Bam. Seite.
Reloaded. Connection. Funzt.
Kannst du nicht das Event Connected abfangen
für den Reload?
Doch.
Aber ich will ja hart nach 3 Sekunden
gucken ob es Connected ist.
Das Event Connected fange ich
hier ab. Ja.
Ich könnte warten.
Ich könnte warten bis das auf Failed steht.
Zum Beispiel.
Gucken wir mal wie lange es dauert bis es auf Failed sich stellt.
So.
Dauert ewig.
Es dauert ewig bis es auf Failed geht.
Das geht einfach gar nicht auf Failed.
Das fängt
auch gar nicht an erst.
Z Intervall.
Wir gucken jetzt mal kurz.
Alle Sekunde.
Log PC
Connection State
und Log
PC Ice
Connection State.
Ok. New. New. New.
New. New.
Das geht nie auf Failed.
Das macht einfach gar nichts.
Ihr seht die Logs nicht.
Ja jetzt habt ihr es gerade gesehen.
Jetzt gerade hat man es gesehen. Ok.
Ich mach das da für euch in die Mitte. Ok.
Das erkennt gar nicht dass es Failed ist.
Das heißt
mein Ansatz
ist einfach bester JavaScript Fix ever.
3 Sekunden warten. Wenn nicht Connected
Restart. Easy.
Guck. Nicht Connected.
3 Sekunden später Restart
und Connected. Connected.
Also ich glaube
das liegt irgendwie in diesem Port Multiplexing.
Was man auch gesehen hat.
Weil sobald ich das Port Multiplexing
Port Multiplexing raus mache.
Ach guck mal.
Irgendwann geht das auf Failed mal.
Github
Github
WebRTCS.
Wir können noch einmal kurz hier rein gucken
in die Examples.
UDP
Single Port.
Ne die hatten gar kein Beispiel
dafür.
Ne die hatten kein Beispiel dafür.
Nice.
Ok die High IQ Leute
setzen das so.
Was ist UDP?
Die verbindungslose Variante von TCP.
Von TCP.
Settings
Engine.
Ok das hat dir jetzt wahrscheinlich nicht so viel gebracht.
Aber.
Settings Engine.
Z UDP Network.
Ok die coolen Leute machen so.
Vielleicht bin ich einfach nicht
Rust Pro genug.
Ich meine mal seriously.
Das hier ist wahrscheinlich nicht viel anders
zu dem was ich gebaut habe.
Äh.
Achso ja. Settings Engine sollte ich vielleicht mal anlegen.
Ob das jetzt.
Das müsste die gleichen Probleme haben.
Es ist kein Unterschied zu dem
was ich gemacht habe.
Warum RUST?
Weil blazingly fast
und coole Leute verwenden Rust.
Ich will auch zu den
coolen Leuten gehören.
Ne ok Problem gibt es immer noch.
Jetzt geht es gar nicht mehr.
Jetzt geht es gar nicht mehr.
Jetzt ist komplett kaputt.
Jetzt komplett broken.
Ne jetzt geht es.
Hat ein bisschen gebraucht.
Ne aber es ist immer noch kaputt.
Ist immer noch kaputt.
Aber leakst du jetzt nicht eine Connection
beziehungsweise eine ID?
Aktuell schon.
Aktuell schon.
Wir probieren WebRTC zu streamen.
Vom Server in den Browser.
Aber wir sind
immer mal gleich los.
Doch aktuell leake ich.
Ich brauche jetzt noch sowas wie.
Das muss auch noch ins to do rein.
To do.
Clean up old connections.
Dazu kann man.
Heute nicht.
Dazu kann man beispielsweise.
Ein Event subscriben.
Da gibt es.
Per Connection.
State.
On.
On State.
On Per Connection
State Changed.
Wie auch immer man das aufruft.
Da steckt man
ein Callback rein.
Ich lasse hier einfach einen Syntax Fehler drin.
Da muss ich nix weiter machen.
Und dann kann ich warten bis der Code quasi.
Closed ist.
Und dann lösche ich den aus der.
Aus der Hashmap.
Und dann wird nix mehr geleakt.
Okay.
Der Rest ist selbsterklärend.
Deswegen hat das auch keine Tests oder Docs.
Brauch man nicht.
Ist alles selbsterklärend.
git add-a git diff.
Ah Quatsch.
git diff--staged.
Oder so.
Okay.
Keine Windows.
Ich wollte gucken ob Windows Line Endings wieder drin sind.
Okay.
git status git commit a-m.
Qt Chat.
Okay.
MVP.
Leute.
Wir küren jetzt am Abschluss jedes Streams.
Chatge-MVPs.
So.
MVP.
Wer ist der heute.
Was ist euch heute besonders positiv aufgefallen.
Wir machen Chatge.
Chatge darf Chatge bewerten.
Communityge.
Gut. Keiner.
Auch gut.
Von Aqua.
Ja. Den können wir tatsächlich reinschreiben.
Von Aqua.
Ähm.
Odolmet war auch voll am Start.
Wen haben wir denn hier sonst noch.
Wer ist mir denn sonst noch positiv aufgefallen.
Heute.
Was Rust Knowledge angeht.
Zwei MVP's reichen.
Ja.
Und uns Deck Overflow.
Git Status.
Gut.
Git Log. Alles da.
Git Push Origin Master.
Bestimmt die ersten getriggert wieder auf Twitch direkt.
Der Brand schreist.
Master und nicht Main.
Anzeige ist raus.
So. Mal gucken ob alles auf
Shithub ordentlich drin ist.
Ja. Sieht gut aus.
Okay Chatge.
Nice. Schön dass ihr am Start gewesen seid.
Ich geh jetzt pennen.
Wir sehen uns. Bis denn. Macht's gut.
See you.
