Ja, auf geht's.
Leko, danke für den Sub.
Hogu.
20 Monate.
Das ist ja richtig.
Wenn ich den Sound finde, das ist ja richtig.
Immer noch.
Ich werde es mir wahrscheinlich nie merken können.
Trotz 20 Monates Dauersubscription.
Ja, heute ist es soweit, Leute.
Heute gucken wir uns die neue Version von...
Warum ist das so klein?
Was auch immer.
Heute gucken wir uns die neue Shit-Air-Version an.
Ich habe übrigens auch gerade meine neuesten Dot-Files gepusht.
Falls sich das irgendjemand zu Gemüte führen möchte.
Ich werde ja öfters mal gefragt.
Habe ich gerade gepusht vor 16 Minuten.
Hat sich nicht so viel geändert.
So ein paar Sachen sind hinzugekommen.
Ein paar sind weggeflogen.
Google Cloud Tools sind dazugekommen.
Ansonsten hat sich nicht so viel geändert.
Ja, das müssen wir mal gucken.
Womit verwaltest du die mit damit?
Schätzmoi.
Wobei, das ist Französisch.
Ich glaube, das heißt eher Chaisemoi oder sowas.
Wobei, ich...
Französische Aussprache muss nicht sein.
Ich würde sagen, ich mache mal einen Abstand.
Ich mache mal ein Update.
Und dann, weil es ist Arsch, es gibt immer Updates.
Chimua.
Ach du Scheiße.
Wie auch immer.
Ich finde Chetsmoi viel besser.
Oder was sagt ihr, Leute?
Chetsmoi.
Oder Chetsmoi.
So, wir machen nochmal alles.
Wieder alles eine Runde geupdatet.
Jawohl, wunderbar.
Excellent, excellent.
Und jetzt hauen wir nochmal
ein Riesen-Update.
Ein Riesen-Update.
Ein Riesen-Update.
Ein Riesen-Update.
Ein Riesen-Update.
Ein Riesen-Update.
Ein Riesen-Update.
Ein Riesen-Update.
Ein Riesen-Update.
Ein Riesen-Update.
Ein Riesen-Update.
Ein Reboot hinterher, weil das kann nie schaden.
Übrigens, der Stream gestern,
ich zeige euch gleich mal was richtig cooles,
was ich gebroggert habe heute,
tagsüber.
Man muss ja irgendwas Produktives
im Homeoffice machen.
Tatsächlich was cooles.
Der Stream gestern hat mich dazu inspiriert.
Wie hältst du die Tabs auseinander?
Gar nicht.
Gar nicht.
Ich gucke manchmal hier oben drüber dann so.
Aber ansonsten eher,
eher gar nicht halte ich die auseinander.
Ist iPhone in Combo der Uhr gut?
Ach, woher soll ich, keine Ahnung.
Ich habe keine Uhr.
Ich habe keine Apple, Apple,
keine Apple Clock.
Nutzt du Arch in einer Windows VM?
Nee.
Ach so, ja, so meinst du das.
Ich benutze Arch in einer VM unter Windows.
So rum.
Ja, das ist richtig.
Guck da, guck hier, da, VM.
Vmware Workstation nur mit dem Unterschied, dass ich das nicht benutze.
Vmware Workstation nur mit dem Unterschied, dass ich das nicht benutze.
Vmware Workstation nur mit dem Unterschied, dass ich das nicht benutze.
Ich habe das so gemacht habe.
Warte mal kurz hier.
Firefox auf, Terminal auf, sodass das wieder halbwegs erträglich aussieht.
Ich habe das so gemacht, man kann jetzt ja seit Windows 10, glaube ich,
ich glaube, ich glaube vorher gab es das noch nicht.
Paper, Wallpaper, ey.
Keine Ahnung, ich habe da nichts mehr von gehört.
Es gibt jetzt seit Windows 10 gibt es ja hier mehrere Desktops.
Und ich habe es einfach so gemacht.
Ich habe da auf dem ersten Desktop meinen ganz normalen Windows-Shit und auf dem zweiten Desktop einfach im Fullscreen meine VM mit Arch-Dilux.
Selbstverständlich, by the way, NeoFetch, Arch, by the way, was sonst.
Ich glaube, da müssen wir gar nicht diskutieren.
Das ist selbstverständlich.
Use ich Arch, da sind wir uns ja einig.
Leute, das ist ja logisch.
Ich hoffe, ihr auch.
Ich hoffe, ihr auch.
Wenn nicht, wenn nicht, dann stimmt mit euch ja irgendwas.
Nein, nein, ich bin kein Mann.
Ich bin nicht mal auf Manjaro unterwegs.
Guck mal, Arch-Linux, Original, Yepcock, Bestel.
So muss das sein.
Es muss, es muss Arch sein.
Und ich muss euch das mindestens 50 Mal heute Abend erzählen noch, dass ich Arch, by the way, verwende.
Nur dann ist es echt.
Ja, das ist, das ist Raw, Raw-Arch, selbst gemoddet, soweit wie es geht.
Selbstverständlich, klar war es sonst.
Korrekt, so sieht es aus.
Cringe, wenn ich Suse nutze.
Ja, ich würde eher sagen Cringe, wer Suse nutzt.
Oder Cringe, wie heißt das, Tumbleweed oder so, heißt doch dieses komische Suse-Unstable jetzt.
Wo ich mich immer frage, wer um alles in der Welt soll wirklich Suse verwenden?
Gibt es einen Grund?
Ähm, naja, eigentlich nicht so wirklich.
Außer, dass man viel cooler ist, wenn man offizielles Arch-Linux verwendet.
Weil man darf ja nicht mehr sagen, dass man Arch, by the way, verwendet, wenn man Manjaro benutzt.
Und nachdem das Wichtigste ist...
Beim Arch-Linux-Verwenden eigentlich permanent zu sagen, dass man Arch-Linux verwendet,
brauche ich schon ein Original, dass ich es auch sagen darf.
Doch, Suse ist richtig mies, Alter.
Ich kriege Anfälle, immer wenn ich Suse benutzen muss.
Ich zeige euch mal was.
Ich habe jetzt schon zwei Sachen und ihr wisst, ich kann mir das mit, mit fast 40, na gut, naja, nur nicht ganz.
Mit, mit fast 39, ja, ähm, kann ich mir das nicht mehr alles merken.
Ich wollte euch, was wollte ich euch zeigen, keine Ahnung.
Achso, ja.
Dass mich der Stream gestern, wer gestern nicht dabei war, gestern war ein bisschen spontan, konfus,
aber das gestern hat mich dazu inspiriert, dass...
Ah, manchmal macht es mich hier durcheinander.
Gestern hat es mich, ja genau, gucken wir uns mal mal die eigene Werbung an.
Gestern hat es mich inspiriert, und zwar, wir haben gestern diesen Stream hier gemacht.
Neues .NET 8 Feature, nun Konkurrenz für Go.
Wir haben relativ wenig zu dem Streamtitel gestern gemacht, sondern wir haben uns damit auseinandergesetzt,
wie man VMs über die C-API von Linux startet.
Das hat mich dazu inspiriert und das Projekt können wir heute eigentlich auch so als Testgrundlage nehmen,
als, also, weil wir einfach ein bisschen was mit Source Code brauchen, um, um Shit, Shit-EA zu testen.
Und es hat mich inspiriert, und zwar, ich habe heute im Homeoffice, äh, Broggerstells gemacht,
Hackermannstells, und ich zeige euch jetzt, ich zeige euch, ich zeige euch jetzt mal was.
Passt mal auf.
HOM Champ.
.
.
.
.
Wie soll das, wie soll das Ding auch sonst bitteschön heißen, ja?
VM Champ.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
der hit jetzt kommt jetzt kommt der hit passt mal auf wenn er fertig die vm starten ist dann
holt er sich eine ip wenn ich wenn ich und jetzt werdet ihr feststellen guck mal da der hat sich
direkt auf meine neue vm pssh connected sehen wir das so und jetzt kann ich sagen vm champ
rm 0w heißt die vm und jetzt die vm wieder weg das mega nice für schnelle vms zu erstellen guck
mal man hat sogar help man hat sogar hilfe ausgabe und jetzt kommt der hit das ding hat
auch shell completion das heißt ich kann jetzt das hier so in meine dass sie so in meine shell
config schreiben und dann hat er auch noch mal die shell completion jetzt passt es wird noch
wird noch viel viel advanced es wird noch es wird noch viel besser das gibt es noch nicht auf
shithub aber das können wir auf shithub posten es wird noch viel advanced vor allem
champ vm champ ok run name name für für vm tolle vm und jetzt und jetzt passt mal auf shell
completion os kann man auswählen was man für den image haben will und jetzt haltet euch fest sogar
image name completion ich will den debian 10 haben so und jetzt passt mal auf der
dass mal da mal die that we off und hier fehlt die stellung plus das man alsmans ist
an mengenエ Takes i also bis jetzt sogar ist ein und nощka von noshis anspreff guck mal
da da da da da macht ja von 20 sekunden centro ci bungs also er wartet auf das dann wartet
dann wartet er auf das netzwerk 30 sekunden und wenn das netzwerk da ist dann cornette
hat sich pssh und dann wird wird wird gleich wird gleich noch advancing richtig richtig
heckermann schild ja das dauert ein bisschen bis die vor angestellten und wisst ihr wie
ich das gemacht habe dass ich mich auf die vm connect anise powerful Pro Cloud Content
nen haben consegue ein eigenesurfiganier und auch andere kullan обeistert eine helping
to myor識 konnex an artist api und becovers kanon k microwave 그래 than admin hacer앙
Cloud-Image, äh, ein Cloud-Init
ISO erstellt, was ich in die
VM hänge, was dann die VM konfiguriert
beim Booten. So, jetzt bin ich auf meiner VM
drauf. Update,
wie auch immer.
Upgrade,
alle möglichen, also ihr seht, die VM funktioniert
ganz normal.
Jetzt kann ich wieder raus aus der
VM
und jetzt kann ich zum Beispiel sagen, VM-Champ
List, wenn ich nicht weiß,
was ich für VMs habe.
Da habe ich sogar eine Tabelle.
Was ich für VMs aktuell besitze
und jetzt, und es wird noch besser, ich kann
sogar, wenn ich mich da drauf connecten will,
noch sagen, VM-Champ
SSH und dann habe ich sogar
Auto-Complete für SSH
und bin schon wieder auf der VM drauf.
Das ist nicht Blazingly Fast,
Written in Rust, das ist, ähm,
Steinarter, danke schön für den Zap.
Das ist, äh,
.NET.
Ich kann das Repo gleich auch mal klonen.
Warum? Autsch, ist doch nice.
Und guck mal,
ich habe das mit dem
neuen Compiler-Feature
von .NET 8 ausprobiert.
Das gesamte
Binary ist bloß 12 MB groß.
Und das startet
auch saumäßig schnell. Guckt mal.
Machen wir mal Help.
Time.
Das braucht einfach nur 6
Millisekunden.
Das ist also wirklich
sehr, sehr zackig.
Irgendwas stimmt mit meinen Default
Sachen wohl nicht so ganz.
Ähm, tolle VM, was, hä?
Warum kein Arch bei den Images?
Kann man einfach hinzufügen.
Überhaupt kein Ding.
So, und jetzt, wenn man fertig,
also ihr seht ja, was ihr hier,
das war mehr oder weniger die ganze Funktion schon.
So, und wenn ihr fertig seid,
machen wir nochmal einen anderen.
Machen wir einen Test nochmal. Eine Sache zeige ich euch noch schnell.
For I in,
wir machen jetzt einfach mal 10 VMs.
Was, macht keinen Sinn,
aber es funktioniert.
Und dann seht ihr auch einfach, dass es schnell,
schnell funktioniert.
Vmchamp, run.
Und der Name von der VM ist jetzt einfach
vm$i, done.
So, wenn man sonst nichts angibt,
dann macht er ein Standard, Standard Image.
Standard Image ist Debian 11.
Ähm, ach so, Moment.
Siehste, siehste, ich bin, ich bin pepega.
Ich bin blöd, ich hab's wieder nicht,
ich hab's wieder nicht gecheckt.
Ich muss noch eine Option angeben.
Und zwar kann ich noch Option angeben.
Minus, minus Background.
Irgendwelchen Gründen geht Shell-Completion in der Schleife nicht.
Okay.
Minus, minus Background kann ich angeben.
Und dann erstellt er das alles.
Ja, dann erstellt er das alles.
Äh, asynchron im Hintergrund.
Also, wenn man hier den Wirt-Manager aufmacht,
dann, ihr seht's ja auch schon,
meine VM ist etwas ausgelastet mit Nested-Virtualisierung gerade.
So, und schon hab ich,
und schon hab ich 10 VMs.
Nicht, dass ich die brauchen würde, aber ich zeige einfach nur, dass es, dass es, dass es funktioniert, ja.
Nicht, dass ich die brauchen würde, aber ich zeige einfach nur, dass es, dass es, dass es funktioniert, ja.
Meine, meine VM ist halt mit Nested-Virtualisierung gerade ein bisschen ausgelastet.
Meine, meine VM ist halt mit Nested-Virtualisierung gerade ein bisschen ausgelastet.
So, und wenn ich jetzt fertig bin,
und wenn ich jetzt fertig bin mit Ausprobieren,
dann kann ich einfach sagen,
vmchamp clean,
und dann sagt er mir,
going to delete all VMs and images,
sogar 12 VMs,
wollen Sie das wirklich machen?
Yes, und alles wieder weg.
Inklusive Images, inklusive Images.
Inklusive Images, inklusive Images.
Weil, wenn ich jetzt,
wenn ich jetzt wieder eine VM starte,
muss er das Image neu runterladen.
Wenn ich jetzt wieder eine VM starte, muss er das Image neu runterladen.
Also, er hat wirklich alles aufgeräumt.
VMs, VM-Discs,
Images, alles, was man gemacht hat.
Das heißt, es ist super,
einfach mal auf die Schnelle,
sich Test-VMs zu erstellen.
sich Test-VMs zu erstellen.
Wo ist das Repo noch? Bei mir lokal nur.
Aber ich kann's, ich kann's gleich, ich kann's gleich pushen.
Wartet mal.
Wir checken, ich check das Repo mal kurz lokal aus.
Wäre nice, wenn die
VMs irgendwie getaggt werden, dass man weiß,
welche mit VM-Champ erstellt sind.
Sonst sind die eigenen erstellten auch da.
Nein, sind sie nicht. Sie sind nicht weg.
Der merkt sich, welche VMs von ihm
erstellt wurden.
Und, weil guck mal, der kann das doch auch listen.
Und, weil guck mal, der kann das doch auch listen.
Der merkt sich, wo welche,
welche VMs er erstellt hat.
Guckt, das merkt er sich hier.
Es gibt hier einfach jetzt eine Datei,
VM-Champ im Heimatverzeichnis
und da ist das alles drinne.
Achso, das Ganze ist sogar Workspace-ready.
Wenn ich Bock hab, könnte ich Workspaces einbauen.
Dass man mehrere Sachen parallel
betreiben kann.
Guck hier, VMs, da ist der ganze Shit drinne.
Und in Cache
und in Cache sind die
Images
Ach, xD
Man wollte es ja mal nicht übertreiben.
Und jetzt kann man sagen, clean,
dann löscht man das Image
und
jetzt ist alles weg.
So muss das sein.
Ein sehr nices Tool, oder?
So, ich klone mir das mal kurz.
Weil das Source-Code-Repo
können wir heute auch für unseren
Shithea-Test ausprobieren.
Repos...
Moment, ich muss mal kurz auf GitHub was gucken.
Shithub...
Ah!
Ja, alles gut.
Alles gut, passt.
So, wir klonen mal kurz das Repo.
Git clone...
VM-Champ already exists.
Ja, das ist der von gestern, den kann ich wegschmeißen.
Jaja, yes.
Alles weg.
Git clone...
VM-Champ.
Ja, VM-Champ.
Also, ihr könntet euch jetzt kurz aussuchen,
was wir zuerst
machen sollen.
Wie wird es ausgesprochen? GitHub oder Jit...
Shithub, eindeutig.
Genauso wie das hier logischerweise
auch Shithea ist.
Was ja sogar
zutreffend ist.
Ist es über Systemneustart persistent?
Nein, das ist Absicht.
Das sind einfach nur on the fly Test4Ms.
Wenn man mal kurz Test4Ms braucht.
Ich will gar nicht, dass es persistent ist.
Sobald es ordnungsgemäß runtergefahren wird,
der Rechner, dann ist alles weg.
Ne, will ich nicht.
Weil Gitthea hat jetzt
GitHub-Action-Support.
Das will ich ausprobieren.
Ich weiß, dass Gitthea jetzt irgendwie China-Chinesen-Zeug ist.
Warum pipst du yes nach m?
Warum nicht mit y bestätigen?
Naja, weil man ganz schön oft
mit y bestätigen muss,
wenn man so ein Git-Verzeichnis löschen will.
Oder Dateien löschen will.
Und wenn ich jetzt nachher m pipe,
dann weiß ich, was ich mache.
Nämlich, dass ich zu jeder einzelnen Datei
yes sagen will.
Ansonsten müsste ich jetzt 90 mal yes drücken.
Wie viel Gigabyte die Sekunde kann dein yes?
Wollen wir das mal ausprobieren?
Äh, Moment.
Wo haben wir denn hier pv?
Ich brauch pv.
Wie heißt das Package hier?
25.
Wollen wir mal gucken, wie viel Gigabyte die Sekunde
mein...
Muss man das jetzt...
Ich glaube, das muss man jetzt umleiten nach def 0.
Das funktioniert jetzt nicht.
Ähm, ich parke 7,5...
7,97...
Also sagen wir mal so,
7,7
im Durchschnitt vielleicht.
Gigabytes die Sekunde schafft
mein yes.
Excellent, oder?
Das muss ich schon immer mal wissen.
Das dürfte wahrscheinlich so ein bisschen
auch durch den
so...
RAM...
Na wobei, nee, RAM packt
mehr. Aber ich glaube, das reicht.
7 Gigabyte die Sekunde, oder?
Wofür steht pv?
Ich hab keine Ahnung, wofür pv steht.
Ich kann nicht sagen.
Ich kann nicht sagen, was pv macht.
pv piped, genau.
Monitor progress of data through a pipe.
Warum ist pv heißt...
Ich habe keine Ahnung.
Ich gehe davon aus, dass es das Tool auch schon
Placingly fast written in Rust gibt.
Es gibt mittlerweile alles rewritten in Rust.
Aber da kannst du Sachen
durchpipen
und das gibt es dann einfach wieder aus.
Damit kannst du checken,
wie viel du an Daten quasi
durch die Pipes durchschiebst.
Die haben CI auch schon.
Wirklich?
Aber ich kann das...
Ich kann forgeo
porgeo
wie auch immer.
Kann ich nicht aussprechen.
Und haben die aber auch CI?
Pipeviewer, aha.
Welche Version haben wir hier?
Okay.
Wo sieht man jetzt hier auf dem
Projekt die Tags?
1.19
Okay.
Die haben quasi
das wieder...
Die synken das regelmäßig mit
Stream, aber stellen sicher,
dass kein China-Chinesen-Spy-Zeug
drin ist, oder was?
Naja.
Wenn es sich anbietet wieder.
Also Leute, ihr könnt
euch jetzt aussuchen, was wir
machen. Ich meine, wir haben ein bisschen Zeit.
Es kann sein, dass ich
MMO-Kreisel-Crime machen muss.
Eventuell. Mal schauen.
Aber ich glaube,
es sieht nicht so aus, als sind Leute da.
Was hat GTA denn gemacht?
Ich krieg das Drama nicht mehr genauso zusammen.
Irgendeine Firma
in Hongkong, aus Hongkong,
also Kekomritz
aus China, haben
das Ding
versucht zu vermarkten.
Mit irgendeiner China-Chinesen-
Firma. Und
ich weiß gar nicht mehr, warum
sich alle aufgeregt haben. Es haben sich zumindest
im Dezember, war das glaube ich,
ist schon ein bisschen her, wo es das Drama gab.
Da haben sich irgendwie alle aufgeregt
und Codeberg hat es dann irgendwie
gefolgt zu Forgeo
oder wie spricht man es?
Forgeo.
Meine Güte, können die sich nicht mal
bitteschön Projektnamen ausdenken,
die irgendjemand aussprechen kann?
Jetzt hätte bloß
noch ein Punkt
I-O-Domain gefehlt.
Dann hätten wir dann Forgeo
I-O gehabt.
Forgeo-I-O.
Da blickt doch kein Mensch mehr durch.
Kann man im Chat nicht mehr
checken mit Ausrufezeichen knu?
Doch, bestimmt.
Ich könnte mir vorstellen, dass der Nightbot gerade wieder
rumspackt. Der hat manchmal Probleme.
Ein Softfork, das heißt
die rebasen das immer oder sowas
in der Richtung. Ja, was auch immer.
Checkt. Ihr könnt es euch jetzt
aussuchen. Und zwar
wir haben ja ein bisschen Zeit.
Drei Stunden Zeit, so lange machen wir heute
wahrscheinlich eh nicht. Ihr könnt
es euch jetzt aussuchen. Entweder fangen wir
gleich mit Shit.EA
an und probieren da ein bisschen rum.
Und gucken uns die neuesten Features an und sonst was.
Wobei ich denke, wir haben genug Zeit.
Oder ich zeige
euch mal kurz im Schnelldurchgang
mein VM auf
Kommandozeile erstellen
Tool, was ich gebastelt habe. So ganz kurz
mal einmal durchscrollen
und gucken, was
Sache ist. Wir brauchen auf jeden
Fall schon mal eine Test-VM.
Weil
unser GitHub Actions Runner
der muss dann höchstwahrscheinlich in eine
VM. Also vmchamp
Run. Machen wir mal
eine Test-VM.
CI Test.
Und jetzt
Bam.
Ich freu mich, wie schön das funktioniert, oder?
Sehr nice.
Zack.
Downgeloadet. Debian Image.
Neue VM gestartet. Guckt hier, da ist sie.
Bam. Neue VM am Start.
CI Test VM.
Pogu. Kann man die
Ressourcen, das habe ich absichtlich nicht
reingemacht, oder sagen wir mal, noch
nicht reingemacht, weil ich bin mir nicht sicher,
ob ich das brauche. Ich wollte es halt
möglichst simpel haben.
Dass man einfach gar nichts außer das OS
angeben kann. Aber man könnte das mit den Ressourcen
schon machen. Sagen wir mal, zumindest
CPU und RAM
wäre vielleicht nicht verkehrt, dass man
das angeben kann. Das ist übrigens auch
einfach hinzuzufügen.
So, guckt. Zack. Und schon haben wir eine VM im Hintergrund
laufen. Mit, ich glaube,
ja, 200
256
MB RAM.
Ne. Was auch immer.
Ich habe das XML kleiner gemacht.
So, und hier habe ich die VM am Start. Gut.
Weil ihr es seid, dann machen wir das so, wie
ihr das wollt. Das heißt, wir gucken erst einmal
ganz kurz in das Projekt rein.
Ja, yes, yes, yes, yes, yes.
Und dann, ich kann es auch
auf GitHub pushen. Ich muss nur mal kurz
gucken, ob ich nicht irgendeinen Mist drinnen stehen habe, den
ich nicht auf GitHub gepusht haben will.
Schauen wir mal. Oh, was ist jetzt?
Es ist broken, Leute.
Broken AF. But why?
Warum ist es kaputt?
Also, zumindest meine IDE.
Ah, wegen .NET-Version.
Das haben wir gleich. Easy.
Easy fix. Cool. Set.
Easy fix.
.NET 8
wollen wir haben.
So, und jetzt müssen wir das Ganze reloaden.
Was auch immer. Das ist typisches Java-Gedöns.
Immer, wenn man Java-Anwendungen startet,
sieht das so komisch aus.
Okay, nice.
Hier sind wir am Start.
So, es funktioniert noch. Ich glaube,
ich habe nichts drin, was ich hier...
Ich meine, das ist nicht das schönste Build-Script.
Das soll mir jetzt aber erst einmal egal sein.
Ähm...
Ist hier irgendwas drin, was ich nicht will?
Was ich nicht auf GitHub haben will?
Ich meine, es ist bescheuert. Seriously, Leute.
Eigentlich bin ich total pipega.
Ich gucke live im Stream nach, in Dateien,
ob ich was nicht auf GitHub haben will.
Entweder zeige ich es jetzt im Stream,
was ich nicht sehen will und nicht auf GitHub haben will.
Dann ist es auch für den Arsch.
Oder ich kann es direkt...
Oder ich kann es direkt auf GitHub pushen.
Oder?
Chat, ihr versprecht mir doch.
Sollte ich irgendwas drin stehen haben,
dann macht ihr die Augen zu, ne?
Passt schon, oder?
Ihr guckt auch nicht hin.
Äh, passt.
Ich glaube, es ist alles gut.
Na klar, okay, nice. Ich bin beruhigt.
Also, repos vmchamp.
Dann pushen wir das mal kurz.
Also, git
remote-v
Was haben wir da drin?
Also, dann gehen wir mal auf git.
Ich hoffe, ich bin noch eingeloggt.
Okay, ich bin noch eingeloggt. Nice.
Aha, gucke mal da.
Unser Renovate-Bot funktioniert noch.
Der sagt, es gibt Updates für
Kubernetes-Config-Files.
Okay, wir brauchen
ein neues Repo.
Zack, New Repository
vmchamp
public
description
popsignal
coming soon
readme
brauchen wir nicht.
Renovate-Bot brauchen wir auch nicht.
Alles gut, vmchamp ist am Start.
Dann, aber Chat, Chat.
Wenn ich euch den Kram jetzt ungesehen schon
auf GitHub pushe, dann brauche ich
wenigstens, wenigstens gebt euch einen Druck.
Wenigstens ein paar Sterne.
Ja, wer sich dazu durchringen kann.
Okay.
ähm
git remote add
git remote add, nicht origin
GitHub
git push
git push github
master
Okay.
So, da ist es.
Der vmchamp ist offiziell
auf GitHub.
So, dann zeige ich euch mal ganz schnell,
was im vmchamp so abgeht.
So innerhalb von 5 Minuten.
Wir gehen da mal ganz schnell drüber.
Das ist tatsächlich verhältnismäßig ordentlich.
Auch für, auch für meine Verhältnisse.
Es gibt natürlich keine Tests.
Das ist ja klar.
Ich mein, wozu,
ich mein, seriously, wer macht schon Tests?
Es ist doch ganz einfach.
Entweder funktioniert oder es funktioniert
es net. Wenn es net funktioniert,
dann ist es kaputt. Man braucht keine Tests,
man weiß ja, dass es kaputt ist.
Und wenn es funktioniert, braucht man keine Tests,
weil dann geht es ja.
Ist, ist doch eigentlich ganz klar.
Also total overrated,
da irgendwas zu testen.
Gut.
So, also mal ganz kurze, ganz, ganz kurze Übersicht.
Was das Tool macht, habe ich euch ja gerade gezeigt.
Ihr könnt auf der Kommandozeile
in Windeseile
äh
vmchamp run cackle
Ihr könnt, ihr könnt in Windeseile
VMs erstellen. Bei euch lokal
zum Testen. Und die dann auch alle wieder
zackig löschen. Das ist, das ist kein Tool,
das muss ich gleich dazu sagen, das ist kein Tool
wirklich zur VM-Verwaltung oder wo man
dann irgendwie langlebige
VMs aufbaut. Das ist, das habe
ich mir absichtlich, ich wollte mir schon
eine Weile sowas bauen. Und gestern
der Stream hat mich auch wieder dazu inspiriert. Und zwar
einfach,
ich brauche öfters mal lokal Test-VMs.
Und manchmal
cuttet's der Container
halt nicht, ja. Also cuttet's nicht alle.
Manchmal macht's halt ein Container,
nicht. Ja, wenn man Docker in Docker machen will
und irgendwas anderes, Kernel-Module
braucht, keine Ahnung. Manchmal geht's halt
mit Container nicht. Und schon, zackig
hat man innerhalb von 15 Sekunden eine lokale
Test-VM. Und
ähm, wir haben noch
Emote-Support im Terminal. Kann dann wieder raus
und ist alles gut. Und wenn man fertig
ist, ich hab hier aktuell gerade zwei
Test-VMs. Und wenn wir fertig
sind, dann kann ich einfach sagen, vmchamp
äh, clean
und alles wieder weg
und gut ist. So, dafür ist das da. Das ist
für schnelle, lokale Test-VMs.
Was spricht gegen Vagrant?
Ich find Vagrant abartig. Vor allem,
weil Vagrant, ähm,
VirtualBox
standardmäßig nur
unterstützt. Es gibt ein
KVM-Plugin,
was
keine Ahnung, irgendwie
Third-Party und
nicht richtig mehr funktioniert.
Ich find das so viel, viel nicer.
Test-VM am Start, fertig.
Danach wieder wegschmeißen. Kein Vagrant
Teil, kein nix. Einfach in your face
starten, gut ist. Man könnte das
auch easy mit Terraform machen. Ich hab's die ganze Zeit
immer mit Terraform gemacht.
Ich hab mir einen Terraform-Ordner
gemacht für ein Debian-VM.
Für eine lokale.
Und hab dann mit Terraform-Workspace
das immer durchgeswitcht, wenn ich eine neue brauche.
So.
Ich hatte heute bei mir einen ganz
lustigen Bug mit einer GitLab-Pipeline
und, mit was?
Goreleaser.
Was ist denn ein Gore...
Goreleaser? Ach,
GORELEASER, nicht GORELEASER.
Oh Mann.
Na gut, fast.
GORELEASER.
GORELEASER, alles klar.
Ich hab mich in einem Tag verschrieben und somit war der Tag
nicht mehr gültig. Semvair. Ja, Sauerei.
Und die Pipeline ist gefehlt.
Nachdem ich das Tag gelöscht habe,
Nicht Tag, Tag.
Hätte ich gleich.
Nachdem ich das Tag gelöscht habe,
und richtig neu erstellt wurde,
in der Pipeline immer noch das alte, kaputte,
als ich einen neuen Brandenstrahl hatte,
alles wieder funktioniert. Okay.
Tja, dann hast du wohl irgendwie noch
zwischengespeichert. Ich mein,
hast du den Tag auch sicher remote gelöscht
und nicht nur bei dir lokal? Wahrscheinlich.
Geh mal von aus. Chat ist ja high IQ Chat.
Chat ist nicht blöd.
Also Leute, das ist tatsächlich
relativ ordentlich gemacht, wenn irgendeiner Bock drauf hat.
Nice, Leute.
Neun Sterne. Dankeschön.
Jetzt ist die Frage.
Was ist nicer?
Neun Sterne oder neun Prime Subs?
Ich würde ja
sagen, neun Sterne auf GitHub,
auf dem Projekt. Ist nice.
GG Eats, Leute.
Ich hoffe, ich hatte hier nirgendswo
jemals was drinstehen, was ich
nicht auf GitHub haben will.
Vor allem, weil ich meine History nicht neu gemacht habe,
sondern
gepusht habe. Also wird
schon
passen. Ja, wird schon gehen.
Okay, also,
jetzt, okay, ich,
das hat, das hat's
keine Readme. Da gibt's doch gar nichts. Ich wollte das eigentlich überhaupt
nicht pushen. Also, falls es irgendjemand ausprobieren
will, könnt ihr machen. Ihr könnt, ihr könnt
auch gerne mir sagen, falls ihr noch irgendwas Kleines
haben wollt, müssen wir mal gucken. Vielleicht können wir das dann auch in einem
der nächsten Streams machen. Also, ich zeig's euch
jetzt noch mal ganz kurz. Da gucken wir uns shit,
shithea an.
Das Ganze ist ein
Kommandozeilentool, wie man ja schon gesehen hat, zum lokalen
erstellen und wegschmeißen
von VMs. Rein per Kommandozeile.
Und um sich danach per SSH drauf
zu verbinden.
Das Ganze basiert auf
dem neusten Microsoft
CLI Framework. Da kann man dann solche Sachen
machen, wie hier
relativ, relativ schön und strukturiert
Kommandos
anlegen und man kann auch
Completions generieren lassen, solche
Geschichten, wie man ja auch hier sieht. Wenn ich
vmchamp mache, minus minus,
dann gibt's, gibt's, gibt's Autocomplete
und solche Geschichten, ja.
Die nicht ganz perfekt ist, muss man sagen.
Immerhin.
Welche Virtualisierungssoftware findest du gut auf Windows 11?
Vor allem bei Workstation. Beste.
So, also, hier werden
alle möglichen Kommandos registriert.
Zum Starten, zum Aufräumen,
zum einzelnen VMs, zum SSH verbinden,
zum VMs auflisten und zum
OS-Images auflisten. Das geht ja auch noch.
Habe ich ja noch gar nicht gezeigt. Man kann auch alle
OS-Images auflisten lassen, was aktuell
unterstützt wird.
Ich würde es gerne an asti kek w in
minus minus version machen. Pull-Request. Merge ich.
kek w
kek w ascii art. Aber bitteschön in Farbe.
Nicht, nicht einfach nur schwarz-weiß.
Jetzt bin ich sofort
dabei. Wird sofort gemerged.
So, da gibt's irgendwie noch ein bisschen Magic.
Das überspringen wir jetzt, weil die Microsoft
Autocomplete schon ein bisschen suckt.
So, und das eigentlich
Interessante habt ihr gestern mehr oder
weniger schon gesehen im Stream.
Das ist das, was wir gestern im Stream
auch gemacht haben, nur etwas hübscher
verpackt. Ja, also
das ist das Kommando, was, was
ähm, die URL gibt's
nicht. Ja, gut, ich hab neulich alles ausprobiert,
hab mich voll verschrieben.
Ja, also, ähm,
hier legt dann, hier legt dann der VM an,
Options-Parsing, äh, Completion
hinzu, bla bla bla.
So, und hier ist das im Prinzip, was wir gestern
auch schon im Stream gemacht haben, nur in etwas
hübscher. Er gibt
bisschen Status aus und
erstellt das Verzeichnis für die VM.
Dann lädt er, dann lädt er die Images
runter. Image runterladen funktioniert
hier über diese Downloader-Klasse.
Im Prinzip lädt er das Image runter,
macht nen Status-Balken
und fertig. Sehr, sehr übersichtlich, ja.
Dann,
dann kopiert er das ins richtige Verzeichnis
und dann
erstellt er ein Cloud-Init
Cloud-Init-Image. Das ist tatsächlich
sehr high IQ. Das hab
ich mir auch auf GitHub abgeguckt von nem anderen
Projekt.
Wenn, wenn er ne VM erstellt,
also wenn man jetzt hier zum Beispiel,
also, ich zeig's euch mal.
Wenn man jetzt hier ne VM erstellt,
machen wir das jetzt mal, run
kekel. So, ich hab jetzt ne VM
erstellt und wenn man jetzt hier reinguckt,
wird man feststellen,
so, da ist die VM,
wird man feststellen,
dass es zwei Disks hat.
Und zwar, es hat das eigentliche
Cloud-Image drinne,
also das, die Festplatte
von der die VM bootet
und es hat ein Cloud-Init-ISO.
Was sind denn so die Pre-Requirements?
Das ist nur für Linux, nur für Linux.
Gar nix, du brauchst Linux
und KVM. Das war's.
Mehr brauchst du nicht. KVM installiert,
libvirt und alles
standardmäßig, sonst brauchst du nix.
Der verlässt sich ja auch
nicht über irgendwelche Kommandozeilen-Tools,
der macht ja wirklich, guckt's euch mal an,
der macht wirklich
hardcore interop mit der libvirt
C-Library hier, guck.
libvirt, libvirt,
das ist das, was wir gestern schon
gemacht haben. Das ist das, was wir
im Stream gestern quasi dazu inspiriert
hat, das hier mal
was zu erstellen.
Ich sorg noch
dafür, dass die Connection immer sauber
beendet wird.
Ja, aber ansonsten ist hier
an der Stelle nix Spannendes. Das hier ist tatsächlich
ein bisschen mehr High-IQ,
aber ist es so safe wie Rust?
Naja.
Rust C interop ist genauso
wenig safe wie C-sharp C interop,
nur wenn man innerhalb von Rust
bleibt, ist es safe und wenn man
innerhalb von C-sharp bleibt, ist es
auch safe.
Potenziell sogar vielleicht noch ein bisschen
safer.
So, also,
der macht folgendes hier an der Stelle,
das ist richtig, also erstmal sammelt
da eure SSH-Keys ein
und schickt die an mich, logischerweise.
Nee, Quatsch.
Da sammelt eure SSH-Keys ein und auch nur
eure Public SSH-Keys,
ähm,
damit ich dann,
ähm,
personalisierte Phishing-Mails erstellen kann.
Also,
da sammelt die Public SSH-Keys ein,
damit ihr euch
auf der VM einloggen könnt.
Hier, sieht man ja auch.
Natürlich wird das nirgendswohin geschickt, aber
sieht man ja alles im Source Code, was passiert.
So, da sammelt die
SSH-Public-Keys ein,
so, und jetzt kommt
absolut High-IQ.
Ihr seht ja, hier hängt ein Cloud-Image,
Cloud-Init-ISO
dran, was ausgeführt
wird, wenn die
VM zum ersten Mal startet.
So, damit das funktioniert, muss man folgendes machen.
So muss der Inhalt aussehen
von dem
Cloud-Init-ISO.
Code oder GitHub ungleich Binary in Release,
ist das richtig? Aber es gibt aktuell kein Binary,
ihr müsst es wenn schon selbst bauen.
So, so muss die Datei aussehen.
So und nicht anders,
sonst funktioniert es nämlich nicht.
Also, man muss das irgendwie encoden als
Multipart Mixed, was auch immer,
habe ich mir geklaut auf GitHub, keine Ahnung.
Und dann muss das Cloud-Init-File
genau so aussehen.
Das heißt, dieses
ich nenne es mal Script,
führt die VM beim ersten Booten aus
und konfiguriert sich selbst.
Also, sie legt
einen
Host-Name fest,
sie legt einen neuen User an mit dem Namen
User, der kommt in die Sudo-Gruppe rein
und kriegt alle eure SSH-Keys rein.
Man hat Root auf der VM,
klar, du kannst Sudo machen, hinten dran.
Warum ist das ein E-Mail-Format?
Keine Ahnung, weil die Datei so aussehen muss.
Das ist ein ISO-Image dann im Endeffekt,
wo das reinkommt.
Und danach startet
der Networking neu und schaltet Cloud-Init ab.
Fertig. So, das passiert.
Danach kann man sich einloggen.
Dann braucht man noch irgendwelche Metadaten-Dateien
mit Host-Namen und sowas. Und jetzt kommt der Trick.
Ich habe mir einen ISO-Builder,
eine ISO-Builder-Library,
selbe für Windows mit
WSL. Das funktioniert unter Windows mit
WSL, solange unter Windows LibWirt
funktioniert, was wahrscheinlich
nicht klappen wird, aber
wenn LibWirt funktioniert, dann
klappt das auch.
So, ich habe mir eine ISO-
ISO-Creation
eine ISO-Erstell-
ISO-Erstellungs-Library
gezogen von GitHub,
beziehungsweise mit Pernugiat hinzugefügt.
Nennt sich CD-Builder.
Das heißt drauf, er stellt ISO-Files.
Und er
erstellt einen ISO-File mit dem
Volume Identifier CI-Data.
Kann sein, dass das so heißen muss.
Magic String, weiß ich nicht. Und dann schreibt er
diese Dateien von hier
quasi in das ISO und speichert
das ISO unter cloudinit.iso.
Und das ist das, was er hier dann reinhängt
in die VM. Und die VM
beim ersten Booten liest
das ISO ein, mountet sich das ISO
und führt das Cloud-Init aus und konfiguriert
sich dann so, dass es sich zum Netzwerk verbindet.
Und eure SSH-Keys
eingerichtet sind, sodass ihr am Ende
vmchamp list,
sodass ihr am Ende machen könnt
SSH
auf die VM euch connecten könnt.
Weil da eure Keys drinnen sind.
Das ist wirklich way
way to dang. Hat auch eine Weile
gedauert, bis ich da drauf gekommen bin.
So, und dann startet er
startet er die VM und das war's
im Prinzip.
VM erstellen,
dann wartet er noch aufs Netzwerk, falls man das
eingestellt hat. Dann gibt er
das aus, connectet sich per SSH
und fertig. Das XML
ist ein bisschen übersichtlicher als gestern noch
im Stream. Ein bisschen gekürzt
alles. Nicht viel.
So weit zusammen gekürzt, wie irgendwie möglich ist.
Ja, und so funktioniert
das im Großen und Ganzen. Der Rest ist relativ
easy. List-Command gibt alle
VMs aus, die im Verzeichnis sind.
OS-Command listet
alle Distributionen auf. Die Distributionen
sind hier drinnen definiert.
Aktuell nur Debian.
Dann gibt's noch
nur bei Helpers eigentlich
nichts spannendes drinnen.
Images auflisten.
VMs löschen.
Das ist alles sehr
übersichtlich. Und am Ende
halt noch
wo ist das? Clean-Command? Da.
Am Ende halt hier kann man noch alle
VMs auflisten. Und ganz wichtig, viele Emojis
in der Textausgabe. Da stehen die Leute
heute drauf. So, fertig.
Das war's. Also ganz grobe
Übersicht hier zum
VM-Champ.
Also, wer Bock hat, das ausprobieren,
kann's gerne machen. Aktuell gibt es noch
keine Binaries oder sonst was. Gibt auch noch keine
Readme oder überhaupt irgendwas.
Ihr braucht .NET 8
und dann .NET Publish
und könnt es lokal bauen.
Das Docker-File
fällt beim .NET
Build. Wirklich?
Warum?
Führst du das dann... Moment. Führst du das
auch mit dem Build-Script aus?
Oder führst du
es von Hand aus? Von Hand geht nicht.
Du musst es mit dem Build-Script ausführen.
Echt? Das ist kaputt?
Wirklich? Okay.
Probieren wir mal aus.
Testen wir doch jetzt mal. Hier.
Build. So, dann musst du eine Versionsnummer
angeben.
0.3.
Bei mir lokal ging's noch.
Achso. Ich weiß, warum's nicht geht.
Weil da Hard... Achso.
Moment. Da ist
ein Verzeichnis drinne von meinem
Rechner, was es bei dir lokal nicht gibt.
Aber...
Fail to solve?
Invalid Reference Format?
Was? Okay.
Keine Ahnung.
Weiß nicht, warum das nicht bildet.
Gucken, ob's
bei mir funktioniert.
Warum Docker-File? Ha!
Das ist eine sehr
intelligente High-IQ-Frage.
Kann ich dir gleich was zu sagen.
Das hat seinen Sinn.
Ich sag aber erst mal
was zu Kolumbo.
Und zwar... Hallo. Ich weiß nicht, ob
ich hier richtig bin. Ich habe eine Frage
zum LAN-Kabel. Ich weiß, dass
es Cat5 bis Cat8-Kabel gibt.
Jetzt die Frage. Kann bei einer
230 Mbit-Leitung Kabel Fritzbox
das normale... Nein.
Nein. Eher nicht.
Die Kabel sind doch auch kurz.
Die Kabel sind doch auch kurz.
Die sind doch auch
5 Mbit.
Was hast du denn für ein Kabel?
Was hast du denn für ein Kabel?
Und
syncht das Ganze auch mit Gigabit?
Ich weiß
jetzt nicht, bis wohin
Cat5 zugelassen ist. Aber ganz im Ernst,
die Kabel sind 2 Meter lang. Darüber geht wahrscheinlich
alles Mögliche.
Das kann maximal 100 Mbit.
Ernsthaft?
Wenn das...
Ja, tatsächlich. Ihr habt Recht, Chat.
Ihr habt Recht. Okay.
Ihr habt Recht. Wusste ich nicht.
Ihr habt Recht. Also, es ist zumindest
nur spezifiziert bis dahin.
Wahrscheinlich geht
das auch. Wahrscheinlich geht da auch mehr.
Aber...
Ich meine, gerade wenn das Kabel in 2 Meter ist
oder so, das macht doch nichts.
Ich wusste
auch, wie gesagt, ich wusste auch nicht, dass es das
überhaupt noch gibt. Ja.
Ey, bei mir
hat das funktioniert mit dem Bild.
SiriusMax, warum geht das bei dir in Docker
nicht, obwohl es exakt das gleiche ist?
Muss ich das jetzt verstehen?
Warum geht
bei mir das Docker-Bild und bei dir geht es nicht?
Also, dass es am Ende nicht
funktioniert. Das kann ich mir
vorstellen, weil guck mal.
Aus irgendwelchen Gründen habe ich
in meinem Bild-Skript hardcoded
den Output-Faden von meinem Rechner-Lokal.
Du kannst das Bild mal von halt...
Okay, dann weiß ich auch
nicht, woran das liegt.
Könntest das mal von Hand ausführen und
gucken, an welcher Stelle er genau
abkackt, aber...
Verstehe ich jetzt nicht
weiter.
Invalid Reference Format?
S?
Ich weiß ja nicht mal, was das für eine Fehlermeldung
bedeutet, was das heißen soll.
Der hat bestimmt Probleme
wegen der Variable, aber...
Ja, keine Ahnung.
Vielleicht ist
das Docker zu... Ich habe keine Ahnung.
Kein Schimmer, woran das liegt.
Du musst
.NET nicht installiert haben, weil
du bildest ja im Docker-Container.
So, und jetzt zum Abschluss, bevor wir uns
GTA angucken.
Leute, das baut im Docker-Container.
Ihr braucht es nicht, lokal installiert
zu haben.
Das macht doch überhaupt keinen Sinn,
dass es bei dir lokal nicht
funktioniert.
Das ist doch das gleiche Docker-File.
Ich meine,
der Vorteil von Docker-File ist doch
eigentlich, dass es... Okay.
Aber das ist ja alles auch okay soweit.
Hat der Probleme?
Hat der Probleme mit...
Trag mal hardcoded hier die Versionsnummer
ein, nur um auf Nummer sicher zu
gehen. Ich habe keine Ahnung, was der für...
Was der für Schmerzen hat.
Da ist ein
Compiler-Error.
Ey, das sind alles nur... Moment, da ist ein...
Hä?
Wie kannst du einen Compiler-Error haben und
ich nicht? Das ist die gleiche .NET-Version.
What the hell?
Hä? What?
Das ergibt doch überhaupt keinen Sinn.
Wie zur...
Moment, welche .NET-Version hast du?
Was lädt denn der hier runter?
Sieht man das irgendwo?
Ihr Preview?
Ich habe keine Ahnung. Das ergibt überhaupt
keinen Sinn.
Er fehlt initialize, er cannot reference the
distro... Was?
Ne, da ist ein Syntax-Fehler.
Er meint, da ist ein Syntax-Fehler.
Ich habe seriously keine Ahnung, warum da ein Syntax-Fehler
drin sein könnte.
Es ist ja offensichtlich das Gleiche, was wir
haben.
Das checke ich nicht.
Das ist mir seriously, das ist mir jetzt zu hoch.
Das ist mir komplett
zu hoch.
Keine Ahnung, warum das nicht geht.
Aber, so, um jetzt abschließend nochmal
diese Frage hier zu beantworten.
Warum das in Docker
gebaut wird und nicht
mit
.NET Publish, also man könnte ja
auch sowas hier machen in der Richtung, ja.
Warum ich das mache, ist folgendes, weil
ich das Ganze
auf einem CentOS 7
baue. Und
warum baue ich das auf dem CentOS 7?
Ich baue das auf dem CentOS 7,
weil
wir native
ahead of time compilation benutzen.
Und
ich will sicher gehen, dass das Binary
auf so alt
wie möglichen Systemen läuft.
Wenn ich das nämlich bei mir lokal baue,
dann läuft das Binary nicht.
Nur auf Systemen, die
eine neuere C-Library haben,
neuer und gleich alt wie ich bei mir auf meinem Arch Linux.
Und das ist 3 Tage
alt oder so.
Na gut, oder 2 Monate alt.
Alles was älter ist, funktioniert da nicht richtig.
Deswegen baue ich das auf einem
uralt System. Das ist was, wo
Go einen riesen Vorteil
hat. Im Container
failt der Build bei euch?
Hä?
Leute, wie kann
das failen bei euch?
Das check ich nicht.
Bei mir geht's doch auch.
Das ist das gleiche Docker-File.
Jetzt plink ich nicht mal durch.
Ich führ das jetzt bei mir auch nochmal kurz auf.
Docker
System
Ich lösche mal
alle Docker-Images.
Ich restarte mal
Docker, weil man weiß ja nie,
was der für Schmerzen hat lokal.
So.
Docker-Images. Und jetzt gucken wir mal.
Was macht der vor...
Warum ist denn da so viel?
So viele Images noch da?
Na gut.
Nicht dick.
Ich pass mal kurz mein Build-Skript an,
damit ich was sehe.
Man sieht ja eigentlich auch sowas.
Ich mache jetzt einfach das Build
von Hand.
Und jetzt bin ich gespannt,
ob es bei mir auch fehlschlägt.
So, Target-Version
0.0.0
Docker-Build.
Okay, mal gespannt.
Vielleicht ist das eine Beta-Version.
Ich meine, wir dürfen nicht vergessen,
.NET 8 ist Alpha as fuck.
Also nicht Sigma-Crime-Set
as fuck, sondern
das ist Alpha-Software.
Vielleicht haben die einfach einen Bug in der aktuellen Version.
Und da, wo ich es vorher gebaut habe, noch nicht.
Das ist durchaus möglich.
Jetzt bildet er. Okay.
Ich glaube, die haben
eine verbuggte .NET-Version gepusht.
Wir hatten wahrscheinlich gerade
fünf Minuten lang eine .NET-Version oben,
die verbuggt war.
Und die haben sie wahrscheinlich gerade aktualisiert.
Oder so.
Das ist halt extrem Alpha hier noch.
.NET 8.
Die pushen da teilweise im halben Minutentakt
irgendwelche Fix-Versionen.
Guck mal hier. Preview.
Ich bin mir nicht ganz sicher, wo wir
gescheit nachgucken können, wann der...
Warte mal.
GitHub.
Wir gucken mal, wann die die Version
veröffentlicht haben.
Main?
Wo findet man das überhaupt?
Preview?
Release bringt mir ja nix.
Main muss ich wahrscheinlich
gucken, oder?
Vor 40 Minuten.
Ja, die sind die ganze Zeit am Arbeiten.
Ich bin mir aber nicht sicher, ob...
Wo diese Versionsnummern herkommen.
...
Ja, jetzt geht's wieder mit dem Bauen.
Hat alles funktioniert.
Also, ich hab keine Ahnung, wo diese Versionsnummern
hier herkommen.
Was sich Microsoft
da ausgedacht hat.
Das könnte aber durchaus
sein, dass es...
Ne, ne, ne, ne.
Die Versionsnummer ist vom
14. März.
Also Leute, bei mir geht das Docker-Bild.
Das muss an euch liegen. Keine Ahnung.
Ich könnte aber auch .NET Build so benutzen.
Ja, das funktioniert.
Wie gesagt, ich mach das ja nur im Docker-Container.
Damit ich das
auch in der CentOS, CentOS 7 bilden kann.
Ich muss mal kurz alle Docker-Images
löschen.
Jetzt geht's wirklich, ja, das ist gut.
Images. Sollte nicht
eigentlich mal ne ganze...
Sollte nicht Docker System Prune
eigentlich alle Images löschen?
Docker PS?
Ne?
Sollte nicht alle
Images sollte der doch löschen, oder?
Oder nicht?
Ich will diesen ganzen Mist... Ah, muss man
machen.
All Images bild aus... Ah, ja, ja, ja.
Ok, will ich haben.
Jetzt ist wieder ein gut bisschen
Speicherplatz. Ok, dann hätten wir
das auch erledigt. Dann gucken wir uns doch jetzt mal
eine Runde, die neueste Version von
GTA an.
Machen wir das mal auf.
Zack.
Exzellente, exzellente.
Was macht der VM-Champ denn? Ok.
Ich zeig's
noch einmal, was der VM-Champ macht.
Ganz,
ganz, ganz kurz. Der VM-Champ,
mit dem kannst du
lokale
schnelllebige VMs erstellen.
Das gleiche, was du sonst auch über
VIP-Manager machen würdest, oder so.
Bloß, dass es minimale
Cloud-Images verwendet
und einfach Test-VM's
schnell erzeugen kann. Ja, du kannst
zum Beispiel sagen, VM-Champ
Run Blub
VM und dann
erstellt er dir eine VM mit
einem Debian 11 Cloud-Image drinnen,
bootet die, wartet bis das Netzwerk
oben ist und wenn das Netzwerk oben ist,
dann lockt er sich da drauf per SSH ein.
Das heißt, du hast ungefähr in 20
Sekunden eine fertige
VM, die du benutzen kannst zum Testen
und wenn du fertig bist, kannst du einfach alle
auf einen Schlag wieder wegschmeißen und gut ist.
Du kannst dir die auch auflisten lassen
und dich per SSH drauf verbinden
im Nachhinein, wenn du es nicht mehr weißt.
Zack, VM erstellt und hier hast
du deine VM.
So, dass du siehst, Internet
und so funktioniert auch.
Jetzt, wenn du raus gehst, kannst du
noch sagen, VM-Champ List, übrigens
Shell-Completion geht auch, da siehst du deine
VM, dann kannst du sagen, SSH
auf
Blub-VM. Da bist du auf der
drauf oder SSH hier drauf,
bist du auf der drauf und wenn du fertig testen
bist lokal, sagst du Clean
und dann wirft er alle VM's wieder weg,
räumt die Images auf, sonst wie.
Manchmal reichen Container
halt einfach nicht aus.
Manchmal will man halt irgendwas haben in
der VM und ich habe halt keinen
Bock im Wirtmanager ewig rumzuklicken.
VM-Champ ist nicht der offizielle
Name, doch ist es.
Dass du bei Google nichts
findest, wundert mich nicht.
Ich habe das vor
60 Minuten ungefähr erst gepusht
auf GitHub, hier, da findest du es.
Aber es gibt, wie gesagt, ich habe das auch
nur gepusht, weil der Chat das unbedingt
sehen wollte. Es gibt keine
Readme, keine Releases, keine Binarys,
gar nichts. Ich habe das heute
im Lauf des Tages zusammengestrickt,
weil ich sowas
gerne hätte, für
mich lokal und weil
mich der Stream gestern dazu inspiriert hat,
das zu machen.
Es muss fertig...
Nee, Raw Images
gehen auch. Du kannst da auch zum Beispiel
Ubuntu Cloud Images einbauen.
Dann müsste man nur noch einbauen,
dass der an dieser Stelle,
das dürfte aber relativ easy sein,
dass der hier in CreateVM
das hier noch
dynamisch, nee,
dass das noch dynamisch ist.
Ja? Also der Type,
der Type muss dann dynamisch
entweder Raw oder
oder QCow2
je nachdem, was man runter
lädt haben. Also das dürfte sich relativ
einfach erweitern lassen, denke ich mal.
Husky Kegway,
komm, so muss das sein. Nice.
Okay, also
neueste Version Shithea.
Eigentliche, was
ich mir heute angucken wollte.
So, ähm...
Nein. Achso,
sorry, ich habe mich gerade verlesen.
Ich habe gerade gelesen, ob ich
Interop für Docker-AP einbauen kann
in das Tool. Nein.
Kennst du eine .NET Interop
für die aktuelle Docker-AP?
Boah, keine Ahnung.
Habe ich noch nie
versucht, habe ich mir noch
Gedanken drüber gemacht. Aber im Zweifelsfall
Nougat,
gucken, was der so
ausspuckt. Docker.
Docker.NET
Docker.NET is alive and allows you to interact.
Ja. Guck mal, das
scheint ja ganz gut zu sein.
Das hat auch nur knapp
10 Millionen Downloads
und wurde vor 23 Tagen
aktualisiert. Ich glaube, die Library
kannst du sicher benutzen.
Ja, und wo ist das Problem?
Achso, okay.
Also,
git here, da sind wir.
So, der Grund,
warum ich mir das angucken will, um erstmal
zum eigentlichen Titel
zu kommen und dass wir heute
was Sinnvolles machen.
Der eigentliche Grund, warum ich mir das
angucken will, ist folgendes.
Ich verwende eigentlich für nahezu alles
mittlerweile GitHub. GitHub
mit Public Repos und GitHub mit
Private Repos. Was ich an GitHub
mag, ist, dass es genau
das richtige
Set an Features hat,
mit der nötigen Tiefe,
um eigentlich alles machen zu können, aber
immer noch einfach zu bedienen ist.
Gerade GitHub Actions. GitHub Actions
ist eine super Geschichte.
Ich finde das von den ganzen anderen,
na gut, von allen kann ich
nicht sagen. Ich meine, ich habe bei weitem noch nicht alle
solche
von diesen Runner
Continuous Integration System ausprobiert.
Finde ich GitHub Actions insgesamt
am angenehmsten zu benutzen.
Jammel, das ist so ein kleiner Nachteil.
Jammel ist einfach immer abfuck. Mittlerweile
macht man von meinem Geschmack auch viel zu viel
in Jammel. Man ist ja mittlerweile
kein Server Admin mehr, kein
DevOps Engineer oder sonst was. Man ist ja eigentlich nur noch
Jammel Engineer. Insgesamt
muss ich aber sagen, GitHub und GitHub
Actions und Large File
Store und was es nicht alles dort gibt.
Das Secret Management und sowas, das ist bei GitHub
einfach nice. Und das Gesamtpaket
stimmt. Und ich persönlich
für mich sehe auch keinen Anlass
großartig was anderes als GitHub Actions.
zu verwenden. Es sei denn,
ich habe nämlich auch noch lokal
was laufen. Für Sachen, die ich wirklich
niemals gedenke zu releasen
oder wo ich halt vielleicht auch mal
nicht so genau drauf achte,
was ich da reinschreibe. Eventuell
auch mal irgendwie das ein oder andere Passwort
in Source Code paste, weil es schnell gehen muss.
Das pushe ich da natürlich nicht auf GitHub.
Und das ist wahrscheinlich
auch der Grund, warum die Leute
was anderes benutzen außer
GitHub. Weil sie es entweder
gar nicht in die Cloud schieben wollen
oder weil sie Microsoft
nicht trauen.
Man darf nicht vergessen, dass
Microsoft ja auch den ganzen Krempel hier durchcrawlt
für GitHub Copilot.
Ich weiß gar nicht,
ob sie sich jemals dazu geäußert haben,
was da genau
jetzt unter welchen Richtlinien
und welchen Bedingungen wieder was wie wo
keine Ahnung auch immer genau passiert.
Weiß ich, aber wer das nicht will,
für den ist GitHub natürlich dann
nix. Wobei man halt sagen muss, GitHub
finde ich, ist immer noch das Beste, was es gibt.
Die Gesamtkombination an Features
und wie viel kostenlos es da
vor allem gibt bei.
GitHub ist ja komplett
kostenlos benutzbar.
Wenn du im größeren Stil
Actions und Runner benutzen willst,
glaub über
wie viel ist Free Tier?
GitHub 500 Minuten
Free Tier.
Müssen wir mal kurz gucken.
Ich muss mal kurz mit meinem Stuhl über das Kabel fahren.
Billing for GitHub Actions
Billing for GitHub Actions
Ach guck mal hier,
2000 Minuten GitHub Actions
im Monat und
500 MB Storage.
Reicht dicke normalerweise aus.
Dicke.
Okay, Storage vielleicht, je nachdem wie groß
die Sachen sind. Aber
insgesamt, ja.
Also das ist absolut in Ordnung.
Mittlerweile machen sie doch
gar keinen Unterschied mehr zwischen privaten
und öffentlichen Repos, oder?
Ey,
es kann
es kann sein, dass es da noch Unterschiede
gibt. So, also
zumindest
GitHub ist die Kombination
ist die Kombination insgesamt
einfach unschlagbar gut.
Allerdings, ich kann jeden
verstehen, der sagt, alter ich hab
keinen Bock auf Microsoft
oder ich will selbst was hosten.
Ich will es gar nicht im Internet haben.
Es gibt ja immer Anwendungszwecke für,
dass man das nicht will.
Das ist ja auch legitim. Muss ja jeder für seine Software
selbst wissen, was er da machen will
und was er nicht machen will. Vielleicht
ist es auch so, dass ihr das Ganze
für irgendeinen Auftraggeber
macht oder für euren Arbeitgeber macht
und der sagt, nee, nee, mein Zeug kommt auf jeden Fall
nicht auf GitHub. Also es hat ja schon durchaus
seinen Hintergrund, dass man vielleicht
auch was anderes als Alternative zu GitHub
verwenden will, außer GitHub selbst.
So.
Dann fällt natürlich auch
GitLab weg, also Cloud
gehostetes GitLab fällt da natürlich auch weg.
Wenn man das gar nicht in der Cloud haben will.
Dann bleibt im Endeffekt nur irgendeine selbst
gehostete Lösung. Da gibt es verschiedene Sachen.
Man kann GitLab selbst hosten.
Man kann sich GitHub Enterprise kaufen.
Ich kenne niemand, Leute.
Sagt mir, ob es bei euch
anders ist. Ich kenne niemand,
der GitHub Enterprise gekauft hat.
Also ich kenne kein Unternehmen,
was GitHub Enterprise kauft. Ich kenne
keinen, der einen kennt, der irgendwo
arbeitet, die GitHub Enterprise gekauft haben.
Ich weiß überhaupt nicht, ob GitHub Enterprise
irgendjemand jemals
gekauft hat. Keine Ahnung. Wahrscheinlich
schon, ja. Aber ich kenne.
Kennt ihr jemand?
Kennt ihr irgendeinen
oder Arbeiter, die irgendwo
die GitHub Enterprise gekauft haben?
Ja, stimmt. Bitbucket gibt es auch noch.
Also mir ist da
nichts bekannt. Sagt mir,
wenn es bei euch ist.
Ihr kennt auch niemand.
Also insofern.
Der erste, der geforkt hat.
Moment.
Wo ist denn der Knopf dafür?
Oh, Knopf. Ach, da steht immer
eins, oder wie? Erstmal gestalkt,
wer geforkt hat.
Azure DevOps Server.
Das sind wir zum Glück. Hier ist das an uns
vorübergegangen. So, also es gibt
ja durchaus Gründe, die Sachen selbst
Läuft da eine Uhr im Hintergrund?
Ne, da läuft irgendeine
Chill-Playlist. Hört sich ein bisschen an wie
eine Uhr.
Da läuft gerade irgendeine Chill-
Playlist. Ist aber relativ
leise, ne?
Ich habe keine Ahnung, welche
Playlist da läuft.
Ich habe zu viele
Tabs offen. Hier.
Die Playlist läuft. Epic.
Epic Chill-Step
Collection. Habt ihr
nicht Epic rausgehört?
So, also. Da gibt es natürlich,
wenn man solche Sachen,
was in der Richtung wie GitHub selbst hosten
will, gibt es natürlich sowas wie
GitLab. Wobei ich da sagen
muss, GitLab selbst
hostet, kann man vielleicht
im Enterprise Umfeld
sich geben, wenn man da wirklich
boah, meine Augen, Alter.
Wenn man da wirklich Bock drauf hat.
Aber ich muss sagen, GitLab selber
hosten ist schon
echt ein bisschen kacke.
AWS, AWS wüsste ich nicht. AWS hat
eine Container Registry. Wüsste nicht, ob die auch
GitHub-mäßig was haben.
Bin nix bekannt.
Also, GitLab selber
hosten ist ein bisschen abfuck, weil
das sehr viel
drumherum braucht.
Was? AWS Code
Commit. Keine Ahnung.
Managed Source Control.
Sag mal, gibt es auch irgendwas?
Warum? Was ist die Daseinsberechtigung
davon? Ja, gut.
Die wollen halt auch irgendwas haben.
Keine Ahnung, warum die auch sowas haben.
Kein Schimmer. Allein schon, dass
das links aussieht wie Amazon, hätte ich gar
keinen Bock drauf, Mann.
Gut, aber es ist AWS. Immerhin.
Immerhin, Leute.
Wir können schon mal froh sein, dass das
bei AWS ungefähr in der
Richtung heißt,
wie das, was man damit macht.
Weil Amazon neigt ja dazu,
die Dinger gerade bei AWS
so zu nennen,
dass man nicht versteht, was dahinter ist.
Also, dass das Ding Code Commit heißt,
ist ja gut. Normale Logik
wäre, dass das Ding
AWS
Elastic...
Ja, solche Dinger behalten...
Also, normalerweise hätte ich
erwartet, dass das Ding
Amazon
Elastic
Soundbar
heißt oder so.
So komplett random Namen, wo kein Mensch
was damit anfangen kann.
Amazon AWS
Elastic Soundbar oder sowas.
Wo du denkst, hä? Und dann ist es irgendein GitHub-Clone.
Ja, also, die AWS-Bezeichnungen
sind wirklich mit Abstand das abgedrehteste.
Oder Fargate. Alter,
wer zum Teufel ist da drauf gekommen,
ihren Managed...
ähm...
Ultra Managed Kubernetes
Kram Fargate zu nennen.
Da kannst du
doch nichts mit anfangen.
Perforce, ja, das habe ich
nie verwendet, aber
kenne ich, ja. Das sind die
mit...
Ich meine, ich brauche ein eigenes
Source Control
System.
Git-Konkurrenz
mäßig. Ne.
Ne, von wem ist
von wem ist Mercurial?
Source Code?
Von wem ist das?
Alter, meine Augen, man!
Okay, keine Ahnung, wer
der Hersteller ist.
Also, aktuell ist,
sagt Amazon ja auch selbst,
Fargate ist für Kubernetes
Workloads. Fargate
Kubernetes.
AWS Fargate.
The technology provides on demand
right size for containers. Fargate...
Aber vielleicht kann das
auch noch. Zumindest...
Also, ich weiß,
dass es ähnlich ist,
dass es was ähnliches ist, wie
GKE Autopilot.
Also, dass du quasi
dich um den Cluster gar nicht mehr kümmern musst,
sondern einfach nur Manifest definierst
für deine Pods.
AWS Snow
Mobile. Das heißt nicht wirklich so, oder?
AWS Snow... Was
zum Teufel ist AWS...
Das muss ich jetzt nachgucken. AWS Snow
Mobile. Massive
Data Transfers. Alles klar.
Wäre ich sofort
drauf gekommen, dass es da um Datentransfers
geht. AWS Snow Mobile.
Warum heißt das eigentlich nicht Elastic? Amazon nennt
doch den Shit gerne Elastic.
Kommt dann irgendwie
der LKW zu mir ins
RZ gefahren, ja?
Und dann kommt erstmal ein Fließband
raus mit Festplatten. USB-Festplatten
vom Saturn. Frisch vom Saturn.
Und dann werden
das alles drauf kopiert. Dann fährt der Laster wieder los.
Massive
Data Transfers.
Das ist kein... Ach, das ist wirklich so. Okay.
Da kommt
dann der Laster. Schau mal Bilder an. Okay.
Fuck, da kommt
wirklich ein LKW.
Ja gut, manchmal hast
du einfach zu viel Daten, um die noch irgendwie
zu übertragen.
Hat der LKW dann auch einen
USB-C Stecker?
Das ist... Das wäre doch mal
geil, oder?
Ein LKW mit USB-C Stecker, der
sich dann als 100 Petabyte
als 100 Petabyte USB-Festplatte
meldet. Alter, ohne Scheiß
den LKW würde ich gerne mal anstöpseln.
Es gibt sogar
einen AWS Snow Mobile
Lego Truck.
Das könnte quasi
glatt als mobiler USB-Stick
durchgehen. Leute,
lasst das nicht. Fridays for Future. Ne, Moment.
Nicht Fridays for Future.
Wie heißen die anderen?
Die Kleber.
Lasst das nicht...
Die letzte Generation, genau.
Lasst das nicht die letzte Generation sehen, sonst
pappen die sich an dem LKW fest.
Ich meine, das ist eindeutig hier
nicht elektrisch und CO2-Ausstoß.
Alles andere als klimaneutral.
Da kann Amazon ruhig noch ein paar Bäume
pflanzen für jeden LKW, der da rumfährt.
Stellt euch mal vor, da klebt sich wirklich
einer an diesen LKW dran.
Der hängt dann so hochkant an der Seite
und der LKW fährt einfach weiter.
Das stimmt.
Wenn er drüber fährt, war es
echt die letzte Generation.
Naja.
Also, shit her.
Ach ja, genau.
Das war die Frage, warum ein GitLab nicht selber hosten
will. Ich würde euch
das ja gerne an einem praktischen Beispiel
zeigen.
Okay. Ich zeige euch das
in 5 Minuten. Das ist total easy. Ich zeige euch
an einem praktischen Beispiel, warum man
warum man
GitLab nicht selbst
hosten will. Ich starte mal
einen lokalen Test-Kubernetes-Cluster
bei mir auf der
VM.
GitLab-Helm-Chart. Passt mal auf.
Ich installiere
jetzt GitLab auf meinem Kubernetes-Cluster.
Wenn ich überhaupt rausbekomme,
wie das funktioniert.
Install.
Helm-Chart. Ja.
Findest du nicht mal was?
Ich zeige das nur, weil das
recht eingängig ist.
Okay. Ich finde noch nicht mal die Anleitung.
Installing
GitLab by Helm. Ja. Okay.
Wo ist denn das Kommando?
Deploy
the Helm-Chart. Okay. Das da braucht man.
Alles klar. Excellent.
Ich paste das jetzt einfach mal rein
hier. Ja. Es ist ja auch egal.
So.
Moment. Ich habe Helm hier nicht drauf. Was ist denn
das da? Zack.
Zack.
Ach so. Ich habe kein Repo drin.
Zack. Zack.
So. Nur mal so als
Beispiel. So. Wir installieren jetzt
Wir installieren
jetzt in unserem Kubernetes-Cluster
Wir installieren jetzt in unserem Kubernetes-Cluster
GitLab. Ich will
es nicht wirklich im Kubernetes-Cluster. Es geht mir einfach nur darum,
dass ich euch was zeigen kann. Guckt mal.
Fällt euch da was auf?
Das ist eine GitLab-
Installation.
Oh. Das wird noch ein bisschen
mehr gleich. Das ist eine
GitLab-Installation. Der hat
jetzt einfach mal ohne Scheiß.
Wie viel ist denn das? 20.
Okay. Guck mal hier.
Default
minus C.
26 Leute.
26
Services hat der gestartet, um
GitLab selbst zu hosten.
26.
Sind die total bescheuert oder was?
Also das ist das, was ich meine.
GitLab ist eine super Software.
Das ist wahrscheinlich die beste GitHub-Alternative,
die es gibt. Und wenn man
wirklich für Enterprise im großen Umfeld
was selbst hosten will, kann man das durchaus
machen mit GitLab. Aber GitLab
zum selbst hosten ist einfach abfuck. Ich meine,
guckt euch das mal an. Die haben
Okay. Jetzt sind es nur noch 25. Die brauchen
irgendwie 25,
26 Services.
Die Pods sind doppelt.
Das ist egal. Ich zähle einfach nur die Zeilen
hier. Ich zähle nur die Zeilen.
Ich zähle nicht die Anzahl der Pods.
Ich zähle einfach nur die Zeilen, wo
default drinnen steht.
Also das sieht man, das ist einfach extrem
umfangreich und
ja,
bloated, könnte man fast sagen,
wenn man GitLab betreiben will.
Gerade für den Heimbereich ist das
vielleicht ein bisschen overkill.
So.
Also ihr habt jetzt gesehen, was das Ding hier
guck mal. Du brauchst Web-Services,
du brauchst irgendwie GitLab Toolbox,
Sidekick, Registry, Redis,
Prometheus, Postgres,
Ok, der Ingress-Controller, irgendein
S3. Der installiert sich ein eigenes
S3, dass das kann.
Migrations, was auch immer ein CAS ist.
Das hier ist wahrscheinlich, was für
Zertifikate. GitLab Shell,
GitLab Runner,
Gitali,
Webhook, was auch
alles mögliche.
Kann man machen. Ich weiß,
dass das funktioniert. Ich weiß, dass das
funktioniert. Ich finde es allerdings sehr umfangreich.
Zum selbst hosten. Ja.
Und man braucht das eigentlich
lokal für sich
daheim gar nicht unbedingt. So ein fettes, so ein fettes
Ding, ja. So, jetzt machen wir Minikube
wieder aus. Ich wollte euch
jetzt bloß zeigen, dass GitLab
eine sehr umfangreiche Software
ist. Und das komplette
krasse Gegenstück dazu
ist GitEA. Das ist ein
einzelnes Go-Binary.
Wir gehen jetzt mal
GitHub.
Das ist ein einzelnes Go-Binary. Gehen wir mal hier unten
auf Releases.
Releases Version 19.
Hat sich ganz schön viel
geändert. Version 19. Und wir wollen jetzt
haben
80 Assets, man. Linux.
Linux. AMD 64.
Das will ich haben. 120
MB Go-Binary. Easy. Fertig.
Temp.
mkdir. Temp.
wget.
So. Also, das ist jetzt halt der
krasse Kontrast. GitLab.
Ihr habt es gerade gesehen. 25 Container.
In der Standard-Konfiguration.
Dass es läuft.
GitEA. Einfach mal
ein Go-Binary.
Und gut ist. Fertig.
Local Host.
Port 3000.
Läuft. Easy. Fertig aus.
Mehr muss man nicht machen.
SQLite wollen wir haben.
Homemax Temp Data. Wunderbar.
Ja, bla bla.
Run as User Server.
Das passt alles. Alles gut so.
E-Mail Settings. Brauchen wir nicht.
Administrator Account.
Administrator Admin Passwort
123456. Was sonst?
Admin at
kappa lul
punkt com. Beste.
Install.
Administrator Username is invalid.
Is Reserved. Haha.
Jibaded. Der nennt es einfach root.
So. Zack. Das war's.
Also, das ist halt ein riesen
Unterschied.
GitLab. 580 Container.
GTA. Go-Binary runterladen.
Starten und es funktioniert.
Das ist halt.
Und Unterschied wie Tag und Nacht.
Das hat alles seinen Sinn.
Das heißt nicht, dass das eine jetzt dadurch besser ist
als das andere.
Also.
Du hast. Wenn man da jetzt
mit vielen Leuten drauf arbeitet
und das alles braucht, was GitLab hat
und sowas. Hey.
Keine Frage. Dann kann man sich auch lokal in GitLab
hinstellen. Man sollte der Fairness halber
sagen, es gibt noch ein paar mehr
Projekte. Es gibt noch GOGS.
GOGS ist das Originalprojekt, von dem
GTA geforkt wurde.
Und ähm.
Es gibt glaube ich auch
noch ein paar mehr. Aber ich
weiß aus dem Kopf ehrlich gesagt keine.
Und jetzt haben wir
hier quasi einen lokalen
nennen wir es mal einfach den lokalen
GitHub-Clone, der nichts wirklich
mit GitHub zu tun hat.
Der bisher
eigentlich hauptsächlich
dafür da war,
Depots anzulegen. Komm mal hier.
Wir machen das gleiche jetzt mal, was wir
in GitHub gemacht haben. Aber nochmal
hier. Ähm.
Bla bla bla bla bla bla.
Create. Ja. Das gleiche
was wir in GitHub gemacht haben, machen wir zurück.
Was wir sehen, standardmäßig Dark Mode.
Muss nicht sein. Kann man auch umstellen.
Appearance.
GTA
und Green und
wir lassen es mal.
Wir lassen es mal im Dark Mode.
Das ist ein guter AD Sync. Ich habe ehrlich gesagt
keine Ahnung, ob es einen guten AD Sync hat.
Ich weiß überhaupt nicht, ob es einen AD Sync
hat. Da kommen wir wahrscheinlich wieder in die
Region, wenn man es im Enterprise Umfeld
einsetzen will, dann ist vielleicht GitLab doch nicht
so verkehrt.
AD wie Active Directory. Wahrscheinlich.
Wir können mal, wir können, wir können gucken
gleich mal.
Site Administration. Gucken wir gleich mal, was
es für Settings hat. So. Jetzt pushen
wir mal unser Repo
da rein. Das ist das, was
ich eben auch auf Git habe.
Git
RemoteRM
Ja.
Cluster.
Main. Nein, das heißt immer noch Master.
Bitte nicht auf Twitter posten.
Internal
Server Error. Okay, nice. Geht gut los.
Wo ist das
Problem?
Wo genau ist das Problem?
Was?
Geht gut los.
Wo genau hat er
jetzt, was hat er jetzt für Schmerzen?
Was hat er jetzt für Schmerzen? Warum, warum?
Guck mal ins
Log. Unauthorized.
Ne. Also ich pushe als
Root, ne. Das ist Unauthorized.
Aber hier, hä?
Nice.
Okay, ich habe keine Ahnung, woran das liegt.
Ähm.
Ich.
Pushing an existing Repo. Haben wir doch schon
gemacht, ja. Na gut, Main ist
wurscht. Das heißt ja nicht mehr.
Ich meine, wir können explizit sagen, dass er das da drunter
posten soll. Ne.
Okay. Was auch immer.
Warum das nicht
funktioniert, ich weiß es nicht. Ähm.
Dann, dann machen
wir das doch mal anders. Dann machen wir das doch mal anders.
Wir, wir machen mal ein neues
Äh.
Hier. Gehen wir mal ins
Temp, Temp Verzeichnis.
Wobei, CD Repos.
SSH Key. Ne, ich mache es über HTTP.
Authentifizierung.
Also das ist.
Ja. So, dann machen wir das mal so, wie die das
hier vorschlagen.
Ja, alles gut. Ja, wunderbar.
Excellent.
Remote Add.
Achso, ja, weil ich geklont
habe. Okay. Aus irgendwelchen
Gründen ist es kaputt. Ich darf nicht pushen. Nice.
Kann es, aber. Hm.
Weiß nicht, was er für Schmerzen
hat. Er ist der Meinung. Unauthorized.
Ref's Pack.
Hat der Schreibrecht? Ne, der hat.
Der hat
das gerade angelegt.
Naja, wisst ihr was?
Wir machen uns mal einen User, der nicht
Root heißt. Vielleicht kommt er mit dem Namen
Root als User nicht, nicht klar.
Wir machen jetzt mal.
Wo legt man hier, wie legt man hier
User an? Side Administration?
Ach mal.
Naja, mehr wirst du, mehr wirst du da.
Oder minus V.
Mehr wirst du da an der Stelle nicht sehen.
Das ist ja, das ist ja die Fehlermeldung.
Der Server Hook
Rejected us.
Weshalb auch immer. Okay.
User Accounts. Da ist es doch. User Accounts.
Restricted nix.
Okay.
Create new user account. Max
at
kappa lul.com
Ne, ne. Passwort 123456.
Bestes Passwort überhaupt.
Max has been created.
Gut. Dann logge ich
mich mal als
Admin. Ich mach mich mal Admin.
Update user account.
Ja. Okay. Dann logge ich
mich mal als Max ein.
Vielleicht kommt er einfach mit dem Namen
Root nicht klar. Bin ich als Max
eingeloggt. Neues Repo.
New Repo.
Keg W.
Vor allem Champ. Nennen wir es mal
wieder so. Max.
123456.
Das ist aus irgendwelchen Gründen
kaputt. Warum geht
denn das nicht? Internal Server.
Was hat er denn für Schmerzen?
Okay. Das hat irgendwas.
Ich hab lokal Master. Ne hab ich nicht.
Ich hab ja auch Main.
Ah Moment. Ist noch das
falsche Repo. Das ist richtig.
Git.
Remote. RM.
Geht aber trotzdem nicht.
Unauthorized.
Hm.
Okay. Dann liegt das vielleicht an meinem Setup.
Weiß ich nicht.
Aber das können wir einfach fixen.
Indem wir.
Ich lösch das mal kurz wieder alles.
Wir starten das jetzt einfach im
Docker Container.
Das sollte ja funktionieren. Da sollten
ja alle Berechtigungen richtig sein.
Repo heißt nicht vor mchamp.
Aber ich hab
das hier doch kopiert.
Egal. So.
Das hier kommt weg. Docker
GTA.
Dann. Wir starten es einfach
im Docker Container. Dann sollte jetzt ja
wirklich nix.
Nein. Nein. Nein.
Please. Kein Docker Compose
File. Ich will einfach ein
popliches
Docker Run haben.
Okay. Das ist so nicht gedacht.
Basics.
Da musst du zwei Ordner weiterleiten und gut ist.
Ich mein ich kann's
auch mit einem Compose File machen. Meinetwegen.
Wenn's sein muss. Aber.
Ah.
Ist so. Hier.
Das da. Genau so.
Docker Run.
So will ich das haben. Easy. Mehr brauchen wir doch.
Mehr brauchen wir doch nicht.
Äh. Nicht. Nee. Nee. Nee.
Nicht VData. Wir wollen
pwd slash
Mkdir Gitlab.
Da kann alles rein.
Gitlab.
Kann nach Data mounten.
1.190
So. Das ist das aktuelle.
Port 22. Brauchen wir nicht weiter zu leiten.
Port 3000. Wunderbar.
Hab ich's Gitlab genannt?
Ups.
Na ist egal.
Ist egal.
Docker ps-a. Alles klar.
Localhost. Nicht 8000.
3000.
Oh ich glaube.
So. Ähm.
SQLite.
Bla. Bla. Bla. Bla.
Wir lassen einfach alles default. E-Mail Settings.
Nee. Nee. Quatsch. Admin Settings.
Max. 123456.
123456. 123456.
Massive.
Max at kappa lul.com
Install.
Save.
So. Jetzt haben wir es in unserem Docker Container liegen.
Jetzt aber.
Ich nenn das Repo jetzt mal anders.
Das heißt Kackel Repo ist das.
Wunderbar.
Wir machen auch ne Readme rein.
Readme. Das er jetzt nicht abcutten kann.
Readme. License. Wunderbar.
Excellent. Genau das will ich haben.
So ist das gut.
Localhost. Port 3000.
Repos.
Yes.
Git clone.
Jetzt hoffen wir mal das es funktioniert.
Ja.
Will ich. Actions ausprobieren. Richtig.
So. Das haben wir geklont.
Das ging schon einmal.
Schreiben wir mal was in die Readme rein.
Ja. Blub.
Git.
Commit. Minus A. Minus M.
Lul. W. Git.
Push. Origin. Main.
Jetzt bitteschön. Ja.
Hey. Funktioniert.
Okay. Dann lassen wir es halt im Docker Container laufen.
Leute. Meinetwegen. Soll mir recht sein.
Soll mir recht sein.
Dann lassen wir es halt im Docker.
Who cares. Who cares. Ja.
Ist egal. Ist egal.
Wurscht.
Keck wait.
So. Also. Das funktioniert.
Da kann ich doch jetzt da. Da kann ich jetzt mein
Vmchamp
Repo anlegen. Vmchamp.
Alles gut. Vmchamp.
So. Zack.
Und da können wir jetzt die Software rein pushen.
Wollte, dass wir auch ein bisschen
Sachen drin haben, die wir dann auch
bilden können und mit Actions ausprobieren können
und sowas. Also.
Git. Remote.
Rm.
Origin.
Add.
Git. Push.
Origin. Master.
Max.
Hat funktioniert.
Okay. Aus irgendwelchen Gründen ging es bei mir lokal
auf dem Rechner nicht. Im Docker Container geht es ohne Probleme.
Wie hieß
das Repo, wo man GitHub Actions lokal
testen kann?
Hä?
Das werden wir jetzt wahrscheinlich. Ach ja.
Genau. Act. Act. Das werden wir jetzt
ausprobieren. Also. Jetzt habe ich den ganzen Campl hier gepusht.
So. Und jetzt gucken wir uns hier mal ein bisschen
um. Ich mache gerade mal alles zu.
Außer das hier.
Was können wir denn jetzt hier machen? Ich habe bei mir lokal
auch ein GTA laufen. Ich muss ehrlich sagen.
Mehr als das hier habe ich noch nie
damit gemacht.
Ich habe einfach nur
Postcode reingepusht, den ich nicht öffentlich in der Cloud
oder im Internet haben wollte. Fertig.
Ich benutze keine Issues lokal. Keine Pull Requests lokal.
Keine Milestones lokal.
Und hier an Settings mache ich auch nicht großartig rum.
Package Registry und sowas.
Benutze ich alles
absolut gar nicht. Ja. Null.
Ähm.
Ich habe auch noch nie großartig hier in den Settings
rumgeklickt. Wir können uns da jetzt tatsächlich mal ein bisschen
umgucken. Was ich mag ist, dass es
standardmäßig ein Dark Theme drin hat.
Das finde ich sehr nice.
Das ist enorm pog.
Package Registry ist auch neu.
Ja. Das probieren wir jetzt mal alles aus.
Also ich benutze nichts davon.
Lokal bei mir. Außer das.
Und es war bisher auch so,
dass in GTA und GOGS
und allen anderen
GitHub und GitLab Konkurrenten
eigentlich
nichts weiter drin war
als eben ein Web Interface
für Git Repos. Reicht ja auch.
Ist ja auch das was zu 90%, 95%
benutzt wird. Aber
aber mittlerweile
ist es ja auch
zunehmend beliebter
direkt
integriert in sein Repo
seine Software zu testen
Packages bauen
zu lassen, Container Images
erstellen zu lassen und
die Container Images dann auch gleich irgendwo
ja damit was
gebundeltes zu hosten.
Das ging
Alter. Das ging die ganze
Zeit
mit GTA nicht.
So.
Und jetzt
haben sie das relativ neu
drinne, dass man
Container Images direkt hier mit hosten
kann und
dass man auch
seine Software
bauen kann direkt da drinne. Also
sie haben GitHub Actions genommen.
Gehen wir mal auf GitHub
und gehen mal hier in
ja gehen wir in das Kubernetes
in das Kubernetes Repo ist es eigentlich vollkommen
egal. Und da seht ihr in dem Moment
nicht ins Kubernetes Repo in
in
Qt App gehen wir rein. So.
Und da gibt es in GitHub so ein Ordner
der sich GitHub Workflows nennt
und da kann man zum Beispiel so Sachen
definieren. Ich zeig das
jetzt einfach mal, weil sich vielleicht
nicht jeder was darunter vorstellen kann was man
da machen möchte mit seinem Source Code.
Zum Beispiel hier passiert folgendes
das ist eine sehr simple übersichtliche
Action.
Die sagt sobald
neue Tags in das Repo gepusht
werden, also quasi könnte man sagen sobald es
ein neues Release Tag gibt
sobald ein neuer Tag in das
Repo gepusht wird, das ist jetzt übrigens auf GitHub
nicht auf Github.
Dann soll er folgenden Job ausführen und zwar
er soll sich den
Source Code auschecken, sich an
der Container Registry von GitHub
anmelden, dann
ein Docker Bild machen und
das fertige Image in die Container
Registry auf GitHub pushen.
Das bedeutet, wenn ich hier einen neuen
Tag pushe, dann baut er
meine Software, baut ein
Container Image daraus,
hostet das Container
Image public in der Container
Registry bei GitHub und wenn ich dann
zum Beispiel lokal sagen würde
docker pull, könnte ich mir das
Container Image ziehen oder
aber ich habe irgendwo einen Kubernetes Cluster
wo ich dann entweder
on the fly oder mit irgendwelchen YAML Dateien
das Image aktualisiere
und er wird sich gleich das neue Image pullen.
Kann man viele
coole Sachen damit machen.
Noch ein anderer Anwendungszweck für
solche Actions ist zum Beispiel, wenn
man Pull Requests aufmacht.
Ich könnte jetzt zum Beispiel sagen, hey
wenn einer
Contributen möchte
zur Qt App
dann soll bei jedem
erstellten Pull Request
3-4 Sachen getestet werden
und nur wenn die Tests
erfolgreich sind, dann beschäftige
ich mich überhaupt mit dem Pull Request.
Zum Beispiel ist die Testsuite durchgelaufen
ging irgendwie
im Background ein Aufbau damit
ging es irgendwie zu starten
was auch immer, da kann man sich ja alles mögliche
ausdenken und dann
hat man solche Actions am Start und die können
ein bisschen diese manuellen
Schritte abnehmen, so
lass mal alle Tests laufen, hat der Typ auch
darauf geachtet, hat er sich an den
Style Guide gehalten
veröffentliche von einer neuen Version
und sowas, das kann man alles damit automatisieren
das ist die letzten Jahre
über sehr viel beliebter
geworden, weil die Leute gemerkt haben
es ist sinnvoll, so
repetitive Sachen zu automatisieren, dass man
nichts mehr dabei verkehrt machen kann
vielleicht ist es initial ein bisschen
größerer Aufwand, sich sowas hier
auszudenken, aber unterm Strich
spätestens bei dem zweiten
oder dritten Release, macht sich's dann
schon bezahlt
und man kann auch nichts vergessen
das geht in Github schon lange
das ist jetzt möglich
auch in Githea
schreiben sie hier
Runner
Register a Runner, bla bla bla
es ist so
beliebt geworden, weil es so einfach geworden ist
ja, ja auch
Github Action ist mir dazu beigetragen, früher musstest du
noch mit Jenkins und sowas
und sowas rum, ich weiß nicht wie es
richtig heißt, früher musstest du
noch mit Jenkins oder sowas rumschlagen
wobei ich persönlich ja sagen muss
ich mag Jenkins eigentlich
so
das ist jetzt möglich
also die haben das jetzt eingebaut
bei GitLab geht das Ganze auch
also bei GitLab sieht das Ganze
dann so aus, also ihr habt das jetzt gesehen
wie das
wie das bei mir in Github aussieht
GitLab hat auch sowas in der Richtung
zum Beispiel ist hier
ein Exempel
wie man genau das gleiche in GitLab
machen würde, also ihr seht schon
das ist ein bisschen
anders von der Handhabung im Großen
und Ganzen, aber
doch
relativ ähnlich
ich mag Jenkins, ich habe früher
viel mit Jenkins gemacht, es ist genauso
ich bin halt ein bisschen Boomer, ich mag auch Nagios
ich würde nicht unbedingt Nagios nochmal
neu installieren heute, beziehungsweise
das irgendwo neu einführen oder mich drum
kümmern wollen, aber ich habe
ganz gute Erinnerungen an Nagios, ich fand das nie
so schrecklich wie es immer gemacht wurde
und
ich mag Jenkins auch, mit Jenkins
kannst du einfach alles machen
ich wäre auch nicht scharf drauf, ein neues Jenkins
heutzutage aufzusetzen und zu verwalten, aber
so schlimm ist das gar nicht
so, und jetzt gibt es
das ganze eben auch in Githea
oder Githee oder ShitEA
oder wie auch immer man das aussprechen will
gibt es jetzt die Möglichkeit auch
solche Actions Runner
zu benutzen
und das schreiben sie auch hier und sie haben es clever
gemacht
die Leute von Githea, ich finde die haben es wirklich
clever gemacht, nämlich
sie sind auf die schlaue Idee gekommen
einfach Github
Actions zu kopieren
das ist 1 zu 1 quasi mehr oder weniger
Github Actions kopiert
was natürlich sehr schlau ist
weil sie haben einfach das beste und einfachste
genommen, haben es kopiert
und bei sich eingebaut
man könnte jetzt sagen
das ist ja auch eine chinesische Firma mittlerweile
dahinter
ne, aber
ich weiß warum die das gemacht haben
die haben nämlich folgendes Projekt dafür
verwendet
nämlich das hier
das gibt es schon länger
damit kann man Github Actions lokal ausführen
und die haben quasi diesen Runner
eingebaut, jetzt einfach
nur in Githea
was natürlich gut geht, weil das ist auch
glaube ich ein Go
Tool, das kann man gut einbauen
also es war wirklich eine gute Idee
das nächste coole was sie
eingebaut haben, was ich alles noch nicht
ausprobiert habe, was wir jetzt gleich machen müssen ist
sie haben eine
Container Registry eingebaut
hier
Package Settings
und ich habe keine Ahnung
wie das richtig funktioniert
das können wir jetzt gleich ausprobieren
sie haben wohl eine Container Registry
jetzt auch mit dabei
also extrem nice
damit hat man
jetzt nicht nur 90%
abgedeckt was man braucht, sondern
95% also wenn das gut
funktioniert wohlgemerkt
das heißt privat braucht man dann eigentlich nichts
größeres mehr
automatischen Runner für seine
Projekte um
Jobs auszuführen und eine lokale Container
Registry, also das ist eigentlich ziemlich
rund
jetzt müssen wir uns nur mal angucken wie der ganze Campl funktioniert
Registry
C Document
geht schon mal gut los
ach die haben Usage vergessen
ok Package Registry
starting with GTH 1.17
also sprich die
vorletzte Version hat das erst eingeführt
Supported Package
Managers
und wo ist jetzt Generic
und wie kann man da jetzt
Container
ach hier Container Registry
Publish Open
Container Initiative bla bla bla bla
Docker Login
ja gut das muss man jetzt nicht machen
aha
interessant
ok das können wir theoretisch
gleich mal ausprobieren
ob das funktioniert probieren wir das einfach mal ausprobieren
Docker Login
Local Host
Port 3000
Username Max Passwort
123456
Login Succeeded nice
cool das war jetzt aber
easy
und jetzt kann man was in die Container Registry
pushen
Docker
Bild
Bild
ok
ich baue mal kurz ein aktuelles
Paket Image
von der Software
und dann pushen wir die mal
in die lokale Container Registry
noch mit Docker noch nicht automatisiert mit
Runner und sonst was aber wir probieren es mal aus
also ich muss es
da noch taggen sonst wird das auf jeden Fall
nicht funktionieren ich muss das Image taggen und dann kann ich
das Image pushen
also ich muss das pushen
nach Owner Image Tag
also wahrscheinlich
Max
Slash
HM Champ Doppelpunkt
Latest oder sowas
hier das Docker Image ist noch am bilden
ja
er ist noch schwer beschäftigt
Alter wie lange bauten der das Image man
Deprecated
Ist Ubuntu nach wie vor eine Distro
die man Anfängern empfehlen kann
ja
Desktop oder Server
was ist euer Begehr
Werte Lefakre
Desktop
ja kann man empfehlen
ich persönlich mag Ubuntu
auf dem Desktop schon
aber es ist nicht meine primäre Wahl
also auf der Arbeit zum Beispiel habe ich Ubuntu
auf meinem Notebook und wisst ihr warum
warum habe ich Ubuntu auf meinem Arbeits Laptop
ganz einfach
weil ich irgendwas wollte was funktioniert
und es jetzt für die 2-3 Monate auch keinen Sinn mehr gemacht hätte
war groß was anderes drauf Fedora mag ich gar nicht
Linux Mint
finde ich persönlich ganz ok
wenn es geht die Mate Edition
aber alles andere ist auch ok
ja
aber Ubuntu kannst du benutzen
Ubuntu Desktop ist auch gut
Manjaro würde ich nicht unbedingt
einem Einsteiger empfehlen
also du kannst
ohne Probleme Linux
Ubuntu Linux drauf hauen
ok Container wurde gebildet
nice
achso
Moment
Docker Images
das ist wahrscheinlich das Richtige
Git Tag
Moment
ach Git Tag
Docker
oh Gott
ja schwierig
schwierig manchmal
Docker Tag
das da
ich bin mir gar nicht sicher ob die Syntax so stimmt
Kekl
ne
Ok so funktioniert das
alles klar
so und jetzt muss das folgendermaßen getaggt werden
anscheinend
Local Host
Local Host
Port 3000 für die Container
Owner ist Max
Image ist VM Champ
ich hoffe es geht Groß- und Kleinschreibung
wahrscheinlich nicht
Tag Latest
ah
ok so und jetzt
Push
Docker Push
und jetzt quasi so
wie das funktioniert
Alter
Alter was pusht der denn da
das ist ein mega fettes
Huge Image Alter
wie fett ist das Image geworden
na gut das ist ein Full Size
CentOS 7 mit allen
Libraries und Dingern
ah es funktioniert
so jetzt haben wir unser Image gepusht
und wir
haben eigentlich erwartet
das steht da unter Packages
steht da aber nicht unter Packages
äh warum steht das hier nicht unter Packages
releases
Max
Packages
hä
du hast das unter deinen User gepusht
ja was eigentlich auch ok ist
vielleicht muss ich doch
Groß- und Kleinschreibung machen
vielleicht achtet der auf Groß- und Kleinschreibung
GitHub interessiert sich nämlich nicht für Groß- und Kleinschreibung
man muss es erst
mit dem Repo linken ok
ok muss Lower Case
muss Lower Case
ich muss es erst mit dem Repo linken
ok also es ist nicht standardmäßig eine
Registry dabei
ähm das heißt wie linkt man das
jetzt Packages
for M's
Settings
Settings vielleicht
ah
ok das ist
das ist halt weniger Magic
da ist es
ok sehr schön
ok es ist ein bisschen
anders gemacht als bei GitHub
aber auch durchaus in Ordnung
so jetzt habe ich eine Container Registry
dabei was ich
was ich wirklich cool finde
so und jetzt kommt aber die größte Neuerung
man kann das ja auch
automatisch bei GTA
bauen lassen man muss das nicht mehr
irgendwie lokal mit Docker oder sonst
was machen sondern man kann jetzt neuerdings auch
GitHub Actions quasi
in GTA
verwenden
was mich jetzt zu der Frage kommen
lässt
wie
wie funktioniert das
also Register ok hier ist
hier ist die Anleitung dazu
Register a Runner
At the moment Act Runners are the only
Option
This can be done on the following scope
site-wide ok
organization-wide ok
Workflow gut
wir brauchen einen Runner
site-wide heißt auch
wahrscheinlich hier irgendwo drin
jetzt ist die Frage wo
wo
register ich hier
einen
Runner
Applications
Configuration
vielleicht
hm ja wo könnte
das sein
mal kurz ein bisschen gedudelt an
wo könnte man hier einen Runner
registern
habt ihr irgendwie eine Idee
Create a Workflow
ok wie registert
wie registert man hier einen Runner
Action
suchen wir mal nach Actions
Configuration Action
Applications
User System Monitoring
Applications Webhook
Packages
da ist es nett
wo könnte das sein
bei Repository
ok ich kann es im Repo
registern
ach steht ist da eine Anleitung
drinnen wie das funktioniert
einfach ein CI-File
anlegen ja ja ein CI-File
bringt er aber nichts wenn du keinen Runner
hast irgendjemand muss ja das CI-File dann auch ausführen
können ok wie
funktioniert das jetzt
kann ich das
ok ok ok wir müssen noch was
checken kurz kann ich das jetzt
hier auch aufmachen wenn ich aufmache?
wenn ich auf meinen Host drauf gehe
Ort 3000
jawoll funktioniert auch
ähm
ah hier
Admin Runners
Admin
Runners
ok
äh
ok ja
und jetzt
wenn es Admin Runners nicht gibt
muss man das vielleicht noch irgendwie aktivieren
oder so
muss man ok
GTA Docs das müssen wir mal kurz schauen
Runner
Act
ach was soll ich denn suchen
welche Vision ist
der Container äh die neueste
wo sieht man die Version hier
das ist
die neueste
ja
also das ist die neueste
die neueste die es gibt
ja 19
also eigentlich alles gut
ähm
warum habe ich denn das nicht
das ist natürlich schon mal geil
wenn das nicht funktioniert
muss man das irgendwie aktivieren?
ja Documentation
gibt es ja dazu auch nicht
ja das ist schon mal geil
ok man hat keinen Plan
wie es funktioniert sehr schön
nice Pogu
da weiß man schon mal klein Bescheid
wie man das nicht machen sollte
Register a Runner
ja das ist ja schön wenn ihr mir sagen würdet
wie ich einen Runner register
so war das in der Preview ok
wir gucken
Zappcon danke für den Sub
ok äh Screenshots
Applications Runner
sollte ich eigentlich haben
Applications Runner
hier dazwischen
äh
wo auch immer
hier dazwischen sollte ich
einen
ok
in upenable
app.ini
ah
da guck mal da
app.ini
ok inni
warum zum Teufel ein inni File
NO GOD
NO GOD
PLEASE NO
Windows Shit oder wie
was ist das denn hier
dann gehen wir da mal hin
alles gut
id
temp
gitlab
warum auch immer ich das gitlab
genannt habe
git
äh conf
wir machen jetzt erstmal docker stop
würde ich sagen
ich hätte das Ding auch mal ordentlich
ordentlich nennen sollen
so ähm jetzt hier
vim conf
ab inni
und jetzt wohin muss ich actions
wie
muss man das von Hand einfügen noch
oder wie
add additional
Moment das ist so neu
das ist noch nicht mal ne disable Sache
in dem in dem
alter
bleeding edge features hier
ok docker start
neuster
neuster shit
ok
präge chat chat
chat bevor ich da reinklicke präge
präge präge
präge das jetzt funktioniert
Okay, ihr habt Prager, jetzt ist alles gut.
Site Administration.
Runners.
Da ist es.
Nice.
Create new runner.
Register token.
Sehr schön.
Pogu.
Alles gut.
Okay.
GTA 19.
Sehr schön.
Das heißt, wir brauchen jetzt ein Act Runner.
Wir machen das in der VM,
weil in einem Docker-Container
wird es wahrscheinlich mit Docker in Docker dann kompliziert.
Hier kannst du weitermachen mit Act Runner.
Wir machen jetzt eine VM.
Wir starten jetzt eine VM.
Und das Schöne ist,
ich habe da zufälligerweise ein Tool am Start,
was relativ einfach lokale VMs erzeugen kann
und sich per SSH darauf connecten.
Geht ganz zackig.
Innerhalb von 20 Sekunden hat man eine lokale VM am Start,
in der man Sachen ausprobieren kann.
Ist das nicht nice?
Wo könnte es dieses Tool nur geben?
Ich habe gehört, das gibt es bei mir auf GitHub.
Ja, man könnte auch das mit nicht quasi Root Privileges bauen.
Aber machen wir mal den Runner in der VM.
Es hat auch seinen Grund,
dass GitHub selber die Runner in VMs laufen lässt.
So, also hier haben wir eine extra VM.
Einmal Update.
So, und jetzt können wir hier weitermachen.
Also, wie funktioniert das jetzt?
Build from source.
Act Runner from...
Download pre-built binary main.
AMD 64.
Das da brauchen wir anscheinend.
Copy link.
Weget.
Aber eher nicht als Root, oder?
Weget.
So.
Könnte man das nicht...
Warum kann man den...
Ja, okay.
Gut.
Wunderbar.
Runner.
chmod.
Plus X.
Act Runner.
Und wie geht es jetzt weiter?
Act Runner.
And you will be asked to input a token.
Also, machen wir das doch mal.
Zack.
Act Runner.
Ähm.
Wie muss...
Ach nee.
Register.
Register.
Enter instance.
Ähm.
Da muss ich meine IP eintragen.
Meine IP ist...
Wo ist meine IP?
Da.
Ja.
Ich hoffe, ich komme da von der VM überhaupt hin.
Aber nicht in der Öffentlichkeit machen.
Oh nein, Leute.
Shit.
Seid ihr schon drin?
3000.
Ah, da muss noch...
HTTP, Doppelpunkt, umslash davon 3000.
Enter Runner Token.
Äh, wo war das hier?
Runner?
Create new Runner Token.
Enter.
Hackle Runner.
Okay, Enter Hostname, ja.
Enter the Runner Labels.
Leave blank.
What?
Okay, blank.
Runner registered successfully.
Sehen wir den?
Da ist er.
Okay, und jetzt muss ich ihn wahrscheinlich einfach noch starten.
Haben wir gemacht.
Ach, man kann es auch einfach so angeben.
Und jetzt Demon hintendran.
Oder Da...
Daimon.
Ach, man muss da einen Docker installiert haben.
Okay.
Okay.
Upt install.
Docker.
Siehst du?
Schon mal gut.
Schon mal gut, dass ich den Krempel in der VM gemacht habe.
Warum braucht der Zugriff auf Docker, um das laufen zu lassen?
Wie will man dann überhaupt Docker in Docker-Gescheit bilden?
Naja, naja, naja, mal gucken.
Okay, wisst ihr was?
Bam.
Okay.
Da ist er, der Runner.
Ubuntu Latest, Ubuntu 22.04.
Das ist easy.
Das ist wirklich easy.
Da kann man sich nicht beschweren.
Das ist cool gemacht.
Okay, dann erstellen wir jetzt mal einen CI-File.
Die haben, glaube ich, nichts hier drin, um das irgendwie ein bisschen zu...
Okay, wir machen jetzt was.
Wir gucken mal, wie gut sie GitHub Actions kopiert haben.
Wir gucken mal, wie gut sie GitHub Actions...
Wie gut GitHub Actions kopiert.
Und also, gehen wir mal da rein.
Machen das mal.
Okay.
Also, mkdir.
Wobei, wir gucken nochmal.
Wir gucken uns mal das How-To an.
GTA.
Das muss auch schon nicht GitHub.
Hier, so muss das heißen.
Alles klar.
Ach, man kann es auch GitHub Workflows nennen.
Okay, das ist gut kopiert.
Man kann es exakt so nennen.
Wie oft GitHub.
Weiß.
Das machen wir einfach jetzt.
GitHub.
mkdir-p.
Plug and Play, ja.
Ich bin im falschen Ordner.
Ich kack nur, Mann.
Repos for mchamp.
Git remote-v.
Da, bam.
mkdir-p.
Oh, ist gut.
Und jetzt kopieren wir da mal.
Ah, ja, hier haben sie ja schon.
Guck mal.
Hier ist doch schon.
Moment.
Go, go, Releaser.
Scheiß drauf.
Ich kopiere das jetzt mal.
Ich kopiere einfach mal den, ähm, den, den Workflow.
Ja, ja, wir trusten dem Autor.
GachiBuzz.
Alles gut.
Workflows, new file.
Äh, ja, ja, was weiß ich.
Runner, hier.
ci.yaml.
Beste, bester Name.
So, dann.
Äh, das heißt nicht Go, Releaser.
Das heißt einfach nur, äh, Test, Runner.
Ah, nee, das heißt, äh, Omega, Omega 0.
Beste.
Ubuntu Latest.
Steps on.
Ich hab mal 2204 hin, weil wir haben einen Runner, der auf 22, das testen wir dann auch mal.
Und wenn ich da was anderes eintrage, ob es dann auch nicht geht.
Äh, Checkout.
Das reicht eigentlich.
Was macht denn eigentlich Go, Releaser?
Push das in die Go Package Registry.
So.
Das reicht zum Testen, ob der Runner läuft.
Ja, mehr muss man ja erstmal nicht machen.
Okay.
On Push Branches Main.
Git Stalos.
Eigentlich alles gut.
Git Add.
Git, äh, Commit.
Ja, bester Commit.
Äh, Git Push.
Push Origin.
Ach, da ist wieder Master jetzt.
Max.
Zack.
Wo sind meine Actions?
Wo sehe ich die?
Und woher weiß ich jetzt, ob mein Runner runnt?
Runners.
Ähm.
Ach, ich hab noch Branch Main drin stehen, das ist richtig.
Aber sollte es hier oben nicht, sollte es hier oben nicht wenigstens einen Actions-Tab oder irgendwas geben?
Ah, hier.
Enable Repository Actions.
Okay, gut, dass ich das gefunden hab.
Jetzt gibt's einen Actions-Button.
Jetzt gibt's...
Sieht ein bisschen aus wie in Github.
Okay, Master.
Max.
So, und jetzt, jetzt...
Jetzt geht die Action.
Alter, das ist ja easy gemacht.
Da kann man sich ja gar nicht...
Also, für lokal ist das wirklich Wahnsinn, dass es das mittlerweile in dieser...
Sollen wir sagen, in dieser Einfachheit und in diesem Gesamtpaket gibt.
Er ist jetzt, er ist jetzt nicht der Schnellste, ja.
Äh, VM Champ, SSH...
Oh.
Kann das sein, dass ich...
Ne, ne, der Test-Runner läuft hier.
Error Response from Deep.
No such image.
Node 16 Bullseye.
Was?
Node?
Node?
Ach, wahrscheinlich für die Checkout-Action.
Es ist schief gelaufen.
Docker Pull Image.
Node 16 Bullseye Plattform.
Klar.
Joa, hat nicht funktioniert.
Kein Internet-Zugriff.
Doch.
Doch.
Kein Internet-Zugriff haben.
Hat er auch.
Weil ich mein, Docker...
Ach so, Moment.
Als, als Root.
Ja.
Machen wir mal.
Docker Run Ubuntu.
Geht.
Kein Problem.
Es gibt einfach das Image nicht.
Was?
Äh.
Ich hab KMX getestet.
Ja, warum nicht?
Schön gut.
Ähm.
Wäääh.
Wo ist das Problem?
Deswegen bin ich übrigens in der VM.
Damit der Scheiß funktioniert.
Ähm.
Was ist, was ist sein...
Ähm.
Was hat er für Schmerzen?
Ja.
Aber Docker minus minus Version.
Was haben wir denn hier?
20.10.
Ja.
Das ist schon ein bisschen älter.
Ich mein, das ist die Debian-Version.
Ja.
Docker Release.
Aber so, so uralt ist das jetzt auch nicht.
Es ist...
Ja, komm.
Es ist 2 Jahre alt.
So viel hat sich da nicht getan.
Meint ihr, meint ihr wirklich, dass es so alt ist?
Ja.
Ich mein, es ist...
Ja.
Ja.
Ich mein, es ist schon ein bisschen älter.
Okay.
Ja.
Aber jetzt...
Ja.
Okay.
Okay.
Meint ihr, dass es an der Docker-Version liegt?
2 Jahre ist doch nicht lange.
Meint ihr, das liegt an der Docker-Version?
Meint ihr wirklich?
Ey, aber wir können.
Docker install Debian.
Wir können die offiziellen...
Wir können die offiziellen Packages benutzen hier.
Kein Ding.
Können wir machen.
So.
Brechen wir mal den Runner ab.
Runner, please, abbrechen.
Ähm.
Add User.
User Mod.
Docker.
Äh.
Wie geht's?
Äh.
Wie ging das jetzt nochmal?
Ja.
Das wollen wir haben.
Ja.
Ja.
Wir fügen mal einen User mal.
Wie?
User Mod ist nicht...
Keck.
Wait.
Was?
Add.
Install.
User Mod.
Das heißt wahrscheinlich nicht User Mod.
Sondern...
Install.
User Mod.
Debian.
Sondern User Utils.
Oder...
Was muss man für ein Package für installieren?
Achso.
Ja.
Hat's funktioniert.
etc.
Group.
Okay.
User ist drinne.
Loggen wir uns mal aus.
Vmchimp.
SSH.
Testrunner.
Docker.
PS.
Jawoll.
Funktioniert.
Docker.
Run.
Ubuntu.
Wir sind jetzt in der VM.
Wohlgemerkt.
Also.
Okay.
Da hat eh...
Aus irgendwelchen Gründen hat der Probleme.
Error during connect.
Post.
Var.
Run.
Irgendwie.
Was auch immer.
Okay.
Dann machen wir das doch, was die offizielle Anleitung sagt.
Wir installieren Docker aus den Package Quellen.
Installation Methods.
Jawoll.
Yes.
Warum so kompliziert?
Aber okay.
Ich...
Ich copy...
Ich copy...
Was?
Was willst du von mir?
Was?
Alter.
Ich hab keine Ahnung, was sie von mir wollen.
Aber ich führ das jetzt einfach aus.
Das ist eine VM, ja?
Deswegen soll es eigentlich gar keine Probleme geben.
So.
Up...
Update.
User...
Was zum...
Was?
Was?
Was?
Was?
Was?
Was?
Was?
Was?
Was?
Yes.
Acht...
Ach.
Haben die auch was zum Curl?
Na ja gut.
So macht der WX die offiziellen Packages.
So.
Jetzt haben wir die offizielle Docker-Version installiert.
Das sollte eigentlich kein Problem.
Ja.
Mach.
Okay.
Docker Hello World.
Das sieht besser aus.
Hello from Docker.
Okay.
Nice.
Sudo.
Jetzt wird der Runner wieder gestartet.
Okay.
Okay, jetzt probieren wir das Ganze nochmal aus.
Hat das einen Knopf?
Hat das einen Knopf, um das Ganze
nochmal neu zu starten?
Hey, ich mag das. Das gefällt mir.
Das gefällt mir.
Das ist
eine wirklich nice Alternative
für lokale Sachen zu GitHub.
Das ist bei weitem nicht so...
Was ist denn jetzt schon wieder, Mann?
Image.
Node.Bullseye.
Das verwendet ein...
ein GitHub-Actions-Kopie
quasi. Ja, richtig.
Was ich super clever
higher-Q finde von denen,
weil GitHub-Actions ist schlicht und ergreifend
das Beste, finde ich.
Das Einfachste und das Beste.
Das Beste vielleicht von dem, was es alles kann.
Nicht, aber die Kombination aus
Einfachheit halber und dem, was es kann.
Das GitHub-Actions ist das Beste.
Und dass die das einfach kopiert haben, die
China-Chinesen, finde ich halt sehr schlau.
Docker-Run.
Das Image gibt es doch.
Wo ist denn das Problem?
Oh, shit.
Moment, Moment.
Docker-System.
Äh, nee, was ist das?
Fuck, ich hab nicht genug Platz.
Fucking Scheiße, Mann.
Meine VM ist doch ein bisschen
zu minimalistisch, hä?
Docker-Run-Ubuntu.
Deswegen funktioniert das auch nicht.
Ja doch, das funktioniert.
Okay.
Docker-Run.
Please, pass rein.
Nein, das ist zu groß.
Das ist zu groß.
Das Image ist zu groß.
Nein, nein, fuck.
Das Image ist zu groß.
Machst du ein Resize vom D-Band-Image
für die VM?
Keine Ahnung, ich hab da noch nichts gemacht.
Okay, df-h.
Wie groß ist ein Root?
Okay, es ist mikroskopisch klein.
Auch noch hinten dran.
Null.
Leute, es ist nur das System.
Mehr ist da halt nicht drauf.
Das System ist halt 1,5G.
Das ist doch 1,5G, ist in Ordnung.
Okay, jetzt wird's, jetzt wird's
interessant.
Wie krieg ich das Image resized?
Das Blöde ist, wenn ich die VM
Wenn ich die VM ausschalte,
ist sie weg.
Weil das sind so temporäre, temporäre VMs.
Ähm, okay.
Jetzt wird's, shit.
Ähm.
Okay.
Lass, lass mal kurz, lass mal kurz gucken.
Also, also, also, Pfeifert, Pfeifert-Time.
Okay.
Ich mein, ich kann den Runner einfach bei mir lokal drauf inszenieren.
Das geht, aber ich, das ist gut, dass wir mal sowas
ähm, sowas
praktisch, praktisch haben.
Also, können wir das on the fly resizen?
Erstmal schauen, wie groß
die Disk an sich ist.
F
Also, da ist ja nix drauf, man.
Das ist ja
F-Disk.
Minus L.
Dev-SCA1.
So, die ist 1,87.
Okay, größer ist das Ganze nicht.
Das heißt, ich muss
mauen eine neue Festplatte.
Sehr gute Idee.
Das ist nicht verkehrt, aber
Docker schreibt immer noch ins falsche Verzeichnis.
So, also, jetzt gehen wir mal in die
Images.
Ich sollte, ich sollte das standardmäßig wohl
ein bisschen, ein bisschen größer machen schon.
Oder noch ein zweites, oder noch ein
zweite, ein zweites Disk irgendwie
dranhängen oder sowas.
Weil das, weil das zu klein ist.
Okay, also
Default
VMs Test Runner.
Da ist mein
Image
Pile
2 GB. Alles klar.
Das passt.
QEMU
Ich glaube euch das jetzt einfach mal, Chat.
QEMU Image
Resize
Disk
Und dann?
Plus oder wie geht's weiter?
Plus 20, 20G?
Ne.
Is another process das?
Ja!
Das geht nicht on the fly, oder? Man muss das ausschalten
dazu.
Ich glaube, ich glaube, man muss es, ich glaube, man muss es
ausschalten.
Ähm, kann man das?
QEMU Image
Image Resize running.
Stopp. Okay, man muss die VM stoppen.
Okay. Online
Method. Increase the size.
Das funktioniert doch nicht.
Wieso VM? Weil, äh, das, ähm, weil der Runner selbst Docker braucht und Docker in Docker und Geschiss.
Ich dachte mir, es ist am sinnvollsten, es in der VM zu machen.
Increase the size. Ja, das funktioniert ja nicht.
Ich kann die Size, die Size ja nicht increasen.
Failed. Ja, ja.
Shit.
Die Frage, warum war nicht persistent?
Weil es eine temporäre lokale VM ist zum Testen.
Und wenn ich die runterfahre, ist sie weg.
Ich mein, ey, es ist, es ist relativ, relativ easy.
Ich kann es auch lokal starten oder in eine zweite Festplatte reinhängen oder sowas.
Okay, das geht anscheinend nicht.
Live. Aber da lernt man immer was bei How to Resize.
Wieso die VM weg ist? Weil ich es so eingestellt habe.
Weil ich die VM so eingestellt habe, dass sobald sie gestoppt wird, sie sich wieder löscht.
Weil das ja einfach nur eine lokale Test-VM zu wegschmeißen ist.
Ich habe nicht damit gerechnet,
dass es zu klein ist.
Reclaiming unused space.
QEMO Image Info.
Okay, guck mal mal, wie groß das wirklich ist.
Da kann man da gar nicht drauf.
Was? Wirt Spasify. What?
Ey, das ist für den Host.
Very important thing.
Before running, we must shutdown the guest VM.
Kann man? Nee, okay, das, das, das, das.
Gibt es sowas wie Wirt Resize?
Nee, gibt es nicht.
Okay, Leute, wir machen es, wir machen es anders.
Add Hardware.
Wir machen einfach nur weitere, wir machen nur weitere Disk dran.
20G.
Disk.
Could not be attached.
Yes.
Alter, warum geht das nicht?
USB?
No free USB port.
Ah, SATA?
Yes. Ah, fuck.
Was?
Read only SATA Disks?
What the hell?
Was will der von mir, Mann?
Okay, Reboot.
Aber Reboot alleine hilft wahrscheinlich nicht.
No!
No!
God, please, no!
No!
Vielleicht sollte ich das Image doch etwas größer machen.
Hm?
Anstatt, also ich weiß, wie wir, also ich kann die VM einfach nochmal aufbauen.
Also das, das USB-Disk.
Ach, guck mal da.
Da hängen sie doch.
Da hängen sie doch.
2x20G.
Okay.
Nice.
Da sind wir doch wieder.
LS-USB.
Hier ist ja nichts drauf auf dieser VM, Mann.
LS-USB.
Upinstall LS-USB.
Ähm.
Moment.
Wie heißt DPKG?
Moment.
Which package APT provides binary?
Ja, ja.
Hier.
DPKG-S.
Search.
Das ist immer in Debian ein bisschen eklig.
DG-S.
So.
Und ich will LS-USB.
What?
APT.
APT.
Install.
Bash-Completion.
Ich weiß, dass es das Falsche ist, Leute.
Ja?
Ich wollte bloß Bash-Completion drauf haben, dass ich, dass ich APT install und sowas machen
kann.
USB.
Und tap, tap.
Die USB-Utils gibt es nicht.
Okay.
Debian install LS-USB.
Not found.
Okay.
So.
So.
So.
Okay.
Not found.
Okay.
Was muss ich installieren?
Sag es mir.
Ach.
USB-Utils zusammengeschrieben.
USB-Utils.
Nice.
Wir nähern uns.
LS-USB.
Minus V.
Erkennt er nicht.
Ja, die VM ist halt sehr minimal.
Ja?
Was soll ich sagen, Alter?
Okay.
Ich weiß, wie wir es machen.
Ich weiß, wie wir es machen, Leute.
Easy.
Easy.
Easy.
Power off.
Ja, jetzt ist sie weg.
Das ist halt das Dumme da dran.
Okay.
Ich weiß, wie wir es machen.
Ich weiß, wie wir es machen, Leute.
Easy.
Okay.
Ich weiß, wie wir es machen.
Ja.
Ich weiß, wie wir es machen.
Easy.
Easy.
So.
VM Champ.
Default.
Cache.
Okay.
Das ist echt nicht so.
Hier ist die VM.
So.
Und jetzt.
Resize.
Hier resizen wir jetzt das Image.
Plus 20G.
Image resized.
Und jetzt.
Und jetzt.
Erstelle ich die einfach neu.
Was ist der VM?
Was, was ich gebaut habe, um schnell lokale VMs zu erstellen?
Man macht es einfach.
Man macht es einfach.
Man macht es einfach.
Man macht es einfach.
Man macht es einfach.
Man macht es einfach.
Normalerweise ist es auch kein Ding.
Normalerweise ist es auch kein Ding.
Dumm ist halt nur, wenn die, wenn der Speicherplatz nicht ausreicht.
So.
Jetzt reused er das Existing Image.
Und das ist schon das bisschen Resizede.
Ne.
Was war das?
Info.
EMU Image.
Ja.
No network found.
Oh ne.
Ist es jetzt kaputt?
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
der nicht mehr? Habe ich mit dem
Resize das Image kaputt gemacht, oder?
Was?
Achso, was machen die da?
Take a backup?
Create a raw image? Warum
ein raw image?
Mach nach dem Resize mal ein Reset
der VM. Ne, ne, ne, ich kann da nichts resetten.
Das ist der allererste Boot von
der VM gewesen.
Oder meinst du,
ich soll die mal neu starten?
Bootet doch im Leben jetzt nicht, oder?
Ich meine,
ich habe die VM mit dem Image erst erstellt.
Der kackt jetzt wieder ab.
Force Champ?
Äh, wie jetzt?
Hä?
Okay, das muss man nicht verstehen, oder?
It's, it's fix.
Nice.
Okay, also.
Jetzt ist die VM wieder am Start. Sehr schön.
Okay.
SSH.
Okay, wenigstens funktioniert, wenigstens funktioniert
das SSH drauf.
Einfach außen
wieder einschalten.
Nice.
Eigentlich müsste ich jetzt MMO Kreiselgrind machen gleich,
aber das, okay.
Curl get docker.
Wir machen jetzt die Hardcore-Variante.
Get docker.
Use convenience script.
Easy.
Wir pipen jetzt, wir pipen jetzt curl.
sudo minus i update.
Docker.
Bam.
What?
Wie jetzt?
Ach so.
Bash.
Direkt gib ihm in your face.
Einfach curl nach Bash wieder direkt aus dem Internet.
So was.
Die pipen nicht direkt in Bash.
Jo, das gehört sich aber so auch.
Also, nee.
Das gehört sich auch nicht.
Muss alles immer direkt in Bash gepiped werden.
Dass das halbe Internet bei einem auf dem Rechner landet.
Äh, ja.
Nice.
Docker PS.
Da sind wir.
User Mods.
Ah, hier, User Mods.
Okay, Docker PS.
Ah, ja.
Docker PS.
Da sind wir wieder.
Hey, nice, du, nice, du.
Äh, we get.
Nee, äh, äh, äh, Runner.
Hier.
Jetzt muss ich den Scheiß wieder runterladen.
Seher Mods.
Und nochmal neu registern, sonst funktioniert es nämlich nicht.
Also, machen wir das mal alles wieder zu.
Das scheint ja soweit zu funktionieren.
So, Dashboard, Dashboard, Runner.
Da lernt man auch, wo der ganze Krempel ist.
Offline kann man den re-registern.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
Und jetzt müssen wir den re-registern vielleicht.
Ne, deleten.
Yes!
Create New Runner, zack, gib hier.
So.
So.
Und wie ging das jetzt nochmal?
Act Runner, man konnte den ganzen Krempel doch übergeben.
Per Konsole.
Ist mir lieber, als diesen komischen Assistent auszuführen.
So!
3000 Token, my Runner Token, no Interactive.
Excellent.
Jaja, ist gut.
heißt anders, ich weiß.
Successfully registered.
Da ist er. Da ist er.
Okay, Runner am Start.
Und jetzt
Act Runner in Demon
starten. Und der Runner ist live.
Okay. Gucken, ob
es jetzt funktioniert.
Ne, wir testen es noch mal kurz.
Wir testen es noch mal kurz lokal.
SSH,
Docker, Run, wie heißt es?
Mass Image, Node Bullseye.
Okay, das sollte jetzt ja funktionieren.
Hoffentlich ist die Festplatte jetzt groß genug.
Hat der ordentlich resized?
Bin mir jetzt gar nicht sicher, ob er ordentlich
resized hat. Ja, muss er.
Muss er. Sonst wäre der jetzt schon abgekackt.
Und sonst wäre der
jetzt schon hinüber.
Ja, ja. Okay, okay.
Alles klar. Ja, jetzt haben wir auch
genug Platz. Okay, nice.
Gut.
Lulwe. Dann führen wir doch
Lulwe noch mal aus.
Setting up job.
Okay. Ha, es funktioniert. Ich sehe,
dass es funktioniert.
Der Job ist durchgelaufen.
Nice. Okay.
Ist im Grunde wie
GitLab Runner. Ja, ne, es ist ein
GitHub Actions Runner.
Quasi ein Fake GitHub Actions.
So, jetzt probieren wir noch mal
eine Sache, von der ich nicht glaube,
dass sie funktioniert.
Und zwar, wir kopieren
meinen kompletten,
meine komplette Action,
nur wir passen sie ein bisschen an.
Also wir machen hier den Job
und so das. Job
Ubuntu Checkout Actions
Docker Login.
Da weiß ich gar nicht, ob das so funktioniert.
Secrets GitHub Token.
Das wird so schon mal nicht heißen.
Glaube ich mal. Man weiß es nicht.
So, Tags ist
192.
Ja, da müssen wir
jetzt richtig reinschreiben.
Äh,
3000.
Slash, Max,
Slash,
VM Champ,
GitHub Rev Name, einfach Latest
hardcoded rein.
Okay, save.
Äh,
bin ich mal gespannt.
Jetzt bin ich mal gespannt,
ob das irgendwas Sinnvolles macht.
Oh, der,
der Runner ist abgekackt.
Geht das schon gut los?
Der Runner ist abgeschissen.
Killed.
Pass auf, jetzt habe ich zu wenig RAM.
Pass auf, jetzt habe ich zu wenig RAM.
Hahaha.
Hahaha.
Ah.
Okay, vielleicht sollte man die VMs doch ein bisschen
mehr customizable machen, oder?
Okay, Leute, lasst mal kurz.
Ich muss mal kurz mir ein To-Do.
Äh, To-Do VM Champ.
Okay, also. Resize Image.
Sagen wir mal so auf
10 GB.
CPU und RAM
konfigurieren.
Äh, Rable machen.
Der Runner ist einfach abgeschossen.
Jetzt macht der nix mehr, der Runner, Alter.
Ich glaube, das hat, ich glaube, das hat,
das hat es nicht gecheckt.
Ich, ich glaube, das hat es nicht gecheckt,
dass das, das, okay,
das muss ich nochmal, das muss ich nochmal abbrechen
und den nochmal starten.
23 MB, oh fuck. RAM voll, RAM voll.
RAM.
Haha, shit.
Das ist zu wenig RAM.
Kann man RAM, kann man RAM
on the fly erweitern? Geht das?
Memory.
512.
Okay, rebooten, rebooten.
Äh, was?
Ich hoffe, rebooten zählt.
Zählt rebooten überhaupt
damit? Ich hoffe
mal. Fuck.
Rebooten zählt nicht mit. Oh nein.
Please.
Oh shit, Alter.
Rebooten.
Ich mach Swap, Swap. Ich, ich hab
20 GB. Ich hab, ich hab
20 GB drauf.
Wir machen jetzt Swap.
Swap.
Ähm.
Swap on? Nee, oh shit.
Wie geht das?
Swap?
Hat der überhaupt einen Swap?
Swap on? Und dann kann man da einfach irgendwie
keckel.image angeben? Nee.
Ähm.
Create Swap File Linux.
Create a Swap File. Ja, ja, okay, okay.
Nee, nee, nee, nee.
Okay, das ist...
MkSwap.
MkSwap.
Ja, jetzt hab ich gleich 40 Zuschauer.
Okay. Touch.
Ach, das muss man wahrscheinlich
in seine Größe, Größe machen.
Ja, ja. Swap, Swap
File. Okay.
Swap on.
Insecure Permissions, Alter.
Geh mal nicht auf den Sack.
No, God!
No, God!
Please, no!
Warum ist das File busy?
Hat der jetzt schon Swap drinne?
Okay, ja, Swap, Swap ist am Start.
Alles gut. Er hat nur rumgemerkert,
aber ist gut. Swap, Swap ist am Start.
Okay.
Wir können den Runner
nochmal ausführen.
Zieh unten mal zu.
Okay, das können wir ausführen nochmal, Runner.
Okay, nice.
Jetzt, please, please. Einfach funktionieren, Mann.
Okay, okay, okay.
Swap, Swap wird, Swap wird aufgebraucht.
Excellent.
So muss das sein.
Swap ist ja nicht umsonst auf SSD.
Da, da flutscht's.
Endlich, endlich kann ich meine SSD mal
sinnvoll benutzen. Oh, ne!
Failure.
Docker Login hat nicht
funktioniert. Unable to execute
File. Please verify that.
Ja, Docker selbst ist ja, ist ja nicht.
Okay, das ist,
das ist, er führt es ja
auch nicht im Docker aus. Er soll das auf
dem Host ausführen. Moment.
Into GCHR?
Was? G, G hat's
kann man doch gar nicht machen.
Ach, Moment. Ich hab da noch die falsche Registry
drinstehen.
Äh, Registry ist
192
3000.
Aber das wird nicht
das Problem sein, oder?
Das wird ja nicht, das wird ja nicht das Problem sein.
Failure.
Äh, hallo? Failure.
Weil, unable to
locate executable
file Docker?
Ich hab Rechte auf Docker.
Das ist überhaupt kein Ding.
Ja. Er kann mit Do-
Ja, das seh ich auch. Aber
warum? Das ist die
Runner4M. Ist das
ein anderer User?
Ne, ne, das läuft als
mein User. Moment.
Der, der lässt das doch
selber nicht in Docker laufen,
oder? Jetzt mal Docker
PS durchlaufen, ja.
GTA-Task, Omega-Lol-Build.
Okay, das ist äußerst
merkwürdig.
Okay, keine Ahnung.
Da muss ich mich ein bisschen im Detail mit beschäftigen.
Aber nicht jetzt.
Das basiert auf Node,
oder was? Auf irgendeinem Node-Image.
Also, das, das, das, das
raffe ich jetzt, raffe ich jetzt nicht.
Also, ich mein, wenn der,
wenn er den selbst nochmal
im Container ausführt, dann ist
klar, dass das nicht funktioniert. Der muss das
in der VM ausführen.
Ist das das Node-Image?
Ne, das ist, hier, diese Actions
benutzen anscheinend das Node-Image.
Keine Ahnung.
Okay, da muss ich mich mit schlau machen, das mach ich jetzt nicht.
Warte, ich geh jetzt ne Runde noch MMO leveln.
Drei Stunden rumgebastelt reicht
mir jetzt.
Schön, dass heute wieder viele Leute mit am Start
waren. Vielleicht, vielleicht
gucken wir es uns auch noch in einem weiteren Stream nochmal an,
wenn ich rausbekommen hab, was Sache ist.
Ähm.
Ich geh jetzt ne Runde Kreisel-Crime machen noch.
Beste Anleitung macht's gut,
TU.
