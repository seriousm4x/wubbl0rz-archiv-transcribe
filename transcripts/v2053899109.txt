Exzellent.
Chat geht auch am Start.
Ich gebe zu, Chat, die Uhrzeit Montag 12.54 Uhr ist vielleicht nicht die, wie soll man sagen, massenkompatibelste Streaming-Uhrzeit.
Aber was willst du machen?
Du könntest einfach während der Arbeit gucken und als Fortbildung abrechnen.
Easy.
Eats.
Um nicht zu sagen, ja, es gibt den Quality-is-Destiny-Schein danach.
Warum leckt der Pepo eigentlich so?
Ich wollte demnächst mit Lua schon mal was davon gehört.
Nicht nur gehört, auch schon damit gemacht.
Nie was wirklich riesengroßes mit Lua.
Immer mal wieder ein bisschen was.
Das letzte, was ich in Lua gemacht habe, ist meine Terminal-Config tatsächlich.
Gerade beim Thema sind.
Ich mache einfach mal die VM an, weil die brauchen wir jetzt eh gleich.
Oder meine VM, wie das manche Leute aussprechen.
Ja, ja, geh mal nicht auf den Sack.
Ich mag Lua nicht.
Und das liegt daran, weil Arrays bei 1 anfangen.
Alle Sprachen, wo Arrays bei 1 anfangen, sind äußerst sass.
Wobei, das sagt man, glaube ich, gar nicht mehr, oder?
Das sagen bloß noch so richtige Kack-Boomer wie ich.
Die denken, dass das cool ist, wenn man das sagt.
So, machen wir mal Updates.
Artstealungs-By-the-Way, gibt es immer Updates.
Ja, so klar.
Wir haben gestern, gestern Morgen im Stream, haben wir geupdatet.
Heute, bam, 23 Package-Updates wieder.
Lua fängt bei 1 an, ja, sage ich doch.
Richtige Boomer können Mehrwertsteuer nicht richtig aussprechen.
Okay.
Ist das so? Warum?
Also das letzte, was ich in Lua gemacht habe, ist meine Terminal-Config.
Die hat so komische Funktionen hier, wie beispielsweise.
Für 1 bis 99 Mausklicks, irgendwelche Actions, Binden und sowas.
Das ist aber vollständiges, also vollwertiges Lua-Skript.
Ein vollständiges Lua-Programm.
Meine Terminal-Config.
Ich fand es am Anfang auch echt weird, Champ, dass die eine Programmiersprache quasi benutzen, um das Terminal zu konfigurieren.
Aber jetzt im Nachhinein finde ich es eigentlich mega nice.
Das Docker-Update dürfte wohl das wichtigste diese Woche sein mit CVE-Score 10.
Ernsthaft?
Das habe ich gar nicht mitgekriegt.
Was ist bei, was ist bei Dockge?
Ne, nicht Dockge, Alter.
Das Dockge ist ja, ich wollte Docker gerade Twitch-Style aussprechen.
Da ist mir eingefallen, Dockge gibt es.
Das ist tatsächlich ein Projekt auf GitHub.
Was ist denn, was ist denn bei Docker?
Diese Woche gewesen, habe ich auch gar nicht mitgekriegt.
Kannst du aus den Containern auf den Host zugreifen?
Ach.
Easy.
Ich führe nur vertrauenswürdige Container aus.
Da ist was.
Ist das alles kein Problem?
Leaky Vessels, Container Escape, Will...
Dieses Wort.
Ich kann dieses Wort nicht aussprechen.
Ich habe so oft...
Ich schaffe es nicht.
Ich kriege das nicht hin.
Verruinabilities.
Verruinabilities.
Ja, das ist so ein Scheißwort, Mann.
Hat der Heise irgendwas zu?
Oder...
Ne.
Keck, wait.
Warum hat der Heise nichts zu?
IT-News für Profis.
Lul.
Ne, das war Golem, oder?
IT-News.
Warte mal, wir gucken.
Wir geben ihm mal eine Chance.
IT-News für Profis.
IT-News für Profis.
Golem weiß wieder Bescheid, ja.
Die Schwachstelle dafür bezieht sich auf Buildkit und das CLI to Run C.
Okay, das ist ja quasi die...
Oh, ich bin da beim Container-Ökosystem immer ein bisschen verwirrt, was die unterschiedlichen Dinger sind.
Also Buildkit ist seit neuerem, sagen wir mal so in den letzten zwei, drei Jahren...
Was ist denn da los?
Warum ist die Bar kaputt?
So, das neue System, wie man Docker-Images baut, beziehungsweise eigentlich muss es ja heißen, wie man OCI-Images baut.
So, und Run C, bin ich mir gerade nicht sicher, ob das die neue von Docker entkoppelte...
Ne, das ist Container-D.
Ach, keine Ahnung.
Da blickst du doch nicht durch.
In Pocket-Speicher.
Nice, ich bin in Pocket nicht eingeloggt, aber Hauptsache in Pocket-Speicher.
Speicher in den Pocket.
So.
Ähm, also, zeig doch mal kurz her.
RF-Programmer, da gebe ich dir recht, das habe ich auch schon bei richtig vielen Boomern gehört.
Ja, Märchensteuer.
Ja, ja, das...
Ich weiß gar nicht, wo das herkommt.
Das habe ich auch schon ganz oft gehört von den...
Von etwas älteren Leuten, die sagen nicht mehr Märchensteuer.
Okay, also, lasst uns das mal kurz abchecken, was da los ist.
Ein Sicherheitsforscher von SYNC Security Labs.
Schwarz.
Identifiziert.
Dies angreift, um aus einer Container-Umgebung auszubrechen und auf das zugrunde liegende Haussystem zuzugreifen.
Möglicherweise...
Okay.
Entdeckt wurde die unter der Bezeichnung Leaky Vessels zusammengefassten Sicherheitslücken.
Äh, Vessels sind ja, sind so kleine, kleine...
Wie heißt das?
Was ist das?
Eine gute deutsche Übersetzung.
Kleine Schiffe sind das so.
Schiffchen?
Bötchen?
Boote?
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Wie...
Schiff.
Naja.
Wobei, das kann auch ein großes sein.
Irgendwas Sicherheitslückenwohlschäum...
Okay.
Eine der Schwachstellen bezieht sich auf das CLI-Tool.
Äh...
Ja.
Das, das, das...
So, was ist das mit dem Score von 10?
Source...
Okay.
Äh...
Ja.
Score...
Ich kann's ehrlich...
Ich kann mich nicht daran erinnern, wann ich das letzte Mal einen 10er-Score gesehen hab.
Wann war...
Wann hab ich das letzte Mal einen 10er-Score gesehen?
Mir fällt jetzt wirklich nix ein.
Ist schon eine ganze Weile her.
Also, 10er-Score ist wirklich selten.
Ich glaube, das ist auch das Höchste, was geht.
Normalerweise sind die, sind die kritisch und so...
Keine Ahnung, 9,3, 9,6, 8,8 oder irgendwie sowas.
Aber 10 ist wirklich selten.
Ja, oder 9, aber 10 ist wirklich selten, ne?
Okay, also...
Das ist...
Das ist für...
Bildkits.
Das ist ein Tool...
Okay, ja.
Bildkit verwende ich übrigens auch laufend.
Also...
Ich hoffe, ich wurde nicht gehackermanned.
Aber ich benutze eigentlich bisher ein...
So, zum Bilden von Containern.
Nur die Debian und Ubuntu Base Images.
Ich hoffe, die sind safe.
Ich hab da aber noch gar nicht gecheckt, um was das geht.
Also, ist cool.
Also, im Prinzip geht es hier um Docker-Files.
Um's mal allgemein umgangssprachlich zu bezeichnen.
Bildkit...
Bildkit...
Ist der neue Weg, wie man aus Docker-Files Container-Images baut seit den letzten 2-3 Jahren.
Vorher gab's ja in Docker eingebaut, das ganz normale Docker-Bild.
Und wenn du heutzutage Docker-Bild machst, ist das eigentlich in der Regel Bildkit.
Ich glaube, man kann noch irgendwie den Fallback auf das alte Docker-Bild machen.
Aber ich glaube, es ist mittlerweile sogar Default und The Way, wie man Images bauen sollte.
Uhu, Boss.
Auch wieder am Start.
Pogge.
Also.
Malicious-Bildkit-Frontend or Docker-File using run –mount could trick the feature that removes empty files created for the mount points into removing a file outside the container from...
Okay.
Ah, heißt jetzt im Endeffekt, ich klone mir einen GitHub-Repo oder ich mache ein Docker-Bild gegen irgendwie ein Image, was ich mir bauen möchte.
Und in dem Docker-File ist das...
Ist das manipuliert? Könnte ich quasi Dateien löschen auf meinem Host-System?
Log4Shell hatte auch eine 10er.
Ja, das wusste ich jetzt aus dem Kopf nicht mehr, dass das auch eine 10er hatte.
Aber Log4Shell...
Also, okay.
Weil Log4Shell hat ja auch extrem einge...
Wie war's bei Hardpleat damals?
Was hatte Hardpleat und Shell-Schock und der ganze Krempel?
Also, so 100%ig...
Die meisten Leute führen doch aber nur eigene Build-Files, also eigene Docker-Files aus, oder?
Also.
Sagen wir mal so, ich bilde zumindest zu 95% nur eigene Docker-Files.
Ist das wirklich so ein riesen Angriffsvektor dann?
Da bin ich immer super überfordert, was die Abkürzungen heißen, ja.
Okay, das müssen wir uns mal ein bisschen genauer angucken.
Okay.
Recheck mounts path with root after container run.
Okay.
A malicious build-kit frontend or Docker-File using run minus minus mount could trick the feature that removes empty file.
Ja.
Check ist auch nicht so genau.
Ja, also...
So ganz...
Nee, nee, nee, nee.
Run ist nicht zum Ausführen.
Run ist nicht zum...
Moment, Moment, Moment.
Da muss ich jetzt was zu sagen.
Nee, nee, nee, nee.
Was du meinst ist...
Nee, warte mal.
Command ist es in Kubernetes.
Wie heißt der Krempel?
Entry point.
Entry point meinst du.
Run ist zum Beispiel...
Guck mal hier, wir haben doch hier irgendwo ein Docker-File rumliegen.
Äh, what the fuck?
Okay, der VM-Champ, der braucht unbedingt einen Docker-File.
Warum hat der denn einen Docker-File?
Jeder hat einen Docker-File.
Run.
Guck.
Run ist, wo du zur Container-Image-Build-Time quasi in dem Kontext von diesem Build-Prozess Befehle ausführen kannst, Command-Line-Befehle.
Da kannst du dann...
Da kannst du zum Beispiel...
Also, man sieht es ja nicht...
Also, hier doch, hier oben sieht man es schön, was man mit run macht.
Mit run machst du zum Beispiel yum install für Packages, die dann Bestandteil von deinem Image sein sollen.
Was du meinst, ist Entry Point heißt es doch, glaube ich, oder?
CMD, genau.
CMD oder Entry Point, meinst du.
Das ist das, was im Endeffekt ausgeführt wird, wenn das Image dann gestartet wird.
Also heißt es im Endeffekt, wenn man ein manipuliertes Docker-File untergeschoben bekommt, können Dateien gelöscht werden.
Und wenn man ein Buildkit Frontend from an untrusted source...
Das verstehe ich nicht so genau, was sie damit meinen.
Was meinen die?
Wie wenn ich zum Beispiel sage, Docker-Build und dann gegen irgendein Remote-Ding gehe oder was auch immer.
Bin ich jetzt ein bisschen was...
Wie heißt das Ding?
Leaky Vessels.
Die werden wieder den gleichen Mist schreiben, den alle dazu schreiben.
Mit AI-generierten...
Aha.
Ah, guck mal.
Jetzt hat er Zugriff auf ETC Shadow.
Jetzt habe ich es jetzt...
Kann man das stoppen irgendwie?
Ne, kann man nicht.
Okay.
Okay.
Ja, guck, jetzt hat er keinen Zugriff drauf.
Danach macht er ein Docker-Build.
Ja, wir sehen jetzt das Docker-File an der Stelle nicht.
Und danach hast du aus dem Container raus...
Ach so!
Damit kann man dann quasi Container starten, die...
Das ist nichts, was zu Build-Time passiert.
Das ist, nachdem man das gebildet hat, kann man dann mit dem Container auf...
Sachen zugreifen.
Ach so.
Ah, ein interessantes...
Okay, zumindest...
10er-Score ist das Höchste, was geht.
Also auf jeden Fall Docker-Updaten.
Muss ich morgen auf der Arbeit auch machen, ne?
Muss ich mal aufschreiben.
Ja, auf jeden Fall sinnig.
Okay, alles klar.
Hat sich ein bisschen was getan die letzten Tage.
Das habe ich überhaupt nicht mitbekommen.
Ich war zu sehr im MMO-Kreisel-Crime anscheinend.
Dass ich das mitbekomme.
Interessant.
Okay.
So, Package-Updates müssten durch sein.
Ich glaube, es ist alles geupdatet.
Jawohl.
Toolbox, gucken, ob alles geupdatet ist.
Pac-Man nochmal gucken, ob alles geupgradet ist.
Sollte eigentlich.
Alles upgraded.
Alles upgraded.
Wann gibt es eigentlich bei JetBrains die ersten 2024.1?
Das schon.
Das schon.
Das schon.
Das schon.
Das schon.
Das schon.
Das schon.
Gibt es schon?
Ach ne, EAP ist open.
Wann ist der Release Date?
Okay, die haben erst vor 14 Tagen den ersten Test-Dings davon raus.
Ich habe vergessen, was EAP heißt, aber bei JetBrains sind es quasi die Beta-Version.
Early Exits?
Heißt das Early Access?
Early Access Product oder sowas?
Lass mal kurz gucken.
Was heißt?
jet brains erp early access program early access product early access program aha gut dann werden
wir mal rebooten ja ist auf jeden fall ein bisschen tiefgreifender als ich am anfang gedacht habe die
docker sicherheitslücke jetzt restart ich erst mal meine vm und dann zeige ich euch was wir uns
heute angucken wir müssen nämlich schon wieder unser frontend game absteppen um möglichst ein
möglichst englisch satz zu formulieren muss doch nicht was den titel schreiben sollte wir schauen
uns heute wie auch immer man das ausspricht schätzen oder so schätzen ui fürs welt an das
ist wohl der neue heiße scheiß seine frontend sachen zu designen wir wissen also erst mal
nudel mit lachs reinhauen ihr wisst ja im frontend bereich vergeht
eigentlich kein tag wo nicht neue frameworks kreiert werden oder neue sub frameworks oder
neue zusatz sachen für bestehende frameworks und das ist jetzt und das ist jetzt das welt der
neuesten scheiß ich kenne das du bist voll outdated overrated chebated das hat hier im
stream schon jemand vor 14 tagen gepostet mit dem windows 3 11 administrator noch bevor das in den
news die runden gemacht hat war das hier schon thema
wir haben uns das angeguckt vor 14 tagen im stream schon und mittlerweile haben es ja irgendwie alle
mitgekriegt also ich glaube mittlerweile sogar heise drüber gepostet ja und dann weißt du dann
ist die sache eigentlich meistens durch ich lese ja auch ganz gern heise zwischendurch weil man
auch nicht einfach man kann auch einfach nicht alles mitkriegen aber die sind meistens jetzt
nicht unbedingt bei den schnellsten dabei wenn es um irgendwelche sachen geht die gerade akut sind
oder gerade so rauskristallisieren heise manchmal bisschen lahm dafür ist es als übersicht
trotzdem finde ich mit golem zusammen wenn man sich da über die qualität der letzten jahre schon
in manchen artikel bis es streiten kann da muss ich ehrlich sagen mag ich gar nicht ich glaube
was ich an hilfe nicht machen ist dass da immer so so belehrungssprüche mit reinpacken muss keine
ahnung ich kann mir das nicht nicht geben ich kenne einige leute die lesen das super gerne und seit jahren schon ich weiß nicht wie viele die das schon jetzt schauen werden ich kann mir das nicht nicht geben kennt einige leute die lesen es super gern und seit jahren schon ich weiß nicht ob die sich gar nicht gut ísst damit was hier so tötet dass ihr euch dann mal hier
die lesen das super gerne und seit Jahren schon.
Ich kann mir viel für nicht geben.
So, jetzt haben wir geupgradet.
Aber so zur Übersicht
muss ich sagen, also die Seiten, die ich
mir angucke auf Deutsch, sind tatsächlich
regelmäßig mal so, immer mal drüber scrollen,
was bei Heiser und Golem steht. Und wenn man wirklich
auf dem aktuellen Stand sein will, gibt es eigentlich
so doof es klingt, nichts besseres
als Twitter, was nicht mal Twitter heißt,
und Reddit und Hacker News.
Und das nutzt du für eine Shell
oder kann man sich die so anpassen wie du hast? Ja, kannst du
machen. Also als Shell
ist das ZSH
oder Zisch
oder Zischel
wie auch immer die korrekte
Bezeichnung ist.
Ich sage meistens ZSH.
Und wenn du wissen willst,
wie ich die konfiguriert habe, dann kannst du auf
GitHub gucken. Guck mal da.
Da habe ich den ganzen Krempel. Unter anderem
habe ich meine Shell-Config hier
irgendwo. Ne.
Da.
Einmal hier meine Shell-Config.
Die ist aber glaube ich gar nicht so hundertprozentig
aktuell, aber das ist zum größten Teil ist die aktuell.
Und dann
zusätzlich für den Prompt das hier. Das ist nämlich
Starship.
Der Prompt. Die zwei Sachen kannst du hier
kopieren. Da sieht das so aus wie bei mir.
Wobei das ja eine sehr individuelle Sache
ist. Okay.
Massive Fivehead-Chatge
habe ich die eine Datei liegen.
Ich traue mich nicht die aufzumachen, weil
ich nicht weiß, was ich da reingeschrieben habe.
Chat, guck dir kurz
weg, wenn ich die aufmache.
Oder Augen
zumachen. Kurz weggucken. Ich will euch, ich habe
keinen Bock jetzt in OBS das auszuschalten.
Ihr müsst weggucken, okay?
Ach, ich
weiß wieder, was das war.
Das ist die Themenliste
für meinen Teambuilding-Workshop
gewesen, wo wir
überlegt haben, wie man die
Punkte so aufschreiben
kann, dass auch normale Menschen
verstehen, was ich sagen will.
Ich habe gesagt, ich will
euch nicht ausschalten, aber ich habe trotzdem ausgeschaltet.
Aber ich wollte gerade was anderes gucken.
Gerade da reingucken, weil ich wusste, was das ist.
Ja, okay.
Dann hätten wir das ja auch geklärt.
Also ich habe
eine Kombination aus, das muss
einfach erwähnt werden, ja, weil
ArchDinux-User müssen das immer der Welt mitteilen.
ArchDinux.
Tatsächlich hier in der VM, auch wenn das nicht
so direkt auffällt, ist das VM
im Fullscreen-Bildschirm. Deswegen kann ich auch so schnell
zwischen Windows und Linux umschalten.
Und hier hast du die ganzen anderen Campe.
ArchDinux.
Xterm, ZSH und Starship
als Prompt.
Bisschen Customized. Ich habe zum Beispiel
die Farben ein bisschen Customized.
Ich habe den Prompt zweizeilig gemacht,
anstatt einzeilig, weil ich einzeilige
Prompts nicht mag. Weiß ich,
wie sieht es bei euch aus? Einzeiliger Prompt
oder mehrzeiliger Prompt? Ich habe
früher auch darauf geschworen, dass mein
Prompt nur einzeilig sein soll, weil es nimmt
sonst zu viel Platz weg.
Aber nachdem es kaum Unterschied macht,
ob eine Zeile oder zwei Zeile,
mittlerweile finde ich zweizeiligen Prompten,
viel besser, weil dann könnte,
weil dann kann zum Beispiel hier oben das
lang werden
und man ist immer an der gleichen Stelle, wo man
schreibt. Ja, deswegen mag ich
zweizeilige Prompts.
Da habe ich aus Verständnissteuerung D gedrückt.
Also wie gesagt, ich war früher auch
ein totaler Fan von
einzeiligen
Prompts, aber mittlerweile wieder zweizeiligen.
Weil ganz ehrlich, du brauchst, du brauchst
die,
den Platz nicht. Wenn du was
ausführst, was Platz braucht, ja,
ein Programm mit viel Output, dann
machen es die Promptzeilen nicht aus, weil
dann gibt es halt eh das aus, ohne
immer zwei Promptzeilen dazwischen zu machen.
Ja, guck hier da,
das ist egal, dann
benutzt trotzdem das ganze Terminal. Erst wenn ich
abbreche oder was Neues mache, habe ich wieder zwei Promptzeilen.
Also im Prinzip verschenkst du halt genau eine
Zeile und dafür hast du die Übersicht.
Also ich finde,
finde das nicht schlecht.
Kommt die Größe, kommen auf die Größe des Bildschirms an?
Also ich habe einen ziemlich
kleinen Bildschirm, keine hohe Auflösung,
und
ich habe eine relativ große
Schriftart. Also ich glaube, viel
weniger Platz wie ich im Terminal werden die wenigsten
haben. Das ist
1080p von der Auflösung her nur
auf einem 25 Zoll
oder so Bildschirm, so irgendwie
in dem Dreh. Und dann
habe ich eine relativ große Schriftgröße. Also mein Terminal
ist schon ziemlich fett. Und sogar da
kannst du zwei Zeilen, kannst du zwei Zeilen
das Ganze benutzen. So, mein eigenes
Video ist wieder am Start, nice.
So muss das sein.
Wo bin ich denn stehen geblieben, Leute?
Ah ja, genau.
Das ist, was wir eigentlich machen wollten.
Und zwar, es vergeht ja kein Tag,
wo nicht irgendwelche
JavaScript-Libraries erscheinen oder sonst was.
Und
ich bin ja kleiner Svelte-Fanboy
beziehungsweise
eigentlich Svelte-Kit.
Chillfreak, ja lass einfach im Hintergrund laufen.
Mehr Views, gack, weh.
Ja, ich bin ja
Svelte- und Svelte-Kit-Fanboy geworden,
muss ich sagen.
Ich bin kein hauptberuflicher Frontend-Entwickler,
deswegen geht vieles
von der ganzen, von dem ganzen
JavaScript-Ökosystem schon ein bisschen
an mir vorbei. Ich habe bis heute
beispielsweise nicht den Unterschied zwischen
React und Solid.js gecheckt.
Wobei doch, doch, ich glaube,
ich glaube, ihr könnt ja mal sagen, ob das stimmt.
Ich glaube, der Unterschied zwischen React und Solid
ist, also das erste Mal, dass das eine das offizielle
von Facebook ist, und das andere quasi
eher ein
ein Klon davon.
Der große Unterschied zwischen,
React und Solid.js ist, glaube ich,
dass Solid.js kein JSX verwendet
im Vergleich zu React.
Der Rest ist, glaube ich,
ziemlich gleich.
Aber wie gesagt, ich habe keine Ahnung.
Ich habe das, ich habe beides noch nicht großartig verwendet.
Also meine Frontend-Sachen habe ich
lange Zeit in Vue.js gemacht
und jetzt schon ein bisschen länger in Svelte.
Wenn ich mal was machen muss.
Und, also
Svelte in Kombination mit Svelte-Kit
und mir gefällt das wirklich gut.
Eine Sache, die ich ein bisschen
vermisst habe, ist
ja, wie soll man sagen,
was halbwegs konsistent ist
für UI, ohne, also für
Web-UIs, ohne, dass man
ein super krasser CSS-Checker sein muss.
Es ist
mittlerweile bei mir nicht mal ganz so schlimm
mit
CSS. Also ich kriege jetzt, ich kriege
in CSS die meisten Sachen mittlerweile halbwegs
hin. Ich habe mittlerweile auch den ganzen
Kram halbwegs gecheckt,
was Flex
und, wie heißt das andere?
Flex versus
Crit und so Dinger.
Ja, also das kann ich mittlerweile ganz gut
verwenden, aber ich bin weit davon entfernt,
der CSS-Zauberer
zu sein.
Ich schreibe in zwei Tagen eine Klausur und lasse mich hier lieber
ablenken.
Dazu kann ich dir kurz was sagen.
Weißt du, was
selbsterfüllende
Prophezeiungen sind?
Oder ich nenne das einfach, nein, nicht direkt mit Bann.
Äh, nicht, wir machen keinen. Also ich
banne niemanden und wir machen das heute auch nicht mit Bann.
Weißt du, was damit gemeint ist?
Mal ein Beispiel.
Ich habe früher
es gehasst, in der Schule
Präsentationen zu halten.
Dementsprechend habe ich mich nie darauf vorbereitet,
wenn ich irgendwas zeigen musste
und dementsprechend beschissen
wurden die ganzen Präsentationen auch.
Und dadurch, dass
ich wusste, dass es beschissen wird,
habe ich mich noch weniger darauf
vorbereitet
und die Präsentationen wurden weiterhin
beschissen. Also ich habe quasi,
selbst dazu beigetragen, weil ich
schon, ja, vorausgeahnt
habe, dass es beschissen wird,
habe ich selbst dafür gesorgt, dass es beschissen
wird. Versteht man, was ich meine?
Deswegen, ein bisschen
Vorbereitung ist immer
deutlich besser als gar keine Vorbereitung.
Deswegen wäre es sinnvoll,
auch wenn man überhaupt keinen Bock hat,
sich die Sachen im Vorfeld ein bisschen anzugucken.
Und mittlerweile
mache ich Präsentationen eigentlich
ganz gern.
Ich mag das.
Also,
ich weiß auch nicht, was mit mir los ist.
Normalerweise habe ich keinen Bock,
irgendwie groß mit anderen Leuten zu interagieren.
Aber beim Präsentationen halten ist das ein bisschen anders.
Da steht man ja, man interagiert
ja nicht so im Austausch
mit denen, sondern man zeigt was.
Und das mache ich
tatsächlich ganz gerne. Wahrscheinlich, weil ich es irgendwie,
wahrscheinlich, weil es mir mittlerweile
irgendwie gefällt, so die Aufmerksamkeit von
20 Leuten zu haben.
Ich weiß auch nicht, zumindest seitdem ich mich
damit abgefunden habe, dass ich es scheiße
finde,
hat es, also, dass ich wusste,
dass ich es scheiße finde, aber es trotzdem ganz sinnvoll
ist, sich anzugucken, hat es sich nach und nach
verbessert. Und mittlerweile mache ich es ganz gern.
Und man glaubt gar nicht,
man glaubt gar nicht,
wie viel es bringt,
wenn man, obwohl man keinen Bock
hat, sich einfach ein bisschen
vorbereitet. Ja, dass man
auf ein Thema, wo man keinen Bock hat,
jetzt keine Lust hat, zwei Tage,
acht Stunden sich da reinzuhängen, das verstehe
ich. Das ist auch meistens,
das habe ich auch nie geschafft.
Aber es ist ein enormer Unterschied,
bevor man was machen muss, ob man sich
30 Minuten damit beschäftigt hat oder
gar nicht. 30 Minuten
kann man zumindest oftmals,
wenn man sich mit dem Thema 30 Minuten
beschäftigt hat, kann man zumindest vordergründig
so tun und Leute davon überzeugen,
als wüsste man, wovon man spricht. Wenn man sich
null Minuten damit beschäftigt hat, geht das nicht.
Natürlich ist es ein riesen Unterschied,
ob man sich
tatsächlich zwei Tage mit was
im Detail beschäftigt hat als 30 Minuten,
aber oftmals,
geht es gar nicht so sehr darum,
zu zeigen, dass man wirklich super krass
tiefe Ahnung hat, weil die anderen Leute wissen das auch
nicht. 30 Minuten mit was beschäftigt
reicht in der Regel erstmal,
zumindest um sich ein bisschen
reinzufinden.
Sonst erfüllst
du dir, du denkst, es ist scheiße,
es ist kacke, das wird nichts und
dadurch, dass du dich quasi im Vorfeld
schon das antizipierst, dass das so wird,
dann wird es auch so.
Ja, okay, P-Thread, das ist ja wirklich,
was macht ihr denn? Irgendwelches
Low-Level-C-Gedöns?
Warum programmiert man
im Jahr 2024 noch auf
Blatt Papier? Und by the way,
niemand weiß aus dem Kopf
die ganzen Overloads
und die ganzen Parameter für alle
möglichen Funktionen. Ich muss da auch
jedes Mal nachgucken.
Und auf dem Papier programmieren, das ist ja wirklich,
das ist ja wie bei mir in der Berufsschule noch.
Bei mir in der Berufsschule, da mussten wir auch
teilweise C auf
einem Blatt Papier machen, so richtig dumm,
Alter. Richtig
hängen geblieben, so richtig realitätsfern.
Warum lässt man das auf dem Papier machen? Wo sind wir denn?
Wo sind wir, Leute?
Ich hoffe, ihr seid auch unter
Linux unterwegs und nicht aus
historischen Gründen unter
fragt mich nicht
HPOX oder
irgendwelchem
Ural-Unix-Kram.
Wie ist deine Meinung zu
Embedded Software-Entwicklung?
Das ist
ungefähr so
eine vage Frage,
wie, Max, was denkst du über
Papier-Herstellung?
Das denke ich über Embedded Software-Entwicklung.
Ich denke, dass das sehr
spannend sein kann,
aber man
ja, die passende
Person dafür sein muss,
die das mag.
Weil Embedded Software-Entwicklung ist in der Regel
ultra-low-level.
Das ist meistens noch deutlich anstrengender
als das, was wir mal hier schon im Stream
öfters auf dem ESP32 gemacht haben.
Hier auf dem ESP32 ist es zwar auch schon low-level,
aber noch ein bisschen, sagen wir mal,
noch ein bisschen abstrakt, ja.
Wir können das meiste, können wir die Arduino-Sachen
verwenden und die ESP32-Standard-Library ist auch
ziemlich gut, was sie da mitbringen.
Aber so richtig Embedded-Steuerung-Sachen
ist noch mal eine Nummer härter.
Okay, weiter geht's.
Also, wir kommen jetzt mal zu der eigentlichen Geschichte.
Ich labere jetzt schon wieder 40 Minuten rum.
Also, ich benutze ja schon eine Weile, wenn ich mal Frontend-Sachen mache.
Wo Svelte und SvelteKit, also eigentlich hauptsächlich SvelteKit.
Also du kannst SvelteKit nicht ohne Svelte benutzen,
aber du kannst Svelte ohne SvelteKit benutzen, so rum.
SvelteKit ist ein, wie heißt das offiziell, ein Full-Stack-Framework.
Letztendlich kannst du damit Backend und Frontend in einem machen.
Ich persönlich verwende das aber nur für den Frontend-Part.
Ich mache meine Backends mit ASP.NET Core und meistens zumindest, es sei denn,
es ist irgendeine Sache, die auf dem Microcontroller läuft oder zur Abwechslung irgendwas in Go
oder so.
Aber das meiste mache ich tatsächlich in ASP.NET Core und meine ganzen Frontend-Sachen, klingt
jetzt viel mehr als es ist, ja, kommt nicht so oft vor, mache ich in SvelteKit.
Und eine Sache, die ich persönlich ein bisschen nervig an SvelteKit bzw. Svelte bisher fand,
ist, dass die ganzen UI-Libraries, die es gibt und gab, die haben mich alle nur so semi-überzeugt.
Das letzte, was wir ausprobiert haben, war SvelteKit.
Das war das letzte, was wir ausprobiert haben.
Das fand ich ganz okay, aber hundertprozentig überzeugt hat es mich auch nicht.
Mittlerweile haben die zumindest ein paar Themes, die ganz brauchbar aussehen, aber
das hat mich so ein bisschen an Material Design ohne richtig Material Design zu sein erinnert,
das Ganze, also war nicht so richtig mein Fall, wobei es schon ganz nice war, aber
war nicht so das.
Zumindest jetzt der neue heiße Scheiß für Svelte muss Schätzen-UI, der Svelte-Port von
Schätzen-UI sein.
Wie spricht man das überhaupt aus?
Schätzen-UI.
Schätzen-UI.
Ursprünglich wurde das Ganze entwickelt für React oder bzw. ist hauptsächlich immer
noch für React, aber es gibt mittlerweile schon Ports für die meisten anderen Frontend-Frameworks.
Und ich glaube, das war es für heute.
Bis zum nächsten Mal.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Tschüss.
Es ist, glaube ich, komplett eigenständig und basiert auch rein auf Svelte-Geschichten, ohne irgendwie da auf was zurückzugreifen.
Also es ist gar kein Port im eigentlichen Sinne.
Es ist eher Inspired by.
So, und soweit ich das verstanden habe, der Vorteil davon, zu beispielsweise sowas wie Skeleton UI, ist folgender.
Mal gucken, ob das stimmt, was ich jetzt erzähle.
Das ist das, wie ich das im Vorfeld so verstanden habe.
Und wir werden es ja gleich ausprobieren.
Also, es gibt beispielsweise UI-Frameworks für Web-Anwendungen, sowas wie, sagen wir mal, zum Beispiel Skeleton UI.
Das besteht aus fertigen Svelte-Components.
Nicht ausschließlich, aber da hast du dann zum Beispiel sowas wie, keine Ahnung, Tabs oder so.
Hier, sowas kannst du dann auf deiner Webseite bauen.
Und das sieht dann Source-mäßig so aus.
Du inkludest quasi so eine Component-Tab-Group, Component-Tab.
Und dann kannst du das hier sozusagen...
Zusammenbauen.
So.
Eines der Sachen, die mir schon aufgefallen ist, bei solch so Component-basierten UI-Frameworks ist,
erstens, fehlt immer irgendwas.
Zweitens, verhält sich immer irgendwas nicht so, wie du es gerne hättest.
Und du kannst relativ schlecht was dran machen.
Und dementsprechend baut man eigentlich drittens fast immer nochmal einen eigenen Wrapper um den Wrapper drumherum.
Also im Prinzip, das hier ist ein Svelte-Component.
Im Endeffekt aus Svelte-Code besteht, also HTML und JavaScript.
Und weil sich das dann oftmals nicht so verhält, wie man will,
beziehungsweise man gerne hier unter den Tabs immer den gleichen Abstand hätte,
oder dass man beispielsweise noch Icons daneben haben möchte, was die offizielle Component nicht unterstützt,
oder was auch immer,
rappt man das dann nochmal in eine eigene Tab-Groups-Component.
So.
Und das ist mir bei vielen UI-Sachen...
Bei Vue damals auch schon aufgefallen, dass man dazu neigt, das so zu machen.
Und deswegen fand ich das in dem Video, was ich hier über Schätzen-UI gesehen habe, eigentlich ziemlich nice.
Und zwar, die haben gesagt, ey, warum überhaupt Component-basierte Sachen, die du inkludest,
warum nicht einfach in das Projekt den Source-Code inkluden, den du sonst rappen würdest und selbst daran dann weiter editieren.
Also soweit ich das verstehe.
Ist das keine fertige Komponenten-Collection, die man inkludet bei sich, sondern man inkludet quasi den Source-Code dieser Komponenten.
Man inkludet hier nicht beispielsweise Tab-Group, sondern man würde halt einfach den Svelte-Source-Code inkluden, aus der sich Tab-Group zusammensetzt.
Und dann kann man daran weiter editieren, so als hätte man das selbst erstellt und muss es nicht nochmal extra rappen um den Rapper.
Soweit, so gut.
Natürlich.
Hat es auch Nachteile, soweit ich das verstanden habe.
Hat es auch Nachteile, weil zum Beispiel, wenn sich was updatet in den Komponenten,
dann kriegst du die Updates nicht einfach mit, wenn du die Dependency auf die UI-Library updatest.
Weil du benutzt ja keine fertige UI-Library, du benutzt ja quasi nur ein, wenn du es so willst, ein Code-Generator für UI-Elemente.
Der Karlsson, danke schön für den Sub.
So weit habe ich das verstanden im Vorfeld.
Und, dass das so ist, wie ich euch versucht habe gerade zu erklären, ob das jetzt wirklich so ist, lasst mal, da müssen wir mal gucken.
Lass mal kurz schauen, ob ich, ah, ich habe gestern ein paar Subs übersehen.
Sad girl.
Wie gesagt, nachdem du das ja selbst alles nochmal 30 mal rappst, ist das vielleicht gar nicht so schlimm.
Vielleicht ist das echt der bessere Ansatz.
Mal gucken, ob das stimmt.
Also, wir gucken uns natürlich Skeleton-UI an, wir gucken uns das hier an.
Die haben standardmäßig ein Dark-Mode, ein Light-Mode.
Das finde ich schon mal sehr nice.
Und die Komponenten kommen relativ...
...dezent gestylt daher.
Was ich persönlich auch gut finde.
Es gibt UI-Frameworks, die sind so...
...vollgeladen mit...
...ja, jedes Element sollte an der Stelle dann einen blauen Schatten haben und dann sollte es da einen orangenen Schatten haben.
Und wenn du das dann nicht willst, kriegst du es gar nicht mehr richtig raus.
Und...
...es ist dann oftmals nicht konsistent, weil du dir vorstellst, ja, grün heißt bestätigen und die sagen, nee, bestätigen ist blau und so.
Deswegen finde ich eigentlich ganz gut, dass die Sachen hier nicht so...
...die Sachen hier nur relativ dezent gestylt daherkommen.
Man kann ein bisschen vorkonfigurieren, bevor man sich das runterlädt, kann man sagen, man möchte Primary...
...man kann im Prinzip die Primary-Color auswählen.
Aber ich werde bei schwarz und weiß bleiben.
Was ich immer ganz gute Base empfinde und nur Color benutzen an der Stelle, wo es halt Sinn macht.
Zum Beispiel bei irgendeinem Delete-Knopf oder Bestätigen-Knopf.
Und standardmäßig gibt es das Ganze wohl in Dark und Light.
Was das für ein Knopf ist, weiß ich nicht.
Ah, man kommt beim Ersteller auf...
...muss ich mich auch noch dran gewöhnen, dass es jetzt X ist und nicht Twitter.
So, und hier gibt es eine Übersicht, was die alles für Komponenten schon fertig gebaut haben, die man inkluden kann bei sich ins Projekt.
Da ist mehr oder weniger alles dabei, was man braucht.
Die ein oder anderen Sachen fehlen wahrscheinlich, aber für die meisten Webseiten ist es, denke ich, ganz okay.
Was ich vielleicht noch sagen oder vielleicht noch zur Entstehungsgeschichte...
...erklären kann von diesem Projekt ist.
Wie gesagt, ich habe ein Video geguckt von dem Autor und deswegen hat mich das inspiriert, das mal auszuprobieren.
Ursprünglich sind die gestartet als Svelte-Klon vom offiziellen Schätzen-UI.
Wo die Seite übrigens zum Verwechseln ähnlich aussieht.
Aber das hier ist jetzt React und das hier ist Svelte.
Also, man sieht, dass man nicht so viel Unterschied sieht.
Außer, dass das offizielle, glaube ich, noch ein bisschen mehr Komponenten hat als das hier, okay?
So, zumindest muss es so sein, wie ich das aus den Videos verstanden habe.
Das hier ist ursprünglich quasi als Klon entstanden von diesem hier.
Also, der hat quasi das offizielle React, die Chat-CN-Library genommen von React und hat die quasi versucht zu klonen, zu portieren.
Nach Svelte und damit halt auch die Elemente zu übernehmen.
Ich glaube, sogar mittlerweile haben sie ein paar abweichende Elemente drin.
Daraufhin ist ihm aufgefallen, dass das gar keine so schlaue Idee ist, React-Sachen zu portieren nach Svelte.
Und daraufhin haben sie angefangen, das unter der Haube auszutauschen und daraus sind entstanden einmal Melt-UI.
Das sind quasi die Low-Level-Komponenten, aus der sich Chat-CN zusammensetzt.
Und dann noch Bits-UI, was die Svelte-Komponenten sind.
Also, Melt sind irgendwie die Logik-Funktionen von einem Switch beispielsweise.
Bits-UI ist dann die Implementierung von einem Switch und Chat-CN-UI ist dann irgendwie die Svelte-Komponenten.
Frag mich nicht, keine Ahnung, scheiß drauf.
Ich habe es nicht so genau gecheckt, was eigentlich der Unterschied dazwischen ist.
Zumindest, in der Regel verwenden sollte man das.
Weil das der Bundle aus dem ganzen Kram ist.
Ob man jetzt weiß, worauf basiert, ist, denke ich, ziemlich wurscht.
Ich würde interessieren, ob du Chat-GPT bei der Arbeit benutzt.
Ja.
Die haben sich bei uns auf der Arbeit sogar einen eigenen Chat-GPT-Klon von Microsoft gekauft.
Das nennt sich dann Azure AI Services oder sowas.
Und da sagt Microsoft, die Sachen, die dort eingegeben werden, die bleiben vertraulich.
Ich glaube denen ja kein Wort, aber ey, wenn das in irgendeinem Business-Vertrag drin steht, dann ist das so.
Ich glaube, ich weiß jetzt wieder, was der Unterschied ist zwischen den Projekten.
Also das hier sind die, genau, das ist die Low-Level-Library, aus der sich die UI-Komponenten zusammensetzen.
Bits sind Svelte-Komponenten, ungestylt.
Und Chat-CN-Svelte sind dann quasi ordentliche Komponenten mit Dark- und Light-Themes und CSS-Kram schon dabei.
Das heißt, in der Regel, wenn wir das verwenden, was man aber auch sehen wird, das hat mich nämlich auch erstmal verwirrt,
dass es beispielsweise hier schon Komponenten gibt, die es noch hier nicht reingeschafft haben.
Zum Beispiel haben die hier irgendwie einen Pin-Input, habe ich gesehen.
Den gibt es beispielsweise hier noch nicht.
Was auch immer. Wir verwenden jetzt das und gucken uns mal an, wie das funktioniert.
Das heißt als erstes, ich habe schon wieder alles vergessen.
Ja.
Ich weiß schon gar nicht mehr, wie man überhaupt ein Svelte-Projekt erstellt.
Gehen wir mal hier rein.
Repos.
MKDia.
PekW.
Champ.
Lul.
Vollkommen egal, wie das Ding heißt.
Ich muss die Projekte natürlich auch immer so nennen, dass ich sie mit Sicherheit wiederfinde danach.
So, NPX.
Ne.
Ja, so ungefähr.
So ungefähr.
Also.
Ich glaube, also Melt.
Ist, glaube ich, die Low-Level.
Library mit den Funktionen Bits ist was aus der Low-Level-Library quasi UI-Elemente baut und Shad-CN ist dann die gestylten
UI-Elemente von Bits so rum.
Das ist halt ganz normaler Frontend-Wahnsinn.
Da muss man sich nicht wundern, dass das Wetter so gemacht.
Ich habe vergessen, wie man das Weltkit-Projekt anlegt.
Das war NP, wenn man das jetzt so richtet.
Ja.
Ich habe einfach mal die Tastatur facerollt gerade, so wie es aussieht, oder?
Ich kann das schreiben, ey.
Ihr creating a project.
Das da.
NPM create.
NPM create.
Ah ja.
Okay.
NPM create the world's latest KGW-Champ.
Bester Name.
Neues Projekt.
Need to install the following packages.
Create Svelte.
Yes.
Es ist Frontend-Zeug.
Wir müssen jetzt eh das halbe Internet runterladen, damit das funktioniert.
Skeleton Project?
What?
Nein.
Svelte-Kit-Demo-App.
Ja, das ist okay.
Add type.
Checking.
No.
Brauchen wir alles nicht.
Raw.
JavaScript.
Select additional options.
ESLint, PrettyAppPlayer, Tests, Alter, ha, lul, ich glaube, es geht los, als würden wir hier irgendwas testen, NPM install, Internet-Download läuft, das brauchen wir nicht, das brauchen wir gleich, was macht das da eigentlich gerade im Hintergrund, Timing, ah, okay, es lädt das Internet runter, alles klar, Moment, vier Packages nur, was ist denn da los?
Ne, ha, ich habe schon gedacht.
Ich wollte schon gerade sagen, ein neues JavaScript-Projekt, was nur vier Dependencies hat, das glaube ich aber erst, wenn ich es sehe.
Also.
Ja, so ist es 53 und das ist noch wenig, Leute.
Wir haben nur 53 Dependencies.
Also, komm, jetzt mal.
Da geht schon noch mehr.
Ich wette auch, die erste Sache, die ich installiere, da habe ich dann 450 Abhängigkeiten oder so.
Okay, dann machen wir mal hier.
Starten wir mal Visual Studio Code, schieben das da auf den zweiten Monitor, yes, yes, wir trusten dem Autor, aber richtig hardcore trusten wir den.
Und dann openen wir das Ganze mal in Chrome.
Welcome to your new SvelteKit-App.
Excellent.
Das meiste werde ich eh wieder rausschmeißen hier, aber das sieht halt die SvelteKit-Demo-App schon seit einer ganzen Weile aus.
About.
About.
Svelte.
Was ist Svelte?
Ah, ein Wörtel-Ding in Svelte.
Furchtbar toll.
Genau, das habe ich jetzt gebraucht.
Okay, SvelteKit-Demo-App.
So, und da probieren wir jetzt mal.
Wir gucken uns mal kurz die Dependencies an.
Sieht man das Package, Jason?
Warum ist da?
Chat, ich habe immer noch nicht den Unterschied verstanden zwischen Deaf-Dependencies und Dependencies.
Also, ich weiß prinzipiell.
Dass das eine dann für die Anwendung ist, das andere für während der Entwicklung.
Aber warum habe ich beispielsweise einen Font als Deaf-Dependency?
Ist das hier der Font?
Aber wenn das der Font ist, warum ist es dann eine Deaf-Dependency und keine richtige Dependency?
Ich werde es nie verstehen, oder?
Kriminell, danke schön für den Sub.
Ich werde JavaScript-Sachen, Frontend-Geschichten wahrscheinlich nie checken.
Da bin ich eindeutig zu noob dafür.
Aus irgendwelchen Gründen meint Visual Studio Code, dass es das ausführen kann.
So, also.
Wir machen das Ganze erstmal leer.
Node-Modules interessieren uns nicht.
Wir machen das Ding erstmal leer.
Roots.
Alles weg hier.
Lib.
Ja, wunderbar.
App-HTML ist okay, das kann so bleiben.
PageJS ist das eigentliche, was uns interessiert.
Was?
Pre-Render gleich true.
Ach, das ist...
Ah ja, okay.
Das ist das, wenn man das am Endeffekt dann bildet und auf Web-Server schiebt.
Dann machen wir das nochmal alles weg.
Und machen da nur unseren Kram hin.
Div.
KW.
Excellent.
So, wir haben immer noch einen Header.
About.
Schmeißen wir weg.
Delete.
Delete.
Delete.
Counter.
Delete.
Header.
Delete.
Oh, jetzt habe ich es kaputt gemacht.
Layout brauchen wir.
Layout.
Layout wollen wir ja auch nichts layouten.
Style brauchen wir nicht.
Brauchen wir nicht.
Das können wir so lassen.
Header kommt weg.
Style CSS weg.
So, perfekt.
Raw Webseite.
Da können wir erstmal anfangen, das auszuprobieren.
Page.
So.
Was wir jetzt vielleicht noch machen, dass es ein bisschen mehr in der Mitte ist.
Ich habe schon eine Weile Frontend-mäßig nichts mehr gemacht, deswegen werde ich es
jetzt voll verkacken.
Wie ging das jetzt nochmal, dass man links und rechts einen ordentlichen Abstand hat?
Margin Y2?
Nee.
Ach, Moment.
Ich habe ja noch gar keinen Tailwind dabei.
Kann das sein?
Ja.
Ja, deswegen kann ich.
Ach so.
Alles klar.
Nee, Y ist hoch.
Genau.
Nee, MX2 müsste es sein.
Aber ich habe ja noch gar keinen Tailwind dabei.
Deswegen funktioniert das auch nicht.
Ja, das könnt ihr erklären.
Dann gucken wir uns doch mal an, bevor wir jetzt hier ein neues Projekt erstellen.
Wie sagen die denn Getting Started?
Wie, wie, wie funktioniert das hier?
Installation.
Svelte Kit.
Wie?
Manual.
Nee, das brauchen wir nicht.
Das haben wir gemacht.
Add Tailwind.
Das haben wir gemacht.
Add Tailwind.
Das haben wir gemacht.
Das haben wir gemacht.
Das haben wir gemacht.
Das haben wir gemacht.
Das haben wir gemacht.
Das haben wir gemacht.
Das haben wir gemacht.
Das haben wir gemacht.
Add Tailwind CSS.
Genau.
Das brauchen wir.
Also ich muss nochmal stoppen das Ganze.
Add Tailwind CSS.
Proceed.
Yes.
Wir proceeden.
Install Dependencies.
Die haben wir aber auch gleich nochmal.
Jawohl.
Setup.
What?
Nee.
Das machen wir.
Wir benutzen Dollar.
Wir benutzen Dollar Lib.
Run the CLI.
What?
NPx schätzen.
Run the CLI.
Run the CLI.
Run the CLI.
Run the CLI.
Run the CLI.
Run the CLI.
Run the CLI.
What?
Run the CLI.
Run the CLI.
Run the CLI.
Okay.
Das hat kein predicted organizations.
Aber does it work?
Okay.
Ja.
Okay!
Anatge?
Ganz genau.
post css ist das glaube ich oder meine güte jetzt wird so like to use type script know
which style would you like to use default oder new york was der unterschied an fritz
ja ich will frankfurt benutzen offenbach will ich haben ok default ist ein bisschen
wetter und new york ist ein bisschen kundenster so wir wollen die fault haben die fault which
color would you like to use as a base color ich weiß nicht mal was late für eine color ist so
was graues oder so herr grau ok grau grau neutral oder grau what the fuck was war
ich
jetzt vielleicht ein beispiel für den teams sieht man das ja eben nicht in teams kannst
du auswählen was du für primary colors verwenden möchtest aber nicht was die kasse mal zink wollen
wir haben wir wollen zink haben zink weiß jo global css file source ab pcss jawohl keine
ahnung
es oder
ok gut kon Lopez
jason
die es konflikt ich will keinen pipelines ich habe ich noch
Eller
hat
es jetzt schon wiederessens
funktioniert das ist einfach nur ein dummer dummes output ich glaube es hat trotzdem funktioniert in
der ts config muss stehen ts gleich falls hat your tailwind config has been renamed to tailwind
config.js nö wurde es überhaupt nicht es hat überhaupt nichts getan gerade okay leute wir
machen das noch mal wir machen das noch mal m-w ok weg wir löschen das wir löschen das noch mal
so machen dass wir mal wirklich nach der offiziellen anleitung also great app ein
weg weh champ so justus welt geht's hier an die kräfte new project kann man nicht so was sagen
wie mt app oder so näher anscheinend nicht okay
so kann man nicht so was sagen wie mt app oder so näher anscheinend nicht okay so
welche demo app wo wir wollen kein typescripts wir wollen auch kein brief für das welt fünf
ne chat ist ich habe mich zu bewegen lassen ich habe gedacht dass wäre noch in überbleibsel von
skeleton ui gewesen ist die benahmung er bei der das ist das ist ein leeres projekt ach so
ja okay jetzt macht es jetzt macht es den skeleton projekt bei kein typescript kann
ist welt fünf preview okay wunderbar haben wir gemacht at tailwind cd kekwe champ aber
erst mal mpm install das darf man ja nie vergessen scallan ui baut aufs welt auf
ok mpm install so jetzt tailwind css hinzufügen jawohl noch mal installen haben wir gemacht setup
alias ja ja dass das müssen wir nicht machen glaube ich weil ich will ja dass die fall verwenden
yes no default zink woher ist hier global css fall ich habe ehrlich gesagt keine ahnung wann
global css fall ist ein global css file ist unter source pp
ab pcs es ist doch richtig woher ist your tailwind config tailwind config punkt cjs
ja ja ja alter was will das das ist ja 3 hat tool was will das von mir nots config file
von ja und ich will ja auch kein typescript benutzen
außerdem stimmt das nicht hier wurde überhaupt nichts renamed und und irgendwas hinzugefügt hat
es auch nicht dass ich mal den lip hinzugefügt okay was was okay okay da müssen wir bei denen
auf github gucken das geht ja schon gut los ist selber schon am start fix support was muss ich
jetzt machen
okay das heißt im endeffekt ich darf das ganze noch mal machen und muss nicht typescript
anschalten sondern ich muss das andere anschalten oder wie es ist super super intuitiv durchschnittliche
frontend framework experience ja ist echt so skeleton project okay okay
yes yes using javascript with js doc commons yes okay gut jawohl npm erstmal soll ich
soll ich tailwind enden ja und jetzt und jetzt sage ich npm install hätten die das nicht vorher
checken können ja doch ne wie wärs mit einem fehler so nach dem motto ts config not found
oder sowas dann wüsste man wenigstens bescheid so und jetzt führen wir das aus
yes
us north die fallton k da da da da jahr estoy русischer russischer stream
jahá jetzt geht's auch sehr schön alles klar ob wie es liekt zu erkennen an der fehlermeldung
dass man das machen muss voll vollkommen logisch ist okay soll was ist jetzt da für die bal על
ogl adaaa der ver staying research ist vollkommen logisch auf jedenfall kann man selbst sehr wenig
jetzt will ich mein code aufgetsinten esantiether. презieren und heißt das war mein mission
logisch. Okay.
So, was ist jetzt passiert?
Meine Tailwind-Config heißt
jetzt so
und steht mehr Zeug drin.
Und ansonsten
habe ich aus
irgendwelchen Gründen
Type-Definitions hier drinnen für
TypeScript.
Warum auch immer,
obwohl ich gesagt habe, ich will kein TypeScript
verwenden, okay. Wichtigste Sache
jetzt, Leute. Ratet mal,
wie viele Packages
jetzt in meinem
Node.js Package,
in meinem Node-Modules
drin sind. Eben waren es noch 40 oder so.
Mal gucken, wie viel es jetzt sind.
180!
Front-End.
Front-End, alles klar.
Logisch
brauchen wir das alles hier.
Ich habe noch keine
Komponenten installiert, richtig.
Also ich habe eigentlich noch
gar nichts laufen, wenn man es mal so will, ne.
So, Open. Wir machen
mal hier den Browser jetzt auf.
Okay, ja.
Hier haben wir unsere Barebones-App.
So, wenn ich jetzt hier was reinschreibe,
keck weh, dann funzt
das auch. So, und wir haben Tailwind.
Wir haben Tailwind. Das heißt, wir können jetzt in
unser Layout gehen
und wir können das einfach auch
bei...
Wir können in unser Layout gehen.
Wir können sagen...
Auf hier das Slot.
So, gell?
Ne.
So.
Und dann kann man hier sagen, Class
MX2.
Ah, es funzt. Okay, oder was haben wir?
Margin 2. Ah, nice.
Warum habe ich übrigens keine
Autocomplete für Tailwind? Was ist hier los?
Es ist
Essential.
Das brauche ich.
Ist es even?
Ist odd? Auch dabei.
Ne, ich glaube, ganz so schlimm ist das noch nicht.
Ist Excel.
Ne, ist nicht dabei.
VS Code neu starten?
Ich bin mir gar nicht sicher, ob ich das
Tailwind-Plugin
überhaupt habe.
Tailwind IntelliSense. Doch, habe ich.
Habe ich das Svelte-Plugin?
Wenn ich das richtig
schreiben könnte.
Habe ich, ja.
Was auch immer.
Ich vermute mal,
ich vermute,
ich vermute mal, mein Visual Studio Code hat es noch nicht
gecheckt. Class gleich.
Ich glaube,
ich vermute mal, mein Visual Studio Code hat es noch nicht
gecheckt.
Also damit hatte ich bis jetzt keine Probleme. Das war eigentlich
eines der Sachen, die immer funktioniert haben.
Ah, jetzt funktioniert
es. MX2.
Sehr schön.
Ah, jetzt können wir so
sehen, wie sie M
10.
Okay, wunderbar. Das funzt.
Dann werden wir mal eine
Component installieren davon.
Das brauchen wir nicht, das brauchen wir nicht. Okay, that's it.
You can now start adding components
for your project.
Add button. So, und wenn ich das jetzt richtig
verstanden habe,
fügt mir das jetzt keine Button-Komponente
hinzu, wie man das so kennt aus klassischen
Frameworks, sondern
fügt mir quasi den Source-Code hinzu
von dieser Button-Component.
Sodass ich daran selbst editieren kann,
ohne es nochmal extra rappen zu müssen.
Probieren wir das nochmal aus.
Add button.
Wichtigste Komponente überhaupt.
Ich glaube, jedes
UI-Framework-Zeug
startet mit einer Button-Component.
Component install add
Source-Lib-Components-UI-Button.
Lib-Components-UI-Button.
Tatsächlich.
Ja, und es ist wie gedacht.
Es ist wie gedacht.
Okay, man bekommt
die
den Button
dort als Source-Code rein
und nicht irgendwie
nochmal zum extra rappen.
Okay, die verbinden Bits-UI.
Muss ich jetzt nochmal npm install machen
oder muss ich Visual Studio Code nochmal neu starten,
dass es checkt, dass das alles da ist?
Oder wie ist das jetzt?
Nee.
Warum checkt Visual Studio Code das jetzt nicht?
Wo ist das Problem?
Ach so!
Da sind gar keine Fehler.
Das sind TypeScript.
Wahrscheinlich, weil ich hier einen TypeScript-File drin habe, oder?
Warum denkt denn,
aus welchem Grund denkt denn man Visual Studio Code,
es soll an der Stelle TypeScript machen?
Es soll nämlich gar kein TypeScript machen.
Wie kriegt man das aus?
Jetzt ist die Frage,
ist das Visual Studio Code
oder ist das das Welt-Plugin,
was das macht?
Weil das sind keine Fehler,
das sind TypeScripts.
Gucken wir mal in die Config.
Von diesem Svelte-Plugin.
Ah, hier, Enable TS-Plugin.
Was?
Ist es das, was ich ausschalten sollte, vielleicht?
Nee.
Wie kriege ich denn hier TypeScript-Geschiss aus?
Enable das Svelte-Plugin?
Diagnostic Messages?
Nee.
Okay, wenn ich das Svelte-Plugin ausmache,
sollte alles weg sein, auch nicht?
Hä?
Okay, ich habe legit keinen Plan.
Ich glaube, das muss man vielleicht nochmal neu starten.
Kann das sein?
Muss man das nochmal neu starten,
dass er das checkt?
Just JavaScript Things?
Ah.
Ah, da ist es wieder.
Fuck, Mann.
Wir lassen es einfach mal so.
Scheiß drauf, ich weiß jetzt nicht,
wie man das deaktiviert.
Wie kann man TypeScript ausschalten,
dass es nicht mehr denkt,
dass es TypeScript ist?
Enable Code Actions for TypeScript.
Enable Diagnostic Messages for TypeScript.
Oder hier?
Moment, warum habe ich,
warum habe ich überhaupt eine TS-Config.json?
Warum überhaupt?
Ich verwende überhaupt kein TypeScript.
Ich will den ganzen Shit gar nicht haben.
Das ist wieder wirklich richtig krasses
Five-Head-Frontend-Zeug.
Kann ich einfach sagen?
Kann ich sagen False?
Ah!
Okay, wunderbar.
War es auch immer.
Meine Güte.
Okay, so, jetzt habe ich einen Button.
Das ist ja schon mal gut,
wenn ich einen Button habe.
Dann fügen wir den Button doch mal hinzu.
Also, ne, nicht in Layouts,
in Page.
So, das, das kommt, das, ja,
Welcome to Kekwe, Beste.
So, und lull.
Speichern da mal,
da fügen wir jetzt mal einen Button ein.
Button.
Lull.
Und jetzt ist es kaputt.
Ah, weil ich noch nicht included habe.
Quick Fix.
Äh.
Sollte er das nicht, sollte er das normalerweise nicht selbst
includen, den Button?
Ich, ich, ich bilde mir ein, dass, dass er den Kram eigentlich...
Hä?
Okay, jetzt hat er es gecheckt.
Da ist ein Button, guck mal.
Kekwe.
Wahnsinn.
Ein Button.
Und wie schaltet man jetzt zwischen Dark- und Light-Mode um?
Weil, okay, Components.
Components, Button.
Okay, der Standard-Button ist anscheinend halt mit dem
Standard-Hintergrund.
Okay, soweit, soweit, so gut.
Installation.
Usage.
Ja, es ist ein Button.
Der sieht bei mir auch sehr
Button-mäßig aus.
Außer, dass ich eine andere Schrift dann anscheinend
habe als die.
Aber haben die eine viel coolere Schrift
dann als ich?
So, und...
Ah, Secondary für den, dann sieht der anders aus.
Was brauchen wir jetzt?
Variant.
Variant.
Gleich.
Na ja, an der Stelle, wo Inams mal irgendwie Sinn machen würden, natürlich nicht, ne?
Okay, jetzt habe ich so einen ganz normalen Disabled-Button.
Destructive.
Okay.
Ghost.
Link.
Ah, guck mal, die haben sogar eingebaut, dass man...
Ah, okay, das ist für den Button, deshalb...
Ja, das muss man dann selbst machen.
Loader 2.
Obviously, dass das Loader 2 heißt.
Fragt man sich, was mit dem originalen Loader passiert?
Also, was ist mit Loader 1 passiert?
Also, was ist mit Loader 1 passiert?
Und was ist...
Was zum Teufel schon wieder Lucides Welt?
Typische Frontends stellt es wieder hier.
Typische Frontends stellt es wieder hier.
What?
Beautiful Icons jetzt.
Alter, wie viele gibt es davon, von diesen Dingern?
Alter, wie viele gibt es davon, von diesen Dingern?
Da gibt es ja drei Milliarden von.
Okay, ich speichere mir das mal.
Okay, ich habe es geschafft, einen Button zu machen.
Das ist doch schon mal was.
Okay, ich habe es geschafft, einen Button zu machen. Das ist doch schon mal was.
Und wenn ich den Button jetzt selbst anpassen will,
mache ich das direkt im Source Code,
anstatt zu hoffen, dass der Button
irgendwelche
fertigen Sachen dafür anbietet.
Ich finde das vom Ansatz her
gar nicht mal so doof, ehrlich gesagt.
Weil die Button-Komponente
ist ja übersichtlich.
Was steht denn eigentlich in Index.js drin?
Warum ist das in einem eigenen JS-File?
Import Root
from
ButtonSelt
TV
from Tailwind
Variants
30 Milliarden
Dependencies, Alter.
Leute,
ich habe keine Ahnung, aber
passt schon.
Ach so, das hier ist
Warum?
Ich meine,
ich habe mal eine ganz bescheuerte Frage,
Leute.
Warum ist das ganze CSS
in einem JavaScript-File definiert?
Also ich verstehe
den Sinn in dem Fall schon.
Das ist, dass man
sagen kann, hier Variants,
Destructive, Outline,
sonst was.
Und dann nimmt er sich, je nachdem, was man hier
an Variant
ausgewählt hat,
die passenden Styles raus.
Ja, das ergibt schon Sinn.
Aber, so ganz checke ich es nicht.
Also wisst ihr, wie ich das gemacht hätte?
So als Frontend-Noob.
Ich hätte da ein If gemacht.
Ich hätte sowas hier gemacht.
Export, Let Variant,
Default, so. Und dann hätte ich
quasi sowas gemacht, wie
sinngemäß irgendwie
If.
Oh, ich bin so dumm.
Ich kann keine Syntax
mehr fürs Welt.
If, nee, wie war das nochmal?
Klammer auf war das, gell?
Geschweift, Klammer auf. If.
Genau. Ich hätte es so gemacht.
If Variant
Gleich, gleich, keine Ahnung.
Destructive oder so.
Und da dann irgendwie
die Styles gesetzt.
Wahrscheinlich ist das
die bessere Variante, wie die das machen.
Ich glaub den einfach mal.
Die wissen, was sie da treiben.
Okay.
Ich erkenne aber schon instant
ein Vorteil von dieser ganzen
Geschichte. So.
Überlegt euch jetzt mal.
Ihr würdet eine UI Library verwenden, wie
die Button UI. Wo es im Endeffekt nicht
den Source Code für den
Button gibt, sondern
einfach nur einen fertigen
Eine fertige
Button Component im Endeffekt.
Wo ihr dann hier.
Gibt es nicht wirklich. Wo ihr dann hier sagen würdet,
Button. Das ist ein doofes Beispiel jetzt.
Nehmen wir an, ihr habt irgendwie so eine Progress
Bar. So. Dann würdet ihr eine fertige
Component Progress Bar nehmen. Und wenn die was nicht
kann, was ihr haben wollt,
würdet ihr es selbst rappen. So.
Was wir jetzt hier haben ist, es gibt Varianten.
Default, Destructive,
Outline, Secondary. Wenn ich jetzt eine Variante
haben möchte.
Von dem Button.
Accept zum Beispiel.
Und die Accept Variante.
Gucken wir mal, ob das jetzt schon so funktioniert.
Accept.
Kunst.
Ja. Kunst.
Das heißt, da könnte ich jetzt zum Beispiel
sagen, meine Accept Variante
ist Text Primary bla bla bla.
Aber. Warte mal. Wo
Destructive. Hier Hover,
Background. Wir nehmen mal.
Ja geil, hier habe ich natürlich keinen.
BG Destructive. Wo ist das denn?
Wo ist BG Destructive
bitteschön definiert?
Wo kommt.
Woher weiß der,
dass es BG Destructive
gibt?
Ist das in der
Tailwind Config drinne?
Ah ja.
Hier. Primary, Secondary,
Destructive, Muted, Accent,
Popover.
Cards. Okay.
Sagen wir mal. Sagen wir mal, ich möchte
sowas hier haben. Okay. Accept.
Nehmen wir mal das hier und sagen BG Accept.
Text Destructive, Foregrounds.
Das heißt, wir brauchen das ein paar mal.
Weiß ich, weiß ich, ob es Sinn macht.
Wir wollen es ja nur für den Button.
Komm, machen wir einfach mal hier.
Machen wir einfach mal
das wieder rückgängig.
So. Sagen wir mal BG. Ja, aber hier.
Hier drinne haben wir jetzt, hier drinne haben wir natürlich
jetzt keine Tailwind Autocomplete.
Das ist schon bisschen, bisschen, bisschen
eklig jetzt, ne. Also ich
will jetzt quasi sowas haben wie, machen wir mal
hier beispielsweise hier Class.
Ne, ah ja. Das ist das,
wo ich meine, man kann HTML nicht gescheit auskommentieren.
Lul.
Da muss ich mich ein bisschen dran gewöhnen,
wie man, wie man das gescheit macht. Also was ich
jetzt, was ich jetzt beispielsweise, machen wir sowas wie
Background Green.
Irgendwie sowas.
Das sieht halt scheiße aus.
So.
Und jetzt gehen wir hier rein.
Sagen BG
Green 500.
Der Hover funktioniert natürlich noch nicht.
Oh.
BG 500.
Guck mal.
Und schon haben wir nen
neues, neues Button Feature und zwar,
dass wir auch nen Accept Button bauen können.
Das finde ich vom Ansatz her gar nicht so
verkehrt, ehrlich gesagt.
Dass man direkt an den Komponenten rumbaut.
Ein Nachteil
davon ist aber halt,
dadurch, dass ich jetzt nicht einfach sage,
include
button from
schätzen UI,
wenn die jetzt irgendwas fixen,
ja, mal angenommen der Hover wäre kaputt
oder so, und die fixen das,
dann würde es bei mir
nicht automatisch mit dem Upgrade der Library
gefixt werden, weil es ja keine Library in dem
Sinn ist, sondern einfach nur Source Code,
der reinkopiert wird.
Das hat seine Vor- und Nachteile,
ja. Und in der
Tailwind-Config kann man die globalen Styles
definieren. Nicht wirklich globale
Styles,
das sind, das sind Tailwind,
wie nennt sich das denn so? Tailwind Options.
Also wenn du hier was einträgst,
zumindest
bilde ich mir ein, das so verstanden zu haben,
dann generiert Tailwind
aufgrund deiner
Farben, die du hier einträgst,
quasi diese ganzen Prefixes,
die es gibt, zusätzlich mit deiner
Farbe. Also zum Beispiel hat
Tailwind sowas eingebaut, wie
Text-Color,
oder
hier Text-Red, zum Beispiel.
Und jetzt kannst du sagen, Text-Destructive.
Das generiert Tailwind
daraus, weil du hier eine neue
Option angelegt hast, die sich Destructive
nennt. Das heißt, sprich, alle Sachen,
die Tailwind generiert,
wo Farben drinne vorkommen,
hat zusätzlich jetzt noch eine,
ja, was auch immer, minus
Destructive, minus Primary,
minus Secondary, ja. Du hast jetzt
BG-Destructive, oder
Text-Destructive, oder
Border
Destructive.
Also Tailwind generiert
quasi alles, was es sonst generiert,
plus zusätzlich die Farben
und Sachen, die man hier definiert hat,
die man hier definiert hat.
Das heißt, wir könnten hier durchaus sagen, dass
wir hier jetzt nicht neben Destructive
noch ein, ja,
Accept oder OK oder sowas
einbauen. Lass uns mal
kurz gucken, was Muted ist, zum Beispiel.
Muted.
Okay. Nicht das, was wir haben wollen.
Accent.
Äh.
Auch nicht wirklich, was wir haben wollen.
Popover. Cart wollen wir wahrscheinlich auch nicht
haben. Ah, ne.
Okay, also das gibt es
schlicht und ergreifend noch gar nicht,
was ich hier haben will. Ich hätte gerne nen Button,
der im Hinter... der
grün ist.
So, man könnte jetzt tatsächlich
hergehen an der Stelle und sagen, okay,
vielleicht will ich das ja nicht nur
für den Button haben, sondern
ich will das vielleicht auch mal für
Popup-Boxen
oder so benutzen. Ja, zum Beispiel,
überlegt euch mal, man möchte den Status
anzeigen von irgendeiner Operation,
so nach dem Motto, hat geklappt,
gab ne Warnung, gab nen Error und dann brauchst
du ja auch wieder die gleichen
Farben.
Und da könnten wir hier jetzt definieren,
zusätzlich noch hier,
anstatt Destructive,
sagen wir so, nennen wir das mal wirklich irgendwie,
ja, ich weiß nicht,
was ist ein schönes, schönes
Wort dafür? Except trifft's ja nicht so wirklich.
Except ist für den Button, ja.
Okay.
Ich weiß nicht. Man könnte
das okay nennen.
Und jetzt ist irgendwelche Magic-Sachen,
die ich nicht checke.
What?
Äh.
Das ist mir zu high IQ. Wo kommt denn das
jetzt wieder her? Zumindest ein
Beispiel jetzt, was das gemacht hat, ist,
ich kann jetzt, ich kann jetzt an der
Stelle zum Beispiel verwenden,
äh, Text,
okay. Ja, das hat es jetzt generiert,
anhand der, aber,
wo kommt denn jetzt der ganze
Krempel her? Das sind,
das sind CSS-Variablen, okay.
Ah, kommen die vielleicht
aus der,
wo ist er denn?
Und was ist Ambient und Non-Ambient?
MonkaS, Alter.
Warum hat das 30 Milliarden Files,
das ganze Zeug wieder?
Wo ist denn mein Post, Post CSS
Ding ab? Da stehen
die CSS-Variablen drin, was das eigentlich
ist. Boah, das ist ja mega durch die
Brust ins Auge, Mann.
Ach, hier werden auch die Dark
und, und Light Styles
definiert. Alter,
who is that?
Okay. Okay, okay.
Ich glaube, ich habe es, ich glaube, ich habe es gecheckt.
Machen wir das mal weg.
Das ist ja nur so ein Zusatz, Zusatz-Ding.
Dann bleiben wir jetzt mal hier bei,
machen wir das auch mal weg.
Gehen wir mal wieder unsere Button-Component
rein, sagen wir hier destruktiv.
Dann ist er rot,
der Button.
So, und wie schalte ich das jetzt um
auf Dark Mode?
Das ist, glaube ich,
das ist, glaube ich, was Globales.
Das mache ich, glaube ich, gar nicht pro einzelner
Komponente, sondern
das mache ich, genau,
das mache ich hier ganz, ganz oben.
Irgendwo hier im Layout oder so.
Schreibt man hier einfach Dark
vor? Ah,
ich bin mir unsicher, ob das jetzt funktioniert hat.
Hat das jetzt funktioniert?
Also, es hat
was gemacht. Ich vermute
schon. Light?
Ich vermute schon, dass es das gecheckt hat
jetzt. Also, ich
gehe, ich gehe davon aus, dass man einfach dann
möglichst hoch in der
HTML-Hierarchie quasi Dark
hinschreibt. Was ist denn,
wenn ich das direkt an HTML dranschreibe,
wird dann der Hintergrund auch Dark?
Aber ich schreibe schon das komplett an HTML.
Ja!
Tatsächlich! Cool!
Okay, das gefällt mir eigentlich ganz gut.
Haben die ein, ein
Switcher eingebaut?
So wie hier? Gibt's das schon fertig?
Das bauen wir doch!
Das können wir uns doch jetzt mal selbst bauen!
So einen Darklight-Switcher,
falls das noch nicht
eingebaut ist.
Theme? Gibt's das hier sowas schon?
Switch?
Switch gibt es, ja, da können wir das selbst bauen.
Ja, das probieren wir doch mal aus.
Wir bauen uns so einen Darklight
Theme-Switcher.
Ach hier, Darkmode, guck mal.
Die haben ja schon alles hier hingeschrieben.
So, wir
machen jetzt, wir machen jetzt noch eine Sache, machen wir jetzt hier
nochmal.
Wir machen, äh, Margin,
Margin, Bottom,
bisschen Abstand dazwischen, dass es hier nicht ganz
aneinander klebt. Guck mal, die haben's hier schon
beschrieben. Darkmode.
We use the classed
strategy.
How
you add
Darkclass to the HTML element
is up to you.
Mode-Watcher. Nee, wir brauchen, ganz ehrlich,
ich brauch keine,
was ist das?
Ich brauch kein extra Button
für Dark- und Light-Switchen,
ganz ehrlich.
Das muss, das muss doch nicht sein, oder?
Das können wir doch, können wir doch
selbst machen. Und hier bauen
sie das mit einem Switch nach, okay.
Eigentlich ganz cool. Das können wir doch jetzt wirklich
mal ausprobieren, das selbst zu bauen.
Da lernen wir ein bisschen auch die, diese Component
Library kennen und gucken, wie, wie man da,
wie man gescheite Icons benutzt und so.
Falls, falls man überhaupt
Icons hier haben kann. Nee, Icons sind ja
da keine dabei. Ah jo.
Wir bauen doch einfach mal
sowas hier, ne? Da, da kommen wir.
Hier, Button, genau.
Und Sun.
Was für Icons? Ah, hier.
Lucidus-Welt wieder.
Also im Endeffekt können
wir jetzt einfach ein Button bauen, das, das
lasst, lasst uns das mal ausprobieren. Also,
das heißt, wir gehen dementsprechend
nicht hier in die Seite,
sondern das machen wir im Layout.
Layout
bauen wir einen Knopf ganz oben hin.
Aus irgendwelchen Gründen, wie der nicht funktioniert
hat. Ah, weil's nicht
included ist. Okay.
So, jetzt haben wir hier einen Button.
Irgendwie, keine Ahnung, Theme oder was auch immer.
Wurscht, der ist nicht
Destructive, der ist erstmal gar nix.
Haben wir einen Button. Und wenn man
draufklicken, dann wollen wir global
das
anpassen, dass da
Dark und nicht Dark dransteht.
Machen wir das doch mal. Das dürfte
tatsächlich relativ easy sein und wir brauchen
ein bisschen
Oldschool-Dom-Manipulation
denke ich mal, weil
unser HTML-Element steht
hier. Gab es da
ins Welt nicht sowas,
gab es ins Welt nicht was, um
direkt
auf, ist das nicht Windows?
Ja, genau.
Ach nee, das ist
nur, dass man beispielsweise für das
gesamte Fenster jetzt
Keyboard-Events
registrieren kann und sowas.
Das Welt-Document, doch, das ist doch
das, was ich haben will, oder?
Aber da kann ich keine Klassen.
Nee, das ist nur um sich
um Tastatur-Events
und sowas mitzubekommen.
Ich glaube,
bringt uns an der
Stelle nix.
Also, wir könnten doch jetzt sagen,
hier, klick, nee, warte mal, wir sind
nicht, klick, ging so,
on, on, klick.
Ich vergesse immer die Hälfte.
Ähm, wie, Moment.
Function.
Irgendwie,
Toggle
Theme, nennen wir das jetzt mal.
Und jetzt
musste man doch irgendwie Trick 17 machen.
War das nicht so?
Nee.
Shit,
ich hab vergessen, wie das ging.
So, so war das richtig.
Gern, dass er das jedes Mal ausgeführt hat.
Probieren wir nochmal aus.
Log, loggen wir mal
irgendwie was und gucken, ob beim Klicken
was passiert.
Jaja, Kunst.
So, und jetzt müssen wir sagen,
wie applyt man denn jetzt
an dem HTML-Element
Document
Get Element
Hack Name?
Wie geht denn das?
Wie krieg ich das HTML-Element?
Geht das so?
Tatsächlich, funktioniert. Easy.
Ist das der W,
das zu machen?
Wahrscheinlich nicht, oder?
Das erste Element?
Weiß nicht,
ob das der W ist.
Ich know nicht der W.
In dem Fall.
Aber das ist richtig.
Und da können wir jetzt doch einfach sagen,
HTML Classes
Ich glaube, das muss man hier
so unreactive
und alles machen.
Classname gleich dark.
Gucken wir mal, ob das jetzt schon funktioniert.
Ja, Kunst, wenn man draufklickt.
Ich meine, das Toggeln funktioniert noch nicht.
Aber beim draufklicken wird das ganze
Ding schon mal dark.
Das ist Funs.
Also könnten wir quasi sowas hier irgendwie sagen,
wie let
beam gleich,
dann mit light.
Es gibt auch document element.
Wat?
Ok, document
document element.
Ah!
Ja, noch besser.
Noch besser.
Dann brauchen wir diesen ganzen Krempel nicht.
Gucken wir mal, ob das auch funktioniert.
Ja, nein.
Das ist ja noch viel nicer.
Wir machen einfach sowas hier.
Let dark theme gleich false.
So.
Wenn dark theme
Hier, Moment.
Dark theme gleich not dark theme.
Hier wollen wir das ja switchen.
If dark theme
Oh je,
JavaScript, wie ging das jetzt nochmal?
Dann dark,
ansonsten light.
Weil light wahrscheinlich nichts macht.
So.
Guck mal!
Und schon Toggels zwischen dark
und light mode.
Das heißt,
hat jetzt mit dem, hat null,
hat null mit
der UILibrary zu tun,
die wir benutzen.
Aber man sieht, dass die schon mal ordentliche default styles
dabei haben. Guckt euch der Button,
der Button ändert ja auch den Hintergrund
aufgrund, ob dark mode
oder nicht dark mode gesetzt ist.
Ja, wir können das auch eigentlich anders machen.
Wir können auch sagen dark.
So, wenn
theme gleich gleich
dark.
Dann
light.
Ansonsten dark.
Und hier kommt einfach
theme hin. Wahrscheinlich sinniger an der Stelle.
Ey, wir sollten da light reinschreiben,
weil wir starten ja mit dem light theme.
Ist wahrscheinlich die.
Keine Ahnung, ob das die schönere Variante ist.
Ich mein, man könnte es jetzt reactive
machen, ne? Ich mein, wir sind ja ins Welt.
Und
ins Welt könnte ich doch
Oh, fuck.
Dazu ist schon zu lang her.
Ist das jetzt nicht so, dass es sich automatisch ändert,
wenn man
Ne.
Hat er für Schmerzen?
Ne, so ging das Ding, so ging das nicht.
Okay, ich bin zu pepega für.
Ne, ist schon okay, das kann so bleiben.
So, aber jetzt wollen wir mal zurück
zurück zu dieser UI Library.
Ein weiterer
Vorteil, den ich sehe ist, wobei
hat der Button Image Support?
Button.
Image.
Ne, egal.
Gibt kein Image, haben die hier keinen Namen.
Gibt es Schaden? Doch, hier ist doch ein
Ach, nicht Image, ja Icon hätte ich
suchen müssen, okay.
Wir benutzen, Leute, wir benutzen
mal das Beispiel von denen.
Das hier ist zwar wahrscheinlich nicht mitinstalliert,
aber das müssen wir zusätzlich installieren.
Aber das können wir gleich mal
testen.
Wie heißt dieses Ding hier?
Lucides Welt.
Das letzte Mal habe ich die, die,
für die letzten paar Projekte haben wir die
Tabler Icons verwendet.
Warum, warum sind die Dinger
hier besser als Tabler Icons?
Weiß man nicht, wahrscheinlich
weil es geht.
Provides 100 plus
Vector Files for displaying Icons,
Symbols and Digital. Okay.
Und warum ist das nicer
als die Tabler Icons? Oder
die MDI Icons?
Wahrscheinlich, wahrscheinlich einfach
Geschmackssache.
Ah, okay.
Vercel used das und supported das.
Jetzt weiß ich auch, warum das in Svelte...
Wobei, eigentlich
hat das ja mit Svelte nichts zu tun.
Also Vercel ist, glaube ich,
also mit die, die, die Sponsoren quasi
von, von Svelte.
Der Svelte-Erfinder ist
bei Vercel, glaube ich, angestellt.
Iconify, das haben wir auch schon mal
benutzt. Ja, das ist, das ist auch
halt...
Ich hab, ich hab auch gerne den,
den Vorgänger davon benutzt.
Das nannte sich Fontello, glaube ich.
Da konntest du auch schon so Meta-mäßig
alle Items benutzen.
Okay, Showcase wie...
Icons.
Hier sieht man die. Okay.
Haben wir da Icons zum Beispiel so wie Light?
Und Moon?
Ja, komm, wir machen das mal so.
Wir machen das mal wie, wie die das hier im Beispiel
haben. Wir benutzen das einfach jetzt mal.
Wie, wie installiert man das? PNPM?
Na, komm hier. Wenn schon gleich volle Pulle.
Gehen wir... Okay.
Und jetzt...
Können wir hinzufügen
ein... Nein, nicht Mail.
Mail wollen wir nicht haben.
Wir wollen...
Komm, wir fügen, wir fügen...
Wir fügen mal Mail ein, ja?
Ah, nee. NPM Install
hab ich noch vergessen. Nee. Oder?
Warum... Sag mal,
das kann doch nicht sein, dass man Visual Studio Code
neu starten muss,
dass der checkt, dass man ein neues
Package installiert hat, oder?
Doch. Ist so.
Ist, ist echt so anscheinend.
Und jetzt? Wow!
Jetzt hä... Guck mal!
Wir haben ein Icon! Pog!
Okay, da wollen wir jetzt aber kein Mail Icon
haben, sondern wir wollen hier
ein Moon Icon
zum Beispiel.
Zack! Dark Theme, Light Theme, Dark Theme,
Light Theme.
Reload Window hilft auch, okay.
Ist mir neu.
Jetzt müssen wir nur noch gucken, dass wir den...
das Icon switchen können.
Je nachdem, was für ein Theme wir verwenden.
Ja, okay.
Also die zeigen quasi den
den Status dann. Aber
an der Stelle muss ich ja
muss ich ja schon wieder ein bisschen größere Logik
reinbauen. An der Stelle brauche ich
jetzt ein If, ne? Oder fällt hier
jemand was anderes ein?
An der Stelle brauche ich ein If.
If
Theme
gleich gleich Dark
Moon
und ansonsten
Else
Sun oder so wahrscheinlich.
Ja.
Guck, nice.
Aber
das geht bestimmt, das geht bestimmt
kürzer und cooler und knackiger.
Wir machen, lasst uns
doch mal gucken, wie das die
Experts hier machen.
Hä?
Warum funktioniert denn
das? Warum zeigten der nicht einfach beide
hier an? Hä?
Chatkill.
Scale? Ah!
Das wird auf 0, das
das wird, das bekommt
die Größe 0, wenn es
Dark Mode ist. Sehe ich das richtig?
Oh, das ist ja super!
Durch die Brust ins Auge,
Mann! Okay, Sekunde.
Ich kopiere mal das mal rüber. Das muss ich mir angucken.
Das ist halt so ein typischer
Fall von.
Das hier kann man ganz gut lesen.
Ja.
Äh, Moment.
Variante Outline
brauchen wir. Outline.
Warum ist denn
da so ein komischer
Platz da hinten?
Ah, MR.
Wegen dem MR.
Okay, ja, schon besser.
Also mit dem If-Else kann man
das halt deutlich besser lesen.
Gucken wir uns mal die Variante an, wie das
hier die Experten machen.
Oh, das ist ja nice. Seht ihr
das? Die haben eine Transition,
oder? Guck mal.
Die eignen Transitionen
zwischeneinander.
Das ist cool, oder?
Das gefällt mir.
Da muss ich sagen, das sieht schon nicer aus
als bei mir.
Vergleicht mal.
Vergleicht mal. Wir halten unseren übelsten
kleinen Scheiß auf gerade, aber
man, why not?
Vergleicht mal. So, hier mit Transition
und bei mir daneben ohne Transition.
Also da finde ich, da finde ich's
mit Transition cooler, oder?
Was sagt ihr? Transition oder
no Transition?
Transition, Transition ist das.
Bleibt so.
Okay, komm. Was machen wir jetzt?
Oh, bin ich klein.
Also ich hab das 4.
Breite auch 4.
Machen wir beides mal so, wie bei mir.
Was ich nicht checke ist, warum ist das
eine Absolut und das andere nicht?
Das...
Ach so!
Ah, ich verstehe. Das ist das, dass das mit den
Transitions richtig funktioniert, ne?
Wenn ich das, mal angenommen, ich mach
hier Absolut raus. Ja.
Dann ist es nämlich hier kleinskaliert
so, ne? Das ist natürlich dann kacke, ne?
Hehehe.
Da sieht man mal, wie
Sixhead schon ein popliger
Themeswitcher im Frontend
ist. Das gefällt mir
aber, das hat was.
Ich als Noob hätte sowas
gemacht, eventuell hier, ne? Guck mal.
Das hätte ich rausgeschmissen
und hätte gesagt,
wir machen mal hier den Kram
mal kurz weg, ja?
Und ich hätte gesagt,
Dark
Hidden, zum Beispiel.
Äh.
Mein Scale 100.
Ach, jetzt ist beides da.
Äh. Ha, dann funktioniert das
nicht so genau, wie ich mir das gedacht hab.
Light gibt's ja nicht.
Ähm.
Ich brauch...
Wait a minute. Shit.
Ich bin zu
Threehead, zu checken, wie ich den
Wie ich den jetzt hide.
Aber hier Scale
und jetzt sag ich Dark
Scale 100, ha?
Ne, Moment.
Visible sag ich. Visible.
Visible.
Dark Visible und ansonsten ist er
standardmäßig Hidden. So rum.
Ne, äh.
Was ist das Gegenteil von Visible?
Es ist nicht
Visible, es ist, ähm.
Display.
Äh.
Block.
Unvisible, genau.
Ja, das ist...
Genau, Block. Block ist
Display, Block versus Hidden
versus None.
Yeah.
So funktioniert das auch, aber
der hat
jetzt nicht so ne schöne Transition
wie bei dem anderen, mit dem
Scale. Also ich muss sagen,
so, so kompliziert
und doppelt und, und
wie das aussah, was die Leute hier gebaut
haben. Ich finde, es haben die, also
ich finde, denen ihre Lösung ist schicker als
meine. Also so, es ist ne
Noob wie ich wäre, hätte ich's
eigentlich so gemacht.
Anderweitig hätte ich's so gemacht, aber
die schönere Variante ist tatsächlich,
muss ich sagen.
Das muss man ihnen lassen.
Das muss man ihnen lassen.
Das ist
schicker mit der Transition.
Das gefällt mir echt gut.
Haben wir uns richtig schön
an kleinen Scheiß aufgehalten.
Aber wir haben nur
einen Theme-Switcher, immerhin, okay?
So.
Haben wir denn sowas wie eine Leiste
zum Beispiel? Haben wir
nicht. Brauchen wir auch nicht. Können wir auch selbst bauen.
Lass mal, lass mal schauen,
was haben die denn eigentlich hier alles für Komponenten
dabei. Ein Akkordeon.
Hab ich noch nie benutzt.
Wann, wann, wann benutzt man sowas?
So für FAQs
oder sowas vielleicht, ja?
Alert. Heads Up.
Ein Dialog? Okay.
Ah, die übliche.
Die übliche Geschichte,
die man bei Frontend-Stells so hat.
Benutzen die schon
das neue Model?
Anzeige? Nein, die machen das noch mit
Overlay und Div, okay.
Weil im Browser gibt es ja mittlerweile sowas
Native, so eine Dialog-Anzeige.
Was ich
extremly nice finde, dass es
das mittlerweile Native gibt.
Was hat denn der Dialog
noch für Optionen?
Wow, ja!
Übertreib halt!
Aspect Ratio?
Hä?
Was macht das jetzt? Muss ich das Fenster
verschieben, dass das...
Ah, okay, okay.
Jetzt verstehe ich,
was das macht.
Avatar.
Bild. Avatar-Style
mäßig anzeigen.
Badge.
So ein Chicken Nugget
Ding.
Button hatten wir schon. Kalender. Oh, die haben
also auch ein bisschen advancedere Komponenten.
Beziehungsweise den Source-Code für Komponenten.
Kalender.
Ja,
Kalender-Komponenten richtig hinzubekommen
ist gar nicht so easy.
Wisst ihr, was ich noch viel schwieriger finde?
Time-Picker ordentlich.
Haben sie anscheinend
auch nicht hier einen Time-Picker.
Time-Picker ist echt immer
so ein Ding für sich, ne?
Was auch witzig ist,
was ich ja komplett
hasse, ist dieser
Material Design Time-Picker.
Das Ding kann ich überhaupt
nicht ab. Den hier.
Den Material... Achso, das ist nicht.
Es ist, äh...
Utifile Time-Picker.
Den kann ich überhaupt nicht ab.
Diesen Material Design
Time-Picker. Ich find das
so eklig, dieses Teil, man.
Und noch schlimmer für 24 Stunden.
Wisst ihr, wie kacke das für
24 Stunden aussieht?
Ihr.
24 Stunden
Das ist so eklig.
Das ist so eklig, dieses Ding.
Ich mag's einfach nicht.
Ich weiß, das ist der Android-Style,
wobei ich selbst gar nicht sicher bin,
ob es Android überhaupt noch benutzt in der Form.
Aber...
Die mag ich überhaupt
nicht.
Ne, bei denen heißt es nur Date-Picker, nicht Time-Picker.
Hier kannst du nur
Dates picken und keine
Times.
Was haben sie sonst noch so?
Okay, die übliche
Sache, die man
so kennt.
Es ist schick. Es ist schick gemacht mit den
Default-Stylings.
Muss man echt sagen.
Und
doch relativ übersichtlich.
Ich find das gut.
Optisch
recht hübsch gemacht.
Eine Sache, die mir daran gefällt ist,
es ist
wirklich sehr dezent gestylt alles nur.
Und das gefällt mir.
Das ist das,
was ich an Skeleton-UI
irgendwie nicht richtig mochte.
Die haben zum Beispiel,
wenn du hier Documentation gehst
und dann auf die Komponenten, dann guckst du dir das an.
Das ist so...
Das ist mir zu viel
gestylt alles.
Und auch wenn du es dann hier umstellst auf...
auf...
Das ist mir zu viel des Guten gewesen.
So dieses...
Zurück halt gestylt, im Prinzip
sind es eigentlich nur zwei Farben.
Schwarz und Weiß
mit ein bisschen Grauabstufung dazwischen
und Farbe wirklich nur an der Stelle,
wo es Sinn macht.
Und das gefällt mir eigentlich ganz gut.
Und das hier sieht auch wirklich übersichtlich aus.
Die benutzen einen Button, die benutzen...
Ah, Switch können wir noch ausprobieren.
Switch-Komponente haben sie bestimmt
auch.
Okay, so
Karussell habe ich noch nie verwendet.
Das benutzt man...
Das benutzen die glaube ich ganz gerne, wenn du so
verschiedene...
Also wo ich das jetzt schon gesehen habe ist,
wenn du so verschiedene Tiers zur Auswahl hast,
so Free-Tier,
Beginner-Tier,
Advanced-Tier, Professional-Tier
und sowas. Da haben die sowas ganz gerne.
Natürlich
wieder eine Dependency auf irgendeine
Library. Sowas kann man nicht ohne Libraries
im JavaScript-Umfeld bauen.
Obviously ist das nicht möglich
ohne Zusatzlibrary, sondern
scrollbares Karussell zu bauen.
Checkbox.
Ja.
Ja, eine Checkbox halt.
Man denkt sich so, wie kompliziert
kann schon eine Checkbox sein?
Bam! Zehn Zeilen!
Okay, es ist im Endeffekt
aber einfach nur ein Diff, um
Label und Checkbox
zu gruppieren.
Ja, sieht alles noch überschaubar aus.
Was haben wir hier? Ein was?
Ein Collaps... Was?
Collapsible?
Was collapsed da?
Achso.
Aha.
Oh Leute, modernes
Web-UI ist echt nicht meins.
Ich weiß immer nicht, wann ich die Sachen
verwenden soll. Hast du das Video
gesehen, wo der Typ eine Webseite gebaut hat,
die Scammer trollen soll? Ne.
Aber da gibt es ja nicht nur ein Video.
Also ich habe nicht
das Video dazu gesehen.
Der beste, der beste
Scambaiter, wie man
das ja nennt, ist KidBoga.
Dem gönne ich echt jeden einzelnen
Zuschauer.
Ich gucke es nicht mehr so oft,
weil es irgendwie auch immer das gleiche
ist, auf lange Sicht.
Aber
ich kenne keinen, der das so gut macht, wie der.
Und vor allem auch
super spontan alles, wie ihm das immer einfällt.
Ich überlege gerade, wann ich das
auf meiner Webseite verwenden würde, ein
Collapsible. Fällt mir jetzt nicht ein.
Combo-Box.
Okay, das ist eines der
feinst-champigsten HTML-Elemente
überhaupt. Eingebaut im Filter
und alles.
Aber schon wieder
nicht richtig.
Geht nicht.
Geht nicht.
Funktioniert nicht.
Post-One und End funktioniert
nicht.
Das würde ich gleich nachrüsten.
Ich kann es nämlich überhaupt nicht haben,
wenn Text-Boxen kein
Post-One und Ende unterstützen.
Da kriege ich Anfälle auf Webseiten bei.
Eine Combo-Box
barrierefrei entwickeln macht niemand so richtig.
Ich weiß gar nicht, ob das überhaupt richtig möglich ist,
das korrekt zu machen.
Guck mal allein, wie lang diese
fucking Combo-Box ist.
Mit Control? Was? Mit was?
Mit Control
links-rechts? Also links-rechts
funktioniert?
Ah, Control? Max, du
bist high IQ, aber warum funktioniert
das nicht mit Ende, Post
und so?
Und das für uns tatsächlich, wie du sagst.
Okay.
Jetzt kann das
Framework mal zeigen, was es kann.
Wir installieren
jetzt die Combo-Box
und ich versuche nachzurüsten,
dass
Post-Eins und Ende
Taste funktioniert.
Mal gucken, weil das ist
ja eines der Vorteile von
wir bekommen den
Source-Code reinkopiert und nicht irgendeine fertige
Component, die wir benutzen.
Äh.
Wait a minute.
Das ist G-Bait. Es gibt überhaupt
gar keine Combo-Box-Component.
Es gibt
Popover und Command-Components,
aus der sich dann die
die Combo-Box-Component zusammensetzt.
Das heißt, eigentlich gibt es gar keine
Combo-Box-Component.
Die haben uns G-Baited.
Das heißt, wie ist das aufgebaut?
Hm. Also sie benutzen Popover
und Command.
Okay, Popover ist sowas hier.
Hier funktioniert Post-Eins
und Ende. Okay, und dann Command.
Hier nicht. Okay, es ist
auf jeden Fall die Command-Component,
die wir brauchen. Alles klar.
Add Command.
Okay, gib ihm.
Ich versuche jetzt
nachzurüsten, dass man Post-Eins und Ende drücken kann.
Weil sowas triggert mich
immer auf Webseiten, wenn das nicht geht.
Okay, Components install.
Command and Dialog.
Äh. Was?
Soll ich pressen?
Shift-J?
Fuck, das funktioniert.
Okay.
Wahnsinn.
Okay, also wie bauen wir das jetzt ein?
Page.
Wir haben jetzt eine neue Component,
die sich Command nennt.
Und wie ist das jetzt aufgebaut?
Command-Root-Input-List.
Okay, mich interessiert eigentlich nur der Input
an der Stelle.
Das ist wieder nett,
weil ich es nicht importiert habe.
Nice.
Import funktioniert nicht.
Hat funktioniert.
Oh.
Äh.
Muss ich vielleicht
neben Command noch
Command und Root
und Input und so importen?
Input?
Ne.
Nein, ich muss.
Alter, natürlich. Natürlich.
Obviously muss ich machen
Import Sternchen-S-Command.
Dann funktioniert es auch. Logisch.
Ey.
Ich kann Bild vor und zurück machen.
Ist das irgendein
Firefox-Bug?
Oder ist das gefixt und auf der Webseite
von denen einfach nicht die neueste
Version drauf? Kann das sein?
Okay.
Wollen wir mal checken, ob das ein Chrome- und Firefox-Problem ist.
Ne.
Hier geht es auch nicht.
Ne. Jetzt.
Hä?
Hä?
Sag mal, Leute, bin ich blind?
Oder kompletter
Brain-Lag?
Ich bilde mir ein, das hat eben funktioniert.
Mit
Bild vor und zurück.
Anscheinend nicht.
Okay.
Aber hier funktioniert auch Dark Mode und sowas.
Ne. Funktioniert
nicht. Ich war blind.
Hat nicht funktioniert.
Okay. Also.
Wie könnte das funktionieren?
Wir gehen mal in die Komponente rein für
Command.
Und
dort dann in
Input.
Command Primitive
Input. Uiuiuiui.
Äh.
What?
Ähm.
Was bin ich sehend?
Data CMDK Input
Wrapper.
Natürlich.
Was ist denn
CMDK?
Wo kommt denn das schon wieder her?
Warum ist Frontend
Zeug? Immer 30 Milliarden
Dependencies, Alter.
Fast, unstyled, composable,
Command-Menü.
Okay. Ich weiß schon, was ich nicht benutzen werde.
Und zwar
das Command-Ding.
Man kann hier anscheinend
nichts einstellen, gescheit.
Wo kommt denn das her?
Command Primitive.
Ja, das kommt
aus
CMDKSV.
Da kann ich also an der Stelle schon mal nichts dran ändern.
Ich hätte jetzt eigentlich gehofft, der baut das hier
zusammen, dieses Menü, dass ich auch ein bisschen
was dran ändern kann.
Weil es geht halt POS 1 und so nicht.
Guck mal.
Das hat doch bestimmt schon irgendjemand.
Homekey nennt sich das
doch im Englischen, oder?
Wie heißt das? Wie heißen diese
diese
Tasten auf
der englischen Tastatur?
Home und End.
Wollte noch keiner haben,
so wie es aussieht.
Das finde ich doof, dass das jetzt wieder
30 Sachen gerappt sind.
Was kann man hier
eigentlich alles übergeben?
Arguments.
CMDKSV.
Was kann man da alles übergeben?
Label.
Input.
Das ist das.
Search.
Moment, ist
das hier die?
Das ist einfach nur das Icon, oder?
Das ist nur das Icon hier oben.
Hier, Class.
30 Milliarden Sachen, Alter.
Search.
Woher weiß ich denn, was ich da übergeben kann jetzt?
Was ist denn das schon wieder?
Das ist aber echt voll durch die Brust ins Auge.
Filter.
Ich will nicht filtern.
Custom Keyboard Events.
Also ich gehe davon aus,
man könnte das schon nachträglich
hier einbauen. Bind Value.
Hier. Input.
All Props are forward
to the underlying input element.
Ja, das...
Da müsste man sich jetzt noch mit einem separaten
NPM Package beschäftigen,
wie man das einmal...
Also das ist mir dann da schon fast ein bisschen zu viel
des Guten
gebastelt.
Dass man Post 1
und...
Es fuckt mich aber ab, dass das nicht funktioniert.
Wisst ihr was?
Warum wir wetten? Das liegt daran, weil der Typ auf dem Mac
entwickelt und gar nicht weiß, dass es die Tasten
gibt. Was meint ihr? Könnte
das sein?
Weil es ein Mac User ist?
Der hat das überhaupt nicht auf dem Schirm,
dass man das gebrauchen könnte.
Gehe ich mal von aus.
Oder keine Full-Size Tastatur.
Also hier will ich eigentlich nicht
jetzt dreherum wursteln, ja.
Ja.
Input.
Das ist das Eigentliche.
Hier ist das Input Element. Ja.
Bind This. Attributes.
Bind Value. Use Action.
Hier. On Input.
Focus Blur. Change.
Jetzt hat er irgendwo sich Subscribed.
An das
Change Event.
Ich checke jetzt nicht so genau,
wo er hier seine...
Ach nee, das kannst du einfach nur weiterleiten
dann. Du könntest da was dran.
Aber irgendwo muss er doch...
Nee, der macht da...
Aber ich mein, ein normales Input Element,
ja. Input Element hat
die Steuerung vor und zurück.
An irgendeiner Stelle
muss die verschluckt werden.
Und ich weiß nicht,
woran es liegt, dass das verschluckt wird.
Woran liegt es,
dass... Also der macht ja
hier nix custommäßiges.
Liegt das an den Attributen?
Ich weiß nicht, wie das
Vor- und Zurück-Taste nicht funktioniert.
Weil...
Der macht keine custom Sachen hier drinnen.
Dass der irgendwie den Input
groß abgreift oder so.
Der greift dann am Ende...
Der liest ja auch keine Keys oder so aus.
Der guckt
im Endeffekt nur, ob sich der Input geändert hat.
Der hier irgendwie...
Bind Value. Ja, irgendwo Value.
Value. Das liest
er im Prinzip.
Und wenn sich Value geändert hat,
dann updatet er irgendwie
Zeug. Super kompliziert.
Nicht zu checken für
normalen User wie mich, aber...
So. Und...
Wie kommt es jetzt,
dass Post 1 und
Ende nicht richtig funktioniert?
HTML Input Post...
Ne, Home... Home and
Keys
Not working.
Was ist das?
Im Jahr 2024 müssen wir immer noch
googeln, warum ein Inputfeld
die Keys nicht akzeptiert.
Eigentlich habe ich da jetzt gar keinen
großen Bock zu gucken.
Was wir jetzt tatsächlich noch mal ausprobieren...
Also, es scheint mir ein ganz normales Input-Element zu sein,
was aus irgendwelchen Gründen das frisst.
Macht denn ein normales Input-Element...
Input...
Macht denn ein normales Input-Element
das, was der Max gesagt hat, mit dem Vor und Zurück?
Ja, das macht
es auch. Aber aus irgendwelchen
Ge... Ach, kann
das sein...
Was ist das da?
Kann das sein, dass das irgendwie durch was Äußeres
verschluckt wird?
Echt keine Ahnung, woran das liegt.
Das sind so Kleinigkeiten, die mich bei jedem
bei jedem UI-Zeug immer super
abfucken.
Wenn die denn funktionieren...
So, hier. Inspect.
HTML Element.
Was haben wir denn hier?
What the f... Okay.
AutocompleteOf. Das wird es nicht sein.
ARIA AutocompleteList
Spellchecking
Was...
Was macht dieser
Kram da? Was macht das
hier? Weg.
Roll ComboBox.
Weg.
Weg.
Weg. Okay.
Funktioniert immer noch nicht.
Warum geht
Vor und Zurück in diesem Input nicht?
Das ist ein ganz normales Input.
Disabled.
Cursor not all owned. What?
Weiß nicht, was
es sein soll, aber...
Ah ne, das ist nur, wenn es disabled ist.
Placehold. Daran kann es
jetzt ja auch nicht liegen.
Autocom...
Typ Text?
Macht aber... Das ist eigentlich
Default?
Sowas nervt mich, ey.
Irgendwo. Woran
liegt das, dass das nicht funktioniert?
Okay.
Autocomplete wird es auch nicht sein.
Autocorrect wird es auch
nicht sein. Spellchecker.
Wird es auch nicht sein?
Ne.
Weil wenn ich jetzt, nur mal so zum
Vergleich, ne. Wenn ich da
selbst ein Input drunter mache.
Was, äh...
Class...
So, muss ich anders machen.
Ne, wartet mal.
Ich bin ja komplett falsch.
Wenn ich hier selbst ein Input drunter mache.
Class...
Breite 24.
Höhe 4.
Ah.
Da geht das mit Vor und Zurück.
Aber wenn man das mal sieht.
Border Red.
Dings, so.
Border.
Ne, wie geht das?
Border 1?
Äh. Radius?
Ne, ähm. Width?
Ne. Ah. Border.
Äh. Ich hab vergessen, wie man die...
Einfach so, gell.
2. Höhe.
8.
Oh, hier geht nämlich Vor und
Zurück. Und was ist der Unterschied dazwischen, man?
Warum geht hier Vor und Zurück nicht und in
meinem Inputfeld geht Vor und Zurück sowas?
Das, sowas nervt mich unglaublich.
Wenn so Basic-Sachen nicht funktionieren, ne.
Ob wir jetzt ein bisschen davon
abkommen, aber das nervt mich.
So.
Woran könnte das
liegen?
Also an diesem ganzen... Das muss dann an irgendwelchen
Events liegen, wo der Typ dran
subscriben. Da kann ich nix, da kann ich nix
dran ändern.
Da geht zwar nix, aber das muss
das muss an irgendwas
an irgendwas hier liegen, ja.
Okay. Das
verwende ich nicht. Sowas fuckt
mich ab.
Vor allem kann mans auch nicht, kann mans auch nicht einbauen.
Weg damit!
Bam! Wird nicht verwendet.
Kein, kein
Input-Command. Weg.
Piss dich,
Alter. Command und Dialog
fliegen raus. Zack.
Ah.
Alles, alles wieder weg.
So, was haben wir sonst noch für Komponenten?
Wo sind wir stehen geblieben überhaupt?
Combo-Box.
Ne, Command sind wir
stehen geblieben. Okay, Command.
Command ist Schrott. Funktioniert nicht richtig, weil
pos, pos 1
und Ende nicht funktioniert.
So, was haben wir noch? Context-Menü.
Displace a menu to the user
such as set of...
Right-Click here.
Okay, Left-Click macht schon mal nix.
Okay, es ist ein...
Ja.
Context-Menü.
Hab ich ehrlich gesagt auf Webseiten
enorm wenig Verwendung für. Ihr auch?
Oder wie sieht's bei euch aus?
Weil ich finde, ich finde, meine persönliche
Meinung ist, Rechtsklick überschreiben
ist so ein, wie nennt man das so schön?
Anti-Pattern. Ich finde
Rechtsklick sollte gefälligst halt immer Rechtsklick
sein. Es gibt ganz wenige
Ausnahmen, wo ich mir Rechtsklick
überschreiben
gefallen lasse. Das ist zum Beispiel so
DrawIO und sowas in der Richtung.
Ja. Da lass ich mir das gefallen
hier Rechtsklick zu überschreiben, weil das ja eben
ne Grafikdesign
Visio-Klon-Geschichte
ist. Aber
für 99% der Webseiten
finde ich Rechtsklick überschreiben ne doofe Idee.
Trotzdem, trotzdem ist gut.
Trotzdem ist gut. Ja,
suchen nervt mich auch immer
richtig. Wisst ihr,
was mich die letzten Jahre
immer zunehmender nervt?
Ist die Verbreitung von
Diskurs oder wie das heißt.
Forum.
Wie heißt das Ding?
Diskus.
Diskus. Ja.
Genau.
Forum. So.
Das ist so nervig,
weil.
Home Assistant hat das zum Beispiel.
Home Assistant Forum.
So. Und das ist
so nervig.
Du machst hier beispielsweise was aus.
Ist doch Diskurs.
So, du machst hier zum Beispiel was auf.
So, nimmst, machst hier irgendwie, keine Ahnung, irgendwie
dieser, hier, dieser Thread
machst du auf, wie in nem Forum.
So. Und jetzt scrollst
du hier durch und sagst
Ah, ich würde gern
mal checken, wie oft das Wort Integration
hier drinne vorkommt.
Und jetzt haben die Steuerung
F überschrieben.
Und dann suchst du hier nach Integration
und
das ist halt nicht so das, was ich, was ich erwarten würde.
Ja, letztendlich ist es das,
was man haben will. Und dann geht's
wieder zu, wenn du da drauf klickst.
Dann musst du es wieder offen machen.
Das ist super abfuck. So, man kann das ganze
austricksen, indem man hier oben auf die
Leiste geht und sucht Integration.
Das Ding ist nur,
das funktioniert
auch nicht richtig, weil,
weil
dieses Forum
nicht alle Posts lädt.
Dieses Forum lädt nur, keine Ahnung,
20 Posts und dann, und dann
muss es quasi Endless scrollen.
Das heißt, wenn ich hier unten bin,
wenn ich hier unten bin,
dann finde ich,
wenn ich so mit der normalen Suche,
mit der normalen Suche suche,
Sachen aus dem allerersten Post nicht mehr.
Für mich ist
dieses Ding der
Inbegriff von abfuck bei
modernem Webdesign.
Warum brauche ich JavaScript für einen fucking
Forum, was Posts
anzeigt? Mit Endless scroll.
Endless scroll ist der
größte Scheiß, den Sie sich die
letzten 20 Jahre im Webdesign ausgedacht
haben. Ich hasse
unendlich Endless scroll. Endless scroll
ist so ein Shit.
Guck ich das mal an.
Guck ich das mal an.
Was eine Dreckseide, Mann.
Endless scroll.
So ein Scheiß.
Ja, schön, aber da finde ich jetzt auch nicht alles
drin. Du musst ja mit dieser hässlichen Suche
hier drinnen suchen.
Endless scroll ist einfach nur
richtiger Scheiß.
Mehrere Seiten mit Strg F suchen geht halt
auch nicht.
Du hast recht, das funktioniert nicht. Mehrere Seiten
mit Strg F suchen. Aber eine Seite
mit dem Text drauf funktioniert.
Und
es gab Zeiten,
da konntest du in einem Forums Post
auf Seite 150
springen und bist dann immer auf der
gleichen Seite rausgekommen.
Und jetzt guck dir das mal an.
Endless scroll unter meinem Video.
Hier, Video von mir. Letztes Video.
Wenn ich sage, ah ok.
Da hat auch vor 3 Tagen
einer was cooles gepostet.
Das heißt, das müsste so auf Seite 5
sein. Ja, geh mal hier auf Seite 5.
Du kannst
YouTube Kommentare nicht durchsuchen durch
Endless scroll.
Weil es erst lädt, wenn du da bist.
Ja.
In einem Forum kannst du wenigstens
noch die Seiten durchklicken.
Bei YouTube Kommentaren
und bei YouTube Kommentaren
Ich will nicht das
gucken, Alter.
Bei YouTube Kommentaren musst du erst
alle Kommentare laden,
soweit wie geht. Und dann kannst du suchen.
Das ist so beschissen.
Ich hasse das.
Das ist so echt Endless scroll
und diese Sachen mit diesem...
Das geht mir so auf den Sack bei modernem
Webdesign. Und
das andere ist, früher hatten
Foren unten so einen Knopf,
da konntest du sagen,
10 Posts pro Seite, 50 Posts
pro Seite, alle Posts pro Seite.
Und ganz ehrlich, wir haben heute
Kisten mit
12-Kern-CPUs,
4,8 Gigahertz pro
Core,
64 Gigabyte RAM.
Da kann mir doch keiner erzählen,
dass ich keine
problichen 116
Posts in meinen RAM
reinkriege und das anzeigen
lassen kann auf der Webseite.
Das konnte ich vor 35
Jahren anzeigen lassen.
Na okay, 30 Jahre, ein bisschen übertrieben.
Hahaha.
25 Jahre.
Ja, weil
vor 30 Jahren war das so mit Internet und so.
Aber, vor 25
Jahren, da war 1999,
da war das
schon so.
Da konnte ich mir ohne Probleme
116 Posts in einem Forum anzeigen lassen.
Überhaupt kein Ding.
Das ist so eine unnötige
Ver...
Verstrickung von
Technologien, die eigentlich
für das, sagen wir mal, für das probliche
Anzeigen von Posts
nicht bräuchte. Okay.
Und irgendjemand hat dann Reddit
auf den Plan gerufen,
das Ganze noch schlechter zu machen.
Hahaha.
Reddit hat Endlesscroll.
Reddit hat, also, ne? Reddit hat
nicht nur Endlesscroll, du kannst auch noch nicht mal
Posts mehr richtig aufmachen.
Also im
neuen Reddit-Design.
Weil wenn du hier auf Reddit...
Wenn du hier auf Reddit was aufmachst,
dann hast du das Problem,
dass hier dann auf einmal
die Dinge eingeklappt sind.
Wenn ich jetzt...
Ja, man kann, glaub ich, irgendwie, irgendwo
oder mit Zusatz kann man, glaub ich, alles expanden
oder so. Frag mich gar nicht, wo der Button dafür ist.
Und wenn ich jetzt hier drinnen suchen möchte,
nach irgendwas, dann geht das doch nicht mal, weil die
Dinger gar nicht geladen sind. Ihr seht's,
guck, die Posts werden geladen,
wenn ich die das erste Mal aufmach.
Deswegen, das einzige, wie man Reddit
benutzen kann, ist tatsächlich...
Old Reddit.
What?
Old Reddit.
Ich mein, ist das ernsthaft zu viel
jetzt für meinen Browser, diese...
Diese 98 Posts anzuzeigen?
Ist das echt zu viel?
Why does Frankfurt still have a bad reputation
with Germans? Naja...
Nicht nur Germans, oder?
Geht da schon wieder ab.
Ich glaube, Frankfurt Bahnhof hat überall eine bad reputation.
Außer die Leute, die den ganzen Tag
da rumchillen
und auf der Straße
hocken und so. Die haben halt keine andere Wahl
wahrscheinlich. Für die hat das keine
bad reputation.
Oder die Dealer am Hauptbahnhof, die finden das geil.
Aber ansonsten
hat Frankfurt Hauptbahnhof zu Recht eine schlechte
Reputation. Okay.
So, jetzt hab ich ein bisschen gerantet über...
Machen wir mal Dark Mode an, ist mir alles zu hell hier.
Bisschen gerantet über
Endless Crawl, aber das ist ohne Scheiß Endless Crawl,
es ist der...
mit die beschissenste Entwicklung
von so Webdesign
Semi-Standards
der letzten 20 Jahre.
Eigentlich sind es eher so der letzten
10 Jahre.
Der letzten 10 Jahre hat sich das so etabliert
erst.
Das ist kein Standard,
aber wisst ihr, wie ich meine, das ist so ein
Semi-Standard. Das machen fast alle
und es fuckt mich fast überall ab.
Was du verpasst hast,
wir haben festgestellt, dass
das Command-Menü Home
und End-Taste nicht funktioniert.
Deswegen werde ich es nicht benutzen.
So, also jetzt haben wir hier ein Context-Menü.
Das werde ich wahrscheinlich nicht brauchen.
Und wir haben Endless gescrollt.
Data Table. Oh, das ist cool,
dass die sowas drin haben. Braucht man selten,
aber wenn man es braucht, ist es nice.
Das ist auch so ein advances
Ding, was ganz vielen UI
Component Library Frameworks fehlt.
Ich persönlich benutze die Dinger nie,
weil die immer
irgendwas so machen, wie ich es nicht haben will.
Und ich baue den Filter meistens selbst.
Aber es ist cool, dass es es gibt.
Suchen wir mal zum Beispiel nach
Success. Ah ne, geht nicht.
Man kann nur nach E-Mails suchen. Ken.
Oder nach M. O.
Achso, M, weil Mail.
R.
Okay, Pfunst.
Wie performant dieses
Ding ist,
mit 50.000 Einträgen,
sei mal dahingestellt.
Kann man selecten.
Das ist
nicht richtig darkmoded,
die Selectbox. Kann das sein?
Oh, doch.
Das ist Absicht.
Absicht, dass die Selectboxen
hell sind.
Aber eigentlich ganz schick gemacht.
Finde ich eigentlich ganz gut.
Also wenn man sowas braucht, dann ist es nice.
Ja, man kann auch hier
eigentlich ganz hübsch gemacht.
Werde ich wahrscheinlich nicht brauchen.
Aber gut, dass es da ist.
So, Date Picker. Das hatten wir schon.
Äh, stand das nicht vorher noch?
Unter Kalender?
Leider haben die keinen Time Picker.
Ja.
Sehe ich auch so.
Jist.
Dialog.
Das hatten wir schon.
Da gibt es ein Popup.
Haben wir auch schon gecheckt, mit was das gemacht wird.
Ich glaube noch mit einem Diff, genau.
Aber immerhin, immerhin haben sie es ganz schön
gefadet, Hintergrund. Und vor allem
kann man rausklicken und es geht wieder zu.
Draw.
Okay, da fadet von unten was ein.
Was ich sehr
merkwürdig finde ist, dass die ganze
Seite sich movt, wenn das
einfadet. Findet ihr das nicht auch
irritierend?
Dass die Seite irgendwie runterrutscht,
wenn der Drawer rausrutscht.
Ich glaube die Seite wird einfach
nur auf 80% skaliert, kann das sein.
Ich glaube die Seite wird einfach nur kleiner.
Okay, whatever.
Da passiert drinne.
Dann haben wir so ein
Dropdown Menü.
Was erstmal
nach oben geht.
Wie man das von einem Dropdown Menü erwartet.
So geht es
jetzt runter. Ah ja, so geht es runter, okay.
Es hat mich erstmal irritiert,
dass ein Dropdown Menü nach oben geht.
Aber das geht immer
dorthin, wo
es Platz hat dafür.
Und jetzt ist die
Frage, was passiert, wenn es keinen
Platz mehr hat.
Da geht es nach oben.
Und es ist
ihm einfach egal.
Und wenn er unten am meisten Platz...
Okay, das ist...
Das ist schon mal gut gemacht.
Probe bestanden.
Selbst wenn nicht alles drauf passt, aber unten
mehr Platz ist, geht es unten auf.
Ja, sehr gut mitgedacht.
Schätzen Entwickler.
Entwickler Teams.
EntwicklerInnen.
Wie man das so sagen muss, korrekterweise.
Freude.
Ich aber keinen Bob drauf habe.
Das haben...
Da haben sie gut mitgedacht.
Entwicklende.
Da habe ich auch gerade dran gedacht.
Entwicklende.
MWD.
Dann haben wir alle dabei.
Schätzen
Entwicklende MWD.
MWX.
Aber das haben sie gut durchdacht.
Und mit Popup Menü, okay.
Werde ich auch nicht brauchen, aber gut, dass da ist.
Boah, nee. Forms habe ich jetzt keinen.
Forms sind immer abfuck. Egal wo.
Aber kann ich hier nach vorne...
Hier kann ich nach vorne und hinten scrollen.
Irgendwas ist da grundlegend kaputt.
Warst du schon immer programmieraffin?
Immer nicht, aber lange schon.
Warte mal kurz. Was schreibt das?
SoulFoxer.
Warst du schon immer programmieraffin?
Ich kenne das fast nur so, dass
Leute, die eher Administration machen,
ein bisschen Kacke finden, außer eventuell Automation
oder so. Ja, das sind Noobs.
Es ist meine Erfahrung.
Leute, die nicht gewillt sind,
also kein Interesse daran haben,
über den Tellerrand rauszugucken
und sich von der einen Sache nicht für die andere
Sache interessieren, sind in der Regel Noobs.
Skillissue.
Es geht übrigens in beide Richtungen.
Entwickler,
die außerhalb ihrer Idee
nichts kennen und nicht mal
in ihrem Leben ein Docker-Image
gebaut haben, sind Noobs.
Meistens.
Also so fürs große Ganze,
so im großen und ganzen Kontext gesehen.
Sicherlich können die in der
einen Sache schon ein bisschen Ahnung haben,
aber in der Regel sind es Noobs.
Das sind meistens auch die gleichen Leute,
die, wenn es ein neues Tool gibt, sagen,
das kann ich ohne Schulung nicht benutzen.
Kennt ihr so Leute? Es gibt ein neues Tool
und ihr denkt euch, finde ich kacke
oder ihr denkt euch, finde ich ganz gut
oder wie auch immer.
Aber dann hast du Leute, die sagen,
oh, das werde ich nicht benutzen ohne Schulung.
Das kann ich nicht benutzen ohne Schulung.
Das finde ich immer so affig.
Bei uns gab es auch letztens
wieder Diskussionen,
die haben sich irgendeine neue
Push-Notification
App gekauft,
sodass man jetzt nicht mehr per SMS
über Systemausfälle
notifiziert wird,
sondern dass man jetzt
Push-Messages kriegt.
Du kriegst halt so eine App aufs Diensthandy
gepusht, äh,
nicht gepusht, kriegst du eine App aufs Diensthandy
installiert und das geht dann halt
über irgendeinen Push-Notification
Anbieter.
Da haben sie sich irgendein Premium-Package gekauft
mit was weiß ich, 150.000 Messages
im Monat oder keine Ahnung.
Und da brauchst du halt die App von denen und dann kriegst du Push-Messages.
Ist ganz cool gemacht, muss ich sagen,
ist ganz cool gemacht, weil
du kannst damit deinen Schichtplan
synchen
und wenn der Schichtplan gesyncht ist,
kommt nur derjenige automatisch
Critical Notifications nachts,
der im Schichtplan als
Nachtschicht eingetragen ist.
Eigentlich ganz cool gemacht.
Wahrscheinlich viel zu viel
Geld gekostet für eine
kleine easy Sache, aber ist egal.
Eigentlich ganz gut gemacht.
Und die App ist super selbsterklärend.
Du machst die App auf,
da hast du einen Knopf,
Schichtstart.
Es ist ein bisschen, ist das nicht Opsgenie?
Es ist ein bisschen wie Opsgenie.
Ganz so umfangreich, ein bisschen in der Richtung.
Ja, die App ist super selbsterklärend.
Machst auf, hast einen Knopf,
Schicht starten, Schicht beenden
oder
du kannst noch
in deine Settings gehen.
Die haben API-Docs und sowas.
Aber im Prinzip hast du einen Knopf,
Schichtstart, Schichtende und
du kannst dir anzeigen lassen,
wer gerade Schicht aus deinem oder anderen Teams hat.
Das ist alles.
Es ist wirklich super
selbsterklärend.
Ich bin auch gleich jemand, der gemeint hat,
ich weiß doch gar nicht, wie das geht.
Ich kann das doch nicht benutzen.
Ich hatte da noch gar keine Schulung drin.
Alter!
Es ist eine App mit drei Dingern zum Klicken.
Was soll man denn da schulen?
Und aus meiner Erfahrung
sind das halt Noobs,
die nicht schaffen, von ihrer eigenen Sache
ein bisschen über den Tellerrand rauszukommen.
Das sind Entwickler, die es nicht schaffen,
sich außerhalb von Eclipse oder IntelliJ,
da bin ich ja schon froh, wenn es IntelliJ ist,
zu bewegen. Oder Admins,
die nicht in der Lage sind,
drei Zeilen Skript oder
vielleicht mal irgendwie ein Python-Programm
oder ein Go-Programm zu lesen.
Sie müssen ja gar nicht unbedingt selbst komplett programmieren.
Das erwarte ich ja gar nicht.
Aber lesen und verstehen, was da abgeht,
würde ich schon erwarten.
Und die, die das interessiert,
das sind in der Regel auch keine Noobs.
Ja, und wie das bei mir war,
also ich war selbstverständlich nicht schon immer
programmieraffin.
Also ich habe angefangen mit Computerzeug basteln
damals mit
also mein erster eigener Computer
war ein
ich glaube ein Pentium 90.
Ich bin mir nicht ganz sicher.
Das war aber gar kein Pentium 90.
Das war irgendein AMD Fake Pentium 90.
Mit Windows 95 und Star Office damals.
Ja, und ich habe damals unglaublich gerne
an Hardware rumgebastelt
und alles mögliche ausprobiert
auf der Kiste.
Und da habe ich dann
die Idee,
dass ich dann
einen DSL-Anschluss sehe.
Und später dann,
wir waren einer der ersten in Hanau,
die einen DSL-Anschluss hatten.
Die Story habe ich schon öfters erzählt,
muss ich jetzt nicht wieder machen.
Gibt sogar ein eigenes Video zu.
Zu der DSL-Story.
Zumindest, da habe ich mich auch hauptsächlich
fürs Basteln damit interessiert.
Das höchste der Gefühle war,
was habe ich damals gemacht?
Ja, das höchste der Gefühle war
das Computer zu verwenden.
Wo man dann beispielsweise
irgendwie was in Games
automatisch klicken konnte und sowas.
Das war eigentlich das höchste der Gefühle.
Aber
schon lange bevor ich
diesen Kram beruflich gemacht habe,
habe ich mich angefangen
fürs Programmieren zu interessieren.
Zwar lange nachdem ich angefangen habe,
mich generell für Technik und Computer
und Gebastel zu interessieren,
aber lange bevor ich angefangen habe,
habe ich angefangen mich fürs Programmieren zu interessieren.
Ich habe damals angefangen,
also wir hatten
wir hatten damals in der Schule
oder in der
nicht mehr in der Realschule,
sondern ein zweiter,
was ich nie fertig gemacht habe,
aber das ist eine andere Geschichte.
So, hatten wir einen
Programmierkurs und
der Lehrer war super pepega.
Der war damals schon
richtig so Hardcore-Linux-Fanatiker.
2002
oder so.
Könnt ihr euch vorstellen, wie advanced
das damals schon gewesen ist.
Also, das war noch recht frisch.
Ich glaube, das war noch
Suse. Wann kam Suse
Linux 4?
Wann kam Suse Linux 4 raus?
Ich glaube, das war nämlich ein Suse Linux 4.
Nee, nee, nee.
Sicherlich 1994. Da garantiert
nicht.
Wann kam das erste Suse Linux raus?
Ja.
Hä?
Nee, nee, nee.
1996 war das nicht.
Das ist zu früh.
Dann war es vielleicht Suse Linux 6.
Ja, Suse Linux 6 ist wahrscheinlich.
Ja, ja.
64 oder sowas.
Irgendwie so in dem Dreh hier muss das gewesen sein.
Irgendwie so in dem Dreh hier muss das gewesen sein.
So 98, 99, 2000.
Und da hatten wir einen Programmierkurs.
Der Programmierlehrer, der war damals schon richtig
so Hardcore-Linux-Fanatiker.
Und der hat natürlich auch nur C programmiert.
Und der hat mir tatsächlich
nicht etwa die Lust am Programmieren
beigebracht, sondern, dass ich es nie in meinem Leben
machen möchte.
Weil der so unfähig war, Sachen ordentlich
zu erklären.
Und du kannst nicht Programmier-Noobs,
die überhaupt gar keine Ahnung haben, was sie machen,
auf irgendwelche
Linux-C-Sachen loslassen.
Das Problem
ist gar nicht so sehr, dass C an sich kommt.
Aber ich glaube, dass das
super kompliziert wäre von den Basics.
Ich glaube, es gibt kaum eine simplere Sprache
vom Umfang her als C.
Sondern dass du einfach keine Ahnung hast,
weshalb du das gerade machst.
Wisst ihr, wenn ihr nicht wisst,
warum ihr das eigentlich macht,
dann interessiert euch in der Regel
auch nicht das, was ihr gerade macht.
So.
Und dann hatte ich überhaupt keinen Bock.
Null.
Danach. So.
Aber.
Als ich die ganze Sache dann abgeblasen
hatte und keinen Bock mehr darauf hatte,
hatte ich dann irgendwann so 2002
oder so, hier so in dem Dreh,
hab ich
mein,
versucht, mein aller allererstes
Programm selbst zu programmieren.
Und zwar war das ein
Logparser für, wer hätte es gedacht,
Dark Age of Camelot.
Und der Sinn war,
das Spiel gibt es
heute übrigens immer noch,
und ich spiele das
auch immer noch.
Und zwar hier auf dem Eden-Free-Chart.
Zumindest,
das ist ein MMO gewesen,
das am Anfang die Beschränkung hatte,
das gab
Release-Date, das war 2002
oder so,
kam das raus.
Ja, in Deutschland, in Europa 2002.
So.
Und als das Game neu war,
konntest du aus
Anti-Cheat-Protection-Gründen
keine Ahnung, was die sich gedacht haben dabei,
konntest du das nicht
minimieren. Also du konntest das nur
starten, und sobald du es minimiert hast,
hat es sich automatisch geschlossen.
Das haben die zur Cheat-Prevention
gemacht.
Du konntest quasi deinen Rechner, während du
gespielt hast, für nichts anderes
benutzen, weil
es nur Fullscreen spielbar war.
Voll für den Arsch. Komplett für den Arsch.
Ja. Es gab damals auch schon
Tricks, das zu machen.
Das zu umgehen. Zumindest,
was ich damals gemacht habe, ist,
ich habe versucht, einen Log-Parser
zu programmieren, weil man konnte
in dem Spiel Chatlogging
einschalten, und das hat auch die eigenen Messages
mitgeloggt. Und ich hatte
dann vor, quasi sowas wie, ich wusste damals
nicht, dass es so heißt, ich wollte so
eine Art Dark Edge of Camelot
Shell programmieren. Ich wusste damals nicht,
dass man sowas Shell nennt. Ich wollte damals
quasi in Chat schreiben können, sowas wie
Music Next,
zum Beispiel. Das hätte,
wäre in der Log-Datei gelandet,
und dann hätte mein Log-Parser
das erkannt, und hätte
in meinem Musik-Player auf Next
gedrückt, so. Weil ich konnte das
Spiel ja nicht minimieren.
Und deswegen habe ich sowas gebraucht in der Richtung.
So. Das waren meine allerallerersten
Versuche, was zu programmieren.
Es hat nie richtig funktioniert, muss ich
dazu sagen. Mein Fehler war auch,
ich habe das natürlich mit C probiert zu
programmieren, weil C das einzige war,
was ich mal gesehen hatte in der Schule, und ich
irgendwie auch dachte, dass, ja keine Ahnung, das wäre das einzige
oder so. Und wenn ich auch mal Text
Parsing versucht habe mit C,
ohne, ich vergesse es.
Hier, Gets
und Parsen und
und was ist, Scan F
und keine Ahnung, was da nicht alles gibt.
Und es ist für den Arsch. Das hat nie richtig
funktioniert, das war abfuck.
Komplett für den Arsch. Richtig eklig.
Zumindest.
Daraufhin
ging das bei mir los mit, dass
mich Programmieren interessiert hat.
Denn ich habe C erstmal
über Bord geschmissen, und
habe mir damals C-Sharp angeguckt.
Ne, das stimmt nicht. Das stimmt nicht.
Ich habe mir als allererstes
ein Python Buch gekauft damals. Das war
Python, frag mich nicht, 2.1
oder sowas. Ja,
kommt ungefähr hin.
Python 2.1 war das. Habe ich mir
damals ein Programmierbuch gekauft auf Amazon.
Habe das durchgeblättert
und durchgelesen und
ausprobiert. Und
Jaja,
wie gesagt, das war 2001 oder so.
Und da habe ich mir dann gedacht,
ey, ist doch eigentlich ganz nice.
Was ich an Python damals richtig geil fand,
ist, dass du nicht schreiben musstest
int plub gleich 1, sondern einfach nur
schreiben konntest, plub gleich 1.
Ich habe damals gedacht, Typsysteme
beziehungsweise statisch getypte
Sachen sind bloat.
Weil ich halt null Ahnung davon
hatte.
Hey, guck mal, ich habe jetzt die Auswahl
zwischen der Sprache, da musst du schreiben
int plub oder nur plub.
Dann ist logischerweise nur plub natürlich besser
als int plub.
Obviously ist das besser.
Und dann habe ich ein bisschen Python
gebastelt. Dann war das Ding aber,
also ich habe wirklich tatsächlich
schon 2001 so die
absoluten Basics mit
Python gelernt.
Das Problem dabei war nur,
dass du mit Python nichts machen konntest.
So wirklich, was ich machen wollte.
Ich wollte damals keine
Kommandozeilenprogramme machen.
Wozu?
Was mir damals vorgeschwebt ist,
ich möchte gerne so ein paar
Windows Gui, also
Windowsprogramme mit grafischer Oberfläche
machen.
Fragt mich bitte nicht mehr was, keine Ahnung.
Weiß ich nicht mehr.
Bastelzeug. So. Und daraufhin
habe ich dann angefangen mit C Sharp.
Es kam nämlich da gerade raus.
Auch so alles in dem Dreh.
Und
haben die hier eine History? Genau.
Hier.
Ich weiß noch, als ich dann mit
C Sharp angefangen habe zu basteln,
als ich dann mit C Sharp angefangen
habe zu basteln, das dürfte so
in dem Dreh hier gewesen sein,
da weiß ich, dass
ganz neu,
ich weiß nicht, ob es Preview war
oder angekündigt war, es war
ganz neu,
Generics. Und Generics
kam mit C Sharp 2.
Also das habe ich, nachdem ich ein bisschen
C Sharp gemacht habe, habe ich das mitbekommen,
dass demnächst dann super
krass tolle neue Versionen rauskommen, die
Generics unterstützt.
Nicht, dass ich damals irgendeinen Plan gehabt hätte,
was Generics sind, aber
das habe ich gelesen und habe mir gedacht, okay,
das ist die Sprache der Zukunft,
weil
die ja voll gepusht wird
jetzt und neue Versionen
rauskommen und so und
macht auch Bock.
Tatsächlich war C Sharp
die erste Programmiersprache, die mir so richtig
gut gefallen hat.
Vom Handling.
Auch vom Umfang,
von den Standard-Frameworks her und sowas, fand
ich damals schon, als richtiger
Noob, der keine Ahnung hat, 2003,
fand ich das eine richtig coole Sache.
Ja, und dann habe ich
weitergebastelt, weitergebastelt, da kam dann
irgendwann C Sharp 2 und da waren halt Generics ganz
neu, kann ich mich noch dran erinnern,
so irgendwie 2005 rum dann.
Ja, und dann habe ich ganz viel C Sharp
gemacht und ich muss sagen, ich habe zwar
mittlerweile jede Menge andere Programmiersprachen
mir angeguckt, von Rust bis
Ruby, Go, sonst was, ich persönlich
mag aber C Sharp immer noch.
Am liebsten.
Ich weiß nicht, ob es daran liegt, dass es die Sprache
war, mit der ich so richtig angefangen habe zu programmieren.
Wahrscheinlich nicht, sondern es liegt
wahrscheinlich einfach daran, dass es eine wirklich gute Sprache
ist. Und ich habe lange Zeit
dann auch Ruby on,
Ruby on Rails
gebastelt, hier so rum.
Ruby on Rails kam mir dann so hier so irgendwie
in den,
dem Dreh, glaube ich, so raus
dann auch.
Mittlerweile ist es ja komplett,
niemand, niemand benutzt das mehr.
Ja, und so sah das bei
mir aus. So, und hier habe ich dann
angefangen, so in dem Dreh,
habe ich tatsächlich auch angefangen, das ganze beruflich
zu machen. Also ich habe
quasi schon so,
was habe ich jetzt, 2001,
also ich habe quasi schon so fünf, sechs
Jahre angefangen,
mich damit zu beschäftigen, bevor ich dann
tatsächlich beruflich in dem Bereich
gearbeitet habe. Wobei ich ja, wie gesagt,
ich arbeite ja nicht beruflich als Anwendungsentwickler.
Und ich habe auch eine Ausbildung angefangen
als Fachinformatiker Systemintegration,
hier so irgendwie in dem Dreh rum.
Hier so, da so.
Und, äh, trotzdem
hat es mich weiter interessiert,
bis heute.
Enjoy Shopify, nicht noch Ruby.
Das kann schon sein, GitHub ist auch
noch immer Ruby und mich würde nicht wundern,
wenn GitLab nicht auch noch,
wenn GitLab
nicht auch noch auf
Ruby Basis wäre.
So, sollen wir mal gucken.
Gems, ja, ja, das ist noch auf Ruby Basis.
Was ich beruflich mache,
guck mal bei mir auf YouTube, da gibt es
ganz viele Videos, da ist noch Ruby,
ganz viele Videos dazu.
Ich bin mittlerweile Senior Linux
Engineer. Hört sich cooler an, als es ist.
Ja, es ist Ruby, ja.
Immer noch.
Hätte mich auch gewundert, wenn man so grundlegende Sachen
ändert. Davor war ich Senior
DevOps Engineer,
aber letztendlich sind Jobbezeichnungen eh nur so ein bisschen Schall
und Rauch, weil ich mache schon sehr ähnliche
Sachen zum letzten Job.
Hier kümmere ich mich hauptsächlich um Automatisierung
und Cloud-Infrastruktur.
Also Automatisierung für
Cloud-Infrastruktur. So Sachen wie
Terraform zum Beispiel.
Zum Teil ein bisschen Ansible,
wobei man das glücklicherweise kaum noch braucht da.
Und generell um sehr viel
Containerisierung und Kubernetes.
Kubernetes.
Ja, so sieht das
bei mir aus. Lange genug jetzt.
SoulFoxer. Ich hoffe, ich habe es ausführlich
genug beantwortet. Ich habe jetzt irgendwie 20 Minuten
drüber gelabert.
Weißt du, ich bin 39.
Ja, ich kenne Leute,
die haben immer noch Eclipse, die sind darauf hängen geblieben.
Ja, doch.
Leute, das ist so.
Was soll ich euch sagen?
Das ist so.
Also mir fällt spontan mindestens noch ein
Java-Entwickler ein, der voll auf Eclipse schwört.
Das letzte Mal, als ich ihn gesehen habe
zumindest. Der Rest ist mittlerweile
auch IntelliJ. Gibt es noch Leute,
die NetBeans verwenden? NetBeans war ja noch mal
eine Zeit lang auch voll angesagt. Ja, doch, gibt es.
Ich kenne Leute, die benutzen Eclipse.
Und schwören da voll drauf.
Wie gesagt, mindestens
einer fällt mir spontan ein,
der voll auf Eclipse steht.
Und Java, ja, ist
auch, denke ich, ganz gute Einstiegssprache.
Da lernt man wenigstens
gleich, wie man Manager
Factories Single
Adapter
programmiert.
Ja, das war eines der Gründe,
warum ich keinen Bock auf Python hatte, weil das in dem Buch,
was ich hatte, richtig beschissen beschrieben
war.
Und
ich finde, der Typ, der das Buch geschrieben hat,
hat einen Fehler begangen.
Und zwar, der hat versucht,
GUI-Programmierung
und Objektorientierung
in Python in einem Kapitel
einzuführen.
Und man muss sagen, die eingebaute UI-Library
in Python ist schon Schrott.
Und Objektorientierung in Python ist
immer so gewöhnungsbedürftig.
Ne, da bin ich weit davon entfernt.
Ich habe beispielsweise
noch nie FORTRAN gemacht.
Ja.
Ja, ja. Dafür ist,
also generell für Microservice, Serverumgebung,
also Go hat
einen riesen Vorteil.
Und das sind Self-Contained
Binaries. Das kann Go so gut wie keine andere
Programmiersprache.
Das hat jetzt mit der Sprache an sich nichts zu tun,
aber Go
also die, das
Ganze
das was am Ende rauskommt,
das Binary, das ist so
das ist besser Self-Contained
als ich das von jeder anderen Programmiersprache kenne.
Go-Binaries kannst du nehmen.
Ich kann ein Go-Binary hier
auf meiner Linux-Kiste kompilieren
und das läuft
auf jedem Linux-System rückwirkend
bis Kernel
2638.
Also das ist quasi schon
keine Ahnung, 20 Jahre alt oder so.
Ey, ich kenn dich von Youtube.
Was kann ich sein?
Ich bin Wobblors, Mann.
Ja, wahrscheinlich auch besser.
Xcode ist Pains Champion.
Oje.
Da weißt du Bescheid.
Ey, ich hab keine Ahnung, ob man irgendwas gut oder schlecht
in Eclipse machen kann. Ich hab Eclipse.
Okay, Leute. Es muss jetzt sein.
Es
muss sein. Wir kommen nicht
drum herum.
Gibt es das überhaupt noch
zu installieren?
Eclipse. Okay, auf geht's.
Mal gucken, ob das immer noch so hässlich
und unbenutzbar ist wie früher.
Ich werde es nicht lange auf-
Ich werde es aufmachen, dreimal drinnen rumklicken,
klicken, feststellen, wie kacke es ist
und wieder schließen, aber
Eclipse gibt es nur noch aus dem Auer.
Ja, ist doch gut so.
Noch ein bisschen abschreckenderes Beispiel,
das zu installieren.
Ich gehe mal davon aus, IntelliJ gibt es gar nicht, oder?
Ach doch, tatsächlich.
Aufladen wir ein bisschen schneller runter hier.
Warum dauert
denn das so lang?
Das ist halt schon die- Das ist die volle Eclipse
Experience direkt von Anfang an.
Es ist langsam und eklig,
noch bevor die Installation fertig ist.
GN, das kommt
mir bekannt vor. Das hat man auch vor
20 Jahren irgendwann mal verwendet.
Irgendwie so ein G-Tick. Okay, passt mal auf,
hier, Leute. Eclipse.
Wenn ich das Logo schon sehe,
wo im Kreis.
Äh...
Und jetzt?
Welcome.
Aber man sieht nix. Okay, ist auch gut.
Nice.
Boah...
Wie ich das Ding hasse, Alter.
Ich finde bei Eclipsen die Einstellung hier
preferences.
Boah...
Alter, es sieht aus...
Es sieht aus wie hingeschissen,
Alter. Was ist das denn?
Das sind meine GTK-Einstellungen vom System.
Ja, aber meine GTK-Einstellungen
für System hat nichts
damit Probleme, außer Eclips.
Nichts. Alles sieht okay aus.
Ja.
Das sind meine System-GTK-Einstellungen.
Die sind auch
vollkommen okay.
Aber für Eclips nicht?
Boah, Dreck, Alter.
Rotz.
Snapshot. Revert.
Weg ist es wieder.
ABAP-Entwicklung.
Echt?
Ist Eclips die Standard-IDE
für SAP-Kram?
Ja, okay, ich geb zu. Ich bin's.
Exposed.
Was ist ein Self-Contained Binary?
Ein Binary, in dem
alles drin ist, was du brauchst, dass du es ausführen kannst.
Also zum Beispiel
kannst du das
von einem System aufs andere kopieren und dort
einfach starten, ohne irgendwas installieren zu müssen.
Und umso besser Self-Contained
es ist, umso weniger Probleme bekommst
du damit. Und in Go ist es halt
super easy. In Go kommt
ein Binary raus.
Oder quasi eine Echse, wie man das unter Windows
nennt. Und
das kopiere ich auf irgendeinem Linux-System
der letzten 20 Jahre und es läuft.
Das kann keine Sprache so gut wie Go.
Und es ist sogar easy, Go
in Go Binary
zu kompilieren
für von hier, was auf ARM
läuft. Genau. Ja.
Also das ist tatsächlich top.
An sich muss ich sagen, Go, die
Programmiersprache, ich bin kein allzu
großer Go-Fan. Es geht schon klar.
Irgendwo. Aber es gibt
so ein paar Dinger, die mich an Go
nerven. Ja.
Zum Beispiel ihre Geschichte mit
ja, benutze halt einfach Schleifen.
Was ich auch nicht mag, ist
diese
Geschichte mit
du kannst nichts auskommentieren, weil dann
kompiliert dein Go-Kram nicht mal richtig.
Auch nicht mal kurz zum testen.
Ja, drei verschiedene
Varianten, wie du Variablen
anlegen kannst.
Aber
die Generics habe ich jetzt noch nicht groß
ausprobiert, sah aber auch sehr hakelig aus.
Also ist
nix, keine
supergroßen
Sachen, dass man es nicht verwenden könnte. Aber es gibt
wie gesagt, so die paar Punkte, die nerven mich
an Go schon. Heißt
nicht so, dass es an C Sharp nichts gibt, was mich nervt.
Da haben sie gerade in den letzten Jahren auch ein paar Sachen
angebahnt,
die ich nicht so toll finde.
Das ist richtig, ja.
Bei Go ist das nicht so.
Deswegen ist Go auch so super portabel.
Ist Helix nicht
der neue Scheiß? Was ist Helix?
In den Texteditor?
Ja, Visual Studio Code
geht schon klar.
Okay, komm wir gucken uns das jetzt auch mal kurz an.
Das kenn ich noch von früher.
Naja, immerhin.
Immer hier kann man schon mal
alles lesen, ja.
Schon mal Vorteil vs.
Eclipse.
Benutzen möchte ich es allerdings auch nicht.
Aber
klein nochmal Revert Snapshot.
So, jetzt haben wir Snapshots
revertet.
Und jetzt löschen wir
die ganzen Snapshots auch mal, weil die unnötig
viel
Festplatten-Speicher
belegen.
Was geht ab?
Virtual...
Was geht ab?
Vor allem bei Workstation.
So viel ist da jetzt nicht passiert.
Okay, Snapshots.
Snapshots, zack, zack.
Delete, yes.
Weg damit.
Das VAR-Keyword
finde ich schlimm. Meinst du in Go?
Ja, das ist auch so eines der Punkte.
In Go kannst du ja schreiben VAR,
Blub gleich 1, du kannst schreiben
äh, Blub
Doppelpunkt gleich 1
und du
kannst schreiben. Es gibt drei Varianten,
wie du auf Go, wie du in Go Variablen
schreiben kannst. Fällt mir jetzt aber grad
nicht ein.
Nee, in C-Sharp ist VAR
nice, ja.
Was magst du an C-Sharp mehr als an Rust?
Das ist jetzt
ein Vergleich, der ist
vielleicht nicht so ganz fair,
weil ich denke, dass beide
Sprachen ihre Daseinsberechtigung haben
und
wenn sie auch Überschneidungen haben,
doch für
sehr entgegengesetzte
Sachen geeignet sind.
Ich bin eh der Meinung,
dass Rust nur ein ziemlich
beschränkten Einsatz,
nennt man das so,
einen sehr beschränkten
Einsatzzweck hat.
Auch wenn Rust mittlerweile für alles
irgendwie verwendet wird und super viele Rust-Fanboys
überall rumrennen und sagen, wir müssen alles
rewriten in Rust.
Sehr viele Github-Projekte,
die in Rust programmiert sind,
sehen für mich so aus, wie
die Rust-Community löst wieder Probleme,
die es nicht gibt.
Aber Hauptsache written in Rust
und...
Rust macht schon Sinn.
Aber nicht unbedingt
für alltägliche
0815-Software.
Also, zum Beispiel,
wofür Rust
komplett Sinn macht, ist,
wenn man sich mal anguckt, wo das herkommt,
das kommt ja von Mozilla,
und wenn man sich mal so einen Webbrowser anguckt,
dass Teile von einem Webbrowser
oder einer Browser oder die
ich glaube, eines der ersten Sachen, was Mozilla
in Rust gemacht hat, war glaube ich
die Firefox-CSS-Engine war irgendwie teilweise in Rust.
Und das macht natürlich enorm viel Sinn.
Das ergibt enorm viel Sinn,
so Sachen in Rust zu machen, weil
Rust hat
so einen Einsatzzweck, wo es
finde ich
nahezu unschlagbar ist.
Das sind Programme, die
kompromisslos performen müssen
und
gleichzeitig
schon zur Compile-Time
quasi alles ausschließen müssen,
was das Thema
Memory Safety angeht.
Also sprich, du möchtest quasi bei einem Programm
wissen, okay, das hat keine
Overflows, das hat keine
Threads,
die irgendwie out of scope gehen und sonst was.
Du willst
zur Compile-Zeit wissen, das Programm
verhält sich so,
wie es da steht
oder nach Möglichkeiten auch so, wie ich es mir gedacht habe
und es soll möglichst schnell sein.
In diesem Anwendungsfall ist Rust einfach
nice. Zum Beispiel,
wenn es um irgendwie
Software geht, die im Kontext von
irgendeinem Browser läuft oder so. Da ist das Sinn.
Ein Browser macht den ganzen Tag nichts anderes
wie quasi
fremde Sachen ausführen,
die nicht von dir sind.
Und
wenn man sagt, okay,
dort muss man besonders auf Security achten
und dort muss man besonders auf Performance
achten, das ist das, wo Rust
gut ist. Wo Rust aus meiner Sicht
nicht so gut ist, ist, um einfach
nur nach 15-er tägliche Software zu
programmieren, wie beispielsweise irgendwelche
Element-Tools oder sonst was, weil
und ich weiß, das sehen die ganzen Rust-Fans anders,
weil Rust doch
sich langsamer entwickeln lässt
und ein bisschen umständlicher zu entwickeln
ist und auch schlechter
zu lesen ist, wie
sagen wir mal
Go oder C-Sharp oder Ruby
oder Python oder sowas.
Das ist ein bisschen gewöhnungsbedürftig,
ja, aber du musst
aufgrund der Herkunft
von Rust, musst du
in Rust an Dinger denken, da musst
du in anderen Sprachen nicht dran denken,
zum Beispiel irgendwelche Laufzeiten
oder dass du beispielsweise
Lifetime
Declarations und sowas brauchst, bin ich
genau sicher, wie Dinger heißen,
dass der Rust-Compiler das frisst,
das brauchst du in keiner anderen Sprache,
also da musst du schon bei Rust dir ordentlich
Gedanken zu machen. Der Vorteil davon
ist, dass Rust die einzige
Programmiersprache ist, die mir einfällt,
wo du sagen kannst, ey, sobald
es kompiliert, macht es
in der Regel auch das, was es soll.
Das ist bei keiner anderen
Programmiersprache so gut wie bei Rust.
Das heißt nicht zwangsläufig, dass du
richtig gedacht hast, unbedingt immer, ja?
Aber bei Rust
Programm passiert selten
was Unvorhergesehenes.
Weil Rust
halt an vielen Stellen aufpasst, ja?
Du kannst in Rust nicht einfach
eine Variable out of Scope gehen lassen
irgendwie und dann
da wieder drauf zugreifen oder
das funktioniert in Rust nicht.
Oder irgendeinen Thread irgendwo mal starten und an der
Stelle, weißt du nicht, läuft er noch, ist er schon
beendet. Das geht in Rust einfach nicht.
Das lässt sich dann einfach nicht kompilieren.
Jo.
Also was ich, kommen wir mal zu der eigentlichen Frage zurück.
Also ich habe euch ein paar Sachen erzählt,
warum Rust nice ist. Also was
ich an C-Sharp mehr mag als an Rust
ist einfach die Geschwindigkeit, in der du da drin was entwickeln
kannst. Nicht im Endeffekt die
Ausführungsgeschwindigkeit.
Wenn du was, sagen wir mal so, jemand
der gut C-Sharp kann versus jemand der gut
Rust kann und du was
und beide was gut optimiertes programmieren
wird wahrscheinlich Rust
immer einen Ticken schneller sein.
Ich würde mal behaupten,
je nach Anwendungsfall ist es gar kein
so großer Unterschied dazwischen.
Du wirst natürlich Fälle finden, da
ist Rust um ein super krass Vielfaches
schneller.
Aber wenn man jetzt mal was nimmt, was jetzt nicht
wirklich der Worst Case ist für irgendeine Garbage
Collected Sprache
und nicht der Best Case für Rust, also irgendwas
0815 mäßiges und du hast
zwei Leute, der eine kann gut Rust, der andere kann
gut C-Sharp, würde ich sagen, okay
der, der gut Rust kann, kriegt es
bisschen performanter hin, aber
dafür ist der, das in C-Sharp programmiert, fünfmal
schneller fertig.
Muss man halt sich überlegen, was einem
da lieber ist.
Also die Entwicklungsgeschwindigkeit
finde ich in C-Sharp eindeutig angenehmer
und was ich auch in C-Sharp
umwelten besser finde, als in
Rust, ist die Standard Library.
Das .NET Framework. Was ja nicht mehr .NET Framework
heißt, sondern nur noch .NET.
Also quasi das
.NET Standard Lib.
Die Aussage,
die ist besser
oder umfangreicher als in Rust, ist noch
komplett untertrieben.
Rust ist fast so ein bisschen wie Javascript,
was das angeht.
Du brauchst erstmal 150
Dependencies.
Wir haben doch letztens hier WebRTC was gebaut
in Rust. Wo ist es denn?
Hier.
Was in Go und was in Rust.
Und Rust hat
Cargo,
das sind meine
Rust Dependencies.
Also bei Rust brauchst du wirklich auch
für jeden Scheiß Dependencies.
Fast so krass wie bei Javascript.
Nicht ganz so schlimm wie bei Javascript,
aber fast wie bei Javascript.
Also zu sagen, dass
die einfach nur umfangreicher wäre, die .NET
Standard Library, das ist ja noch übertrieben.
Die .NET Standard
Library ist einfach ziemlich komplett.
Mit nahezu allem, was man standardmäßig
so immer mal brauchen kann.
Ich würde sogar sagen, mit
mittlerweile fast schon ein bisschen zu übertrieben.
Ich meine, es gibt in der
C-Sharp Standard Library
5 oder 6 verschiedene Timer
Klassen, wo man sich auch denkt,
WTF Microsoft?
Aber immerhin hast du den
ganzen Kram in deiner Standard Library
dabei. Bei Rust nicht.
Also das ist echt...
Also die Geschwindigkeit, wie du was entwickeln kannst,
finde ich deutlich angenehmer in C-Sharp.
Die generelle Lesbarkeit
des Source Codes finde ich persönlich
viel angenehmer als in Rust.
Also finde ich in C-Sharp viel angenehmer als in Rust.
Und der Umfang der Standard Library
ist auch deutlich, deutlich,
DEUTLICH besser als von Rust.
Und ansonsten,
wenn man das jetzt nochmal vergleicht,
wenn du
so super memory
intensive Sachen machst,
wo du beispielsweise in C-Sharp
gefühlt in einem
Schleifendurchgang 150.000 Objekte
anlegen müsstest und wieder löschen,
beziehungsweise die dann irgendwann mal
der Garbage Collector aufräumen muss,
da ist es natürlich durchaus sinnvoll,
sowas unmanaged zu machen in Rust.
Wobei es da, und da muss man sagen, Microsoft hat
enorm viel unternommen,
was das angeht, in letzter Zeit.
Wobei es da mit
ähm...
Rekordstructs und
Ref und Spans
und sonst was in C-Sharp mittlerweile auch
viele Möglichkeiten gibt,
das sehr
performant zu machen.
Deswegen würde ich sagen, wenn du
zwei Leute ans gleiche Problem setzt,
der eine in C-Sharp
und der andere in Rust,
dann wird das Programm
von dem Typ in Rust am Ende vielleicht ein bisschen besser performen,
aber das C-Sharp-Typ ist
ein bisschen besser. Nicht wirklich
meilenweit besser, ja, ein bisschen besser.
Aber das C-Sharp-Typ ist fünfmal schneller
fertig. Und so viel schneller
wird die Rust-Geschichte nicht sein.
Ausnahmen bestätigen wie immer die Regel in beide
Richtungen.
Echt, war
Haskell jemals schon der heiße Scheiß?
Außer irgendwelche
weirdchamp-Leute auf
YouTube habe ich noch keinen erlebt,
der mir das schmackhaft machen wollte.
Wie gut ist die Sharp, was
Self-Contain angeht? Nicht so gut wie Go,
aber ziemlich gut mittlerweile.
Spätestens seit .NET 8
verbessern
die ihren Compiler immer weiter
und das geht mittlerweile auch ganz brauchbar.
Es geht noch nicht so geil und easy
wie in Go. Also in Go
sagst du Go Build,
kannst sogar noch die Plattform und alles angeben
und dann hast du ein Binary, was einfach
läuft. Egal worauf, rückwirkend auf
ein Linux-System von, hast du nicht
gesehen. Bei C-Sharp sieht es ein bisschen
anders aus. C-Sharp
hat zwei verschiedene Modi.
Hat mehr, aber prinzipiell hast du in C-Sharp
zwei verschiedene Modi, in denen du ein Programm laufen
lassen kannst. Du kannst es entweder
zu einem Binary
kompilieren
oder du kannst es zu einem Binary inklusive
Runtime kompilieren.
Das sind zwei unterschiedliche
Gut, du kannst natürlich auch
noch ohne Runtime kompilieren und dann die
Runtime zusätzlich installieren, aber wenn es um
Self-Contained geht, gibt es bei
.NET zwei verschiedene Varianten.
Kann ich dir auch mal zeigen.
Ich weiß, wir wollten eigentlich UI-Framework machen, aber
scheiß drauf.
Sidetrack beste.
Ich kann dir den Unterschied auch mal zeigen.
Machen wir hier mkdir.
Machen wir hier mkdir
was weiß ich, kekw, lul.
Hauptsache ich kann es mir noch merken.
Ja, beste. Kekl, kek, kek, kek, kek, kek.
Kwechamp, lul, kekwe, lul.
Alles klar, natürlich weiß ich immer noch sofort, welches
Projekt was ist.
.NET New Console,
Konsolenanwendung .NET, so eine ganz
popelige Konsolenanwendung, die
nichts macht, außer
Moment,
die gibt hello
cute chat
aus, ok.
So, jetzt kann man die ausführen,
.NET run und dann macht er ein bisschen
was und irgendwann kommt dann raus hello cute chat.
So. Und wenn du die jetzt
möchtest kannst du sagen dotnet publish release das ist das erste was du
machen kannst dann fällt hier unter bin release bla bla bla
fallen so ein paar sachen raus so was du feststellen wirst ist es fällt ein binary
raus es fällt eine dll raus im endeffekt werden hier alle dependencies drin
gespeichert und die das programm ist am ende auch nur 71 kilobyte groß manch
einer würde jetzt sagen 71 kilobyte für den hallo welt ist ziemlich klein
manch einer würde sagen ein 70 kilobyte für den hallo world ist ja riesengroß in der
dotnet welt würde ich sagen ist es ziemlich klein und das liegt daran weil
das nicht allein lauffähig ist wenn ich das jetzt versuche auszuführen dann
wird das funktionieren aber ja dann wird es funktioniert aber auch nur weil ich
die dotnet runtime hier installiert habe und er die finden kann
das ist das ist ein das ist ein dotnet binary ohne runtime das heißt ich muss
auf dem ziel system wo ich das ausführen möchte dotnet installiert haben das ist
also alles andere als selfcontained dafür ist es klein und das ist nicht
schlecht ja ist die runtime nein da ist nix da ist nix dabei
da ist nix dabei ach so du meinst das ist das ist quasi gegen die runtime
gelingt dynamisch wenn das so willst ja da steht auch drin dass du dotnet 8
brauchst dass das ausführen kannst sowas also wenn ich hier kein dotnet
installiert hätte dann würde das nicht funktionieren dafür ist das binary klein
und das ist gar nicht schlecht weil wenn du die beispielsweise auf den server
legst wo die runtime installiert ist und du willst dort 80 dotnet anwendungen laufen
dann kannst du das einfach machen brauchst die runtime nur einmal heutzutage nur so semi toll weil
du wirst es in irgendeinem container image packen und da laufen lassen aber
selbst da nachdem du ja das image erstellst kannst du einfach die
kannst du die runtime mit reinpacken und gut ist das ist übrigens auch der der
standard weg der den microsoft vorschlägt wie man so dotnet an dotnet
server anwendungen dann verpacken soll ja binary rein runtime rein in container
image und gut ist so dann gibt es schon relativ lange in dotnet einen weiteren schalter der nennt sich
in dotnet einen weiteren schalter der nennt sich
das problem ich bin mir nicht sicher ob ich die dinge jetzt richtig hinbekomme weil die
command line flags sind schon relativ weird ich glaube es ist minus minus self contained ist es
glaube ich so und wenn man jetzt hier hingucken wenn es jetzt funktioniert hat du siehst da liegt
jetzt deutlich mehr drin dort liegt jetzt alles drin was ich brauche um die software auszuführen
jede menge dotnet shit
jetzt kann ich keck w lul da drin ausführen und es läuft einfach auch auf systemen ohne installierte dotnet runtime
das problem ist nur 72 mb
von 71 kilobyte auf 72 mb
gibt's sowas wie copilot für die shell
du meinst jetzt nicht copilot aus der shell aufruf sondern für shell kommandos
boah du kannst chat gpt fragen danach aber was ist kill
was ist kill
was ich persönlich ganz gut finde ist explain shell das finde ich ganz nah ist ja wenn du zum
beispiel so was wie er so minus vtr trägst du das da ein und er erklärt hier welches kommando
was macht dass das finde ich ganz praktisch ganz ganz ohne ei ganz ohne 72 mb für selbst
content ist hart das ist aber halt die primitivste version für selbst content es ist im endeffekt ein
ordner mit runtime und das ist tatsächlich relativ portable dadurch weil es eben alles
mitbringt was es braucht so natürlich ist es ein bisschen doof dass es ein ordner ist wo alles rum
liegt das heißt das hat microsoft auch gecheckt dass das eine blöde idee ist und hat noch zusätzlich
eingeführt dass du nicht nur selbst content sagen kannst sondern publish single file aber das hier
mal weg weil es kann sein dass ihr runtime angeben muss
und dann hast du das gleiche bild dann hast du das gleiche wie vorher aber alles in einer datei
ist auch noch sehr portable kannst du auch auf nahezu jede linux geschichte der letzten zehn
jahre koppieren und es wird laufen ist ein bisschen umfangreicher als als aber das ist schon mal ganz
nice ja es ist zwar recht fett man muss sagen go binary mit ein paar dependencies auch relativ
fett vielleicht nicht 64 mb
fett, aber
je nach
den Dependencies so
20 MB
fängt an mit so einem Hello World. Wie groß
ist ein Go Hello World?
5, 6 MB mit allem dabei?
Weiß gar nicht.
Aus dem Kopf.
Warum das 64 MB ist? Weil die komplette
.NET Runtime da drin ist.
Der komplette JIT,
Code Generation, alles.
Komplette .NET Runtime ist da drin gebandelt.
Wenn du das
startest, passiert unter der Haube folgendes.
Die Anwendung wird in irgendein
temporäres Verzeichnis entpackt,
inklusive Runtime und dann wird
.NET Run drauf
gemacht. Ist die Größe
so wichtig? Ne. In der heutigen Zeit
würde ich sagen, ist die Größe nicht so wichtig.
Gar nicht mal. 64 MB ist
kein Ding. Viel wichtiger
ist, ob das schnell startet oder
nicht. Und man muss sagen,
die Startup Time, im Vergleich
zu Java zum Beispiel,
ist die Startup Time
von einer Self-Contained .NET
Anwendung gar nicht so schlecht.
Aber immer noch ziemlich schlecht.
User
Bin Time.
Wie? Ist das nicht installiert?
Tatsächlich habe ich nicht installiert.
Aber es braucht halt immer noch
Ja, man sieht es nicht richtig.
Es ist immer noch nicht
sonderlich schnell gestartet.
Es braucht irgendwie
immer noch, was ist denn das?
200...
Ne.
20, 20 Millisekunden und insgesamt
insgesamt 40.
Das 40 Millisekunden zum
ausführen.
Das ist halt nicht wirklich,
nicht wirklich schnell.
40 Millisekunden zum Start.
Moment, zumindest kommen wir mal
zu der eigentlichen Geschichte zurück.
So, das ist die Variante, wie du schon ganz
lang Self-Contained .NET
Anwendung machen kannst.
Und das ist nicht schlecht.
Die sind relativ gut portable.
Die kannst du, die kannst du im Endeffekt dahin
kopieren.
Wo halt .NET offiziell drauf supportet ist.
Und dann geht das halt.
Aber mittlerweile hat auch Microsoft festgestellt,
dass das vielleicht nicht mehr so das allergeilste ist.
Wobei ich jetzt sagen muss, jetzt kriege ich die Sachen
nicht mehr so richtig gut aus dem Kopf hin.
Microsoft hat aber auch festgestellt, dass es nicht
mehr das allergeilste ist.
Deswegen kann man jetzt seit .NET 5 glaube ich sogar schon,
aber so richtig gut geworden ist es erst seit .NET 8.
Kann man jetzt nicht nur sagen Publish Single File,
sondern man kann sagen Publish AOT oder sowas.
Das kann man doch von Hand irgendwie einschalten.
Tja, Microsoft Docs mal wieder, keck wait.
Checkt wieder keiner.
Checkt wieder keiner.
Publish AOT gleich true muss man setzen.
Okay, jetzt kannst du sagen, F-Sharp haben wir nicht gemacht.
Und jetzt kannst du sagen, seit .NET 8.
Du willst das hier machen.
Und jetzt kannst du sagen, seit .NET 8, du willst das hier machen.
Und jetzt kannst du sagen, seit .NET 8.
Du willst das hier machen.
Publish AOT.
Und jetzt kompiliert er das wirklich.
Jetzt baut er nicht mehr die Runtime rein, sondern er erzeugt wirklich
direkt ausführbaren, ein direkt ausführbares Binary ohne .NET Runtime.
Wenn man jetzt hier mal reinguckt, .NET Build, man sieht.
Das ist erst bloß noch 1,5 MB groß.
Ist schon ein bisschen besser geworden und es ist auch deutlich schneller.
Und es ist auch deutlich schneller, es braucht nur, keine Ahnung, 2-3 Millisekunden oder so, bis das gestartet und gestoppt ist.
Man kann das Ganze noch ein bisschen weiter verbessern.
Das ist das Einzige, was mir jetzt einfällt, es gibt noch ein paar mehr Compiler Flags.
Letztens habe ich da auch irgendeinen Blogartikel drüber gelesen.
Also, so, jetzt kann man sagen, man möchte sogar noch die Debug Symbols raus strippen.
Und dann ist das Ganze am Ende.
Nur noch 1,5, da macht er das Standardmäßig wohl schon.
Konnte man noch Compressor machen?
Ich weiß es, ich weiß es nicht.
Es gibt noch, es gibt noch ein paar mehr, paar mehr Optionen für Publish AOT.
Da wird es noch ein Ticken kleiner.
Kann man, kann man hier sagen Strip?
Läuft es da noch, wenn man hier Debug Symbole entfernt?
Wahrscheinlich nicht, oder?
Doch, die sind schon entfernt.
Das sind wir nicht.
Nicht kleiner geworden.
Ähm, minimalsize.net AOT, da gibt es, naja, ich glaube, wir müssen uns das jetzt nicht weiter angucken, aber es gibt noch, es gibt noch ein paar zusätzliche Optionen, wo man, wo man es noch ein bisschen, bisschen verringern kann, die Größe so.
Aber ich finde, das hier ist ein ganz guter, ganz guter Kompromiss in der .NET Welt.
Ähm, es ist quasi.
Nur noch 1,5 MB groß.
Es startet sehr schnell und wenn einem das wichtig ist, kann man das so machen.
Wohlgemerkt.
Man hat damit aber auch ein paar Probleme.
Chat, wer, wer ist pfeifert?
Wer kann sich denken, was die Probleme sind?
Von diesem 1,5 MB Binary versus meine 64 MB Version mit dem einkompilierten, mit der einkompilierten .NET Runtime.
Was sind die Probleme von dem ganzen Ding jetzt?
Es gibt ein paar, aber was sind so die, so die ersten Probleme, die das haben könnte, die euch einfallen?
Portability, ja, unter anderem, je nachdem, wie man es macht.
So, also, letztendlich ist das, ist das auch das, worauf ich, dass du .NET extra benötigst.
Nee, ich brauche kein .NET extra.
Das läuft ohne .NET.
Das ist jetzt wirklich direkt eins zu eins native ausführbarer Code ohne .NET.
Also Portability ist ein ganz guter Punkt.
Dadurch, dass es jetzt wirklich.
Native kompilierter Code ist, ist er abhängig von dem System, auf dem ich es kompiliert habe.
Nicht so wie bei Go, die das ja.
Bisschen abstrahiert haben alles, sondern er ist beispielsweise von der Version meiner eingesetzten C-Library abhängig.
Das ist eines der Punkte richtig.
Das heißt, wenn ich das jetzt versuche, ich meine, ich habe ein super aktuelles Arch Linux.
Wenn ich das jetzt versuche, laufen zu lassen auf einem, keine Ahnung, Ubuntu 2004, dann wird das.
Eigentlich nicht laufen, kann ich euch, kann ich euch zeigen.
Wir machen jetzt hier Docker Run.
Ubuntu.
2204.
Das ist dynamisch gelingt gegen die gegen meine Worte.
Minus minus.
Mann, Alter, ich kann mir das immer nicht merken.
Wie ist das einfach so?
Okay, kann man das nehmen?
Vielleicht nehmen.
Heck weh, perfekt.
So können wir jetzt sagen.
Docker CP gibt es sowas?
Ja, nice.
Docker, Docker, CP, heck weh, lull auf.
Ich weiß, dass das mal Kubernetes so kopieren kann.
Ich bin mir nicht sicher, ob man das auch so hier kopieren kann.
Geht geht sowas?
Das geht.
Nice.
Okay, jetzt haben wir die.
Jetzt haben wir das Programm hier liegen.
Guck im Docker Container auf einem Ubuntu 2204 und jetzt führe ich das aus und siehe da.
Da fehlt ja Zeug.
Da fehlt irgendwie eine.
Okay, das ist jetzt mein Fehler gewesen.
Das hätte ich noch machen.
Soll ich tatsächlich die dem fehlen.
So, was ist das für Zeit und und Datumsumwandlung?
Sachen fehlen dem, dass das ruhig machen.
Wir können uns das Ganze angucken.
Also wenn ich jetzt sage hier, was das LDD, glaube ich, ne, zeigt an, gegen was das gelingt ist.
Und du siehst das auch hier ging.
Ja, man sieht es richtig.
Ich zeige euch das.
Ich muss mal kurz dieses komische Ding hier ausschalten.
Global Dings System Invariant brauche ich so.
Wie wie setzt man den Kram?
Wie geht das jetzt noch mal?
Pepega?
Reiter.
Öffnen.
Wo hat man das jetzt gesetzt?
Ob hier irgendwo in der Projekt in der Projekt Konflikt?
Auf Reiter mach hinne Mann.
Okay, ja.
Und hier konnte man jetzt, glaube ich, sagen Invariant oder so global.
Frag man alle, wie heißt das richtig?
Invariant.
Ja, genau.
Invariant.
Wo muss ich das setzen?
Nicht hier, hier meine Güte.
Alter, ich check das komische Microsoft Format immer nicht.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Wie setzt man das denn?
Amt doch bestimmt irgendein Beispiel drinne.
Ja.
Invariant Globalisation.
Das will ich setzen.
Genau.
Wunderbar, Exit.
Jetzt können wir das Ganze noch mal bilden.
Nam.
Ehem wie es bildet als Bauman das nochmal selfish.
Jetzt Volkswagen.
Name.
Docker cp
Ja, ich hab's gelöscht
Jetzt kopieren wir das nochmal drauf
So, guck mal, jetzt ist es sogar noch ein
Jetzt ist es noch ein Ticken kleiner
Weil die ganze Translation-Sachen
Und so raus sind, sondern wenn ich es jetzt ausführe
Dann funktioniert's
Weil das System nicht alt genug ist
Es funktioniert, weil das System
Nicht alt genug ist
Also anscheinend ist von Ubuntu 22.04
Meine C-Library aktuell genug
Dass es noch funktioniert, okay
Wir brauchen noch ein älteres System
Äh, 18.04, okay
Äh
Da ist es doch
Heck weh, lull
Guck mal, und jetzt sagt er, es geht nicht
Weil ich
Mindest, mindest
G-Lib C-Version 2.32
Und hier an der Stelle 2.34 brauche
Das Problem hab ich mit dem
Self-Contained Binary so nicht
Also wenn ich jetzt hier zum Beispiel
Sagen würde, Self-Contained
Hoffe ich erzähle jetzt kein Mist
Ja, wenn ich sage mal hier
Minus, minus Self-Contained
Oder sagen wir Single, Single, Single
File, ja, Build 2
Bild 2
Jetzt kopieren wir das mal rüber
Docker-CP nach, ähm, ja, keine Ahnung
Keck-W-Lull-2
Jetzt habe ich hier
62 MB oder 67 MB
Rumliegen
Seht ihr auch hier, aber wenn ich das jetzt versuche auszuführen
Dann geht's
Obwohl es das gleiche ist
Also der Unterschied ist
Der, der Native-Content
Der hat Abhängigkeiten
Auf meiner
C-Library, auf meiner G-Lib C
Vom System, auf dem ich
Die Software gebaut habe
Und mein Self-Contained Binary mit .NET
Runtime mit drin
Hat das nicht, braucht es ja auch nicht
Weil es quasi den eigentlichen Programm-Code
Nicht als Native
Ausliefert, sondern als .NET
Byte-Code
Der dann von der .NET Runtime, die einfach nur
Embedded ist, in diesen 67 MB
Wiederum ausgeführt wird, das heißt für
Portability ist tatsächlich
Die 67 MB Variante
Einfacher
So, das ist das, das ist das Erste
Aber warum kann man denn nicht Native-IoT
Statically linked machen, weil du gegen G-Lib C nicht gescheit
Statically linken kannst, das Problem haben so gut wie alle Binarys unter Linux
Egal welche Programmiersprache du nimmst
Go hat das nicht, weil Go, ja das könntest du machen
Das könntest du machen
Das Go hat das Problem nicht, weil die darauf nicht zurückgreifen, ja
Das könntest du machen
Du könntest irgendeine andere C-Library verwenden als G-Lib C, ja das könntest du machen
So, aber
Jetzt kommen wir mal zu der eigentlichen Sache zurück
Das ist eines der Punkte, die vielleicht beim Native-Kompilierten .NET ein bisschen problematisch
sind
Versus quasi .NET Self-Contained mit Runtime
Also dem Self-Contained Binary und dem Self-Contained Binary mit Runtime
Also das mit Runtime ist ein bisschen besser portable
Es hat noch ein paar andere Nachteile
Also Vorteile sind eindeutig die Größe und die Geschwindigkeit beim Starten
Das sind umwelten besser als hier mit Runtime
Ein weiterer Nachteil ist, das manche Features nicht richtig funktionieren
Zum Beispiel Reflection
Reflection funktioniert nicht in native-kompilierten .NET Binaries
Man muss jetzt allerdings sagen, Reflection wird eh immer weniger benutzt
Die meisten Leute programmieren C-Sharp und haben wahrscheinlich noch nie Reflection verwendet.
Chatge, wer von euch ist C-Sharp Entwickler und benutzt regelmäßig Reflection?
Oder umgedreht, wer von euch ist C-Sharp Entwickler und benutzt eigentlich nie Reflection?
Kann man gegen Musel Static linken und dann auf Ubuntu ausführen?
Ich sag mal in der Theorie ja, praktisch habe ich es noch nicht gesehen mit .NET.
Du kannst .NET gegen Musel C linken lassen für Alpine Linux.
Was dann allerdings nicht auf Ubuntu läuft.
Es gibt aber noch was anderes, worauf ich jetzt eigentlich raus will.
So.
Also das ist auch noch ein Nachteil davon.
Und das sind eigentlich so die zwei größten Nachteile, die mir einfallen.
Erstmal Portability.
Und wenn man so Sachen wie Reflection verwenden will, dann geht das nicht.
Mittlerweile gibt es aber mit Code Generation tatsächlich schon ganz brauchbare Alternativen für vieles, wo früher Reflection benutzt wurde.
Da wird nämlich zur Compile-Zeit schon Dinger generiert, die du später callen kannst, die du nicht dir erst zur Runtime aus Reflection zusammenbauen musst.
Also.
Aber.
Was man machen kann natürlich ist, man kann das Ganze kompilieren unter einem alten System.
Oder besser gesagt, es muss kein altes System sein.
Du kannst das kompilieren gegen eine alte GLibc-Version.
Das kannst du machen.
Und was ich da anbiete zum Beispiel ist, ein altes Debian oder ein altes Ubuntu zu verwenden, das noch im Support ist.
So dass du nicht im Zweifelsfall dir noch irgendwelche Probleme einfängst.
Du kannst zum Beispiel, sagen wir mal, guck, das hier kann man jetzt ja nicht ausführen lassen auf Ubuntu 18.04.
Aber was du natürlich machen kannst ist, was du machen kannst ist, du kannst hier natürlich Update.
Ich zeige euch das jetzt mal exemplarisch.
Wir sind schon so krass, krass gesidetrackt, da ist das jetzt auch vollkommen egal.
Wir sind hier auf dem alten Ubuntu 18.04.
Wir installieren uns mal ein .NET hier drauf.
Ich hoffe, ich brauche nicht noch irgendwelche Dependencies, dass der ganze Shit läuft.
Wir installieren uns mal ein .NET drauf.
Was sagt heute eigentlich die Küche?
Heute gab es supergesunde Mozzarella Sticks mit Pommes frites und Dip.
So, und jetzt kann ich in dem Container, nee, ich muss erst mal die Software nehmen, einmal mit Docker CP Ordner kopieren.
Geht das?
Ja.
Kann ich jetzt sagen?
Das geht doch bestimmt nicht, oder?
Kann ich sagen, Docker CP?
Tatsächlich, man kann Ordner kopieren.
Das wusste ich ja gar nicht, dass das funktioniert.
Das ist ja cool.
Nice.
So, und jetzt kann ich hier drinnen sagen, .NET, äh, .NET, .NET Publish Release, oh, IQ fehlt, okay.
Das brauche ich jetzt nur zum Kompilieren.
Äh, apt install libIQ, nee, oh, meine Güte, warte, warte, warte, lib, libIQ, äh, IQ-Libs, wie heißt der Kram unter libIQ-Dev?
Ey, warte, libIQ-Dev, wunderbar.
Das brauche ich jetzt nur für das Build-System, ne?
Später, später zum Ausführen nicht mehr.
So, jetzt bauen wir uns das Binary auf einem alten, ich weiß nicht, was das älteste, noch supportetste Ubuntu ist, ich vermute mal 1804.
So, und jetzt kompilieren wir das Ganze hier auf dem System.
Und jetzt werdet ihr feststellen, dass, wenn das fertig ist, wir unter Build ein Binary liegen haben, was im Prinzip das gleiche Binary ist wie vorher, 1,4 MB.
Das jetzt allerdings läuft.
Das jetzt läuft auf einem alten Ubuntu.
Und wenn ich das jetzt runterkopiere, hier, äh, kekw, kekel, build, kekw, wenn ich die Sachen halt auch nochmal gescheit benennen würde, ja, build, kekw, lul.
So, jetzt habe ich hier das Binary aus der VM.
Und wenn ich das hier ausführe auf einem Archilux, dann geht's auch.
Dann geht's auch.
Das heißt, damit kann man das umgehen.
Man nimmt sich einfach ein Möglichkeitssystem.
Das ist ein richtig altes Linux, was noch supportet ist.
Und kompiliert das da drauf, gegen die GLibc-Version, die da drauf ist.
Man kann natürlich auch nur die alten Library-Versionen nehmen und das Ganze dann umbiegen und auf dem aktuellen System kompilieren.
Vielleicht die bessere Variante.
Aber das funktioniert.
So, und jetzt habe ich in C-Sharp einen Binary, was 1,4 MB groß ist, saumäßig, saumäßig schnell startet.
Und relativ.
Portabel ist zwischen allen Linux-Versionen.
Ich meine, Ubuntu 18.4, welche Version hat das?
Welche GLibc-Version hat das Ganze?
Kann man da nicht danach suchen.
Uptsearch.
Wir haben 227.
Ha?
227.
Release-Date 2018.
Ja.
Also wir haben jetzt ein .NET Binary, was auf jedem Linux lauffähig ist.
Was?
Weil es seit 2018 erschienen ist.
Das ist zwar nicht ganz so gut wie ein Go-Binary, was rückwirkend läuft auf jedem Linux-Sidekernel 2638 oder so.
Mein Kernel war schon ein bisschen älter, ja.
2638, März 2011.
Also unser .NET Programm ist nur lauffähig bis 2018.
Aber man sieht, die haben sehr viel aufgeholt.
In C-Sharp.
Also sprich, man kann mit C-Sharp portable, kleine, relativ kleine Self-Contained Binaries erzeugen mittlerweile.
Die ziemlich kompatibel lauffähig sind zwischen unterschiedlichen Linux-Versionen.
Und ich denke mal, du wirst kaum einen Anwendungsfall finden, wo du sagst, hey, das muss aber lauffähig sein auf einem System von vor 2018.
Da fällt mir jetzt ehrlich gesagt nicht so viel ein, wo das der Fall ist.
Ich bin mir auch gar nicht sicher, ob Ubuntu 18.04 tatsächlich das kleinste ist, was du laufen lassen kannst.
Vielleicht geht auch 16.04 noch.
Wir können, by the way.
Lass uns doch mal gerade ausprobieren.
Es interessiert mich mal, ob 16.04 geht.
Aber ich persönlich denke, 16.04 wird nicht mehr funktionieren.
Aber probieren wir mal.
By the way, 0.4 immer.
Weil 0.4 alle zwei Jahre die LTS-Version sind.
Wenn überhaupt, dann muss man die verwenden.
UPDATE gibt es überhaupt noch?
Kann man noch? Ja, okay.
UPDATE INSTALL CURL.
Ja.
Gucken wir mal.
Da bin ich jetzt selbst gespannt, ob das noch funktioniert.
So, installiert mal.
Gucken wir mal, ob man .NET überhaupt gescheit aufrufen kann da drauf.
Dass man das downloaden kann.
Und entpacken kann ich mir vorstellen.
Es hängt. Warum hängt das?
Aber es soll doch wahrscheinlich auch die nächsten Jahre noch laufen.
Ja, macht es ja auch.
Das Problem ist ja nur rückwirkend.
Vorwärts nicht.
Wenn du das jetzt da kompiliert hast, das ist vorwärts lauffähig bis in alle Ewigkeit.
Unter Linux.
Es ist nur Rückwärtskompatibilität das Problem.
Vorwärtskompatibilität ist kein Problem.
Okay.
Ah, .NET, .NET Version.
Ich brauch bestimmt wieder IQ irgendwas.
Ja, genau.
UPDATE INSTALL LIP IQ DEV.
Okay, lauf.
Aber wahrscheinlich, weil gibt es Version nicht.
Naja.
Ist es Minus Minus Version?
Ja, ist Minus Minus Version.
Okay, dann machen wir CP nochmal.
CP.
Den ganzen Ordner dahin kopieren.
Ja, genau.
Hat funktioniert.
So, und jetzt sagen wir BILD.
Ah, das funktioniert noch.
Gucken wir mal, man kann das ganze noch bauen unter Ubuntu 16.04.
Oder auch nicht.
Ne, kann man nicht mehr.
Hehe.
Oder habe ich GCC und so nicht installiert.
Ah, das kann sein.
UPDATE INSTALL BILD ESSENTIALS.
Vielleicht brauche ich das auch noch, dass das funktioniert.
Äh, BILD.
BILD ESSENTIAL.
Aber es kann sein,
dass 16.04 nicht mehr funktioniert.
Das ist möglich.
Ne.
Ne.
16.04 funktioniert nicht mehr.
Aber witzigerweise läuft das Binary,
was ich auf 18.04 kompiliert habe,
nur auf 16.04.
Also guck mal, wir können unsere Binarys
bis Ubuntu 16.04 ausführen.
Also,
ganz ehrlich,
ich behaupte einfach mal, das reicht.
Das ist 8 Jahre.
Ich glaube, 8 Jahre rückwirkend ist
zu 99% ausreichend.
Fällt euch irgendein Fall ein,
wo 8 Jahre rückwirkend
Kompatibilität von Betriebssystemseite nicht ausreicht?
Also,
Siemens setzt noch Körner an,
die mit 2.x anfangen.
Ja, dann brauchst, dann brauchst,
dann musst du Go verwenden,
wenn du da rückwirkend was haben willst,
was da noch läuft.
Gerade in der Bank sollte das ausreichend sein.
Ich kann es dir nur aus Sicht von der Versicherung sagen.
Ähm,
dort wird ganz stark drauf geguckt,
dass du Systeme hast, die aktuell sind.
Ja, die haben doch Oldschool-Dinger
wie IBM Hosts und sowas.
Aber die normalen Linux-Systeme,
da wird ganz stark drauf geguckt,
ob sie aktuelles verwenden.
Also, aktuell ist dann sowas wie Red Hat 8
oder so.
Was nicht wirklich aktuell ist,
aber noch supported ist für 10 Jahre.
Oder wie lange auch immer Red Hat 8
noch supported ist.
Und das geht, das geht ja.
Da drauf lauffähig ist das.
Also, lange Rede kurzer Sinn,
ich habe ziemlich lange gebraucht,
das dazu zu beantworten, aber
IoT, nicht IoT, AOT,
also ganz normales Kompilieren
ist mittlerweile in .NET
echt gar nicht mehr so schlecht.
Es ist noch nicht ganz so geil wie unter Go
und noch nicht so easy zu benutzen
und noch nicht ganz so kompatibel
wie unter Go, aber
es hat sich sehr viel getan
und ich würde sagen, zu 95%
ist es ausreichend, was es kann.
Wer wirklich heutzutage
Software programmiert, die lauffähig
sein muss auf Kernel 2638,
der wird es wahrscheinlich
mit einem Custom-Build von .NET
auch hinkriegen, aber das ist glaube ich
den Aufwand nicht wert.
Dann musst du irgendwas anderes verwenden.
Aber wer solche Anforderungen hat,
der hat bestimmt auch Gründe für
und der entwickelt wahrscheinlich
die Sachen dann auch nicht in .NET Core
für solche Systeme.
Also ich finde 8 Jahre rückwirkend ist echt
mehr als ausreichend.
Also was ich meine mit Portabilität ist,
du kannst das bauen auf einem
Linux-System, dann nimmst du das Binary,
kopierst es auf ein anderes Linux-System rüber,
führst es aus und es geht einfach.
Und dann musst du irgendwas
installieren zusätzlich.
Das meine ich mit Self-Contained Binary.
Portable Binary.
Irgendjemand wollte wissen, wofür man
Reflection braucht.
Was ist eine Reflection?
Reflection ist die Möglichkeit
in .NET zur Laufzeit
Informationen über sich selbst
rauszubekommen.
Klingt jetzt erstmal wir,
aber nehmen wir mal ein Beispiel.
Nehmen wir mal ein Beispiel.
Eines der Beispiele,
welches in .NET
und Reflection
ist.
Stell dir vor,
du entwickelst eine Software,
die per Plugins erweiterbar sein soll.
Du musst ja zur Laufzeit
die Plugins laden.
Du kannst ja keinen Compile Step
da in irgendeiner Art und Weise einbauen,
dass das irgendwie gebundelt wird,
integriert wird in deine Software,
weil du lieferst die Plugins ja nicht mit aus.
Du lieferst die Software aus
und irgendjemand programmiert
jetzt quasi ein Plugin in C-Sharp
und
legt das in dein
Anwendungsverzeichnis rein.
Die Anwendung wird gestartet und dann musst du irgendwie
diese Plugins laden. Und das machst du
in der Regel über Reflection.
Du nimmst dann Reflection, sagst
hey, Load Assembly, guckst nach
welche Klassen
gibt es in diesem Assembly, dann hast du irgendeine
Naming Convention für deine Plugins, die müssen
beispielsweise ein IPlugin Interface
implementieren. Dann guckst du mit
Reflection nach, in diesem Assembly gibt es
eine Klasse, die IPlugin implementiert,
aha, gibt es, dann
diese Klasse laden und
dort die Methode Init aufrufen.
Plugins sind ein ganz
klassisches Beispiel für Reflections.
Für Reflection.
Und ein bisschen einfacheres Beispiel,
stell dir mal vor, du benutzt eine Library
und kannst,
du musst unbedingt auf
eine Funktion zugreifen in dieser Library,
oder du musst
unbedingt etwas,
internes auslesen von
dieser Library, weil
die Library ist alt, wird nicht mehr maintained,
aber die Informationen gibt es.
Zum Beispiel, du benutzt
irgendeine Library
für irgendeine Web-API oder so,
und der Web-API ist doof,
die kannst du einfach mitkönnen.
Du benutzt irgendeine Library, um irgendein
Gerät anzusteuern.
Und die Library
hat intern Informationen darüber,
über die Seriennummer von dem
Gerät, aber der Typ, der die Library
programmiert hat, hat vergessen,
dass er ja eine
Get-Seriennummer-Methode anbieten sollte.
Leider ist dein Support-Vertrag
abgelaufen und du müsstest 50.000 Euro
bezahlen, um eine neue Library-Version zu bekommen.
Was du jetzt machen kannst, ist,
du kannst Reflection
nehmen und dich mit Reflection
durch diese Library durchhangeln und
die interne Variable,
also irgendeine Private oder
Internal, was auch immer, Variable
auslesen, aus
einer Klasse, auf die du eigentlich
normalerweise nicht zugreifen kannst.
Per Reflection geht das.
Und für solche ekligen Dinger wird auch
meistens Reflection verwendet.
Hauptsächlich aber für so Sachen wie Plugins.
Aber für
diese anderen Sachen auch.
Aber man braucht das selten.
Also man braucht es wirklich selten
für normale Anwendungen und
es ist ja auch ganz logisch,
dass das mit
self-contained
kompilierten Binaries nicht funktioniert,
weil Reflection ist ein Runtime-Feature
und du hast keine
Runtime mehr, wenn du es zu einem
Binary kompiliert hast.
Es gibt mit beispielsweise
der neuen Möglichkeit
zur Code Generation
hast du ein paar Fälle,
die du abdecken kannst, die du früher
mit Reflection gemacht hättest, die kannst du
heute mit Code Generation machen.
Aber wenn man Reflection braucht,
kannst du keinen AOT verwenden.
In anderen Sprachen, wo es keine
Reflection gibt, können die Leute trotzdem
Software entwickeln.
Aus meiner Sicht ist das
nicht verwenden können von Reflection
nicht wirklich ein großes Problem
für 95% der Anwendungen.
Viele anderen Sprachen
haben sowas gar nicht.
Und man kann damit trotzdem ganz normal.
Ich glaube Go hat sowas auch nicht.
Leute, hat Go sowas wie Reflections?
Oder Reflection?
Glaube nicht.
Wie ist bei euch der Prozess für ein Versionsupdate
von Linux-Distributionen?
Da ist ja kein...
Du guckst ja nicht zur Runtime
dein Programm selbst an, sondern
als Entwickler guckst du dir das Programm an,
was es macht.
Das würde ich nicht als Reflection sehen.
Also ich glaube nicht, dass Go hat...
Go hat
Reflection.
Runtime Reflection in Go?
Tatsächlich? Aha.
Und was...
Und was könnten die so?
Okay, bisschen...
Alter, das ist übertreibend.
Bei Go geht das,
aber Go hat ja auch eine Runtime mit dabei.
Go ist ja nicht nur reines...
Wie soll ich sagen?
Reines Binary mit deinem Code drin,
sondern
hat ja immer noch seine Go-Runtime
drin für
Thread Scheduling und alles mögliche.
Ja.
Wusste ich nicht, dass Go sowas hat.
Habe ich auch noch nicht benutzt.
Aber Rust hat sowas definitiv nicht.
Also Rust hat keine Reflections.
Also ganz ehrlich,
C hat keine Runtime.
Rust hat auch keine Runtime.
C++ hat auch keine Runtime.
Und ob man das bei Go so bezeichnen kann,
bin ich mir auch unschlüssig.
Also mit Runtime meine ich sowas wie die
.NET Runtime, wo du dann im Endeffekt
deinen Code
nicht als Binary
vorliegen hast, sondern als irgendwelchen Bytecode,
der zur Laufzeit quasi von
der Runtime dann ausgeführt
wird oder kompiliert wird.
Was bei Rust?
Keine Ahnung, was die damit meinen.
Eventuell die Teile von Rust,
die so Sachen machen wie
Runtime
Out of Bounce
Checking von Arrays oder sowas.
Aber das ist
ganz weit entfernt
von einer kompletten .NET Runtime,
wenn du dir C Sharp anguckst.
Deswegen ist ein Rust Binary auch nur ein paar Kilo Byte
und ein .NET Binary mit
Embedded Runtime 67 MB.
Ahja.
Wie ist bei euch der Prozess für ein Versionsupdate
von Linux Distros?
Wird die Anwendung auf einen frischen Server mit aktuellem OS umgezogen
oder wird stumpf das OS update?
Das kommt ein bisschen drauf an, wie die Leute Bock haben.
Also in der Regel wird
neuer Server installiert
oder drüber installiert, also sprich
das System wird ausgeschaltet,
neu installiert und die Anwendung wieder drauf
deployed. Wenn es was
ist, was ein bisschen
länger dauert und das nicht so lange down sein
darf, dann bauen manche
Leute auch einen zweiten Server auf und
lassen das dann drauf ausführen und schalten dann wieder um.
Manche machen tatsächlich
auch ein OS upgrade.
Wobei ich frisch aufbauen immer gar nicht
so übel finde, da sammelt sich ja manchmal
ein bisschen Schrott an.
Wir haben uns leicht sidetracken lassen,
was unsere
schätzen
Experimente anbelangt.
Ich glaube ich hab
von 4 Stunden Stream
die letzten, keine Ahnung,
1,5 Stunden über was anderes gelabert.
Aber lasst
uns doch mal schnell noch die restlichen Elemente
durchklicken, die es wenigstens noch gibt.
Richtig
geiles UI, was wir gebaut haben, oder?
Bock, Alter! Massive, krasses
UI. Nen Button für
Themeswitchen. Huge.
Wir haben eine Hovercard, die macht was?
Äh, was?
Ah! Man muss ja
auch hovern drüber. Also,
das ist tatsächlich ganz nützlich.
Wenn man es braucht, ist gut, dass
es da ist. Input.
Mal gucken, ob hier das Input,
das Inputfeld frisst nicht
Ende und Post 1.
Wenn das Theme jetzt noch mehrsprachig
kann. Ah ja!
Du meinst
mehrsprachiges Schwarz und Weiß?
Ah, das verstehe ich.
Also, ich finde, dass
das muss auf Chinesisch,
sieht das bestimmt anders aus.
Labels? Ja, gut.
Labels halt, ne? Menübars!
Brauch ich auch!
Ich bin quasi nie auf einer Webseite.
Okay.
Ja, zum Durchschalten auch gut, dass es
sowas gibt. Popover.
Das ist jetzt ein bisschen verwirrend, sind die
Dinger schon, ja? Es gibt
ein
Dropdown-Menü, was
standardmäßig nach oben geht und nicht nach unten.
Und es gibt ein Popover,
was drunter und nicht
overpoppt. Ich finde
das Default-Verhalten besser, so
wie er das hat. Ist schon alles gut.
Aber die Benahmung im
Vortex ist halt schon ein bisschen pepeger, so.
Und ja, ich weiß, man nennt die Dinger halt
so. Aber ist trotzdem blöd.
Progressbar.
Oh, ich hoffe, das benutzt
nicht die Native-Browser-Progress-
Dinger. Die sind richtig abfuck.
Okay.
Ich hoffe, das muss ich mal kurz ausprobieren.
Ich hoffe, das
benutzt keine Native-Progressbar. Die sind so
eklig zu stylen.
Probieren wir das doch mal aus.
Ja, Components.
Was war das denn?
Äh.
Typ. Components.
Progress.
Progress.
Oh.
Alter, Visual Studio Code hat
einfach mal wieder den Abgang gemacht.
War zu lang inaktiv im Hintergrund.
Kann man nicht erwarten, dass es dann auch weiter funktioniert.
Progress.
What the f...
Progress. Alter, warum geht
das nicht?
Okay. Wollen wir halt
so.
Geht's jetzt?
What?
Fuck. Warum nicht?
Was hat's für Schmerzen?
Geht doch. Geht doch. Keine Ahnung, ob's
Autocomplete wieder im Arsch ist.
Es basiert auf...
Oh. Zum Glück
auf nem Diff, Alter. Und nicht
das Native Progress.
Die Native
Progress-Elemente sind so broken
und kaputt.
Und lassen sich so
kacke stylen und sehen auf Mobile wieder
schrottig aus oder aufm Desktop schrottig
aus und so. Ja, das find ich
viel besser, dass die das einfach mit nem Diff machen.
Anstatt das Native...
Anstatt das Native Progress
Elements zu benutzen.
Viel besser.
Find ich.
Weiß nicht, wie ihr das seht, aber ich find das besser.
Value.
Ups.
Value. Gleich.
Keine Ahnung. 20? Oh. Perfekt.
Was kann man da sonst noch einstellen?
Was hat das sonst noch so?
Max. Mehr gibt's nicht.
Ja, Color und so kann man wahrscheinlich dann
überschreiben hier.
Style. Translate.
Ich muss sagen, ich find den
Ansatz von dieser Library wirklich ganz cool.
Dass es hier quasi in den Code
reinpastet und du
es nicht extra rappen musst und selbst dran rumbasteln
kannst. Wenn ich jetzt hier irgendwie
den Style bräuchte für...
Keine Ahnung. Dass der Balken hier
in Rot ist.
Da könnte ich mir selbst ein Property
machen, um das durchzuschalten. Oder ich sag einfach
ich will das defaultmäßig
in...
Ich bin jetzt ein bisschen
verwirrt.
Wie ich die Farbe
da mach. Moment. Das ist
jetzt... Ach hier. Das ist der. Das ist doch die
Farbe hier. BG.
Red. 400.
Zack. Schon ist Rot. Das find ich
cool. Das muss ich
jetzt nicht nochmal extra rappen, sondern könnt ihr
quasi sowas sagen wie hier. Keine Ahnung.
Export. Irgendwie Alert.
Alert ist false.
Ups.
Ja. Let. Alert.
Kann ich mal. Das ist false.
Da könnte man jetzt hier drinnen zum Beispiel
gucken.
Wie könnte man das jetzt gescheit machen?
Warte mal. Ich glaub so, gell.
Template String könnte man jetzt machen.
Quasi checken ob...
Chat? Wo ist das Problem?
Wo ist... Was...
Ah. Ah ja. Kann sein, dass
ich das in Klammern setzen muss
oder so.
In... Oh.
Ah ja.
Ah gut.
Schön ist was anderes.
Muss man...
Oder kann ich hier irgendwas
einsetzen? Kann ich... Moment. Ich könnte doch einfach
hier drinnen direkt
könnte ich quasi gucken, ob Alert und dann
wenn es Alert ist, dann ist es hier
keine Ahnung. BG. Red. 500.
Ah. True.
Wird nicht rot. Achso.
Achso. Ja. Logisch. Weil...
Es ist entweder Alert
oder wenn es nicht
Alert ist, dann
ist es
BG. Primary.
Siehst du? Und schon kann ich das umschalten.
Das finde ich... Ich finde den Ansatz
von dieser UI Library wirklich nicht schlecht.
Weil diesen Mist müsste ich eh
selbst basteln. Warum
müsste... Warum sollte ich ihren Kram
noch extra nochmal rappen?
Warum?
Einfach nach drinnen editieren.
Vom Ansatz her echt nicht verkehrt.
So. Und jetzt könnte ich hier beispielsweise sagen
hier Alert.
Oh.
Und jetzt ist das eben ein
Progress mit einer roten Progressbar.
Und wenn ich Alert wegmache, ist das wieder ein normaler
Progress.
Eigentlich ganz cool. So. Was haben wir sonst noch?
Radio Groups.
Es sind halt Buttons.
Es sind
Buttons, die laggen?
Irgendwie bisschen laggy sind?
Ja, jetzt haben sie sich eingekickt.
Aha.
Ah, das ist auch was, was ich nicht mag.
Der Klick zwischen Text und Button
nichts macht.
Ich finde, wenn man hier hinklickt,
oder Chat, wie seht ihr das?
Wenn man hier hinklickt, sollte das
zählen als
ich will das haben. Weil warum soll ich...
Ohne Mist. Aus welchem Grund sollte ich
hier hinklicken? Hier. Genau an die Stelle.
Wenn ich das
nicht selecten will.
Range-Kalender brauchen wir nicht. Select.
Den ganzen Text. Du kannst den...
Das geht ja witzigerweise. Den Text kannst du
klicken.
Den Text kannst du klicken.
Du kannst den Button klicken, du kannst den Text klicken,
aber du kannst nicht zwischen den Button und den Text
klicken. Was ich schon wieder
übertrieben finde, was ich auch schon gesehen habe,
es gibt Libraries, die machen dann die komplette
Zeile. Ja, das ist ein bisschen übertrieben.
Ja, das ist
ein bisschen doof. So. Was haben wir
sonst noch? Range-Kalender. Select.
Operator.
Es ist ein horizontaler Strich
und vertikaler Strich.
Oh. Sheet.
Oh. So was brauche
ich nicht. Das ist zu advanced das Webdesign
für mich.
Way too advanced.
Sekunde. Lass mich mal
was checken. So.
Was haben wir
hier? Use to show a
placeholder while content is loading.
Das ist nicht schlecht.
Ich bin für so was immer
faul. Ich blende,
ich blende an irgendwie, ich blende lieber
einen Spinner ein, über
die komplette Seite, anstatt
ich mir die Mühe gebe zu gucken,
ah, wie groß könnte es
am Ende werden und ah, bauen wir einen
Skeleton. Ne.
Da wird irgendwo ein Spinner eingeblendet
und dann hängt die Seite halt einfach so lange oder
macht nichts.
Bis alles da ist.
Da bin ich, cool, dass es das gibt,
aber da bin ich viel zu faul für.
Slider.
Oh.
Jetzt kommt die Frage der Fragen.
Ist es ein Native Slider?
Nein. Oder?
Nein, ist es nicht.
Sehr gut.
Das ist ein selbstgebauter Slider.
Ich mag die Leute,
weil die, weil die
Slider, die im Browser Native
zur Verfügung stehen, sind auch kacke.
So.
Da haben wir einen Slider.
Nächste Frage ist, funktioniert
der Slider in Chrome richtig?
Die Native Slider in Chrome
buggen immer mal ganz gerne.
Ein Slider.
Und der, fuck, der buggt auch.
Der buggt auch.
Okay, da ist es
doch ein Native Slider.
Roll Slider.
Nö, anscheinend nicht.
Weil der richtige Slider
ist ein Inputfeld mit Typ,
Typ Range, glaube ich, ne.
Nö. Aber,
der Slider buggt
auch.
Guck.
Sobald ich aus dem Fenster rausgehe,
hier ist der am buggen.
Und witzigerweise in Firefox
nicht.
Das ist irgendein Chrome Bug,
den ich nicht richtig nachgestellt kriege.
Manchmal ist es so, manchmal nicht.
Aber in Firefox ist es nie so.
Kein Problem, in Firefox
und in Chrome, sobald du aus dem Fenster
rausgehst, broken Slider.
Ich meine, das ist jetzt wahrscheinlich nicht
das normale Userverhalten, erstmal den
Slider anzuklicken, dann aus dem Fenster raus, und wie der Rest trotzdem doof, dass er nicht geht.
Da müsste man wahrscheinlich noch
irgendwie das fixen, extra für
Chrome, mit Fenster active, Fenster
inactive, und dann wieder fokussen, oder
sowas, weiß nicht, was man dafür machen muss.
Da gibt es ein Sonner.
Leute, bevor ich das jetzt anklicke,
kann mir irgendjemand
erklären, was ein Sonner ist?
Wenn man mit der Maus ausrutscht, schon richtig.
Ja, finde ich auch. Also, ganz ehrlich,
ich finde, sowas sollte funktionieren.
Was ist ein Sonner?
Nicht so nah.
Nicht so nah. Sonner.
Okay, wir gucken, was es ist.
Was? Ladering?
Ne, das würde wahrscheinlich Spinner heißen,
oder? Was ist ein Sonner?
Okay.
Ein Toast!
Warum heißt es Sonner und nicht Toast?
Unter Toast hätte ich mir
sofort was vorstellen können.
Warum Sonner?
Warum muss man es so kompliziert
machen, Alter? Ach, Sonner ist
ein Library.
Svelte Sonner. Ach,
deswegen heißt das. Okay.
Ich dachte,
Sonner ist irgendwie eine spezielle Art
von Toast oder sowas.
Okay, das ist cool, dass das drin ist.
Finde ich nice. Okay, Switch
muss, must have.
Ist auch wichtig,
dass es gibt, weil es gibt kaum ein Element,
was so abfuck zu stylen
ist, wie...
Was ist da immer unten drunter? Eine Checkbox?
CSS
Experts im Chat.
Wie macht man einen Switch mit einer Checkbox, gell?
Ich glaub, da wird eine Checkbox
missbraucht, dass das so angezeigt
werden kann. Ein Button?
Nee, oder?
Doch hier, Input-Type, Checkbox.
Ja, genau.
Checkbox. Die Leute machen das immer mit einer Checkbox.
Ah, da kann man bei der
Slider mal gucken. Da habe ich nämlich, glaube ich,
nicht richtig geguckt. Nee, der Slider
ist tatsächlich ein
Span und kein
Slider.
Ja, das Web ist kaputt, aber
richtig, ja.
So, Switch.
Das wird immer mit einer Checkbox gemacht.
Das ist mir auch schon aufgefallen.
Dann haben wir noch eine normale Table.
Halt, eine Table.
Was ich spannend finde, ist, kann die Zebra-Style...
Ich finde Zebra-Style
bei Tables immer nice.
Sieht nicht so aus.
Tabs?
Ja, Tabs halt.
Wichtig und richtig,
dass es Tabs gibt.
Wie heißt das, Adon, dass immer den Kopf
einer offenen Klammer anzeigt, wenn man
Tabs hat?
Meinst du sowas wie Rainbow Brackets
oder sowas?
Du meinst sowas hier?
Also das hier ist Default tatsächlich
in Visual Studio Code.
Das Highlighten von den dazugehörigen Sachen.
Es gibt Addons zum
Klammern-Highlighten,
weiß ich jetzt aber nicht genau, was
du machen willst.
Und weiß ich aus dem Kopf wahrscheinlich auch nicht, wie das Addon heißt.
Aber Tabs, das ist wichtig.
Ohne Tabs geht nix.
Also in Vim
früher habe ich sowas wie
Rainbow Brackets oder so
glaube ich verwendet.
In Visual Studio Code...
Ja, ich weiß was du meinst.
Du meinst sowas hier, du hast verschiedene Klammern.
Ich glaube sogar, dass das Default
mittlerweile in Visual Studio Code ist.
Kann das sein?
Ist das mittlerweile Default?
Weil ich bilde mir ein, ich habe nichts installiert dafür.
Brauchst gar keinen Addon.
Ja, Tabs wichtig.
Ohne Tabs geht nix.
Textarea.
Schon wieder ein Bug gefunden.
Der...
Das ist nicht der richtige Cursor.
Das müsste eine Hand sein an der Stelle hier.
Ich persönlich
finde es nicht schlimm, weil ich
eh nur sehr ungern Resizable
Textareas verwende.
Und Resizen am liebsten ausschalte,
wenn es überhaupt eine Textarea sein muss.
Toggle.
Äh, what?
Schmilzt quasi mit dem Hintergrund.
Sieht man das besser im Light-Theme?
Oh, mein Auge, mein Auge.
Ah.
Close, close. Fast erblindet.
Toggle Group.
Ach, damit kann man.
Okay, verstehe. Falls irgendjemand sowas machen will.
Ja, nice.
Gar nicht so schlecht.
Tooltip. Das Ding ist...
Ah, ich wollte gerade sagen, wo bleibt denn der Tooltip?
Da ist er noch.
Aber guck mal.
Wenn ich das direkt habe, gibt es keinen Tooltip mehr, oder?
Ist klar.
Okay. Ja, sowas, sowas muss sein.
Ich hoffe, man braucht keine extra Library
dafür, dass das funktioniert.
Also, ich mag den Ansatz. Der gefällt mir
wirklich gut, der Ansatz von der Library.
Ich, ich, ich werde das mal
im Auge behalten.
Okay, Leute. 4 1⁄2 Stunden, das war
für meine Verhältnisse erstaunlich lang heute.
Ich weiß nicht, wie es die Leute schaffen,
8 Stunden am Strück zu streamen.
Die müssen ja permanent
Halsschmerzen
haben, wenn du jeden Tag 8 Stunden
am Stück laberst.
Ich weiß nicht, wie das geht.
Geht's was? Ne, ich gehe noch nichts essen.
Ich gehe eine halbe Stunde, eine halbe Stunde gehe ich was essen.
Immer ein Entschluss.
Oh.
Ich hoffe, euch hat es gefallen. Wir haben uns ja wieder richtig krass
sidetracken lassen.
Aber ich denke jetzt mal ehrlich, Leute.
Ich glaube, die Streams sind immer relativ
educational, oder?
Jetzt vielleicht mein
Frontendgebastel weniger.
Aber beispielsweise der
über AOT Compilation in
.net. Also das
hast du doch auch nicht an jeder Ecke.
Auf den Qsharp
Stream. Ich bin jetzt mir nicht sicher, ob
normalerweise würde ich denken, du veräppelst mich.
Aber ich weiß, dass es eigentlich
fast nichts gibt, was es
nichts gibt. Deswegen gucke ich jetzt mal, ob es das nicht wirklich
gibt. Mich hätte es
nicht gewundert. Hä? Gibt es?
Qsharp?
Für Quantenalgorithmen.
What?
Whatever. Da brauche ich erstmal
einen Quantencomputer für, würde ich sagen.
Dass wir Qsharp machen
können. Qsharp klingt
auch toll, oder? Qsharp.
Qsharp.
Wie würde Semper Video dazu
sagen? Der würde nicht Qsharp
sagen, der würde sagen Q.
Würde er wahrscheinlich sagen.
In Qsharp.
In diesem Video nur ganz kurz.
Qsharp.
Nein, nein, nein. Nicht Raute.
Wenn schon Qlattenzaun.
So Leute. Also, ich gehe jetzt auf.
Gehe ich nachher was futtern.
Jetzt erstmal ein bisschen
Kreiselgrinden.
MMO Kreiselgrind startet.
Gucken, ob die anderen Leute schon
da sind. Dann mache ich jetzt eine Runde
RPs.
Ein paar Gegner killen. Bis dann. Macht's gut.
See you.
