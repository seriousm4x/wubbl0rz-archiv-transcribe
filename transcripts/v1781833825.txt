Und, ja, es war eigentlich gar nichts mehr großartig, dann dachte nur, da kommt noch was, aber es war dann gar nichts mehr großartig.
Aber, ey, ich mein, besser so als umgedreht, oder?
Besser denken, man hat Dünnschiss, als man hat wirklich Dünnschiss.
Ja, machen wir mal ein bisschen was anderes an.
Ein bisschen Wupp, Wupp, Wupp oder so.
So, irgendwas, ähm, bisschen was anderes als Nintendo-Gedudel heute.
Was, glaub ich, von der Lautstärke auch ganz gut her.
Fortnite, na klar, bin ja bekannter für großer Fortnite-Liebhaber zu sein.
Wusstet ihr das noch nicht?
Bin der Nummer 1 Fortnite-Fanboy.
Ich weiß gar nicht, was ist denn?
Leute, ihr müsst mir mal was, ihr müsst mir mal helfen.
Früher, ja, als die ganzen Kontakte...
...All-of-Duty-Quickscope-Geschichten angesagt waren,
da gab es ja immer so Meme-Namen, so XXHD, Quickscope, iScope360 und solche Dinger.
Wie ist der entsprechende Meme-Name für Fortnite?
Da gibt's ja doch garantiert auch sowas.
Es wird halt nicht i360-Quickscope-HD oder so sein.
Vor allem HD.
Heute ist ja nicht mal 4K irgendwie was Besonderes.
Heute muss das schon...
Heute muss das schon, ähm...
...8K-Ultra-Wide-Super-HD sein.
Da gibt's doch garantiert auch sowas für Fortnite, was entsprechendes, was dem XXHD-Quickscope von Call of Duty früher entspricht.
Von der Benahmung.
No Skin?
No Skin? Okay.
Kein Plan, ja.
Ich auch nicht.
Ich auch nicht.
Ich dachte, vielleicht wisst ihr das.
Leute, ich hab jetzt ganz schön viel gestreamt die letzten Tage.
Leute, ich hab jetzt ganz schön viel gestreamt die letzten Tage.
Leute, ich hab jetzt ganz schön viel gestreamt die letzten Tage.
Ich seh das grad bei mir.
Müsst ihr euch mal angucken.
Hier, schaut euch das mal an.
Wirklich.
Äh, warte mal.
Falsches.
Falsches Tab.
Guck du mal hier.
Ne.
Wollte ich überhaupt nicht hin.
Papas Kreditkarte.
Ist das in Fortnite wirklich so schlimm?
Also ich weiß, dass es die ganzen Kinderspieler meinte, die kaufen sich alle...
...Skins heimlich.
Oder was heißt heimlich?
Alle nur noch Skins mit Papas Kreditkarte.
Aber davon abgesehen.
Man kann auch bestimmt mit was anderem als Kreditkarte bezahlen.
Guckt euch das mal an.
Guckt euch das mal an.
Heute gestreamt.
Gestern gestreamt.
Vorgestern gestreamt.
Vor, vor, vorgestern gestreamt.
Vor, vor, vor, vor, vor.
Was auch immer.
Ich hab die letzte Woche fast durchgehend...
...bis auf immer mal so einen Tag zwischendurch...
...fast durchgehend...
...Streamwords gemacht.
Sagen gibt's.
Hätte ich selbst gar nicht gedacht, dass das so viel gewesen ist.
Und teilweise auch recht lang.
Hier.
Hier haben wir dreieinhalb Stunden.
Drei Stunden 45.
Also das ist ja für meine Verhältnisse enorm viel.
Gibt andere Streamer, die schaffen es irgendwie am Tag sieben Stunden zu streamen oder ich weiß nicht.
Ich weiß seriously...
...nicht wie das gehen soll.
Okay.
Die spielen auch meistens irgendwas.
Ich geh mal davon aus, sieben Stunden am Stück spielen, auch wenn ich meine Probleme habe, sieben Stunden am Stück sitzen zu bleiben mittlerweile.
Aber ich könnte mir vorstellen, dass sieben Stunden am Stück Gaming-Zeug machen noch besser geht als High-IQ-Technik-Shit.
Oder, was ist hier neben los?
Die, die, die, die ganzen, die Chess-Grills werden mir empfohlen hier.
Weiß, weiß nicht wie die drauf kommen, dass ich jetzt, dass ich jetzt Chess gucken will.
Aber gut, nein, warum nicht?
Ich will mich jetzt mal nicht über High-IQ-Chess-Content beschweren.
Gibt's deutlich nervigeres auf Twitch als Chess-Content.
Was ist der Vorteil von UEFI vs. Bios?
Hast du nicht gestern schon mal gefragt?
Immer noch? Ist das immer noch angesagt?
Wundert mich, weil vor einem, vor eins, vor, wach, eineinhalb Jahren war das angesagt als XQC auch mal.
Chess gelernt hat.
Da wusste nicht, dass das immer noch angesagt.
Aber warum nicht?
Ich mein, Chess ist ja quasi seit Jahrhunderten quasi, weiß nicht wie lange es wirklich das schon gibt und gespielt wird.
Aber ich sag jetzt einfach mal, seit Jahrhunderten beliebtes Game.
Warum soll das nicht auch auf Twitch ankommen?
Was ist der Vorteil von UEFI vs. Bios?
Du kannst die Maus im Bios benutzen.
Es ist neuer.
Es hat so komische Sachen wie Secure Boot und sowas.
Es hat so komische Sachen wie Secure Boot und sowas.
Und...
Sag mich nicht, keine Ahnung.
Das einzige, was mir bei UEFI immer auf den Keks geht, ist, wenn das Ding die Boot-Partitionen bzw. die Boot-Discs vergisst.
Die Entries im Boot-Manager bei irgendeinem Bios upgraden und dann erstmal gucken darfst, wie du die wieder rein kriegst.
Da fand ich diese stumpfe Booten vom ersten Device per MBR übers Bios fast noch angenehmer.
Da fand ich diese stumpfe Booten vom ersten Device per MBR übers Bios fast noch angenehmer.
Dynamische Partitionsgröße.
Was hat eine dynamische Partitionsgröße?
Was hat eine dynamische Partitionsgröße?
Was hat eine dynamische Partitionsgröße mit UEFI zu tun?
Was hat eine dynamische Partitionsgröße mit UEFI zu tun?
Wie groß ich meine Partition mache, liegt doch an meinem...
Wie groß ich meine Partition mache, liegt doch an meinem...
Wie groß ich meine Partition mache, liegt doch an meinem...
An mir und nicht an meinem UEFI.
Mal gucken.
Weiß ich noch nicht genau.
Ich muss mir das erstmal in Ruhe noch ein bisschen weiter angucken.
15,3 Stunden.
Ja, das ist ganz schön viel.
Überlegt euch das mal.
Das ist fast.
Das ist fast.
Was heißt fast?
Ich arbeite ja nur 32 Stunden.
Ich habe quasi die Hälfte
von meiner normalen Arbeitszeit nochmal gestreamt.
von meiner normalen Arbeitszeit nochmal gestreamt.
Das musst du auch erstmal hinkriegen.
Das ist jetzt nicht so einfach mal aus dem Ärmel geschüttelt.
Das ist jetzt nicht so einfach mal aus dem Ärmel geschüttelt.
Nächste Woche dann wahrscheinlich
bisschen weniger, zumindest am Montag.
Montag gehe ich ja
nach Frankfurt zur neuen Arbeit.
Und da werde ich dann wahrscheinlich
nicht ganz so früh daheim sein, sondern wahrscheinlich
erst irgendwie so 16.30 Uhr oder sowas.
Und ob ich da
abends noch Bock habe auf Streamerino,
keine Ahnung, weiß ich noch nicht genau.
Wenn ihr Linux benutzt,
wisst ihr, was ich schon mal
gut finde? Also
Stolman wäre stolz auf dich, dass du
sagst, es ist GNU Linux.
Allow me to interject for a moment.
I like to call it
GNU plus Linux.
Oder wie auch immer das geht.
Ja,
ich benutze hauptsächlich tatsächlich Arch
by the way. Wir können mal die
VM starten, wo wir gerade dabei sind.
Wie starten wir die VM?
Ich muss, glaube ich, ein bisschen weniger
Dauerschwätzen. Merkt das teilweise.
Es ist übelst anstrengend nach 3 Stunden.
Ich rede ja ohne Punkt und Komma
die meisten Streams, aber
nicht, weil ich mich zwinge
dazu, sondern weil das irgendwie so
irgendwie so mir natürlich
vorkommt, das so zu machen.
Keine Ahnung, wie man das beschreiben soll.
Aber
es ist nicht, weil ich muss.
Muss
ich ja gar nichts.
Wobei, dann würde wahrscheinlich auch keiner zugucken,
wenn ich gar nichts sagen würde.
So.
Wollen wir bei der Gelegenheit mal den Rechner
neu starten. Wir starten mal die VM neu.
Das kann nichts schaden.
War eine Runde Reboot.
Also ich benutze, ehrlich
gesagt, hauptsächlich Arch Linux.
Allerdings nicht für
Server, logischerweise.
Für Server macht sich jetzt Arch Linux.
Man geht. Man kann jedes
Linux auf dem Server betreiben bzw. jeden
Rechner als Server betreiben.
Hat wenig mit der Linux Distribution
oder der Hardware zu tun.
Aber da ist jetzt Arch
vielleicht nicht so
das Beste, so ein Rolling Release auf
dem Server, wo man auch will, dass es dauerhaft gut
läuft.
Jetzt eher nicht so eine gute Idee, aber
auf dem Desktop.
Auf dem Desktop auf jeden Fall
ist das sehr sinnvoll.
Arch Linux zu verwenden. Ansonsten
auf dem Server verwende ich ehrlich gesagt am liebsten
mittlerweile Debian.
Oh guck mal, das Serious Max hat
Improvements Committed.
At Rocky 8 und 9
hatten wir das nicht schon sogar?
Ach nee, nee, einmal Linux
hatten wir. HiIQ Shit
hier. Es wird Pull Requested.
Luna Lobster
heißt das nächste Ubuntu.
Stimmt.
Das ist endlich mal ein guter Name.
Die letzten paar Ubuntu Releases haben
mir ja nicht gefallen, von der
Samung her.
Aber Luna Lobster ist mal wieder ein guter Name.
Jellyfish, Jeremy Jellyfish
geht auch. Aber dazwischen waren ein paar, die
waren so nicht zahm. Aber Luna Lobster
finde ich nice.
Oh, habe ich mich hier vertippt?
Mit Fedora, ja.
Ach ja, Rocky
hat tatsächlich Q-Cow Images. Sehr schön.
Wusste ich gar nicht.
Wir haben sogar
eine Hilfe jetzt mittlerweile
auf der
Meine Güte.
Aber advanced hier langsam.
Ach so, das meinst du, okay.
Gut, ich frag
mich halt, braucht man das oft? Wahrscheinlich
nicht. Aber es ist nicht schlecht, dass es gibt.
Hast du einen Tipp für
Locals in, hä?
Also,
ich habe immer englische Sprache,
deutsches Tastatur Layout.
Das ist aber wahrscheinlich nicht das, was du wissen willst.
Moin, ich habe gerade gesehen,
du hast ein Pull Request aufgemacht.
Vielleicht können wir den heute noch merchen und gucken,
dass es dann Versionen, keine Ahnung,
0.0.3 gibt,
um unser Arch Linux Package
testen zu können.
Also, um nochmal kurz
darauf zurückzukommen. Ich muss mich ja, Leute,
ich muss mich ja ein bisschen zurückhalten mit
schwätzen. Also, ich rede die ganze
Zeit sonst in den Streams so super
fast schon so
super excited, presentation-mäßig,
ja. Ich muss mich
auch ein bisschen beruhigen.
Ich muss nicht nach einer Sekunde
ohne Wort denken, so nach
dem Motto, oh ja,
weiter, weiter reden. Wobei, ich mache es ja gar nicht mal
so sehr, ich labere
ja nicht so krass viel die ganze Zeit, weil
ich denke, das muss jetzt so
sein, sondern irgendwie
irgendwie überkommt es mich dann
immer so. Aber
ich muss mich ein bisschen beruhigen, weil
ansonsten geht das auch, wenn man jeden Tag streamt,
für zwei, drei Stunden echt ein bisschen
auf den Hals. Wenn man jeden
Tag drei Stunden durchgängig
labert, manche Streamer, wie gesagt,
labern irgendwie acht Stunden am Tag,
weil die halt auch nicht
wirklich die ganze Zeit so
ohne Luft zu holen, wie ich den ganzen Stream
schwätzen. Ja gut, mit GPT
hast du ja immer 4 MB oder so,
da reicht es ja dicke für alles mögliche.
Aber
hast du mittlerweile
eine Lösung für deine Zählerstand-Erkennung
gefunden? Nee, also was
ich ausprobiert habe, ist Open
Flamingo. Das ist eine
Hier gab es das, ach nee, keine Ahnung.
Ja, das ist irgendwas auf
so einem Model von Facebook
basierende Image-Erkennung.
Da gab es auch online,
da gab es auch online Demos
von. Da habe
ich ein paar Zählerstände
hochgeladen, wobei Zählerstand, das ist kein
Zählerstand, das habe ich auf Twitter so geschrieben,
weil die meisten, die meisten Leute
was mit anfangen können. Es ist nicht
wirklich ein Zählerstand,
was ich mit Image-Erkennung machen will,
sondern
ich habe an der Heizung
so eine Druckanzeige
Heizung, so was,
so was, ja, genau.
So was in der Richtung.
Sieht
mehr oder weniger so aus, ja.
So ein ähnliches Ding
habe ich bei mir
an der Heizung unten. Ich will ablesen,
wo das ist. Also ich habe es halt auch
so von 0 bis 4 und bei mir
ist es eigentlich immer so zwischen 1 und 2
und der Hintergrund ist hier ein bisschen schwarz.
Man sieht die Nadel. Also ein Mensch, der auf das Bild
guckt, kann dir sofort sagen,
das ist 1,2 oder
so was, ja. So und ich habe,
also ich habe Fotos gemacht
von dem Ding mit verschiedenen
Zeigerständen und ich habe dann diese Model
versucht zu erklären, so nach dem
Motto, hier sieht man eine
analoge
Anzeige
mit Schritten, also mit
Werten von 0 bis 4.
Jeder Zwischenschritt ist 0,2
und
auf welchem Wert steht
die Nadel? Das habe ich probiert,
also es hat überhaupt
nicht funktioniert. Ich setze ein bisschen
auf GPT-4, wenn die
endlich Image-Input
supporten. Da hat uns ja,
ich habe es ja im letzten Stream schon gesagt, da hat uns ja
Microsoft,
ne, wer ist jetzt,
ja, OpenAI halt, ist
ich glaube zum größten Teil Microsoft.
Bisschen Cheap-Aided mit der
GPT-4 Ankündigung,
weil GPT-4
kann halt gar keine Bilder zum aktuellen
Zeitpunkt.
Die haben groß getönt,
dass GPT-4
ja, die Dinger heißen
OpenAI, wie open sie sind.
Das trainierte
Model ist auf jeden Fall nicht open.
Naja, und
die haben ja angekündigt,
das wird Bilder unterstützen
und das sah auch in der Präsentation
so aus, als würden sie
direkt Bilder können. Sie haben das ja quasi damit
fast schon beworben, dass man jetzt
Bilder-Input machen kann, aber das geht noch nicht.
Und mal gucken, wann das
kommt. Ich, aktuell ist es nur so, dass
wohl spezielle Leute
mit Developer-API-Zugang und
speziellen, ja,
Freischaltungen das bekommen.
Ich find's doof, weil
ich spekuliere ja drauf,
dass
GPT-4
meine Heizungsdruckanzeige
erkennt.
Das wär wirklich, das ist, das wird der
ultimative Test für GPT-4.
Imageerkennung.
Ne, das, genau,
das bringt nix.
Weil ich dann an der Heizung rumschrauben müsste.
Da müsste ich irgendwie das Ding abschrauben.
Ich weiß gar nicht, wo
ich da schrauben muss und ich will auch ehrlich gesagt
nicht an der Heizung
rumschrauben, weil das Ding
ist ja eingebaut in die Heizung.
Da müsste ich irgendwie
die Klappe aufmachen und
da was dazwischen
bauen. Ich hab keine Ahnung, was passiert, wenn
ich das abschraube.
Einfach ne Abzweigung dazu.
Ich weiß nicht, wie einfach das ist.
Weil ich mein, da musst du ja irgendwie das Ding
abmachen und dann entweicht da irgendwie noch
der Druck oder so. Keine Ahnung, ich will eigentlich nicht
an meiner Heizung rumschrauben.
Hat GPT-4
mach mal ein Foto.
Ja, das sieht ungefähr so aus, das Teil.
Ich hab,
ich hab n Bild, aber da erkennt man glaube ich
nicht so viel drauf.
Chat, ich,
ah ne, das hab ich aufm Tablet.
Das Bild hab ich aufm Tablet,
das hab ich hier gerade. Ich kann n Bild machen.
Ich kann n Bild machen, easy.
Pass auf, ich mach n Bild. Easy.
Kann doch einfach auf die Kamera gucken.
Guck, so sieht das aktuell aus.
So sieht das aus.
Ja, ist gerade ein bisschen unscharf, aber
so sieht's aus.
Man erkennt da nicht wirklich viel, das ist halt eingebaut
in die Heizung.
Das geht nicht, dass ich mich nicht ablenken lasse.
So sieht das aktuell bei mir im Keller aus.
Und ein Mensch
erkennt sofort, dass wenn ich ihm sage,
das ist 1 bis 2
und 0,2 Schritte, erkennt er sofort.
Ah, das steht auf 1,4.
Siehst du
sofort. Aber ich hab
bis jetzt noch keine AI gefunden, die
das auslesen kann.
Da ist kein Rohr zu erkennen.
Da muss man aufklappen und da hinten
Ich kann dir
sagen, was das für ne Heizung ist. Das ist eine
Wiesmann
Vitodens 200 F
oder irgendwie sowas.
Ist das 200 F? 200 W?
Weiß nicht, sowas
könnte das eventuell
theoretisch sein.
Ja, ich glaub so sieht
das innen drin aus.
Tja.
Also daran rumschrauben ist keine
allzu schlaue Idee.
Aber Leute, ich wollte noch was zu dieser
Sache sagen. Achso,
was wir heute machen. Wir bauen
heute ein Arch User Repo Package.
Wir machen mehrere
Sachen. Wir bauen ein Arch User
Repo Package. Das gibt es teilweise.
Also ich hab heute Morgen schon ein bisschen
gebastelt. Wir erweitern dann unseren
GitHub Workflow, dass das Ding auch automatisch
Updated werden kann.
Dann bauen wir noch ein paar schöne Badges
ein im Projekt, dass es schicker aussieht.
Vielleicht bauen wir noch
1-2 kleine Features ein in
den VM Champ, dass es
rechtfertigt Version 0.0.3
zu bauen, um
zu testen
ob das
Updaten vom Package funktioniert.
Ehrlich gesagt, ich sollte mal langsam
auf Version 1
hochgehen, weil
dann kann ich die hinteren Stände eben
mit Patches machen. So ist es ein bisschen doof.
So muss ich halt immer für jeden Scheiß hochzählen.
So, ich wollte aber noch kurz dazu
was sagen.
Lizenz, das ist eine gute Idee.
Lizenz.
Wir legen die Lizenz fest.
Ja, erinnere mich mal nachher dran.
So, also
ich wollte noch was zu der Thematik
sagen.
Welches Linux sich für
was eignet.
Es ist wie bei vielem.
Man muss
gucken, was man machen will.
Also nicht nur
gucken, ist es
ein Server System oder ist es irgendwie
ein Desktop System und ist es
irgendwie, sondern muss auch gucken, was man
da für Anwendungszwecke hat. Zum Beispiel
nur mal so etwas Praktisches zu sagen.
Ich habe
lange Zeit im Wohnzimmer
sowas hier stehen gehabt.
Das ist
es sieht ein bisschen hässlich aus, aber wenn
eine Festplatte drin ist und man das noch zu macht,
sieht es gar nicht mehr so hässlich aus.
Das ist im Prinzip ein
Festplattengehäuse
mit einem
mit einem
so eine Art Raspberry Pi mit einem
Single Board Computer hinten dran mit SATA
Schnittstelle. Das ist quasi so
um sich sein eigenes
Mininas zu bauen.
Und das Ding
hat acht Kerne. Also das ist so
schneller als ein Raspberry Pi, zumal
es als ein damaliger Raspberry Pi gewesen ist.
Es ist gar nicht so, also 100
Mbit kriegst du, also Gigabit kriegst du damit
locker, easy, voll.
Sogar teilweise mit Verschlüsselung.
Zumindest worauf ich raus will ist,
ich habe das Ding ja nicht im Wohnzimmer
liegen gehabt, just for fun, sondern
das war zum Aufnehmen
von DVB-T,
äh nicht DVB-T, DVB-C
also.
Vodafone Kabelfernseher zum Aufnehmen.
Da war TV-Header drauf und eine Festplatte
dran und per USB
war ein Dual-Tuner
angeschlossen für
DVB-C. So und normalerweise
könnte man jetzt sagen und habe ich auch
versucht, wir nehmen was Klassisches,
ja wir hauen Ubuntu drauf oder wir
hauen Debian drauf
und gut war,
aber ging nicht.
Wir haben
einen neueren Kernel gebraucht,
der updatete,
geupdatete DVB-C
Treiber hatte. Das heißt, da muss
man wirklich so ein System, was eigentlich für
24 Stunden 7 laufen ist,
damals tatsächlich mit einem Arch-Linux
ausstatten, weil wir was
wirklich Neues gebraucht haben
mit den eingebauten Kernel-Modulen
mit den neuen. Also es hängt
ein bisschen davon ab, was man machen will. Normalerweise
so auf 0815
x86 Hardware,
wo man jetzt nicht
irgendwie spezielle
Hardware-Treiber oder so braucht,
sondern das meiste ist ja schon seit Jahrzehnten
im Linux-Kernel drin, was man so braucht.
Zumindest so an den
klassischen Intel-Netzwerk-Karten-Treibern,
Realtek und was es nicht noch gibt.
Dann ist Debian eine super Geschichte
für Server-Betriebssysteme.
Debian, ich habe
jahrelang gerne auch Ubuntu verwendet
auf dem Server. Ich fand Ubuntu
lange Zeit war eine super Kombination
aus
Aktualität
und langem Support. Also sprich,
die Dinger waren immer relativ aktuell,
als sie rausgekommen sind und wurden dann lange
supported. Nicht wie Debian, was schon
irgendwie uralt ist, wenn es
erscheint.
Und ich fand auch die Paketauswahl
und wie das standardmäßig vorkonfiguriert war
und der Weg, wie man was macht, unter Ubuntu
jahrelang wirklich gut gemacht, sodass ich
Ubuntu
auch auf Servern-Systemen
vorgezogen habe, gegenüber Debian.
Mal im Enterprise-Business-Umfeld
außen vor,
da ist es gerade in
Finanzbranche
ist es da
sehr viel CentOS und
Red Hat, original Red Hat
oder aber auch
manchmal habe ich da Suse gesehen,
aber ganz selten. Aber das meiste ist Red Hat
beziehungsweise CentOS. CentOS
gibt es jetzt ja nicht mehr.
In der älteren
Form. So, aber
nachdem es ja Canonical die letzten
Jahre über so verkackt hat mit
Ubuntu, habe ich
gar keinen Bock mehr drauf, Ubuntu auch auf
Servern zu verwenden.
Das hat alles angefangen mit
diesem
leidigen Thema Snap-Packages,
dass die
immer mehr Sachen, die man haben wollte,
in Kack-Snap-Packages verpackt haben.
Davor hat es
schon angefangen mit Netplan
für die Netzwerkkonfiguration.
Ich meine, wir haben alles auf die
Idee gekommen, dass es ein
guter Gedanke ist,
die Netzwerkkonfiguration in irgendeinem
undurchsichtigen YAML-File
abzubilden.
Snap-Packages,
dann die Sache mit
Netplan und wenn ich jetzt
ein bisschen nachdenke, fällt mir bestimmt noch mehr ein.
Und da ist Ubuntu für mich
so ein bisschen unattraktiv geworden.
Deswegen habe ich gesagt,
weißt du was, wir nehmen
jetzt wieder den Klassiker Debian und
ich mache mittlerweile die meisten Kisten, wenn ich
die Auswahl habe, wieder mit Debian
drauf.
Und auf dem Desktop gibt es eigentlich gar
keine Frage. Auf dem Desktop
ist es Arch, by the way.
Eigentlich immer.
Arch ist auf dem Desktop super, gerade in der
VM ist das toll, weil da machst du auch
ab und zu mal einen Snapshot, sollte es mal wirklich nicht gehen
nach dem Update.
Aber das hatte ich noch nie. Ich hatte legit,
ich verwende das jetzt jahrelang schon, also
wirklich lange, seit
10 Jahren vielleicht noch nicht, aber
naja,
sagen wir mal, seit 6, 7 Jahren verwende ich
Arch schon und
ich hatte noch nie, dass wirklich durch ein
Update das System kaputt
gegangen ist. Ich meine, die Chancen dort sind höher
als bei anderen.
Dank Rolling Release, aber bis jetzt
noch keine Probleme gehabt, ja.
Was ich von Pip halte ist,
das ist ein Package Manager für Python.
Naja, es ist ein Package Manager
genauso was wie Cargo
oder
Gem oder sonst was. Dir bleibt ja
nichts anderes übrig, wenn du Sachen
installieren willst, die es vielleicht nicht in deinem
Package Manager gibt.
Oder NPM oder sowas.
Ansonsten muss ich sagen,
also, was ich bisher mit
Pip gesehen habe, waren
ein bisschen umständlich, wenn man das mal mit
anderen Package Managern vergleicht, aber
ist halt so.
Ja, umgeht PacMan, aber was willst
du machen, wenn es in den Repos
das Package nicht gibt?
Minus Minus Force.
Wenn nichts geht,
Minus Minus Force.
Vorher einen Stepshot machen.
Ich will ja nichts selbst programmieren.
Ich will ja irgendeine AI haben, die das Bild erkennt
und zuverlässig
ist. Wenn ich selbst irgendwas gebastelt
habe, habe ich keinen Bock drauf in dem Fall.
Nee, das funktioniert nicht.
Du meinst AI?
Du meinst das
hier, gell? Let's play
gear. Du meinst das
hier. Nee, das funktioniert nicht.
Das funktioniert mit Zahlen oder nur mit Runden
solchen Analog-Anzeigen.
Die durchgehende. Nee, nee.
Das funktioniert nicht gescheit damit.
Sind diese China-Chinesen
Android-Boxen nicht bissl
virenverseucht? Äh?
Ich weiß jetzt nicht, wie du drauf kommst,
aber ich würde es nicht wundern, wenn irgendwelche
China-Chinesen-Handys Backdoors
drinnen hätten.
Gerade die super billigen und
noch weitgehend unbekannten Hersteller
hier. Ich glaube, dann bist du
der Einzige, der Snap mag.
Chat, mag noch jemand Snap von
euch? Ubunt, diese Canonical
Ubuntu-Snap-Geschichte.
Wie sieht die Netzwerkkonfiguration
unter Arch aus?
Ich benutze einfach einen Network-Manager und mache mir
darüber keine Gedanken.
Hatte mit Snap nur Probleme, ich auch.
Mich nervt das, dass viele
Sachen unter Ubuntu noch als Snap
ausgeliefert werden, wie zum Beispiel Browser und sowas.
Endeavor hat mich
nicht überzeugt. Wir haben es hier im Stream ausprobiert.
Es gab letztens
ein Problem mit Krupp, glaube ich.
Da war
was. Ich erinnere mich. Das ist auch
ein halbes Jahr her. Da hat
irgendein Krupp-Update bei manchen Leuten das System
zerlegt. Also es kommt immer mal
wieder vor. Deine Meinung
zu Linux-Viren?
Ja, sind nicht so verbreitet.
Also unter Linux bist du immer noch am sichersten
unterwegs aktuell.
Das liegt an zwei Sachen.
Es liegt einmal daran,
dass Linux weniger verbreitet ist.
Aber es liegt auch daran,
es liegt an drei Sachen.
Einmal, dass Linux weniger
verbreitet ist. Das zweite,
dass Linux
generell ganz gute Sicherheitsmechanismen hat.
Und das dritte ist, was Windows
aber auch hat, muss man sagen. Windows ist
da auch, ich will nicht sagen Windows
fast noch mehr, das kann man so nicht sagen.
Aber Windows auch.
Aber Windows ist halt deutlich mehr Beschuss ausgesetzt.
Aber das dritte ist, und das finde ich ist eigentlich
das Wichtigste, dass Linux-
User, wenn sie Linux
User werden,
sonst werden sie ja keine Linux-
User, logischerweise,
meistens ein bisschen mehr Ahnung von Technik haben,
beziehungsweise ein bisschen mehr Interesse dran.
Und dementsprechend sie nicht auf
die 0815 Scams reinfallen.
Das heißt, die Linux-User sind in der Regel
schlauer und fangen sich deswegen auch
weniger Viren ein. Was heißt
schlauer? Technisch
versierter. Doch, doch, doch,
doch, Ubuntu-Binarys laufen auch unter
Arch, die in den meisten
Fällen schon. Warum sollten Ubuntu-Binarys
nicht unter Arch laufen?
Also, natürlich,
es gibt Fälle, da ist das so.
Wenn du Abhängigkeiten
hast von einem Binary zu
bestimmten Library-Versionen und
die ist dort zu alt oder
nicht vorhanden oder so, ja, das ist
immer so. Aber du hast
mittlerweile viele
Umgebungen, die, also
sei es jetzt neuerdings C-Sharp, sei
.NET, .NET 8 oder auch
Go. Go ist ja wohl der
Vorreiter schlechthin, was das
angeht.
Die haben unabhängige Binarys,
die du auf allen Distributionen benutzen kannst.
Also, die laufen schon.
Also, du kannst schon Binarys
von einer Distribution
auf die andere schieben, zum größten Teil.
Ne, also, gut, es kommt
ein bisschen drauf an, was es ist.
Aber wenn es Go ist, auf ganz
gar keinen Fall. Go geht einfach so
und viele Sachen gehen auch so.
Die Leute bauen dann einfach Linux-Binarys
und keine
expliziten Ubuntu-Binarys und Arch-Binarys.
Aber was die Leute machen ist,
die bieten verschiedene Packages
an. Die bieten
Ubuntu, Debian-Packages an
oder RPM,
Red Hat, Fedora-Packages oder sowas.
Aber wenn du Binarys hast,
da läuft vieles auch
cross-distributionsmäßig.
Also,
die werden wahrscheinlich lauffähig sein.
Nun gut.
Rechner neu gestartet,
vmchamp am Start mit Pull-Request.
Der richtige Name ist Go
und es ist golang nur aus dem Grund,
damit man danach suchen kann, weil niemand kann
nach Go suchen. Nach golang schon.
Wie sieht Go-Quelltext
aus? Du gehst auf Google
und gibst ein Go-Example
und guckst dir das erste Beispiel an.
Ja. Bei Alpine
Linux wäre ich tatsächlich ein bisschen vorsichtig.
Ich habe da in letzter Zeit
immer mal so ein paar
Blame-Posts drüber gelesen,
dass die Leute mit Alpine
Linux Probleme bekommen haben.
Nicht Security-technisch oder so,
aus dem Kontext, sondern
mit DNS-Auflösung.
Weil Alpine
verwendet ja keine normale C-Library,
sondern die haben hier ihre Musel
glibc oder nee, nee, warte mal.
glibc ist das normale und
musel.libc ist das, was Alpine
verwendet, was sonst irgendwie niemand außer Alpine
verwendet.
Oder Musel oder wie auch immer
man das ausspricht.
Also wahrscheinlich für
Micro C8
keine Ahnung wofür das steht.
Und die haben tatsächlich
Probleme mit DNS-Auflösung.
Wenn die DNS-Anfrage
ich glaube
mehr als
512 Byte ist
der
DNS-Request
oder die Response
ich bin mir gar nicht sicher wieviel es war
oder 1024 Byte
dann mag Alpine nicht
und deine DNS-Requests gehen nicht richtig.
Und in Zeiten von
komisch generierten Namen
heutzutage heißen ja Cloud VMs
irgendwie so
Punkt so, Punkt so
da kann das schon mal passieren, je nachdem
wenn es da noch mehrere Records gibt
dass das nicht so
nicht mehr reinpasst
und Alpine Probleme macht.
Dann würde ich es mir zweimal überlegen
aktuell wirklich Alpine zu verwenden
zumal der Riesenvorteil von Alpine
eigentlich
also Alpine hat zwei Vorteile
einmal es ist ein bisschen
die C-Leihe ist vielleicht ein bisschen exotisch
und es ist besonders minimalistisch
das heißt es bietet auch weniger Angriffsfläche
aber die
der zweite Vorteil von Alpine
das es eben so minimalistisch ist
und die Images
die Alpine verwenden so klein sind
diesen Vorteil gibt es
eigentlich gar nicht mehr
so extrem seit
Multistage Builds
also seit man Docker Builds machen kann
wo man dann am Ende nochmal ein extra
Image generiert, wo nur der Output reinkommt
den man auch wirklich haben will
da kannst du auch Debian nehmen
das ist dann da unterm Strich vielleicht 15 MB größer als ein Alpine
aber du hast halt mit nichts Probleme
übrigens Max bist du noch da?
Das was du hier geschrieben hast dürfte nicht so sein
oder?
Ja, hast schon gesehen, hast schon gesehen
aber du hast recht
das Problem an sich, dass man auch kein Custom Key auswählen kann
so das gibt es noch
aber das klang jetzt erstmal
wenn es jemand liest
kopiert alle Private Keys
die Leute denken erstmal
Monk KS alter
was ist da los
dabei kopiert das überhaupt keine Private Keys
China Chinesen Tool
auf GitHub
kopiert erstmal alle eure Private Keys
ne der nimmt nicht den SSH Ordner
der nimmt
Public Keys die
IDRSA
IDDSA und
ED256578585970
oder so auch immer heißen
ja
ok
also
Chat ich zeige euch nochmal wo wir gestern
stehen geblieben sind
ne ich zeige euch was anderes
ich zeige euch das Arch User Repo
was ich angelegt habe
guckt mal da
ich habe nämlich im Vorfeld schon was angelegt
2 Packages
vmchamp
guckt mal da
es gibt 2 Packages
es gibt einmal das Git Package
also das was immer live baut
vom Vorti und ich habe heute morgen auch eins angelegt
Maintainer ist da wubblos
und
da gucken wir heute
das wir was reingepusht bekommen
ich kann euch auch beweisen das das funktioniert
machen jetzt mal folgendes
guckt hier ist die Software
die wir packagen wollen als
Arch Repo also als Arch User Repo
Package
die liegt bei mir aktuell noch lokal
hier rum
hopp
die löschen wir jetzt
bam
jetzt ist weg
geht nicht mehr
nicht gefunden
und jetzt installieren wir
das Arch User Repo
Package davon
und siehe da
äh
wir haben es wieder
diesmal allerdings aus einem Arch User Repo installiert
das habe ich heute morgen
glaub sieht man hier irgendwo auch die Zeit
hier 12 Uhr 11
ne UTC dann ist es 13 Uhr 11
was auch immer
irgendwann heute Vormittag Nachmittag
oder Mittag
sag mal Mittag habe ich das gemacht
was ist besser
also
ich mag das
Paru ist das in Rust glaube ich
also das habe ich lange Zeit verwendet
das ist aber sehr oldschool
noch in Pearl programmiert und sowas
und
jetzt verwende ich das
und ich sehe auch keinen Grund irgendwie zu switchen
na 14 Uhr 11 habe ich das aber nicht
das habe ich nicht gemacht
das war relativ sicher
früher
wobei ne kommt hin
vergisst was ich gesagt habe
14 Uhr 11 ist ok
es gibt einen Vergleich
zwischen den ganzen Hilfstools
Auer Helper
mal her
ja oder ist es
oder ist es Jeha
so richtig Kokona Style
oder Jeha sagen die ja eher
Kekona
Twitch Emotes
long ago
weiß nicht mal
wie das geht
so ähm
da hier da ist ein Vergleich
also es gibt ein Vergleich
zwischen
oder weniger alle das gleiche oder
also
du kannst eigentlich benutzen was du willst
gut ist das Jaurt
nicht mehr drinnen steht
Jaurt
das hieß auf Französisch Joghurt
ja man sieht es hier auch
Arch Linux FR
aber das wird nicht mehr supported
schon eine ganze Weile nicht mehr
jo
was haben sie denn hier für ein Vergleich drinnen
zeigt mal her
eigentlich ist es egal was du benutzt oder
die können alle mehr oder weniger das gleiche
also ist jetzt egal ob du Paru benutzt
oder Yay benutzt
oder Trizin benutzt
oder Pick Auer benutzt
oder Paku
oder was auch eigentlich wurscht
ich benutze das
wenn das Pogu heißen würde
anstatt Paru
dann würde ich mir das tatsächlich überlegen
aber es heißt nicht Pogu
ganz schön weird champ
die Benamung ja es ist written in
Rust aber hey ich meine nur weil
eine Software written in Rust ist
das heißt nicht zwangsläufig das man die verwenden muss
ich weiß die krusten Tiere unter uns
die sehen das anders
aber für mich ist es erstmal zweitrangig
in was eine Software programmiert wurde
solange sie gut funktioniert
und ich eine hab mit der ich mich auskenne
und die gut funktioniert sehe ich erstmal keinen Anlass
dazu mich da irgendwie
nur weil das andere in Rust programmiert ist
das zu benutzen und man kann es ja auch
nicht sagen als wäre Yay irgendwie super langsam
oder so das ist ja auch gar kein Problem
es geht einfach
es sei denn sie wurde in Javascript
man kann selbst ohne Probleme heutzutage
Javascript Software verwenden die ist auch ziemlich schnell
man kann sogar
guckt euch Discord an man kann sogar
Elektron Software ganz gut verwenden
allerdings muss man sagen Discord Cheated
Discord hat in der Desktop
Version viele Sachen
in Node
C++ Modulen drin
habe ich mir sagen lassen
weiß nicht
ob das stimmt aber ich glaube
ich kann das einfach mal jetzt
und ich könnte mir sogar vorstellen
dass Discord für die Web Apps
sogar relativ
gut auch schon
Web Assembly verwendet
ohne es zu wissen ich rate das jetzt aktuell
also
ich würde sagen dann fangen wir mal an
also hier haben wir unsere User Repo
was WhatsApp Desktop war früher
Elektron und die haben dann auf Native umgestellt
100 mal besser und schneller geworden
ja WhatsApp hat ja auch überhaupt keine
Sinn warum muss das warum muss
das also wobei damit kann man
ja auch telefonieren ja es hat schon
ok dann nehme ich das zurück es hat
schon seinen Sinn oder ich kann es gut
verstehen dass Discord
eine Elektron
Anwendung ist oh Mensch
muss gerade mal was gucken so
also ich kann es schon
ich kann es schon verstehen
können wir gleich gucken
ich kann schon verstehen warum sowohl
WhatsApp als auch Discord in Elektron
im Browser programmiert ist
also gerade im Fall von Discord
verstehe ich es gut
hä
also
jetzt habe ich mich ablenken lassen
durch das zweite Browser Fenster
hier auf dem zweiten Bildschirm
also ich kann schon verstehen warum
WhatsApp Desktop und vor allem Discord
in Elektron im Browser
programmiert ist also
das offensichtlichste ist natürlich
dass es damit relativ easy ist
alle möglichen Plattformen zu
unterstützen also du kannst
ja wenn du eine Elektron Anwendung hast
kannst du die easy laufen lassen unter Mac
Windows Linux und mit ein paar Anpassungen
auch auf den ganzen
Mobilgeräten
der zweite und wahrscheinlich
sogar noch ausschlaggebendere Faktor
warum Discord
sich nahezu anbietet
das in Elektron zu machen ist
Discord ist eine
Multimedia Anwendung
also die benutzen Audio
Video
Bilder alles mögliche
so und wenn du Audio Video
selbst
bauen möchtest
auch nur die Native Schnittstellen
benutzen möchtest dann wirst du verrückt
da musst du das
komplett anders handhaben unter Windows
unter Linux und Mac vor allem unter
Linux ist abfuck da gibt es
1000 Varianten wie du Sound machen kannst
ja 1000 Varianten
wie du grafische
Ausgaben machen kannst wie du Videos machen kannst
das ist für den Arsch
und deswegen haben die sich
zurecht gesagt die Leute von Discord
wir machen das mit Elektron
weil da können wir das Audio Video Zeug
vom Browser benutzen
und das war eine sehr clevere Entscheidung
auch wenn vielleicht
eine Native App
theoretisch ein bisschen speichersparender
und ein bisschen schneller und ein bisschen
mehr responsive wäre
es wäre den Aufwand nicht wert gewesen
Discord
ist das perfekte Beispiel dafür
warum es sinnvoll sein kann
auch große Anwendungen Elektron zu machen
inzwischen Audio
bei Screenshare im Discord
keine Ahnung
aber wenn es im Browser geht kannst du davon ausgehen
dass es im Discord mittlerweile auch geht
beleg dir mal die müssten es selbst programmieren
dann würde es wahrscheinlich nie richtig funktionieren
ja aber
so viel dazu
ok also was wir heute vorhaben
ist folgendes
ich habe eine Software hier in meinem Repo drinne
den VM Champ
es ist egal was er macht
und das Ziel ist
dass wenn ich einen neuen Tag pushe
ins Git Repo
aktuell sind wir bei Versionsnummer 0.0.2
wenn ich einen neuen Tag pushe
dann soll folgendes passieren
der soll
die Software bauen
unter einem uralten CentOS 7
wenn ihr wissen wollt warum
ein uraltes CentOS 7
dann schreibt es ins Chat
dann erkläre ich es nochmal
dann soll die Software
hier in Github Actions
als Build angehängt werden
am Ende soll noch irgendwann mal
ein neuer Release gemacht werden
hier auf Github und
ich möchte
dass ein Arch User Repo
mit der aktuellen Software Version
aktualisiert wird
aktuell habe ich hier ein Arch User Repo
von Hand erstellt
wir können uns mal das Package Build angucken
ich habe das zum ersten mal gemacht
aus unterschiedlichen Quellen
so sieht das Build File aus
für ein Arch User Repo
für eine Software
die man über ein Arch User Repo
verteilen will
da muss man dann Sachen reinschreiben
wie das Repo heißt
die Package Version Nummer
Package Release
Description für welche Plattform
es zur Verfügung gestellt wird
die URL vom Projekt
die Lizenz
welche Abhängigkeiten man hat
hier unten ist dann das drin
was auf dem System installiert wird
warum ich da zwei Install Calls drin habe
einmal um das Verzeichnis
zu erzeugen im Output
und einmal um es rein zu kopieren
vielleicht kann man auch Install-P machen
weiß ich gar nicht
so
das ist das Ziel
dass das Arch User Repo
dieses Package Build funktioniert
habe ich euch ja gerade gezeigt
nicht vor M wer
die Software ist unter
Arch User Bin
also das funktioniert
jetzt ist nur die große Preisfrage
wie kriegen wir das miteinander
verzahnt
also wie kriegen wir Github Actions dahin
das ordentlich zu bauen
und danach ins Arch User Repo
hochzuladen
und eventuell danach auch noch
ein Github Release anzulegen
das müssen wir heute raus bekommen
wie das funktioniert
und ich überlege gerade
mit was wir am besten anfangen
ich kann euch mal das Package Build
zeigen wie das aussieht
also
wenn man das
das Github hinter dem
Arch User Repo
Projekt hier klont
dann bekommt man
ein Repo mit genau zwei Dateien drin
es gibt einmal
PKG Build
das ist das was ich euch eben gezeigt habe
und es gibt Source Info
das wird aus dem PKG Build
erzeugt nochmal
das ist quasi das gleiche
nur in anderer Form
und was das hier macht
ist wie gesagt relativ übersichtlich
das lädt das Programm
von Github runter
also das hier muss es geben
diese zwei Sachen damit ich das hier machen kann
damit ich über den Package Manager
von Arch Linux diese Software
hier installieren kann
dass es geht
sieht man ja hier
und diese zwei Dateien braucht man dafür
was da drin steht ist folgendes
hier steht wo es die Software gibt
in dem Fall ist es halt ein Binary Release
deswegen heißt das Ding ja auch vmchamp bin
da muss man nix selbst
kompilieren das wird fertig runtergeladen
von Github hier muss die Download Version rein
in dem Fall ist es halt immer hier
wo bloß vmchamp releases
Package Version
vmchamp dienungs
Package Version AMD64
und hier ist dann drin
was passiert
wenn das Package erzeugt wird
ich kann euch das auch mal zeigen
wir können das jetzt
von Hand machen
Make Package
das ist das was
das ist das was dieses Tool hier unter der Haube
auch aufruft
Make Package
bumm
und jetzt hat man hier quasi die Rohversion
von diesem Package im Verzeichnis liegen
man sieht das hat er jetzt aus diesem
Package Bild erzeugt
und man kann sich den Inhalt
von dem Package auch nochmal angucken
das ist im Prinzip das was man erwarten würde
es ist quasi ein
der Pfad wo das installiert werden soll
im Endeffekt
ist in diesem Package drin
und das ist quasi ein Target Set
was der baut
und dann ein Target Set
was der Package Manager wieder auspackt
und bei euch ins System legt
das ist halt das wie Arch Packages funktionieren
bei der Haube ist das
wenn man so will nur
ich sag jetzt mal Zip
auch wenn es kein Zip ist
so eine Art Zip
da sind zwei Sachen drin
einmal das Programm an sich
und einmal einen Link auf das Programm nochmal klein geschrieben
so sieht das aus
und
klauen wir das nochmal
gut
heißt im Endeffekt
wir können dort weitermachen
wo wir gestern aufgehört haben
ich zeige euch mal wo wir gestern aufgehört haben
gehen wir mal hier
achso
ja ich kann euch jetzt noch erklären
ich weiß nicht ob jemand gefragt hat im Chat
ich kann euch noch erklären warum ich diese Software unter einem
uralt CentOS 7 baue
ich zeige euch mal das Dockerfile dazu
warum will ich eigentlich immer dicker
File schreiben
jep kocka
so Dockerfile
das passiert
beim Build von der Software
er checkt ein uralt
CentOS 7 aus
dann installiert er ein paar
YUM Dependencies
installiert
.NET 8
Preview wie man hier sieht
man sieht nicht das Preview ist
aber .NET 8 ist gerade im Preview
dann kopiert er die ganzen Source Dateien rüber
setzt ein paar Magic Variablen
für .NET
und dann kompiliert er das ganze
also hier
er kompiliert das mit .NET Publish
für Linux x64
Release Version
er soll jetzt
selfcontained executable bauen
er soll das ganze
zusammen kompilieren in eine Datei
er soll ein paar Debug Sachen
rauslöschen und in Output
also er soll das in den Build Ordner
als Output schreiben
und danach das ist jetzt Trick 17
danach lege ich noch ein
leeres Image an mit dem
resultierenden Binary
das Binary liegt dann am Endeffekt in
im Build Ordner
aus dem resultierenden Binary baue
ich dann quasi noch ein leeres Image
damit ich
das gebaute Programm
aus dem Image wieder raus bekomme
und das ist alles was in diesem
Docker Fall passiert
so und jetzt ist die Frage Chat
ich sag gleich was zu
und jetzt ist natürlich die Frage warum
muss ich das bauen mit einem uralt CentOS 7
was kann ich euch erklären
ich benutze hier ein neues
was ist ein neues ein erweitertes
Feature was sie mit .NET
8 eingeführt also was sie mit
.NET 8 erweitert haben und zwar
sie haben ihren
Compiler verbessert für .NET 8
sie haben ihren
Compiler verbessert in .NET 8
und zwar
die Binaries die rauskommen sind
jetzt viel kleiner als
vorher und die Startzeit
ist noch schneller
was natürlich eine coole Kombination ist
es gibt bloß ein Problem
wenn man diesen neuen Compiler benutzt
es klingt jetzt
erstmal so als hätte das alles nur super viele
Vorteile weil ich meine es ist kleiner es startet
schneller und so ist eigentlich ganz toll
naja es hat einen Nachteil
wenn man diesen neuen
diesen neuen Compiler in .NET benutzt
man bekommt eine
Abhängigkeit rein
und das ist eine Abhängigkeit
auf die GLibc Version
des Systems auf dem man die Software
baut
und wenn ich die Software baue
das ist übrigens ein riesen Vorteil
und Go damit hat man solche Probleme
nicht Go erstellt
Selfcontained Binaries
ohne solche Probleme
zumindest in dem Fall hat man das Problem
und man hat eine Abhängigkeit auf
die GLibc Version
des Systems auf dem die Software
kompiliert wurde
was natürlich
bisschen doof ist weil ich habe hier
GLibc 2.37
das ist sehr neu
und es gibt Systeme
die haben ältere Versionen und da läuft
es dann nicht drauf
dann habe ich zwar ein Binary aber es funktioniert
nicht weil es beim Start sagt ja
GLibc Symbols not found
auch wenn er nichts davon benutzt
was die vielleicht anders machen
das heißt der Trick ist jetzt
wir bauen das in einem ganz
alten System
und nachdem wir auch sonst nur als Abhängigkeit
also nachdem wir auch sonst nur GLibc
als Abhängigkeit haben holen wir uns da auch
keine OpenSSL
irgendwie Sicherheitslücken oder sowas rein
wir kompilieren das auf einem ganz alten
System auf dem ältesten System
was Dotnet 8 noch unterstützt
und dementsprechend haben wir dann
nur eine Abhängigkeit gegen
GLibc 2.17
und GLibc 2.17
Release Date
ist
von Ende 2012
das heißt unsere Software
läuft auf allen Linux Systemen
die neuer als 2012
sind
und da gehen wir mal von aus
dass
ok ist wenn ich Linux Distributionen
die älter als 11 Jahre sind
nicht mehr unterstütze
ich glaube damit können wir leben oder
da gibt es wahrscheinlich noch ganz andere Probleme
so das ist der Grund
warum das ganze
in einem Docker Container gebaut wird
damit ich die uralt GLibc
Version von CentOS 7 benutzen kann
CentOS 6
geht übrigens an der Stelle nicht mehr
das wird nicht mehr unterstützt
das wäre wirklich antik schon CentOS
CentOS 6
auf meiner alten Arbeit
hatten wir ein CentOS System
das war ein CentOS 6
was ich selbst
als CentOS 4
ja doch ein CentOS 6
was ich als Red Hat Enterprise
Linux 4 getarnt hat
da
da lief eine
uralt Oracle Datenbank
drauf für irgendein
Warenwirtschaftssystem
und das wurde nur 3 mal
im Jahr eingeschaltet oder sowas
und die lief nur
rückwirkend bis
Red Hat Enterprise Linux 4
also CentOS 4 quasi falls es das damals schon gab
und
damit wir das weiter betreiben konnten
haben wir ein CentOS 6 installiert
damals auch schon vor
10 Jahren oder so
und haben in die
ETC
Red Hat Release glaube ich
reingeschrieben du bist kein CentOS 6
du bist ein Red Hat Enterprise Linux 4
und wenn es in der Datei drinnen steht
dann reicht es Oracle dann startet es
das ist nur ein Teil
das hat mich überlebt bei der Firma
weil ich bin jetzt weg
ich bin seit
19 Stunden und 50 Minuten
nicht mehr angestellt
dort
Kündigung ist raus
die Kündigung war schon im Dezember raus
und am Montag geht es dann weiter
woanders da bin ich echt gespannt
drauf wie das läuft
ja soviel zu meinem
Jocker Fall und warum das ganze mit CentOS 7
läuft
bist du aufgeregt?
ja bisschen schon
du hattest ein Video gemacht so was wie morgen ist mein letzter Tag
wie war ihr wirklich?
relativ normal
ich hab mich von den Leuten
verabschiedet
ich hab nochmal in Teams
in paar Channels geschrieben so Jungs bin jetzt weg
ich hab alle ich bin super ordentlich gewesen
ich hab alle meine Tickets geschlossen
ich hab alle meine Tickets geschlossen
mit dem Hinweis das ist mein letzter
Tag im Unternehmen
wenn es irgendwie noch
wenn es zu dem Ticket Rückfragen gibt
und dann
bitte neues Ticket eröffnen in dem und dem Bereich
also
ich bin da mit 0 Tickets
mit 0 Tickets raus
und ansonsten wie war der letzte Tag
ganz normal
nix wildes
ich hab mich bisschen über die Personalabteilung wieder aufgeregt
weil sie immer noch nicht alles fertig hatten
normal bei dieser Personalabteilung gewesen
die war immer bisschen lahm
mit allem
ansonsten gibts da nix großartiges
zu berichten
war recht unspektakulär
es hat mir ein bisschen leid getan halt
weil die ganzen Leute sich die haben sich ja noch
alle verabschiedet und so
manche haben geschrieben Max es war mir eine Ehre
also so Redewendung mäßig
hab ich dann auch noch
mal mit Herzchen geliked im Chat
obwohl ich das sonst nicht mache
aber es war ein ganz normaler Tag
15 Uhr
10, 15, 15 oder so bin ich abgehauen
zum Hauptbahnhof heimgefahren
und hatte noch gar nicht so richtig das Gefühl
oh das war es jetzt
aber
das war es, es ist gewesen
bin jetzt weg
mein Account geht noch
ich hab mich heute morgen mal versucht über den Browser
justforfun einzuloggen
also deaktiviert haben sie mich noch nicht
mal gucken wie lange sie dafür brauchen
bis sie mich deaktiviert haben
und vor allem mal gucken
und nein ich hab nichts
ich hab nichts eingebaut oder so Leute
aber ich bin mal gespannt was kaputt geht
wenn sie meinen Account deaktivieren
weil ich könnte mir durchaus vorstellen
dass unter meinem Account noch irgendwo
irgendwelche Sachen laufen
und getriggert werden
die dann nicht mehr funktionieren
ich meine ich war da so lange dabei
da bleibt es nicht aus
aber da kann ich ja nichts für
Max du kennst dich ja gut mit PCs aus
nee nicht wirklich
mit Hardware und sowas
und gerade von Windows habe ich gar keine
keinen Plan
vielleicht warum ich in Fortnite mit der 470
die ESLG Mikroruckler bekomme
nö keine Ahnung
meine Standardvermutung wäre sie wird zu heiß
aber das ist meistens nicht so
neuer Treiber sie wird zu heiß
keine Ahnung ich kann dir da auch nur die 0815 Tipps geben
da gibt es Leute die kennen sich besser aus
damit
du könntest VMChamp nutzen um VMChamp zu bilden
das wäre richtig high IQ
du meinst ich könnte eine VM anlegen
und in dieser VM dann VMChamp kompilieren
ja dumm nur dass
glaube ich in Github Actions Nested Virtualisierung
nur schwierig doch geht
ich glaube Nested Virtualisierung
geht sogar
in
Github Actions aber ist halt
unsinnig langsam
ja
ja das ist halt so
ich muss mich bei mir den Bedanken gleichzeitig beschweren
ich habe dich vor 1
ich habe dich vor 1 bis vor 1 nach einer Linux
Anfänge dazu gefragt bin nun an meinem
ersten Arch Install dran der Mist lässt sich nicht
lässt mich nicht locker
ja
du hast schon mal die einzig wahre
Gigachat Distribution ausgewählt
neue
Mario Kart 8 Karten
du hast schon mal die einzig wahre
Gigachat Distribution ausgewählt
eins kannst du dir sicher sein
wenn du das ordentlich installiert bekommst
wobei es mit dem Arch Installer eigentlich
geht und dann
halbwegs ordentlich eingerichtet bekommst
so wie du es haben willst dann hast du schon mal
mehr Ahnung als 95%
aller Linux User
und und mehr Ahnung
na gut das kann man so nicht sagen wahrscheinlich sind
sind nicht nur 5% der Leute Arch User
sondern mehr also du hast
auf jeden Fall mehr Ahnung als 95%
aller Computer User
ja also aller PC Benutzer
und wahrscheinlich auch mehr Ahnung
als die meisten der Linux User
wenn du das auf die Reihe bekommen hast
Hi Max du kennst nicht
zufällig das Problem das die Fritzbox IP
Adressen außerhalb der DHCP Range
vergibt nee warum macht die denn sowas?
auf diesen Geräten komme ich dann nicht
außerhalb meines eigenen Netzes
hä wie jetzt?
ich glaube
ich weiß was
ich weiß was schief läuft
kann das sein
dass die IP
mit 169 anfängt
guck mal nach sag mir mal die IP
die da vergeben wird
fängt die mit 169 an
ich hab so ein ganz gutes
Gespür für solche Fehlerbeschreibung
lasst uns mal gucken ob ich richtig liege
mit meiner Vermutung
erzähl mal die IP
SK99
sag mal die IP
von deiner Fritzbox
also was die vergeben hat
meine Vermutung ist nämlich folgendes
dass das DHCP nicht funktioniert
und sich deswegen das Netzwerk Interface
eine
wie heißen die Dinger
wie heißen die 196 IP Adressen
wie nennt sich das
IPA
APA
ach du kacke man
APIPA
genau
das vermute ich nämlich dass es schlicht und ergreifend
nicht geht
und die einfach sich so ne Link Local Adresse
generaten
das heißt der DHCP vergibt
die Adresse nicht sondern
das Interface selber
aber wahrscheinlich ist SK
schon weg
weil er nicht 5 Minuten Zeit hatte zu warten
bis ich seine Frage beantworte
da ist er
da ist er doch schon wieder
achso
ok ich hab falsch gelegen
ich hab falsch gelegen
die IPs die vergeben werden sind unter anderem
178
178 klingt nach
Fritzbox Default Netz
ok
ehrlich gesagt keine Ahnung
wie man IP Ranges angibt
in
im DHCP von der Fritzbox
keine Ahnung
aber du solltest da trotzdem drauf zugreifen
können
weil das ist ja höchstwahrscheinlich
ein Slash24 und dementsprechend trotzdem
das gleiche Netz
oder ist es kein Slash24
gut dann machen wir mal weiter
ich zeige euch
jetzt wo wir stehen geblieben sind gestern im Stream
und an der Stelle setzen wir jetzt
auch an
gestern haben wir folgendes gemacht
ich mach diesen ganzen Camp
die wollte ich jetzt eigentlich nicht zumachen
wir starten mal ein Firefox neu
wobei ich habe
keine ganzen Rechner neu gestartet
so
what the fuck
komplett verkehrt
also wir sind hier stehen geblieben
wir haben
für diese Software
wie gesagt egal was sie macht
haben wir GitHub Actions gebaut
und zwar haben wir folgende GitHub Actions gebaut
recht übersichtlich
das ganze noch wir haben eine GitHub Actions
gebaut die folgendes macht
nur mal so Recap
von gestern folgendes
macht die Software
äh macht
GitHub Actions in dem Fall
bei jedem Push von einem neuen Tag
ins Git Repo
wird dieser Build Job ausgeführt
bzw. wird der Job ausgeführt der den Namen Build hat
das ganze läuft auf einer
Ubuntu 22.04 VM
warum? weil das Default ist
was heißt Default?
Default ist es nicht aber weil das eine der VMs ist
die auf GitHub angeboten werden
auf GitHub wird angeboten
Mac, Windows und
Ubuntu, Linux
und Ubuntu gibt es in
18.04, 20.04 und 22.04
wir nehmen das aktuelle
Ubuntu und wir führen
dann diese Steps hier der Reihe nach aus
erstmal den ganzen Source Code
auschecken der im Repo drin ist
bzw. den ganzen Source Code
in diese Build VM kopieren
dann
zusätzliche Docker Plugins installieren
wenn wir das brauchen gleich
um das Image zu bauen
und dann führen wir dieses Skript hier aus
das Skript ist relativ übersichtlich
das holt sich aus
Environment Variablen von der GitHub Action
holt sich den aktuellen Tag Name raus
das hier ist der Tag der gepusht wird
also zum Beispiel
wenn hier Tag V003
gepusht wird
dann steht hier unter GitHub Revname V003 drin
davon
schnippel ich
das V vorne weg
also ich nehme Cut an Character
und ich will vom zweiten
Character bis zum Ende alles rausholen
das heißt am Endeffekt in Target Version
steht da nicht V003
drin sondern 003
so dann macht er noch ein bisschen
Magic
wurscht was er da macht er holt sich ein paar
Tokens raus die er braucht und dann
baut er sich ein Container Image
mit Grundlage eben
auf diesem Docker File was ich euch eben
gezeigt habe
was macht er hier mit diesem Kommando
Docker BuildX Build
BuildX ist ein Plugin für Docker
das ist das
das Build Kit Plugin
damit kann man zum Beispiel Docker Container
bauen ich glaube sogar ohne
Root Rechte
und man hat ein paar mehr Features
zu bieten
als das klassische Docker Build
das klassische Docker Build
geht so
und mit BuildX sieht das ganze halt so aus
und zwar gibt es hier so ein paar kleine
Unterschiede zum normalen
Docker Build
nämlich also hier setzt
er die Target Version von den Binary was
rausfallen soll das ist jetzt erstmal egal
man kann das ganze Cachen denn
BuildX bzw wir nennen es einfach mal
Build Kit
Build Kit unterstützt mittlerweile
direkt das Caching
des Container Builds
in den GitHub Actions Cache
das ist eine sehr nice
Geschichte
das heißt die Builds sind jetzt wenn man sie einmal
durchgeführt hat auch viel schneller
weil er vom letzten Build auf die
dort generierten Container Images
zugreifen kann was sonst ein bisschen
problematisch war wenn man in GitHub Actions
Container baut das war
sehr langsam lokal ist es
kein Problem weil er sich das ja immer
speichern kann aber in GitHub Actions ist es
ja immer eine VM
die weggeschmissen wird nach dem jeweiligen Run
was
bei GitHub Actions kann man auch
eigene Docker Images zum Beispiel
von Docker Hub nutzen ja kann man
machen also jedoch
ist dann der Job nie gestartet sondern war
immer pending weißt du warum GitHub
den Job nicht starten möchte sondern immer
nur bei
wir benutzen heute den Docker Image
wirst du wirst gleich sehen wenn er
einfach nur auf pending ist dann waren wahrscheinlich
gerade alle Runner belegt
das ist das ist schon möglich
gerade wenn man das Freed hier hat
aber
normalerweise startet es und gibt einen Fehler
vielleicht waren auch
vielleicht haben die auch gerade Probleme gehabt aber
normalerweise ist das kein Problem das funktioniert das machen wir
heute also wir bauen heute noch was mit einem
Container Image weil wir brauchen einen Arch
wir brauchen einen Arch
Container um unser Package
bauen zu können
so dann bildet er das ganze
und was ich euch
eben im Docker Fall gezeigt habe dieser letzte
Step hier dieses Fake Image
dass er den den Output
dass er das Binary in dieses Fake Image
hier rein kopiert das brauchen wir an
das benutzen wir an dieser Stelle hier unten
nämlich Target Output
nach Temp Output also sprich
das kompilierte
Tool was aktuell noch im Container
Image steckt wird raus
kopiert wieder auf die Ubuntu
VM zurück nach Temp Out
und danach wird das
fertig kompilierte Binary
als Artefakt
also als als Zip
angehängt an den jeweiligen
GitHub Actions Run
dass man sich das runterladen kann
mehr haben wir
gestern nicht gemacht
und das funktioniert auch
ich habe
noch was anderes raus bekommen
was noch sinnvoll ist
zu machen nämlich
dieser Cache
ist standardmäßig gescoped
auf den Branch das heißt
wenn ich jetzt den Branch habe und dort
neue Comets pushe
und für jedes Comet wird so ein Bild gemacht
dann funktioniert das Caching von den
von den Containern
wenn ich allerdings das auf Tag
Basis mache dann funktioniert
das zwar mit der gleichen Tag
Version immer wieder
wobei normalerweise pusht man die
gleiche Tag Version genau einmal
und nicht wieder
und jetzt ist es so
man kann das allerdings um umscopen
man kann nämlich sagen
zum Beispiel hier Scope
oder sowas wie Bild
und dann ist es Tag übergreifend
machen wir jetzt nämlich mal
dass meine Builds in Zukunft
schneller sind
so sind die
jetzt machen wir dieses kryptische
dieses kryptische Kommando mal
damit ich nicht immer von Hand triggern muss
gut
push
und das werden wir gleich sehen was
gestern
Alles klar, so und wenn man jetzt bei GitHub Actions reinguckt, sieht man, der macht ein Bild, was er von Version 4 nicht machen soll, können wir gleich wieder abbrechen, ah please canceln und jetzt müssen wir dem Bild mal zugucken und ihr werdet feststellen, das Bild ist sehr langsam.
Warum ist das Bild langsam? Gut, weil wir noch keinen Cache haben, also unser GitHub Actions Cache, der ist leer, den habe ich heute Morgen gecleart komplett, damit wir heute nochmal frisch anfangen können und ihr werdet sehen, das Container-Bild, das Initiale dauert lang, das dauert 3,5 Minuten oder sowas und das nächste dauert dann bloß noch 15 Sekunden, also das Caching bringt schon was.
Gut, jetzt kann ich nochmal kurz ein paar Sachen aus dem Chat beantworten, so.
Du hast kein Internet auf den, ah du hast kein Internet auf den Geräten, weil der kein Geld, weil er sich per DHCP gezogen hat, ja, sehr merkwürdig, was deine Fritzbox da macht, so, gab ja sonst nichts, ne.
Okay, so, gucken wir mal, ob das Container-Bild durch ist, nein, es baut immer noch, guckt mal, seit 2 Minuten ist es am Bilden, also ihr seht, ein Container-Bild über GitHub Actions ohne Cache ist abfuck langsam.
Also richtig nervig, das braucht am Ende 3,5 Minuten oder sowas, das ist halt, das hält, das hält man halt nicht aus im Kopf, richtig langsam der Shit.
Irgendwann so nach 3,5 Minuten ist er dann fertig und dann kann ich euch zeigen, dass der nächste Push viel, viel schneller ist und das ist das, wo wir gestern stehen geblieben sind, jetzt geht es darum, wie bauen wir ein Arch-User-Report.
Package in GitHub Actions.
Wir könnten es uns einfach machen, machen wir aber nicht, sage ich auch gleich schon dazu, wir könnten es uns einfach machen und ein, nein, nein, nein, nein, nicht, nein, nicht Kobol-Setup, das wollen wir nicht, wir könnten es uns einfach machen und ein fertiges, ein fertigen Build-Step verwenden aus dem GitHub Actions.
Das ist Marketplace, das Ding nennt sich Marketplace, das ist aber nichts, was was kostet, warum auch immer es Marketplace heißt.
Da gibt es nämlich Leute, die haben schon fertige Actions gebaut zum Publishen eines Arch-User-Report-Packages.
Da könnte man einfach sowas hier reinschreiben, ja, Package-Name wäre in dem Fall beispielsweise, Moment, also Package-Name wäre in dem Fall vmchamp-bin, Package-Build-File ist das hier, Commit-User-Name.
Package-Name würde ich angeben, SSH-Private-Key könnte ich angeben zum Pushen, ja.
Ist eine schöne Sache, wenn man keinen Bock hat, sich damit zu beschäftigen, wie man das selbst machen könnte, ich würde sagen, wir bauen das mal selbst, dann wird es nämlich schon ein bisschen komplizierter und ja, wenn jemand keinen Bock hat, das von Hand zu machen, kann er einfach die GitHub Actions hierfür benutzen und es geht.
Das ist ja das Feine an GitHub Actions, viele Leute haben schon die Sachen implementiert.
Man hat die Sachen im Vorfeld für einen gebaut und man kann die Sachen, wenn man einfach nur schnell was benutzen will, ist das eine super Geschichte.
So, also mein Bild ist fertig in 3 Minuten 41 und jetzt passt mal auf, das Bild hat 3 Minuten 41 gebaut, wir triggern das Bild jetzt nochmal und ihr werdet jetzt gleich sehen, wie krass das Ganze ist mit Caching.
Jetzt sollte das Bild gleich nochmal laufen, so, passt mal auf.
Sobald das Bild anfängt, sobald das Bild anfängt...
Bild fängt, drücke ich mal auf meinen Timer, so, bam, Bild fängt an, Pause Champ und Bild ist fertig.
Also, warum habe ich einen Timer gestartet hier oben, 26 Sekunden, ja, ich hätte überhaupt keinen Timer gebraucht, aber gut, 26 Sekunden, also sprich, allein durch das Cachen meines Container-Bilds sind wir runter von 3 Minuten 51 Bild-Time auf 36 Sekunden.
Und ich glaube, 36 Sekunden ist kompliziert.
So, und jetzt müssen wir uns damit beschäftigen, wie bekommen wir ein Arch-User-Repo-Bild in GitHub Actions hin.
Dazu öffnen wir mal GitHub Actions.
Ich muss dazu sagen, ich mache das nicht komplett blind, ich habe mir da im Vorfeld schon ein bisschen Gedanken zugemacht, wie man das machen könnte.
Ich habe es aber nicht komplett zu Ende gebaut, bis zum Push in das User-Repo.
So.
Die Sache ist die, ich habe es euch ja hier gezeigt, wie das prinzipiell geht, das Arch-User-Repo-Package zu bauen.
Man muss dieses Git verzeichnen, man muss dieses Arch-User-Repo-Git auschecken und dann muss man sagen, Make Package mit dem PKG-Bild und dann muss man noch eine Source-Info generieren und dann muss man das Ganze wieder pushen in das VM-Champion Arch-User-Repo.
Git-Repo-Package, was auch immer.
Hierhin, auf jeden Fall.
So, das heißt, das müssen wir jetzt in einem Container machen, weil, warum müssen wir das in einem Container machen?
Ja, das hier ist eine Ubuntu-VM und eine Ubuntu-VM oder wie die coolen Leute das nennen würden, eine Jubantu-VM, die hat kein Make Package.
Und Pac-Man und so Zeug drauf.
Also wir sollten das in einer Arch-Umgebung bauen, das Package.
Das heißt, wir müssen jetzt einen zweiten Build-Step machen, also keinen Build-Step, sondern einen zweiten Job, um das Arch-User-Repo-Package zu bauen.
Ich verschiebe das mal.
Warte mal.
Ah, Tibet.
Tibet.
Guck mal, Tibet.
Normalerweise sollte das eigentlich anzeigen, dass man hier...
...verschieben kann, aber es jebaitet mich.
Ich kann das verschieben, ohne dass es so aussieht, als dass ich es verschieben kann.
Aber was auch immer.
So, also der erste Build-Shop, der baut die Software und uploadet das Ding auf GitHub.
Ja, so weit, so gut.
Jetzt brauchen wir aber noch einen zweiten Job.
Nämlich einen Job, den wir jetzt einfach mal Hour nennen.
Also für hier das, um das ins Arch-User-Repo zu pushen.
Und den ersten Step, den copy-paste ich mir.
Weil der ist ziemlich simpel.
Den muss ich nicht tippen.
Und zwar, der erste Step, den wir brauchen, ist folgendes.
Wir müssen das, was dieser Job hier erzeugt hat, müssen wir in diesem Job importieren.
Und das können wir so machen.
Dann sagen Action, wir benutzen die Action Download Artifact und downloaden das, was wir hier oben generiert haben.
Nein, nicht in Gmail öffnen.
Jetzt ist das Ding, es ist immerhin noch eine Ubuntu-VM, auf der das hier standardmäßig läuft.
Wir wollen das allerdings in einer Arch-Umgebung machen.
Und jetzt muss man ein bisschen was anpassen.
Nämlich, erstmal müssen wir sagen, dass das nicht parallel ausgeführt werden darf.
Sondern, dass dieser Schritt nach diesem Schritt passieren soll.
Standardmäßig ist es nämlich so, dass die Steps...
Innerhalb von einem Job sequentiell laufen.
Es sei denn, man macht irgendwas mit Bildmatrix und so, dann geht das anders.
Aber es ist erstmal so, die Steps in einem Job laufen sequentiell.
Allerdings, Jobs dürfen parallel laufen.
So, das will ich in dem Fall jetzt ja nicht.
Weil, wenn diese beiden Jobs parallel laufen, dann will dieser Job was machen mit etwas, was noch gar nicht da ist.
Deswegen muss man als erstes hier mal sagen...
Dieser Job hängt von diesem Job ab.
Das ist alles, das was macht.
Also, der Job-Hour braucht Job-Build als Dependency, als Abhängigkeit.
Aber man hätte es auch Depends-On oder was auch immer nennen können.
Oder Run-After oder so.
Aber die haben es halt gern Needs.
Needs-Build bezieht sich hier in der Name, bezieht sich auf den Job hier oben.
So.
Und...
Dieser Job hier oben lief in einer Ubuntu-VM.
Das hier unten wollen wir nicht in einer Ubuntu-VM ausführen, sondern wir wollen...
Naja, doch.
Um zwei Ecken schon.
Wir wollen wieder sagen...
Wir sagen...
Weil GitHub-Actions sind immer VMs.
Da kann man nichts dagegen machen.
Runs on.
Und jetzt kommt aber der eigentliche Step.
Container Arch Linux.
Das heißt, was hier passiert ist, da startet wieder ein Ubuntu-Github-Actions-Runner.
Da drauf führt er jetzt allerdings direkt einen Arch-Linux-Container aus und lässt uns darin Zeug machen.
So wie man das direkt auf einer VM machen könnte.
Und da müssen wir jetzt ein paar Build-Steps hinzufügen.
Nämlich, wir müssen unser Arch-User-Package bauen.
Also am Anfang auf jeden Fall GitLab von GitHub.
Mittlerweile könnte ich mir vorstellen, gucken die sich...
...ein paar Sachen voneinander ab.
Übernimmt er die VM, der erstellt immer eine neue VM.
Das ist ja der eigentliche Grund, warum wir hier den Cache für die Container-Builds überhaupt brauchen.
Das ist jedes Mal eine neue VM und er würde jedes Mal komplett neu diese Container bauen.
Was halt doof ist.
Deswegen brauchen wir ja erst den Cache.
Deswegen ist es auch so langsam ohne Cache.
Weil es immer eine neue, komplett cleane VM ist.
So.
Und bevor wir jetzt hier unsere GitHub...
...Action bauen, würde ich sagen, starten wir jetzt mal lokal einen Docker-Container.
Genau den.
Wunderbar, dass ich den noch habe.
Ein Arch-Linux-Docker-Container.
Ich ver...
...vom Build-Shop.
Ja, das ist immer eine neue.
Du meinst die hier, gell?
Die hier.
Auch die gleiche...
...die gleiche wie hier.
Und auch ja, und auch wenn ich einen Container verwende, ist das immer ein neuer.
Ist immer ein cleaner, frisch ausgecheckter Container.
Du kannst nichts behalten zwischen Action-Runs.
Wenn du was zwischen Action-Runs behalten...
...willst, dann musst du es entweder in den GitHub-Actions Cache schreiben, als Artefakt hochladen oder manuell mit Cache-Save und Cache-Restore wiederherstellen.
Du kannst auch noch so Sachen wie S3-File-Systems und so was.
Also du brauchst auf jeden Fall was Persistentes außerhalb von GitHub-Actions, damit das funktioniert.
So funktioniert das, funktioniert das nicht.
Also du kannst nicht die gleiche VM wiederverwenden.
Das ist immer frisch.
So.
Wir starten uns jetzt mal eine lokale Arch-Linux-VM und probieren mal aus, wie wir darauf das Package bauen könnten.
Make-Package ist schon mal drauf.
Gut.
Also.
High-IQ-Shit.
Lass mal überlegen.
Das erste, was wir machen müssen, ist wahrscheinlich...
...Packman...
...Git ist nicht drauf.
Okay.
Das erste, was wir machen müssen, ist Packman-Git installieren.
Gibt es nicht.
Okay.
Dann ist der erste Step Package-Sources updaten.
Da haben wir doch schon mal was.
Das brauchen wir.
Also.
Build-Step.
Hinzufügen.
Name.
Make-Package.
Und da wollen wir jetzt...
Da wollen wir jetzt Kommandos drin ausführen.
Und unser erstes Kommando, was wir ausführen wollen, in unserem Build-Step, ist eindeutig Packman-SY.
Um den...
Die Package...
...Package-Quellen zu laden.
So.
Als nächstes wollen wir Git installieren.
Ich kürze das mal ein bisschen ab.
Wir wollen Git installieren.
Sudo installieren.
Das weiß ich schon, weil ich mir ein bisschen Gedanken im Vorfeld drüber gemacht habe.
Und wir wollen Open-SSH installieren.
Oh.
Bam.
Wait a minute.
Da gibt es eine Abfrage.
Das muss automatisiert gehen.
Packman.
Packman-Auto.
Yes.
Packman-Option to assume.
Yes to every question.
Minus, minus, no confirm.
Excellent.
Das brauchen wir.
Das heißt, das hier ist der nächste Step, den wir machen müssen.
Gut.
Das war.
So.
Jetzt müssen wir das Git-Repo klonen.
Also.
Wir gehen mal nach Temp.
Ich glaube, Temp ist ein guter Platz dafür.
Git-Klon.
Das Repo.
Ach, Moment.
Ich brauche meinen SSH-Key in diesem Container.
Ich muss ja was pushen am Schluss wieder.
Okay, es ist doch ein bisschen komplizierter, als ich mir das Ganze vorgestellt habe.
Wir tun mal so, als könnte ich pushen.
So.
Jetzt habe ich das Repo ausgecheckt mit meinem Package-Build drin.
Jetzt muss ich im Package-Build die Versionsnummer.
Das kannst du über ein GitHub-Secret machen.
Nicht alles verraten.
Okay.
Ich habe das GitHub-Secret schon längst hinterlegt, weil ich wusste, dass ich den SSH-Key brauche.
Als Volume rein-Mounten.
Ich weiß gar nicht, GitHub-Actions-Volumes.
Wie man damit, ob man da, Alter.
Ob das was bringt.
Mounting-Volumes.
Use container to set an array of volumes for container.
You can use volumes to share data between services or other steps in a job.
Ach so.
Ja, will ich ja nicht.
Ich mache ja alles im gleichen Step.
Ja, Serious Max.
Richtig weird champ.
Um nicht zu sagen, wo habe ich das Emote?
Leute, wo ist das weird?
Wo ist das weird champing Emote?
Ihr müsst mir mal kurz...
Ich finde meine Emotes gerade nicht mehr.
Oh, hier.
Weird champing.
Alles klar, da ist es.
Okay, ich habe es gefunden.
Unscripted.
Extremst weird champ.
Cringe stream.
So, also.
Wir haben das Repo jetzt ausgecheckt.
Ich würde sagen, das machen wir jetzt als nächstes.
Das bringt an der Stelle nichts.
Wie können wir das Package bauen?
Warum gibt es so viele Emotes von dem Typen?
Weil das eines der Twitch Original...
Emotes ist, die es jahrelang, jahrzehntelang quasi gab.
Oder sagen wir mal so, naja, jahrzehntelang vielleicht nicht.
Aber die es sehr lange gab.
Und eines der beliebtesten Emotes überhaupt ist.
Leider hat sich der Typ, ich weiß gar nicht, was er erzählt hat.
Leider hat sich dieser Typ auf Twitter über irgendwelche Dinger...
Nicht, äh...
Ja, nicht Twitch kompatibel geäußert.
Ich weiß nicht mehr, um was es ging und was er erzählt hat.
Zumindest hat das Twitch nicht gefallen.
Und Twitch hat die Emotes mit ihm entfernt.
Ach ja, genau.
Das war das, wo die versucht haben, nicht das weiße Haus zu stürmen.
Nee, nee, nee, nicht das andere.
Nicht das weiße Haus, sondern das andere.
Ja, genau.
Ja, ich erinnere mich wieder.
Und er hatte irgendwelches komisches Zeug geschrieben auf Twitter.
Und daraufhin hat Twitch gesagt, den Typ wollen wir nicht mehr als Emote haben.
Und hat ihn rausgekickt.
Es wurden ja schon ein paar andere entfernt in der Vergangenheit.
Ja, das stimmt.
Ja, das stimmt.
Ja, das stimmt.
Ja, das stimmt.
Ja, das stimmt.
Ja, das stimmt.
Ja, das stimmt.
Ja, das stimmt.
Ja, das stimmt.
Ja, das stimmt.
Ja, das stimmt.
Das war, glaube ich, zum größten Teil auf eigenen Wunsch oder auf rechtliche Probleme hin.
Also, ich weiß, dass Wind Waker entfernt wurde als Emote.
Falls das noch jemand kennt.
Das da.
Das war Cosmo.
Und das wurde, glaube ich, auf eigenen Wunsch entfernt.
Dann gab es noch Scoots.
OM Scoots oder so, wie das hieß, gab es noch.
Den...
Der CS-Commantator, der noch älter ist als ich, der wurde entfernt, weil es rechtliche
Probleme mit dem Emote gab und ansonsten fallen mir gar keine Emotes mehr ein, die entfernt
wurden.
Na gut.
Also.
Weiter geht's.
So, wir haben jetzt das Git-Report ausgecheckt, das heißt, ich muss jetzt mein Package-Build
anpassen.
Ich muss mein Package-Build anpassen und zwar muss ich die Versionsnummer anpassen.
Ich muss die Versionsnummer anpassen auf das, was mein aktueller GitHub-Tablet ist.
Das heißt, ich muss mein Package-Build anpassen und zwar muss ich die Versionsnummer anpassen.
Ich muss die Versionsnummer anpassen auf das, was mein Tag ist.
Lul wurde entfernt.
Ja, Moment.
Lul wurde entfernt.
Lul war ein...
Lul war ein Better-Twitch-TV-Emote.
Und das konnten die nicht übernehmen, weil der Typ keine Rechte an seinem eigenen Bild
hatte, sondern der Fotograf noch dabei war und so was.
War ganz, ganz weirde Geschichte.
So, jetzt müssen wir irgendwie uns überlegen, wie wir in Bash mit einem Zed die Versionsnummer
hier austauschen.
Vielleicht habt ihr da irgendwie eine schlaue Idee.
Also, ich würde sagen...
Wir machen ein Zed.
Also, vielleicht habt ihr auch eine andere Idee.
Wenn ihr eine coole Idee habt, sagt Bescheid.
Ich habe das Git-Repo noch nicht ausgecheckt.
Das stimmt.
Das bringt jetzt aber auch an der Stelle noch nichts, weil ich muss noch meinen SSH-Key
und so einfügen.
Da muss ich mal überlegen, wie wir das am besten machen.
So.
Also, Zed.
So, wir wollen was replacen.
Und zwar wollen wir replacen Package-Version.
Und zwar...
Ja, im Prinzip alles.
Ne?
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Ja.
Und jetzt wird das ersetzt.
Okay, das könnte man so machen.
Und jetzt machen wir noch, seht, in place auf PKG-Bild.
Das müsste jetzt an der Stelle schon mal ganz gut funktionieren.
Nur, dass wir nicht Version benutzen wollen an der Stelle, sondern GitHub-Refname, was die aktuelle Tag-Nummer ist.
Vorher müssen wir natürlich noch nach TMP, vmchamp-bin wechseln.
Ja, ja, den SSH-Key muss ich noch, äh, ächeln, ja.
Ja, ist nicht schlimm.
Selbst wenn ich den SSH-Key ächle, bis ihr den abgetippt habt, habe ich den schon wieder geändert.
Ich benutze den nämlich nur fürs Arch-User-Repo.
Alles klar.
So, vorher muss ich noch das Repo...
Geh mal weg.
Vorher muss ich noch das Repo klonen.
Das können wir ja schon mal simulieren, ohne, ohne, dass ich Schreibrechte auf das Repo habe.
Ist ja alles in Ordnung.
So, wir gehen nach cm, okay, nee, wir gehen nach c, wir gehen nach temp.
Und dann machen wir einen Klon, git-Klon auf das Repo.
Einfach auf gist posten, da brauchst du kein Secret.
Five-Hat-Time, so machen wir das.
So, dann klonen wir das Repo hin.
Dann...
Gehen wir in das Repo rein.
Dann machen wir unser Seed.
Danach müssen wir noch folgendes machen.
Ich zeige euch das mal.
Danach müssen wir noch Package...
Äh, oder Make-Make-Make-Package.
Ähm...
Minus-Minus...
Oh, fuck, weiß ich doch nicht.
Waren Make-Package irgendwas mit Info?
Print-Source-Info, alles klar, das brauche ich.
Make-Package...
Print-Source-Info...
Print-Source-Info...
Print-Source-Info...
Print-Source-Info...
Print-Source-Info...
Ah, scheiße, man darf das als Root nicht ausführen.
Okay, jetzt bin ich...
Moment, ich muss doch einen User anlegen jetzt dafür, oder wie?
Oh, nee.
Das macht es wieder unnötig kompliziert.
Das macht es wieder unnötig kompliziert,
dass ich das nicht als Root machen darf.
Geht nicht Minus-Minus-Force.
Mal ausprobieren.
Nee.
Nee.
Running Make-Package...
Running Make-Package as Root is not allowed as it can cause permanent catastrophic damage to your system.
Catastrophic damage, Leute.
Weiß nicht, warum ich jetzt Gachi-Roll anmache, aber irgendwie war es mir danach.
Catastrophic damage.
Das ist wie wenn er drüber rollt über euch hier.
Catastrophic damage, also das darf man nicht.
Das heißt, ich muss noch einen User anlegen, oder was?
Add User, gibt es nicht.
User Add.
Sag mal, gibt es noch andere Leute, die das nicht auseinanderhalten können,
ob es jetzt Add User oder User Add ist?
Ich glaube, Add User ist das Skript,
was Heimatverzeichnungen und alles drumherum anlegt
und User Add ist das RAW-Kommando.
Okay.
Heißt im Endeffekt auch, wir müssen noch einen User dazwischen anlegen.
Äh.
Das ist ja mal richtig eklig.
Okay.
User Add.
Build nennen wir das einfach.
User Add Build.
Jetzt haben wir hier einen User.
Das heißt, wir müssen jetzt dieses...
Okay.
Ich spiele das mal.
Ich spiele das mal durch hier.
User Add.
Build.
Minus Minus S Root.
Invalid Option.
Keine Chance, Leute.
Gibt es nicht.
Man muss es als eigener User machen.
So, das heißt, wir machen jetzt Sudo Build.
Äh, äh, Quatsch.
Sudo Minus U.
Build.
You don't have right permissions.
S.
Ähm.
Das ist in der Tat wahr.
Das ist aber sehr doof, dass ich keine right permissions habe.
Wisst ihr das?
Das heißt, ich muss noch ein CH Own oder sowas davor machen.
Oder ein CH Mod 7.
7.
Das würde auch funktionieren.
Ich mach mal ein CH Own.
Okay, also machen wir noch ein CH Own davor.
Minus R.
Build.
So, auf Build.
Okay, man könnte...
Man könnte es theoretisch auch so probieren, dass wir User...
Wir machen User Root.
Moment, gibt es jetzt eigentlich eine Group für den User?
Okay.
Also wir könnten User Root Group Build sagen, wenn wir da die passenden Rechte haben.
Wir haben aber nicht die passenden Rechte.
Nice.
Also muss ich tatsächlich User Build und Group Root nehmen.
Weil Root...
Darf ja prinzipiell alles.
Wobei, scheiß drauf.
Ich gebe das Ding...
Ich gebe das Verzeichnis dem User Build unter Gruppe, Build.
Und zwar wollen wir haben TMP vor MChamp Bin.
So, testen wir jetzt, ob das funktioniert.
Vor MChamp Bin.
Und danach machen wir jetzt sudo make package.
Cannot find strip binary.
Wie jetzt?
Was muss man dafür installieren?
Wir installieren einfach...
Wisst ihr, was wir machen?
Wir installieren einfach Base Entwicklungstools noch oben drauf.
Jawohl, perfekt.
Bam.
Komplett noch oben drauf.
Nimm als Container Arch Linux.
Ach, ist das da schon dabei?
Das ist nice.
Ist da auch Git und sowas schon dabei?
Gucken wir mal.
Docker run Arch Linux.
She baited hat mich der Chat.
Den Container gibt es überhaupt nicht.
Ja, es gibt irgendwelche...
Ach, Moment.
Du meinst als Tag Development, oder?
Ah, den gibt es.
Nice, gut.
Einfach try and error, bis man was gefunden hat, was funktioniert.
Okay, das ist gut.
Das ist gut.
Und da hat man dann auch Git und so...
Ne, das hat man natürlich...
Hat man SSH drauf? Ne, hat man auch nicht.
Na gut.
Das heißt, den Rest muss man schon noch selbst installieren.
Okay, dann probieren wir das doch jetzt mal aus.
Das heißt, wir nehmen hier diesen Container.
Und den starten wir jetzt hier auch.
Und gucken mal, ob unsere...
Alter, ich kann ja immer tippen.
Und gucken mal, ob unsere...
Ob unser Ablauf irgendwie Sinn ergibt.
Von dem, was ich da mache.
Also, als erstes machen wir Pacman Update.
Dann machen wir Pacman NoConfirm.
Ähm...
Git, sudo und OpenSSH.
Dann machen wir Pacman NoConfirm.
Dann machen wir Pacman NoConfirm.
Dann machen wir Pacman NoConfirm.
Dann machen wir Pacman NoConfirm.
Dann machen wir Pacman NoConfirm.
Dann klonen wir das Git-Repo dahin.
Dann klonen wir das Git-Repo dahin.
Dann gehen wir nach...
Dann gehen wir nach...
Das hier überspringen wir jetzt.
Das ist eigentlich egal.
Ich editier es jetzt einfach mal von...
Wir haben gar kein Limb drauf.
Alter.
Wir machen das so.
Wir machen das so.
Ich github Actions.
So.
Alter.
Dann machen wir UserAddBuild.
Dann machen wir UserAddBuild.
Dann machen wir...
Bis jetzt funktioniert alles.
Dann machen wir chown auf das Temp-Verzeichnis.
Dann machen wir chown auf das Temp-Verzeichnis.
So.
Und jetzt geht Status.
Was?
Ah, jetzt muss ich...
Okay, das ist natürlich...
TestRunner wäre jetzt geil.
Ich bin mein eigener TestRunner von Hand.
So, das müssen wir nach SourceInfo umleiten.
So, das müssen wir nach SourceInfo umleiten.
Ne, Moment.
Das müssen wir nicht nach SourceInfo umleiten.
Wir müssen...
Moment.
Sudo, das habe ich noch gar nicht hinzugefügt.
Wo habe ich denn das gemacht?
Hier oben.
Sudo-U
Ich schreibe das mal hier oben.
Wir müssen jetzt hier an der Stelle machen.
Sudo-U
Build.
Was war das?
MakePackage
Info
Ja.
Build.
Und das dann umleiten.
Und das dann umleiten.
Nach SourceInfo.
Hat funktioniert.
Hat geklappt.
Gucken wir mal, ob es funktioniert hat.
Version 3 steht da drin.
Ja, okay.
Also das müssen wir machen.
Dann müssen wir es wieder zurück...
Das ist ja kacke, Mann.
Dann müssen wir es wieder root geben.
Wobei, nö. Können wir eigentlich drauf scheißen.
Wir müssen es nicht root geben.
Ist doch egal.
So, jetzt habe ich das editiert.
Wenn ich jetzt git status mache...
Doch, ich muss es wieder root geben.
Sonst funktioniert das nicht.
Oder ich müsste alles jetzt mit Sudo ausführen.
Was auch bescheuert wäre.
Ich muss es wieder root geben.
Git status.
Pushen ins UserRepo.
So weit, so gut.
Jetzt muss ich sowas machen,
wie ein...
Das mit dem Commit sparen wir uns mal.
Wir testen jetzt erstmal,
ob das so weit funktioniert,
wie ich mir das hier gedacht habe.
Gehen wir mal am Ende SourceInfo aus
und PackageBuild aus
und gucken, ob das funktioniert.
Jetzt bin ich mal gespannt, ob der Krempel auch so 1 zu 1
in GitHub Actions funktioniert, was ich hier gebaut habe.
Alles klar.
Also, Push.
Ich will mal bilden.
Oder mach nach Opt.
Ist doch egal, ob ich nach Temp oder Opt mache.
Bildchamp.
Okay, Actions.
Auf geht's. Schauen wir mal.
So, der erste...
Guck, jetzt haben wir auch die zweite Action hier schon drinnen.
Beziehungsweise nicht die zweite Action,
den zweiten BuildShop haben wir jetzt hier drinnen.
Der erste sollte schnell gehen,
weil wir haben jetzt...
Ist schon durch der erste Step.
Kommt der zweite Step.
Gucken wir mal. Jetzt bin ich gespannt,
was wir hier gebaut haben.
Ja, ja, mach hin.
Initialize Containers.
PauseChamp.
PauseChamp.
Pregel, Leute.
Wir brauchen wieder eine Runde Pregel in Chat.
Sonst wird das nichts.
Okay, okay, okay.
Wie das...
Das ging jetzt, oder wie?
PackageInstall.
PackageBased.
Ja.
Ja, funktioniert.
Versionsnummer SV003.
Der Tag, den ich gepusht habe,
wurde dynamisch eingetragen.
Das ist gut.
Genauso soll das Ganze sein. Sehr schön.
So, jetzt kommt...
Jetzt kommt allerdings das Komplizierteste.
Wie kriege ich Zugriff auf
mein UserRepo?
Und zwar schreibenden Zugriff,
nicht nur lesenden Zugriff.
Also.
So, also den Build haben wir jetzt fertig.
Ne, erstmal... Moment, Moment, Moment.
Erstmal muss ich committen.
Das können wir nämlich noch lokal ausprobieren.
git commit
ähm
a-m
äh update
heißt das jetzt einfach.
Ahhhh.
Das funktioniert
jetzt natürlich nicht.
Weil ich...
Naja, das ist natürlich doof.
Weil ich keine E-Mail-Adresse
und sowas für git gesetzt habe.
Okay, das heißt, das müssen wir jetzt noch schnell nachholen.
git commit
äh
update
So, und da kommt nochmal der Tag rein in die commit.
Wie setzt man denn
jetzt hier seine...
Ich habe eine Idee. Können wir nicht...
Können wir nicht bescheißen?
Können wir nicht bescheißen, anstatt
mal eine E-Mail-Adresse zu setzen?
Leute, wir machen jetzt...
Wir machen jetzt Six Head-Beschiss.
Und zwar...
Hier steht es doch schon drinnen.
Kann man das nicht einfach wiederverwenden,
den Autor?
Kann man git clone commit
oder sowas machen?
Du kannst E-Mail leer lassen.
Okay, funktioniert das, wenn ich E-Mail-Adresse leer lasse?
Ja, wir können...
Wir können irgendeinen fake...
Fake-User setzen, ja.
Also Username, den kenne ich ja schon mal.
Wo bloß?
Den kenne ich.
Den krieg ich auch...
Den krieg ich auch github actions.
Ja.
Bitte.
Mag er nicht.
Das heißt, ich sag mal github mail.
Mal gucken, wenn ich den leer setze.
Easy.
Gibt einfach...
Gibt einfach keine E-Mail-Adresse.
Scheiß drauf. Fertig.
Ja.
Ja, das ist easy.
Okay.
Also müssen wir im Endeffekt hier nochmal setzen.
Das da vorher.
Irgendwo.
Vor dem Commit.
Müssen wir das da setzen.
Und wir müssen User setzen.
User setzen wir aber nicht
Hardcoded auf Wupplors.
Sondern Sixheadtime.
Github...
Wir holen uns den Usernamen
aus dem aktuellen Github
Actions-Kontext raus.
Da gibt es nämlich sowas wie Owner.
Irgendwo. Da.
Repository Owner.
Und der soll das...
Der soll das committen.
Heißt, wir wollen an der Stelle sowas haben.
Ja.
Und jetzt...
Repository Owner.
So, gut.
Dann machen wir einen Commit.
Und jetzt müssen wir pushen.
Jetzt wird es halt kompliziert.
Jetzt muss ich meinen SSH-Key da irgendwie reinkriegen.
Gilt log
minus 1 minus p.
Wunderbar.
Wir pushen das nochmal.
Und dann gucken wir, ob es bis zu diesem Zeitpunkt funktioniert.
Und jetzt muss ich mir überlegen,
wie ich da meinen SSH-Key reinbekomme.
Also mein SSH-Key selbst
kann ich euch ja mal zeigen.
Ist kein Secret. Also den SSH-Key nicht.
Den zeige ich euch nicht.
Aber ich zeige euch das Secret.
Actions. Ich habe ein Secret.
Our Key. Da ist mein
Private SSH-Key drinne.
Glaube gibt eine Action
dafür. Ich mache sowas auch.
Das geht auch mit dem Github API-Key.
Ja gut.
Ich könnte...
Neuen Key generieren lassen.
Irgendwie für Github intern.
Und den dann im Our hinzufügen.
Das müsste
wahrscheinlich funktionieren.
Ob ich was mache?
Also...
In Frankfurt auf jeden Fall.
Aber ob es 500k sind...
Da bin ich auch ein bisschen entfernt von.
Aber mit der aktuellen
Inflationsrate, vielleicht mache ich irgendwann
auch mal 500k.
So, schauen wir mal, ob die Actions soweit funktionieren.
Ja.
Sieht gut aus.
DevOps Infra Action Push.
Das bringt
mir doch jetzt nicht wirklich was, oder?
Ne.
Der hat ja
da nicht automatisch
Magic Rechte
auf mein Branch.
Auf mein Repo.
Ja, guck.
Du brauchst trotzdem...
Außerdem von Github nach Github.
Ich pushe ins
Arch User Repo.
Ne, das funktioniert nicht.
Okay, es hat aber funktioniert
bis dahin.
Und zwar, was hat er gemacht?
Committed.
Maintainer.
Das wurde hinzugefügt.
Das wurde geändert.
Sehr schön. Sehr schick.
Alles gut. Alles klar. Nice.
Nice, nice, nice.
Wupp, wupp.
Wupp, wupp, wupp, wupp, wupp.
Also, bis hierhin funktioniert das Ganze.
Gut, jetzt muss ich meinen Key irgendwie
hinzufügen.
Können wir nicht einfach
einen
SSH Agent
verwenden?
Da muss ich dann gar keine Datei anlegen.
Man könnte einfach einen SSH Agent benutzen.
Wie ging das nochmal?
SSH Agent...
Oh, Hammer.
Eval SSH Agent.
Das ist Pfeiffer-Time, wie das funktioniert.
Eval SSH Agent.
Eval SSH Agent.
Hast du nicht SSH Agent minus S?
Was ist minus S?
Von Schellkommando.
Ja, okay.
Also, was müssen wir jetzt machen?
Eval SSH Agent.
Eval SSH Agent.
Ne, Moment, Moment, Moment.
Nicht so, sondern so.
SSH Agent
SSH Agent minus S. Okay.
Dann muss
ein SSH Key rein.
Das können wir ja hier unten dann machen.
Das reicht ja noch.
Gehen wir mal das Log aus. Das ist eigentlich ganz gut, wie es jetzt ist.
SSH Agent. So, und jetzt müssen wir dem
SSH Agent meinen
GitHub Key zum Fressen geben.
Aus einer Variable.
Wir machen mal einen Fake Key.
Key gleich...
Wir generaten
mal einen Fake Key und gucken, ob das
funktioniert.
SSH Keygen.
Ah, irgendein Key, mir doch egal.
Ja, perfekt. Genau den will ich haben.
Äh...
CD, SSH...
Cat... Leute!
Private Key League!
Oh, nein!
Key League!
Freshly Generated Key League!
So, und jetzt
löschen wir ihn wieder.
TMP for MChamp Bin.
So.
Da habe ich den Key in der Zwischenablage.
Wie bekomme ich den
Key jetzt in
SSH Agent rein?
SSH Agent... Also normalerweise
kann man angeben, SSH
Agent und dann das
Keyfile, glaube ich, hinten dran.
SSH
Agent Standard
in. Kriegt man das irgendwie...
Add SSH Key from Variable.
Oh, Pfeifertime!
Was ist das?
SSH Key Private Variable.
MonkaS. Okay.
Key gleich.
Jetzt brauche ich diesen Shit, der muss da rein.
Und jetzt habe ich es kaputt gemacht.
So, und jetzt was?
Da, da, da. Key.
Ha!
Error.
Warum Error?
Echo Key.
Ah, Moment.
Muss ich das vielleicht direkt hinten dran schreiben,
dass es funktioniert?
So?
Ne, so funktioniert es nicht.
Ähm...
Alter, das ist ja richtig
Six Head Time.
Noch ein Minus zu viel. Ne, das muss da sein,
dass er Standard in annimmt
an der Stelle. Das ist das Symbol für Standard in.
Oder... Ja stimmt, wir können
ja auch faken. Wir können den auch
aus der Name Pipe lesen lassen.
Sehr gute Idee.
Pfeifertime.
Ist der Key irgendwie kaputt?
Weißt du was?
Wir hauen das mal in GitHub Actions rein.
Und gucken,
ob es funktioniert.
Ich mein...
Äh, wie geht das?
Secrets... Ne, Moment.
Jetzt muss ich das hier...
Wenn das jetzt funktioniert, beiß ich mir in den Arsch.
Also...
Nicht wörtlich genommen.
Äh... Secrets...
Secrets...
Our Key.
So geht das glaube ich.
Push.
So, ich werd jetzt mal kurz
mein Clipboard ausschalten.
Nur für den Fall der Fälle.
Our Login machen.
Auf dem zweiten Bildschirm.
Nur für den Fall der Fälle, dass ich
irgendwelche...
irgendwelche Keys wirklich leake.
Das wollen wir ja nicht.
Und in mein Profil
gehen. Und theoretisch
den Key löschen können.
Wenn's sein muss.
Ähm...
Toggle Clipboard. Können wir wieder enablen.
So.
Es hat funktioniert. Okay.
Ja gut.
Es hat keinen
Error gegeben schon mal.
Also vermute ich jetzt einfach mal,
dass es funktioniert hat, oder?
Falscher Run.
Oh ne.
Shit.
Command not found.
Okay.
Echo Key.
Also.
Wo, wo ist das, wo ist denn jetzt das Problem?
Wie, wie kriegen wir das jetzt da rein?
Minus.
So, so, so.
Und jetzt.
Jetzt machen wir's einfach nochmal so.
Jetzt machen wir's doppelt gemorpelt. Guck mal. Echo Key.
Nein, fuck.
Hab ich den vielleicht falsch kopiert?
Hab, hab ich den, hab ich den Key falsch
kopiert? Okay.
Wir erstellen uns nochmal einen etwas übersichtlichen Key.
Ich hab das Ende
nicht mit kopiert. Okay. Das ist natürlich ziemlich doof.
Ähm.
Ich muss doch Files an. Ich hab doch keine Files.
Das ist doch das Problem.
Wenn ich Files hätte, wäre das sehr easy.
GitHub
Generate Keys.
ID irgendwas.
Kann man das? Moment.
Nimmt das Standard in an der Stelle so an?
Ja klar.
Muss es eigentlich.
Wartet mal.
Ich erstelle mal kurz nochmal einen neuen Key zum testen.
Ja, ja. Wunderbar, wunderbar.
Excellent.
ID Dingsbombser. Den da will ich haben.
Ich hab wahrscheinlich die Hälfte nicht mit kopiert.
Der ist jetzt auch ein bisschen umgänglicher.
So.
CD. Temp.
Vmchamp. Bin.
SSH. Agent.
So, weil jetzt könnte man, könnte man net.
Könnte man nicht einfach sowas hier sagen?
Echo.
Nach SSH. Agent.
Minus.
Mann ist das scheiße, alter.
Warum funktioniert
denn das nicht?
Wegen dem Newline hinten dran vielleicht?
Das mach ich fertig.
Okay.
Key gleich.
Ach so. Ach es ist SSH. Agent.
Ich bin ja auch blöd.
Minus.
Es hat funktioniert. Nice.
Okay. Dann machen wir das jetzt so.
Also. Easy. Easy.
Echo minus N.
Viel besser.
Viel besser so.
Zack.
Sehr gut. Sehr schön.
So machen wir das jetzt.
SSH Key.
So. Und jetzt das Pushen.
Das Pushen spare ich mir an der Stelle noch.
Ich will gucken ob es funktioniert.
Okay. Jetzt bin ich mal gespannt.
Kurz warten bis dieser.
Bis der Run hier startet.
Chat. Wir brauchen eine Runde
Pregel Support.
Pregel Support im Chat.
Dass es funktioniert.
Pregel Time.
Ohne mindestens 5
Pregel Emotes wird das nix.
Hast du gerade den SSH Key nicht geleakt?
Nö.
Ich habe einen frisch generierten SSH Key geleakt.
Okay. Nice.
Haben genug Pregel.
Am besten wäre natürlich.
Man macht für sowas einen Base Container.
Wo das alles schon drin ist.
Und. Und. Und. Und. Und.
Fuck man. Alter. Wo ist das Problem?
Ey.
Boah.
Wo ist das Problem?
Error. Loading Key from standard in.
Ich habe es doch genauso gemacht wie hier.
Secrets.
Our Key.
Ist der Key denn valid?
Ich würde mal von außen gehen.
Ich kann den euch jetzt ja nicht zeigen.
Ähm.
Habe ich das richtig geschrieben?
Okay. Was gibt es denn sonst noch
für Möglichkeiten?
Wenn das so nicht geht.
Können wir dann.
Kann man denn dann auch das ganze.
Okay. Probieren wir es mal umgedreht.
Probieren wir es nochmal so.
Echoo.
Jetzt wird es etwas.
Funktioniert auch.
Okay. Dann machen wir es nochmal so.
SSH.
Add.
Und jetzt was?
Minus. Minus. Minus.
3 in error time.
Leute.
Ja. Ähm.
Secrets.
Punkt.
Our Key.
Push.
Jetzt aber. Let's go.
Wenn das jetzt funktioniert habe ich gar
keine Ahnung warum. Das ist eigentlich
mehr oder weniger äquivalent zu dem was ich
vorher gemacht habe.
Eval SSH Agent.
Habe ich doch.
Habe ich vergessen?
Nö. Ist doch richtig.
Alles gut.
Break it time.
Einfach funktionieren jetzt GitHub Actions.
Please.
Jaja. Setze mal den Job ab.
Break it. Break it. Break it. Break it.
Das ging.
Okay.
Warum geht das
und das vorher ging nicht?
Das vorher war doch viel schöner.
Hä?
Okay. Das müssen wir jetzt mal irgendwie das super krasse Linux Pro erklären.
Der dann noch mehr Ahnung hat.
Warum geht. Okay. Moment.
Moment. Moment.
Also. Nur mal so zum. Wir vergleichen
das jetzt mal. Wir vergleichen.
Wir vergleichen das jetzt mal.
Okay. Warum geht das
oben und warum geht das unten nicht?
Vermutlich weil Action
Echo von Secrets verbietet auf irgendeine
Weise. Aber hier mache ich
auch ein Echo.
Davor war ein Echo minus n.
Echo minus n ist eigentlich die bessere
Variante, weil es kein extra Newline hinten
dran macht. Und es hat hier unten
auch Funktion. Also das an der minus n wird es nicht
liegen. Ey Moment. Ich bin
ja auch blöde. Wait a minute.
War das wirklich das was ich
vorhin da stehen hatte? Nee oder?
Nee. Nee. Nee. Nee. Nee.
Das hatte ich vorhin da stehen.
Blödsinn
was ich da kopiert habe.
Also. Das da versus
das da. Ich habe es.
Vielleicht unterdrückt das
GitHub wirklich.
Vielleicht filtern die das oder so.
Weil für mich
sieht das.
Okay. Das hier ist halt Bash
Redirection Magic.
Ich habe legit keine Ahnung.
Was es da macht.
Hier liest es halt Standard in.
Und hier liest es
ja eigentlich auch Standard in. Was auch immer.
Es funktioniert. Das ist die Hauptsache.
Gut. Nice. GG Eats.
Jetzt sind wir eigentlich bereit zum
Committen.
Wir haben alles.
Wir haben Commit. Jetzt könnte man eigentlich
pushen. Da muss man
aber das richtige Repo nehmen zum pushen.
Und zwar. Ich suche das richtige Repo
mal kurz raus.
Was man hier nehmen muss.
Das da.
Muss man
da nehmen.
PostKeyCheck vom Auer.
Ah.
Moment.
Ja. Wir sind.
Wir sind doch noch nicht ganz fertig.
Weil ich vermute mal das das GitClone
an der Stelle nicht funktionieren wird.
Guck mal.
TMP.
Wo MChampGit.
GitClone.
Ja. Man muss.
Man muss diesen ganzen
Krempel akzeptieren.
Ok. Also wollen wir haben.
GitClone. Und im Vorfeld
wollen wir das ein bisschen überschreiben.
Nice. Exzellente Stack
Overflow. Google. Google stellt es.
Alles klar. Was müssen wir
machen? GitCommand.
Exzellent.
Der Chat weiß
wie man es macht.
GitCommand minus SSH.
Also im Prinzip so.
No
Strict Host Key Checking.
User unknown. Sehr gut.
Genauso will ich das haben.
Nur dass ich diesen Krempel
davor machen muss. Sonst funktioniert es nämlich nicht.
Und da können wir nämlich.
Ja. Das ist. Das ist ok so.
Können übrigens dieses ganze GitSetup
Zeug hier oben machen.
Dass das durch ist. Da können wir das nämlich ein bisschen.
Ja. Das ist das quasi.
Hier. GitSetup.
Mach doch Export für später.
Push. Ja.
Ja.
Äh. Wahrscheinlich gar nicht so
verkehrt. Export.
Ok. Dann schauen wir mal ob das funktioniert.
Das heißt er müsste das jetzt
klonen. Und er müsste das
auch schon mit dem richtigen SSH Key machen.
Sodass ich. Sodass es keinen Fehler
gibt beim Klonen. Das probieren
wir jetzt nochmal aus.
Und wenn das geht. Können wir eigentlich
die neue Version pushen.
Ich denke das passt.
Ich glaube. Ich glaube das ist es.
Ich glaube das müsste dann gehen.
Gib ihm.
Auf nicht so langsam.
Ah jetzt. Starting Job.
Ok.
Gucken wir mal ob das jetzt funktioniert.
Visualize Containers.
Package.
Ja.
Sehr gut. Sehr gut.
Es hat alles funktioniert.
Würde ich sagen.
Kann ich das jetzt einfach per J installieren?
Ja. Kannst du.
Kannst du jetzt schon. Allerdings dann kannst du immer
die aktualisierten Versionen auch per
Also kannst du das jetzt schon hier. Guck mal.
Das ist meins.
Und das ist das von Vorti. Wo immer die aktuellste
Version gebildet wird.
Hier ist die aktuelle Release Version.
So.
Also das hat wie es aussieht
funktioniert.
Der macht hier installieren
dependencies.
Create temporary file.
Bla. Wo ist das denn hier?
Ja. Ja.
Funktioniert. Funktioniert.
Ok. Nice.
Pogu.
Extremely Pogu.
Ich würde sagen
Jetzt fehlt
eigentlich nur noch das pushen von dem Repo.
Jetzt müssen wir gucken
dass wir auch die neueste Version pushen.
Update
Bild. Jamme.
Ja der Pull Request und so ist schon dabei.
Fix. Fix. Fix. Allemal Images.
Vielleicht können wir noch ein paar weitere Pull Requests
dabei hauen auf die Schnelle.
Wobei gibt ja keinen. Gibt ja den. Der ist
groß. Den muss ich mir erstmal angucken.
Update Readme.
Hab ich da alles gehabt?
Update. Update.
Vielleicht soll ich jetzt mal ein ordentliches
Vielleicht soll ich da mal ein ordentliches
Comment draus machen.
Weil das ist ja wirklich nicht gescheit zu lesen.
Hier.
Hab ich nicht irgendwo noch
im Master. Warte mal.
Git Checkout Master.
Pull GitHub Master.
Hatte ich nicht irgendwie da noch was
drinne?
Update Readme. Update Readme.
Hab ich nicht irgendwo gestern noch die
die Message im
SSH
Command gefixt?
Die war nicht so schön.
Ne hab ich anscheinend
nicht gepusht.
Ne die hab ich
das hab ich anscheinend noch nicht gepusht.
Ich hatte die Message hier gefixt. Ich hab da reingeschrieben
Connecting to und so
ein Flugzeug Emoji reingemacht.
Ja dann
machen wir das doch jetzt schnell noch.
Rechtfertigt dann selbstverständlich
Versio 0.3
Easy.
Ok.
Also Git. Jetzt machen wir das mal ein bisschen ordentlich.
Git Checkout Dev.
Git
Cherry-V Master
macht folgendes.
Zeigt alle Comets an die in diesem Branch
drin sind. Aber nicht
in Master. Das heißt das sind
meine letzten, das sind meine letzten
Bastel, Bastel Comets.
Sieht man ja auch hier.
Update
Update Build YAML
Bild YAML und davor hab ich irgendwie noch
Temp und sowas drin.
Können wir uns auch anzeigen lassen was da drin ist.
Git log minus minus p
So nur
Updates am Workflow
Updates am
Docker Image. Das muss ich auf jeden Fall auch
im Master pushen dann.
Update am Workflow, Update am Workflow
und Temp Name
Bild. Alles klar. Ja.
Dann fassen wir das mal zusammen zu
einem ordentlichen Comet.
Git Reset
Git
Git Comet
A
So das heißt jetzt nicht Temp des Comets, sondern das heißt
Edit
Git Lab Actions
CIR irgendwie.
Workflow
For Our Build
So jetzt haben wir ein Comet.
Wo alles schön benannt ist.
Und auch alle Änderungen
hinhält. Also so kann man das machen.
Selbst wenn man eine Branche hat mit
150.000 Temp Temp Temp Comets
Da hab ich Git Lab
geschrieben.
Oh.
Fast.
Ja aber auch wenn man eine Branche hat mit ganz vielen
ekligen Comets, so kann man das ganz gut
zusammenfassen. Einfach Resetten
auf das erste Comet und dann
anhängen alles und die Comet Message ändern.
Das geht natürlich nur in eigenen Branches.
Also in irgendwelchen Public Branches wo noch mehr Leute
mitarbeiten würde ich euch das nicht empfehlen so zu machen.
Und da würde ich euch nicht empfehlen 140
Temp Comets rein zu pushen.
So.
Das ist quasi
Das ist
Es ist quasi sowas wie ein Rebase.
Rebase macht es ja
Rebase macht ja das gleiche.
Rebase macht ein Reset
und dann Cherrypicks der Reihe nach.
Ist im Prinzip das gleiche.
Gibt ein paar Wege wie man das machen kann.
So.
Ich glaube
jetzt passt alles soweit.
Ich würde sagen
wir können das in Master
mal rüberpicken.
Lokal erst einmal.
Git Checkout Master
Äh.
Passt doch alles gut.
Git Checkout Master
Git Merge
Dev. Jo. Sehr schön.
So und jetzt passe ich die eine
Sache hier noch an, was der neue Version
rechtfertigt. Nämlich
wir machen ein schöneres Hilfe
Befehl. Kommt jetzt nicht einfach an der
Stelle Console Write Line.
Nein, nein, nein, nein. Das ist nix.
Da kommt jetzt Console
Markup Line.
Ganz hübsch. Und zwar
Connect to
Poem Name
und jetzt müssen wir uns
Moment. Warum mach ich eigentlich so?
Ich kann doch hier mein
Connect to und jetzt muss da an der Stelle
ein Emoji
ein
Plane hin.
Was willst du?
So
und jetzt ist das Version 0.0.3
eindeutig. Also
ich finde diese Meldung macht
es jetzt schon mal viel besser.
Das ist auf jeden Fall ein neuer Versionssprung
wert.
Huge Changes
So. Bestes, bestes Comet.
Lizenz.
Du hast Recht.
Lizenz können wir auch noch machen.
Ist das gerade die Kommandozeile von Arch
gewesen? Also Vanilla oder irgendwie Custom?
Was denn? Das hier meinst du oder was?
Das da? Oder wie?
Oder was, was, was? Hä?
Jetzt blick ich nicht durch.
Was denn? Genau.
Also das hier ist Custom.
Kommandozeile.
Da ist einiges dran customised.
Das Emoji. Ne das ist Rofi.
Das ist der Emoji Picker
aus Rofi.
Guck. Leider kann er keine Twitch
Emotes. Das fehlt. Das fehlt. Das fehlt.
Das sollte eigentlich mal jemand
jemand einfügen. Rofi
Twitch Emote. Gibt es da schon
was? Moment.
Moment.
Ne das ist was anderes.
Das sind auch nur Emojis.
Der kann keine Twitch Emotes.
Der faked.
Der faked, dass er Twitch Emotes kann.
Aus irgendwelchen Gründen meint Google,
dass es Twitch Emotes kann.
Alles gut. So.
Also jetzt haben wir den Kram gemerged. Jetzt können wir das pushen.
Geht
Push Origin.
Wobei nicht Origin. Github Master.
Guthub. Github Master.
So.
Gucken wir mal ob das ganze angekommen ist.
Jo.
Jetzt haben wir die Workflows auch hier im
Master
drin.
So ich mache jetzt ein Test Run nochmal.
Ob das funktioniert.
Und wenn das funktioniert dann pushen wir
die Version ins
User Repo.
Äh.
Das brauchen wir nicht mehr.
Neues Tag.
Fake Tag 3 drauf machen.
Ich habe aber nichts groß geändert.
Das sollte eigentlich. Huge Changes
gibt es jetzt.
Ich könnte bei der Gelegenheit
mal. Wo wir gerade dabei sind.
Während der Run läuft.
Das muss ja nicht unbedingt
da drin sein.
Wenn man das nicht von Hand machen will. Man kann die Github
Actions. Äh nicht die Github.
Man kann die Github äh das Github
CLI Tool verwenden für solche Geschichten.
Da kann man dann auch
Schleifen drum bauen und sowas.
Man kann dann auch den Cache komplett clearen.
Da muss man nicht hier von Hand
sinnlos rumklicken. So wie ich das gerade mache.
So. Huge Changes
sind am Start.
Huge Changes. Achso da muss ja
kurz. Ok. Der muss jetzt
das Container Image zumindest zum Teil
neu bauen. Logischerweise.
Weil da hat er die Software neu
installiert. Ja das dauert jetzt kurz.
Dauert jetzt ein bisschen länger.
Der muss ja. Genau.
Jetzt muss er den Cache wieder exportieren.
Er dauert jetzt. Dauert ein bisschen länger.
Und jetzt könnte man noch
gucken. Wie man automatisiert
Github Releases erstellt.
Achso eine Lizenz muss ja auch noch rein.
Habe ich ganz kurz wieder ganz vergessen.
Alter was macht der denn da so lange.
Was macht der denn da so lange.
Ok hat alles funktioniert. Nice.
Das heißt wir fügen jetzt noch
eine Lizenz hinzu.
Und dann ist gut.
Make Package.
Hat alles funktioniert.
Yo.
Version 3.
Wunderbar. Ok. Hatte Github nicht
sowas drinne wo man. Hatten die nicht
sogar so einen Lizenz Picker
mittlerweile dabei.
Nö anscheinend nicht. Ach hier doch.
Da ist es doch.
Choose a License Template.
Oh komm.
GPL. Ne was haben wir denn.
Die Unlicense.
Ach ne hier ist es doch.
Public. Was haben wir denn hier zur Auswahl.
GPL3
oder MIT.
MIT ist im Prinzip du darfst alles damit
machen. Du musst auch die Leute nicht mal erwähnen.
Oder sonst wie was.
Was ist denn der Unterschied zwischen GPL Dings und
Conditions.
License und Copyright Notice.
Disclosed Source. Same License.
Ey wir nehmen GPL nicht
dass noch einer auf die Idee kommt.
Fette Stonks zu machen mit dem
VmChamp. So geht es ja nicht.
Davon abgesehen ist es egal.
Weil die das tun ja wahrscheinlich dann
wenn das einer machen sollte.
Als so verwenden in
irgendwas größerem. Komm.
Review und Submit.
Alter das spammt
erstmal schön alles voll oder.
Create License.
New Branch.
Lull.
Ich glaube es geht los.
Ich bin direkt auf Master alter.
Jawoll.
So.
License haben wir auch am Start.
Holen wir mal.
License auch hier am Start.
Ok gut. Dann bleibt uns
jetzt ja abschließend nur noch.
Ok das Release anlegen können wir
vielleicht danach noch gucken.
Aber uns bleibt jetzt ja an der Stelle eigentlich nur noch
das Pushen ins User Repo
und gucken ob das funktioniert.
Also dann
passen wir das doch jetzt mal an.
Wim.
So das heißt wir brauchen am Ende
jetzt nur noch einen Push.
Und hoffen das es dann funktioniert.
Git Push Origin.
Achso wie heißt denn der Default Branch bei denen?
Sind das noch
Master Enjoyer?
Sind das noch Master Enjoyer?
Ok.
Git Push Origin Master.
So.
Ich hoffe das funktioniert jetzt
alles so.
Wie ich mir das.
Gedacht habe.
Comet.
Äh.
Oh Push.
Tag.
Gut.
Bam.
Gucken wir mal ob es funktioniert.
Jetzt bin ich gespannt.
Das dauert jetzt ein bisschen weil er die Software wieder neu.
Wobei muss er die Software überhaupt neu bauen?
Ja muss er.
Weil sich die Quellcode Dateien
geändert haben.
Ne muss es nicht. Oh das ging.
Das ging auf jeden Fall deutlich schneller jetzt.
Schauen wir mal.
Jetzt bin ich gespannt.
Das sollte jetzt gleich V003 sein.
Wenn alles funktioniert.
Wahrscheinlich klappt irgendwas wieder nicht.
Irgendwas ist immer.
Auf Shithub.
Shithub.
Ah bum bum bum bum.
Wisst ihr was ich finde es immer geil wie schön schnell Pacman ist.
Ah ah ah ah.
Ok ok ok.
Hat funktioniert.
Version 3.
Ich habe den Cache vorhin
glaube ich gar nicht gelöscht.
Ich habe die Builds gelöscht.
Version 3.
Ok.
Testen wir gleich mal.
Ob er was erkennt.
Ja.
There is nothing to do.
Was ist da los? Warum?
Wahrscheinlich weil es Auer noch nicht gesynct hat.
Es hat noch nicht geupdatet.
Würde ich sagen.
Es hat noch nicht.
Er hat noch nicht erkannt dass es geupdatet wurde.
Vielleicht brauchen die auch ein paar Minuten bis er es checkt.
Dann warten wir nochmal kurz.
Mal gucken.
Mal gucken.
Pause Champ machen wir jetzt.
Pause Champ.
Pause Champ.
Wird mir dann irgendwann
Rate limited wenn man es zu oft probiert?
Ich lasse mal die Finger von weg.
Wir gucken.
Wir gucken jetzt mal in das
Repo rein.
In das Auer Repo.
Was kann ich mir sagen Schreiker?
Ja es hat funktioniert.
Also zumindest hat er es committet.
Also während wir warten kann ich es erklären.
Wir haben ein Arch User Repo
angelegt.
Für den VM Champ.
Haben die GitHub Actions erweitert.
Das die ein Arch User Repo Package
bauen können.
Und es anschließend pushen.
Also jedes mal wenn ich ein Tag pushe.
Dann.
Wenn ich ein Tag pushe dann baut der.
Das da unten kann ich übrigens jetzt zu machen.
Dann baut er die Software zusammen.
Mit dem richtigen Tag drauf.
Und danach baut er ein Arch User
Repo Package zusammen.
Und pusht das.
Kann es sein das der Download noch nicht da ist?
Ja darauf warte ich jetzt ja selbst.
Also hier hat er es schon aktualisiert.
Aber im Arch User
Repo selbst.
Im Champo.
Hat er es noch nicht erkannt.
Ich glaube wir müssen einfach warten.
Als ich das heute Mittag.
Habe es auch ein paar Minuten gedauert.
Beim GitHub Link.
Gibt es ein 404?
Nö.
Gibt es nicht.
Ah.
Da gibt es ein 404.
Ja natürlich.
Weil ich noch gar kein Release erstellt habe.
Low IQ Leute.
Das Release gibt es ja noch gar nicht.
Ich muss also.
Äh.
Das Release gibt es ja noch gar nicht.
Das muss ich ja auch noch anlegen.
Das muss ich aber eigentlich auch.
Automatisch anlegen.
Sonst funktioniert es ja.
Nicht.
Wie legt man ein GitHub Release an?
Per GitHub Actions.
Also er sollte zumindest mal ein Update zu bringen.
So langsam aber sicher.
Oder?
Ganz schön lahm gerade.
Refresh Mirrors.
Ja habe ich ja gemacht.
Bei mir hat das noch nicht.
Bei mir hat das noch nicht gecheckt.
Dass sich das aktualisiert hat.
Aber es hat sich aktualisiert.
Weil.
Hier ist die neue Version drin.
Gut wir müssen auf jeden Fall.
Noch ein Release anlegen.
Sonst wird das ja natürlich so gar nichts.
This Repository has been achieved.
Ja toll.
Es ist irgendwie ziemlich outdated.
Overrated.
Cheapated oder?
Warum ist das?
Ist das eine offizielle Action?
Für Create Release?
Das ist doch bescheuert.
Was haben wir denn hier für Alternativen?
Von irgendwelchen Randoms?
Ok Februar.
Last week.
Ok das ist.
Das ist sehr beliebt.
Das scheint das beliebteste zu sein hier.
Below is a simple example.
Release.
Ja schön und gut.
Kann man es mittlerweile aktualisieren?
Aha.
Jetzt hat er es.
Leute jetzt hat er es.
So und wenn ich es jetzt versuche zu installieren.
What?
Dann kackt er ab dabei wahrscheinlich.
Ne?
Äh.
Ich hätte aber erwartet das er abkackt.
Weil das Release gibt es noch nicht.
Wait a minute.
Jetzt bin ich verwirrt.
Warum funktioniert das jetzt?
Warum geht das jetzt?
Weil ich nicht Clean Build gemacht habe oder?
Ok.
Vmchamp.
Minus Minus Version.
02 ist es noch.
Vmchamp bin.
Das geht bei mir auch nicht.
Ich deinstalliere nochmal.
Und.
Hä?
Warum ist es jetzt wieder 002?
Jetzt blick ich nicht mehr durch.
Was zum?
Ich blick nicht mehr durch.
Warum wird das jetzt nur noch als Version 2 angezeigt?
Hä?
Das ist aber das alte.
Kann man.
Andere Caching.
Ah jetzt. Ok jetzt ist es 03.
Wir machen jetzt Clean Build.
Clean Build.
Ah jetzt geht es kaputt.
Ok.
Alles gut.
Jetzt ergibt das Sinn.
Das Release gibt es nicht.
Das passt ja.
Das Release gibt es nicht.
Ok gut.
Das geht aber schnell an.
Wie macht man so eine.
Xuki danke schön für den Sub.
Wie macht man denn ein GitHub Release?
Damit.
Ja gut.
Aber ich muss doch da zum Beispiel.
Einen Text eintragen können und sowas.
Ah hier.
With Files Release TXT.
Probieren wir das mal aus.
Ja.
Wir probieren das einfach mal aus.
Also.
Ähm.
Den Step.
Den Step können wir hier als letztes
dann tatsächlich durchführen.
Den müssen wir.
Den müssen wir nicht im Our Step durchführen.
So.
Release Planner.
Den Check.
Kann ich mir sparen.
Weil das geht nur auf.
Tag Pushes.
So.
With Files Release TXT.
Ja aber was passiert denn dann?
Kann man da nicht.
Automatisch erstellen.
Ja.
Body kann ich reinschreiben.
Also da könnte ich.
Da könnte ich jetzt zum Beispiel.
Wobei Moment.
Ich will ja da gar keinen statischen.
Statischen Text reinschreiben.
Das muss ich mir überlegen.
Wie wir das am besten machen.
Jetzt machen wir das mal Easy Mode.
Fixes.
Muss reichen.
Fixes.
Was hast du gepatcht?
Fixes.
So ich hoffe das reicht jetzt.
Weil im Beispiel.
Im Beispiel ist es nicht mehr.
Defaults to Tag Name.
Ja Moment.
Ich muss noch die Datei anhängen an das Release.
Ich muss noch die Datei anhängen.
Ähm.
Asset Upload.
Hier. Files.
Aha. Files.
Muss ich da noch dranhängen.
Files?
Ich kann ja im Prinzip nur.
Das hier haben.
Und wo müssen.
Wo müssen die Dateien liegen?
Wo müssen die Dateien liegen?
Also kann ich jetzt irgendwas hier hochladen?
Ich mein ich hab Bild.
Ich hab ein Bild hier in.
Temp out.
Vmchamp.
Wir probieren es.
Wir probieren es jetzt einfach mal aus.
Ob das geht.
Ich lass es jetzt einfach mal so laufen.
Why not? Why not?
Git commit minus a minus m.
GitHub release action.
GitHub release action.
Push.
Master.
Jetzt machen wir nochmal.
Lassen wir den Tag nochmal pushen.
Ich vermute mal das es sowas ist was man nicht machen sollte.
Mit dem Tag nochmal pushen.
Weil dann hat man quasi.
Das gleiche.
Das gleiche doppelt gepusht.
Was.
Was es wahrscheinlich dann verwirrt.
Hauptsache.
Hauptsache der legt jetzt ein release an.
So.
Ah fuck alter.
Wo ist das Problem?
Release failed with status 403.
Okay. Sehr schön.
Warum? Man weiß es nicht.
Muss man vielleicht noch die passenden permissions?
This action requires the following permissions.
This action requires the following permissions.
Das ist ja schön und gut.
Das es permissions braucht.
Aber wäre es nicht sinnvoll gewesen.
Das auch.
In das Beispiel reinzuschreiben.
Nur mal so.
Rein.
Nur so gefragt also.
Contents.
Write.
Ich push das jetzt nochmal.
Push.
Push. Origin.
Master. Force. Bam in your face.
Ah ne ist es nicht. Origin.
GitHub.
Ja examples sind extrem.
Overrated. Outdated.
Okay.
Brage.
Startup failure.
Was?
Ach ich habe Contents doppelt drin stehen.
Ich kack noob.
Lull.
HD.
So jetzt aber.
Jetzt haben wir ein release.
Okay.
Brage time.
Release. Release ready.
Yeah.
Release ready.
Okay.
Fixes.
Ah da ist das file dran.
Sehr gut. Sehr gut.
Das file heißt aber noch falsch.
Das file heißt noch falsch.
Das müssen wir auf jeden Fall noch fixen.
Das das file richtig heißt.
Ich lösche das release nochmal.
Weil ich mir nicht sicher bin was passiert.
Wenn man releases doppelt anlegt.
Ich glaube da kommt er dann ein bisschen durcheinander.
Okay.
Das file heißt noch falsch.
Jetzt einfach.
Dest for mchamp.
Wird umbenannt.
In.
Temp. Out.
So.
So jetzt heißt das Ding richtig.
Und jetzt sollte dann.
Ich häng das einfach wieder an.
Push. Egal.
Und jetzt sollte das auch als release funktionieren.
Das gibt nen Fehler. Warum?
Sag. Wieso?
Doch.
Tatsächlich. Ja.
Ich hab das TP vergessen.
Wir können es aber eigentlich machen.
Greif ich da nachher noch irgendwie drauf zu?
Jaja. Okay.
Ich move es nicht.
Ich kopiere es.
Ihr habt wieder.
Absolute best practices.
Massig comments amenden.
Und force pushen.
So macht man das.
Und text 1000 mal überschreiben.
Und text 500 mal überschreiben.
Wobei text ja eigentlich was eindeutiges sein soll.
Aber who cares.
0.
Okay.
Tag.
Bild release.
Dann bilde mal.
Uploade das Binary.
Machen release.
Uploading release.
Release ready add.
Und jetzt.
Release 3.
Release now.
Die Github Seite ist kaputt.
Okay.
Was passiert denn jetzt eigentlich in der weiteren Bild Action.
Wenn ich jetzt nochmal eine Sache.
Wenn ich jetzt das.
Das doppelt hinzufüge.
Ah. Der schlägt fehl.
Was aber auch okay ist.
Weil es hat sich ja nichts geändert.
Das ist gar nicht so schlecht.
Dass der fehl schlägt Leute.
Das ist gar nicht so schlecht.
Der schlägt fehl.
Weil das was ich ändere exakt.
Also der Output ist exakt der gleiche bei beiden.
Okay.
Vmchamp in.
Yes. Yes.
Jawoll.
Dazu kann man nur sagen.
Eindeutig.
Easy as fuck.
Easy.
Easy as fuck.
Easy clap.
Vmchamp minus minus version.
Bam 003.
So.
Run kekel vm.
Und jetzt können wir uns auch gleich.
Die ganz furchtbar tolle.
Ah.
I see.
Es ist ein kleiner.
Kleiner Bug.
Wenn man groß und klein Schreibung verwendet.
Dann funktioniert.
Das natürlich nicht.
Das heißt.
Wenn man groß und klein Schreibung supporten will.
Muss man wahrscheinlich.
Ah.
Meine Autocompletes.
Die Autocompletes gehen bloß auf Großschreibung.
Guck.
Source.
Vmchamp.
Vmchamp.
Vmchamp.
Completion.
Der Vmchamp Ordner.
Wird nicht beim installieren gelöscht.
Ist das schlimm.
Vmchamp.
SSH.
Guck hier.
Neueste.
Output ist auch dabei.
Sehr gut.
Abflug.
Per SSH.
Ich glaube.
Wir müssen noch folgendes einfügen.
Hier muss noch eine zweite Zeile rein.
Damit das Autocomplete.
Damit das Autocomplete funktioniert.
Das machen wir jetzt schnell noch.
Weil wir wollen das Autocomplete hier auch.
Wir können auch das.
Das ist eigentlich noch besser.
Oder?
Das ist noch besser.
Wobei das erkennt man eigentlich nicht.
Leider.
Ich lass das so.
Ähm.
Die Completion.
Die habe ich irgendwo hier drinnen.
Completion.
Ich glaube da muss.
Zwei Sachen rein noch.
Vmchamp in klein.
Muss da noch rein.
Ich glaube dann.
Funktioniert.
Das bilde ich.
Ach komm YOLO wir machen direkt nochmal.
Wir pushen direkt jetzt einfach nochmal.
Log.
Das wird jetzt 004.
Leute.
Jetzt können wir es final einmal testen.
Ob das.
Ob alles so funktioniert wie gedacht.
Wir machen jetzt einfach 004 hinten drauf.
Noch.
Für besten fix aller Zeiten.
Nämlich.
Wobei das teste ich vorher nochmal lokal.
Nur um auf Nummer sicher zu gehen.
Dass es auch tut.
Aber man sieht da nicht so viel.
Wenn er das lokal baut.
Aber er macht im Hintergrund gerade.
Ganz viel.
Warum?
Na geil.
Jetzt habe ich mein Build Script irgendwie.
Ach so.
Ja weil mein Dockerfile nicht mehr funktioniert dafür.
Shit.
Ich habe doch das Dockerfile angepasst.
Jetzt funktioniert das Dockerfile lokal nicht mehr.
Ah da muss ich mir.
Da muss ich mir noch was überlegen.
Ich muss jetzt auch Build X lokal benutzen.
Target Version 4.
Target Output.
Temp.
Out.
Out for mchamp.
Minus Minus Version.
Ok.
Jetzt gucken wir mal ob das.
Completion ZSH.
So das ist der neue Output.
Source.
Und jetzt gucken wir mal.
Ob das jetzt auch mit kleingeschriebenem vmchamp funktioniert.
Yo.
Ok dann können wir jetzt wirklich abschließend pushen.
Commit.
Machen wir neues.
Hit Commit.
Fixed.
Ehm.
Completion.
For lowercase.
Ist Lowercase ein Wort?
Ich glaube es ist ein Wort.
Push.
Gute Changes.
Hit Push Origin.
Master.
Es ist nicht Origin.
Es ist gut das es nicht Origin ist.
Weil ich will immer zwischen unterschiedlichen Sachen pushen.
Und manchmal verpushe ich mich.
Wenn das Ding Origin heißt. So wie eben.
Wenn ich mich fast verpusht hätte.
So.
Jetzt haben wir Master gepusht.
Eventuell die Commits im Release verwenden.
Kannst du beim Release Body nicht den Commit Grund verwenden?
Doch.
Aber es sind ja normalerweise mehr.
Als ein Commit.
Das heißt ich müsste mir das aus den Commits zusammenbauen.
Und ich kenne meine Commits.
Die sind eigentlich nicht dafür.
Geeignet.
Da ordentliche Release Notes draus zu machen.
Tag.
Moment.
Ich kann jetzt ja ganz einfach sagen.
Tag.
Ich kann jetzt sagen.
Mach einen neuen Tag.
V4 und push die Tags.
So und jetzt.
Jetzt sollte es.
Initial einmal komplett durchlaufen.
Aber nur den Commit mit dem Tag.
Mit sauberer Message.
Spooky.
Das ist eine sehr gute Idee.
Wir könnten einfach die Commit Message des Tags verwenden.
Für die Release Notes.
Das ist eine gute Idee.
Das gefällt mir.
Ist nur die Frage wie man da gescheit rankommt.
Das ist eine gute Idee.
Haben wir schon Release?
Noch nicht da.
Jetzt baut er ja erstmal die Software neu.
Jetzt baut er ja erstmal die Software neu.
Das dauert ein bisschen jetzt.
Moment warum baut er?
Scope. Ja guck hier.
Might be.
Might be your scope key which contains.
Tja dann ist es vielleicht doch nicht so.
Also so habe ich das ja auch.
Also so habe ich das ja auch.
Okay aber wir haben ein neues Release am Start Leute.
Es ist Release 4 am Start jetzt.
Es ist Release 4 am Start jetzt.
Fixes.
Die besten Release.
Die besten Benahmung ever.
Fixes.
3 ist Fixes.
4 ist Fixes.
Und mein Build hier.
Ist auch Version 4.
Also die eigentliche Sache.
Die funktioniert.
So jetzt müssen wir nur noch warten.
Gucken wir mal hier.
Ich mach sogar mal wieder ein Uninstall.
Machen wir mal sogar ein Uninstall.
Minus R vmchamp bin.
Dass es wirklich wieder von vorne installiert wird.
Dass es wirklich wieder von vorne installiert wird.
Vmchamp.
Noch hat er es nicht erkannt.
Okay wir lassen es mal hier.
So und wir gucken jetzt mal.
Wann es updatet.
Das dauert wahrscheinlich wieder so 5 Minuten oder so.
Bis er das gecheckt hat.
Aber er sollte es jetzt.
Gleich kapieren.
Github Event Head Commit Message.
Ist das die.
Also quasi die.
Die letzte Commit Message.
Das wäre dann die Commit Message aus dem Tag.
Das ist eine sehr gute Idee.
Die Commit Message aus dem Tag zu nehmen.
Das finde ich äußerst Fiveheader.
Das können wir sogar ausprobieren.
Das können wir sogar ausprobieren.
Ohne das ich jetzt noch mal ein neues Hour und so Zeug pushen muss.
Ohne das ich jetzt noch mal ein neues Hour und so Zeug pushen muss.
Okay bis jetzt ist noch nichts da.
Nicht so viel rum.
Machen wir mal hier.
Repos VM Champ.
Das können wir jetzt tatsächlich noch mal machen.
So also.
Wir haben jetzt.
Body ist nicht fixes.
Body ist.
Muss ich das so machen?
Falls hier mehrere Zeilen drin sind.
Kommt der mit Zeilenumbrüchen klar an der Stelle?
Kommt der mit Zeilenumbrüchen klar an der Stelle?
Okay.
Probieren wir mal.
Also ich glaube so sollte es passen.
Push.
Git Push GitHub Master.
So Tag.
Dann lassen wir noch mal Jibain.
Wir machen den Vierer Tag einfach noch mal.
Das ändert dann nämlich nichts am Hour Build.
Was ganz gut ist.
Da muss ich ja nicht laufen neues Zeug pushen.
Aber wir können noch mal uns ein neues Bild angucken auf GitHub.
Aber wir können noch mal uns ein neues Bild angucken auf GitHub.
Ob das funktioniert.
Achso.
Ich bin ja auch doof.
Ich hab hier die Commit Message.
Gucken wir erst mal.
Ich löscht das Release wieder mal.
Jetzt habe ich broken.
Okay neues Release.
Sollte schon am Start sein.
Sehr gut.
Ja sehr schön.
Das gefällt mir.
Okay ich löscht es mal wieder.
Und.
Warum ist es jetzt wieder da?
Es ist weg.
Es war widerspenstig.
Ist es weg? Es ist weg.
Okay.
Jetzt machen wir es mal wirklich doppelt.
So.
git tag-a-m
Moment das ist verkehrt.
Da soll nicht
ghfixes drin stehen.
Da soll die Message aus dem Tag
drin stehen.
Das bringt mir nichts.
Ich brauche an der Stelle ja
die Tag Message.
Kriegt man das auch irgendwie?
Oder ich mach halt die letzte
Commit Message.
Ich mach halt die letzte Commit Message.
Ich mach halt die letzte Commit Message.
Okay.
Also was haben wir hinzugefügt?
Wir testen jetzt mal ob das funktioniert.
Ja doch.
Ich mach es jetzt zweizeitig.
Was haben wir denn für Changes gemacht?
Better Message
for SSA
Connect
Keine Ahnung.
Was haben wir sonst noch?
Irgendwas Sinnvolles noch gemacht?
Ist ALMA
8N1
8
N
Ich kann nicht schreiben.
Image
Links
Gut.
Jetzt können wir das überprüfen.
Ob da was ordentliches reinkommt.
Als Vierer.
Bin ich mal gespannt.
Mal gucken ob das
funktioniert.
Mit mehrteiligen Sachen.
Es wäre auf jeden Fall extrem nice
wenn das funktioniert.
Weil da muss ich gar nichts mehr machen.
Da mach ich einfach ein ordentliches Commit.
Und dann mach ich ein Tag drauf.
Und push das.
Und es sieht einfach dann sofort
hübsch aus.
Ohne das ich was machen muss.
Zack. Oh wie nice.
Das ist cool. Das gefällt mir.
Wenn man die letzte Commit Message nimmt.
Man könnte auch einen
Changelog File machen.
Dann könnte man dann.
Aber das ist cool.
Das mag ich.
Das gefällt mir.
Sehr sehr nice.
So das schlägt jetzt fehl.
Weil es das ganze schon gibt.
Wird jetzt abkacken.
Aber das ist auch in Ordnung.
Eine Sache müssen wir danach
aber noch machen.
Das muss noch ein bisschen hübscher
gemacht werden im Repo.
Wir müssen nämlich noch hier Leute.
Eine Batch für das User Repo.
Und den Last Build hinmachen.
Die coolen Leute in ihren Repos
haben alle hier so eine Build Batch.
Ist natürlich doof wenn dann da steht
Build Failing.
Aber naja. Willste machen.
So jetzt mal gucken.
Ob mittlerweile das Arch User Repo
das ganze gecheckt hat.
Aha guckt mal da.
Der VM Champ wird geupdatet.
VM Champ.
Minus Minus Version.
Muss ich Clean Build machen?
Muss man in Clean Build machen dass das funktioniert?
Aber warum?
Ja. Warum muss ich den Clean...
Das versteh ich nicht.
Warum muss ich ein Clean Build machen damit das funktioniert?
Das ist ziemlicher Kack.
Muss ich dafür vielleicht Checksum
einfügen dass das kapiert?
Oder...
Warum checkt der nicht das es ein neues Package gibt?
Da meint doch einer das was nicht gelöscht wird.
Ne das wird
das wirds nicht sein.
Next big idea moin.
Aber wir haben jetzt auch Auto Complete.
Okay. Sehr schön. Sehr schick.
Warum muss ich...
Das versteh ich nicht.
Our only update
Clean Build.
Ja das versteh ich nicht.
Warum?
Warum er das nicht updatet?
Das leuchtet mich nicht ein.
Ich mein das funktioniert ja prinzipiell
weil ich Clean Build machen muss.
Aber warum? Hä?
Keine Ahnung.
Zumindest eine Sache müssen wir jetzt noch machen.
Das müssen wir uns dann nochmal im Detail angucken.
Warum das nicht geht.
Weil das ist ja blöd.
Wenn das nur beim Clean Build funktioniert.
Niemand denkt doch dran das er dann Clean Build machen muss.
Wahrscheinlich ist das Package File einfach nicht
richtig.
Was ich da erstellt hab.
Woran könnte das denn liegen?
Das der das nicht checkt.
Ich mein hier sind eindeutig die Versionsnummern drinnen.
Und hier wird die Versionsnummer geupdatet.
Also...
Muss man vielleicht Package Release hochmachen?
Ich dachte das Package Release bezieht sich...
Moment.
Vielleicht bezieht sich das Package Release
nicht auf das Release
mit der gleichen Versionsnummer.
Sondern damit das überhaupt funktioniert
muss man das hochmachen.
Okay.
The Release Sum.
This is usually a positive integer number that allows two...
...
...
...
Was ist das?
Das Build passiert ja auf GitHub.
Da ist ja ein Clean vergessen nicht möglich.
Das Build passiert bei jedem Lokal.
Die Software wird auf GitHub gebaut.
Dieses Package installieren.
Das passiert...
Das passiert...
Also das was hier in diesem Package Build drinne steht.
Das passiert bei jedem Lokal auf der Kiste der sich das Package installiert.
Das passiert bei jedem Lokal auf der Kiste der sich das Package installiert.
Das passiert bei jedem Lokal auf der Kiste der sich das Package installiert.
Aber warum er das nicht checkt?
Does not update.
Da muss ich mich mal schlau machen.
Da ist bestimmt in meinem Build File irgendwas...
...irgendwas verkehrt.
Weiß jemand von euch?
Nur mal so.
Downgrade gab es doch hier.
Downgrade.
Jaja.
Ich will das nochmal nachstellen.
Downgrade for mchamp.
Äh.
For mchamp bin.
Geht das so?
Ah shit.
Das geht glaube ich nicht.
Ich glaube das geht nicht.
Okay.
Ne das geht nicht.
Was?
Cache for mchamp bin.
Ich habe ja clean Build gemacht.
Das ist jetzt weg.
Install.
Old.
Our version.
Wie macht man das?
Da habe ich mir noch nie Gedanken drüber gemacht.
Ja das Package Build kann ich runterladen.
Das ist mir klar.
Ja gut.
Dann heißt es aber anders.
Oder?
Kann ich jetzt...
Könnte ich jetzt das alte auschecken?
Also git log.
Also mal lokal.
Okay ich uninstall das mal.
For mchamp.
Yes.
Pull.
So und jetzt gehen wir mal hier bei mir lokal.
Git reset.
Minus minus hard. Einfach 1 zurück.
Das ist jetzt das 3er Build.
Okay.
Make package.
Minus minus install.
Yes.
Vmchamp.
Minus minus version.
Ist wieder der 3er.
So und wenn ich das hier jetzt so mache.
Dann bietet er mir das an.
So okay so kann man das nachstellen.
Das ist doch schon mal gut.
So und was ich jetzt überhaupt nicht checke ist.
Damit du eine Trash vm.
So muss das sein.
So jetzt kann ich updaten.
So ich mache jetzt kein clean Build.
Build file exists.
Ist das...
Kann ich sonst auch nicht clean Build machen.
Show diff.
Yes.
Proceed to install.
Yes.
Skipped.
Already made.
Ah Moment.
Jetzt hat das wieder.
Jetzt wird es stimmen.
Das Problem ist das es eben beim Upgrade.
Nicht die neue Version gezogen hat.
Und ich weiß nicht warum.
Erst wenn ich ein clean Build gemacht habe.
Na gut.
Dann sind wir bei Version 5.
Warum das nicht funktioniert.
So aber eine Sache müssen wir noch machen.
Das es cooler aussieht.
Und zwar müssen wir die README anpassen.
Ganz wichtig.
So Achtung.
Build.
Gabs da nicht.
Schau mal ob die Changes überhaupt.
Sind sie.
Alles gut.
Aber er hat nicht geupdatet.
Das ist das was ich nicht verstehe.
Er hat eben nicht automatisch.
Er hat die 003 genommen.
Als Version.
Und hat sie quasi.
Als 004 installiert.
Wenn ich ein clean Build mache.
Kommt das mit.
Okay Serious Max.
Damit kennst du dich aus.
Ich brauch jetzt ein.
Actions.
Ja.
Github Workflow Status.
Excellent.
So.
Status User.
Reports.
Repo.
Vmchamp.
Muss bei der Groß- und Kleinschreibung drauf achten.
So Workflow.
Build.
Jamel.
Fail.
Vielleicht soll ich dann die Builds nicht da vorne drauf schreiben.
Wir machen jetzt.
Easy.
Chebated.
Ich lösche jetzt einfach alle Workflows die gefailt sind.
Und dann ist der letzte Workflow okay.
Easy as fuck.
Easy.
Sehr gut.
Okay.
Aktuelles Build.
Aktuelles Build.
Dravon rein.
Vmchamp.
Ist jetzt richtig gemacht.
Build Passing.
Jawoll.
Last Commit.
Ach ne Moment.
Man muss das ja hier natürlich anpassen.
Wo werden denn die Images gespeichert?
Schon aufgeregt wie im Motor.
Ja.
Bisschen.
Die Stars.
Die wollen ja auch.
Ich glaube so ist das richtige.
Wo man die Übersicht der ganzen Leute sieht.
Star Gazers.
Ja.
Die ganzen Leute sieht.
Die gestarrt haben.
Die Hour Badges brauche ich auch.
Sollte man hier nicht den Link machen.
Auf das letzte.
Build.
Den Link.
Den können wir einfach hier auf die Actions setzen.
So.
Und dann noch für das Hour Package.
Selbstverständlich.
Das brauchen wir auch noch.
Unter welcher Kategorie ist denn das drunter?
Auch Build?
Oder wo versteckt sich das mit dem Hour Package?
Plattforms und Version Support?
Ne.
Man kann.
Ach das ist ein Suchknopf hier.
Das habe ich nicht gesehen.
Hier.
Version.
Das brauchen wir.
Our Version.
Votes.
Votes habe ich genau eins.
Den finde ich selbst.
Our Version.
Package Name.
Das ist eine coole Seite für diese Badges.
Finde ich extrem nice.
Moment das machen wir nicht vorne hin.
Das machen wir vielleicht hinten.
Arch muss vorne.
Weil.
By the way.
Ich weiß nicht ob das hinten irgendwo angezeigt wird.
So.
Our Version.
Imagesource.
Und jetzt der Link.
Der geht dann auf mein.
Repo.
Our Vmchamp.
Gut.
Ne Moment nicht die Imagesource.
Der Link.
Muss dahin.
Mal gucken wie es jetzt ausschaut.
Sehr stylisch.
Excellent. Excellent.
Wo sind die QCOW Dateien die schon runtergeladen sind.
Hier.
Es gibt glaube ich.
Gibt es nicht sogar einen Flag zum
Force.
Neu downloaden.
Wenn nicht sollten wir das machen.
Die sind hier.
Die sind in deinem Heimatverzeichnis.
Vmchamp.
Gibt es kein Force Redownload.
Du kannst aber auch einfach löschen.
Du kannst aber auch sagen Vmchamp clean.
Also wenn du das sagst räumt er alles auf.
Also ich denke das sind die.
Und dann.
Die Chacksummen wären nice.
Ja da müsste man die Chacksummen hinterlegen.
Was wieder doof ist.
Weil dann müsste man die bei jedem Image aktualisieren.
Oder man holt sich die Chacksummen aus dem.
FDP.
Oder er hat auf Webserver von dem.
Anbieter.
Wäre es eigentlich nicht sinnvoll den Image Cache.
Nach .image zu packen.
Ja schon irgendwo.
Ja.
Jetzt müssen wir das erst mal committen.
In dem Distrofile.
Ein Link zur Chacksumme.
Ja stimmt.
Die müsste dann auch unter Latest liegen.
Ja das ist eine gute Idee.
Release 005.
Noch nicht.
Aber bald.
Ich muss noch die Readme committen.
So sieht das doch sehr schick aus.
Das gefällt mir.
Last commit today.
Passing stars 29.
Release 004.
So.
Commit changes.
Bam.
Haben wir nicht.
Was sagt ihr eigentlich zu dem Logo.
Ist das Logo nicht Poggers.
Habe ich mit so einem billigen.
Kostenlosen Logo Generator gemacht.
POG Logo.
Vor allem mit Farbverlauf.
Sehr schick.
Jetzt haben wir auch noch.
Nice.
Badges am Start.
Wo man drauf klicken kann.
Ah.
Das gefällt mir.
Und ich finde es auch nice.
Dass ihr mir schon so viele Stars gegeben habt.
Das sind so viele Stars.
Da kann ich mich fast selbst wieder anstarren.
So geht das nicht.
Farbverlauf ist nicht.
Das darf nicht sein.
Das ist zu modern.
Das ist nicht Richard Stallman approved.
Allow me to interject for a moment.
I call it GNU plus Linux.
Also das mit dem.
Das das Update.
Nicht richtig funktioniert hat.
Mit der mit.
Das muss ich dann bei Version 5 mal überprüfen.
Ob es da irgendwelche Probleme gibt.
Weil das.
Verwirrt mich aktuell.
Wisst ihr was auch sein kann.
Wisst ihr was sein kann.
Das alles funktioniert hat.
Aber ich noch.
Aber der noch das genommen hat aus.
Meinem lokalen.
Sippts Helper.
Ne da liegt es ja gar nicht mehr.
Ach dann weiß ich auch nicht.
Das werden wir dann bei Version 5 sehen.
Das werden wir dann bei Version 5 sehen.
Eine Update Benachrichtigung.
Ach Quatsch.
Ne das brauchen wir nicht.
Die Leute sollen sich das über das Arch User Repo installieren.
Oder aber.
Das ist zu nervig.
Also wir bauen auf jeden Fall ein.
Das man minus minus force.
Downloaden vom Image machen kann.
Checksum Support.
Und das es die ganzen Sachen dann doch.
Unter Images speichert.
Äh unter Punkt Cache speichert.
Und nicht hier unter.
Unter unter VM Champ.
Das vielleicht.
Ist vielleicht doch keine so geile.
Position hier.
Lässt sich glücklicherweise relativ einfach ändern.
Weil ich in weißer Voraussicht.
Die ganzen.
Folder.
Hier.
Hier drüber definiere.
Das heißt ich müsste eigentlich nur hier.
Ähm.
Pass Combine.
Home Directory.
Und dann quasi.
Punkt Cache.
Ne wo muss das hin?
Punkt Cache oder Punkt Config Cache?
Ne Punkt Cache.
Also müsste ja quasi sowas.
Cache.
Und schon würde das jetzt alles.
Im richtigen Cache Verzeichnis.
Landen.
Fühlt man sich als VM Champ Inventor.
Massive.
Big Brain fühlt man sich.
Und das geht nur.
Dank ganz vieler Prime Subs.
Weil ansonsten wäre hier einfach das.
IQ Niveau auch gar nicht hoch genug.
Um so krasse.
Sachen zu inventen.
Ach Leute das.
Ich muss sagen das hat sich heute gelohnt.
Da habe ich auch ein bisschen was gelernt wieder.
Also erstens haben wir jetzt eine noch hübschere Readme.
Wir haben.
Ne.
VAR Cache geht nicht.
Hat doch nicht jeder.
Hat da jeder Zugriff drauf?
Ja gut das ist wahr.
Wahrscheinlich schon.
Wir haben jetzt eine noch schönere Readme.
Wir haben GitHub Actions.
Die neue Releases bauen.
Sowohl GitHub Releases als auch.
Neue Arch User Repo Releases.
Wir haben sogar halbwegs hübsche.
Release Beschreibung.
Das hat was.
Das hat was das gefällt mir.
Ich habe noch eine Idee.
Wie wir das mit dem Upgrade noch nachvollziehen können.
Ich habe eine Idee.
Das teste ich jetzt noch.
Already exists.
Ja ja ist gut.
Git log.
Was liegt denn das hier rum?
Da hat es ja überhaupt nichts zu suchen.
Repos.
Also klonen wir nochmal das Repo.
Resetten das auf Version 3.
Reset.
Make.
Package.
So.
Und jetzt mal mal.
Jetzt werden wir es gebeten.
Wo ist das hier unter.
Cache.
Da.
Ne.
Ja.
Da.
Da kopiere ich das jetzt nämlich einfach rüber.
Also.
Dings hier from.
Repo.
Repos.
Vmchamp.
Achso.
Ok müsste eigentlich passen.
Die Dateien sollten wir noch rüber.
Sollten wir Source Info rüber kopieren.
Und.
Package Bild rüber kopieren.
So. Install.
Lärft nicht rum.
So und jetzt beim Update.
Schlägt der mir vor.
So also jetzt können wir es mal ausprobieren.
Was das Problem war.
Das ist nicht TMAX das ist Vesturm.
So wir sind jetzt auf Version 3.
Und jetzt kommt das Problem was ich eben hatte.
So wir sind auf Version 3.
Ja.
Das ist nice.
Ich wusste gar nicht das es Twitch Turbo noch gibt.
Was ist der Vorteil noch von Twitch Turbo jetzt.
Wo es Prime gibt.
Achso man sieht überall keine Werbung.
Nicht nur da wo man abonniert hat.
Bei Prime ist es ja wieder raus.
Das man keine Werbung sieht.
Das war ja bloß die ersten 2-3 Monate so.
There is nothing to do.
So guckt mal Leute.
Jetzt sagt er mir.
Build files already exist.
Ich update jetzt auf Version 004.
So.
Version 004 geupdatet.
Already made. Skipped Build.
Und jetzt ist aber immer noch.
Ne jetzt ist auch wieder Version 4.
Ne jetzt ist auch wieder Version 4.
Okay.
Dann habe ich nichts gesagt.
Dann war das vielleicht sowas.
Okay.
Dann habe ich mich verguckt vorhin.
Habe ich vorhin irgendwie verguckt.
Oder das nicht aktualisiert hat.
Vielleicht habe ich mich auch einfach verguckt.
Ja ich habe auch 3 gesehen.
Aber ich weiß halt nicht warum.
Ich weiß halt auch nicht warum.
Egal.
Das werden wir bei Version 5 sehen.
Wir müssen ja.
Noch einbauen.
Ich habe mir das jetzt aufgeschrieben.
Ich habe mir das jetzt aufgeschrieben.
Wir.
Wir brauchen ja noch sowas hier.
Ich schau das jetzt einfach mal hier rein.
Also Moment ich habe doch so ne.
Ich habe da extra Textdatei gemacht.
Für To Do's was damit zu tun hat.
Ja.
Also wir könnten gucken ob wir irgendwie.
Offiziellen Config Repo.
Pfade unterstützen können.
So dass wir Punkt Cache als Update nehmen.
Und vor allem das hier.
Ist echt nicht verkehrt.
Und das mit dem Netzwerk.
Vom GitHub Issue.
Das wir Force Download machen können.
Das ist tatsächlich ganz sinnvoll.
Heute mit dem Force Download.
Aber das man zum Beispiel hier bei dem.
Beim Run Command.
Einbaut das man noch Minus Minus Force.
Angibt.
Oder oder oder.
Muss man sich irgendein gescheites Kommando für überlegen.
Das Ding hat schon.
Hat schon ganz schön viele Kommandos.
Guck mal.
Es hat schon.
Mehr als genug.
Ok die Hilfe Ausgabe ist MassivePepega.
Man kann Minus Minus OS angeben.
WIss CPU, BG, Local Image.
Man bräuchte noch irgendwie sowas wie.
Refresh oder so.
Minus Minus Refresh.
Wäre vielleicht nicht schlecht.
Wie auch immer man es nennen mag.
Minus Minus Force.
Ist ein bisschen doof.
Weil man da nicht weiß.
Auf was sich es bezieht.
Wie heißt das.
ZSH Plugin mit dem du alle verfügbaren Parameter von einem Befehl.
Das ist gar kein Plugin.
Mein Programm unterstützt das.
Mein Programm unterstützt das.
Hier guck.
Completion.
ZSH.
Das ist die Definition von der Completion.
Das ist die Definition von der Completion.
Und damit das geladen wird.
Muss man auch.
Das hier in seine ZSH RC einfügen.
Muss das hier quasi sourcen.
Muss das hier quasi sourcen.
Muss das hier quasi sourcen.
Und wie das.
Ne das ist kein Plugin.
Man kann so Dinger machen.
Aber das unterstützt das von Haus aus.
Man muss das hinzufügen.
So und was noch ganz nice ist.
Das ist halt.
Quasi so.
Kann man das testen.
Irgendwie so funktioniert das.
Irgendwie so funktioniert das.
Keine Ahnung.
Da geht es doch nicht.
Das ruft er halt auf.
Das ruft er halt auf.
Ach ne ich muss VM Champ da vorschreiben.
Dass das funktioniert.
Oder auch nicht.
Ach keine Ahnung.
Hauptsache.
Meine Completion funktioniert so.
Das ist West Term.
Super nice das Terminal.
Vor allem weil man das.
Vor allem weil man das.
So schön customizen kann.
Und weil es so ein bisschen die Sachen von TMAX eingebaut hat.
Und weil es so ein bisschen die Sachen von TMAX eingebaut hat.
So das man nicht TMAX in TMAX in TMAX braucht.
So das man nicht TMAX in TMAX in TMAX braucht.
Aber gibt es ein ZSH Plugin mit dem man die Parameter von jedem Befehl anzeigen lassen kann.
Aber gibt es ein ZSH Plugin mit dem man die Parameter von jedem Befehl anzeigen lassen kann.
Du meinst als Autocomplete.
Ja du kannst so Sachen basteln.
Dass er sich aus der.
Dass er sich aus der Hilfe versucht.
Autocompletion zusammen zu bauen.
Für Kommandos.
Die keine ZSH Completion mitliefern.
Aber das kann ich dir aus dem Kopf nicht sagen.
Wie das funktioniert.
Das geht aber.
Das geht.
Das ist aber meistens nicht sonderlich gut.
Wenn die Befehle nichts mitliefern.
Weil dann splittet er die Wörter falsch.
Weil dann splittet er die Wörter falsch.
Weil dann splittet er die Wörter falsch.
Weil dann splittet er die Wörter falsch.
Wie wäre es mit Clean Image.
Clean Download von TMAX.
Wie wäre es mit Clean Image.
Clean Download von TMAX.
Clean.
Machen wir jetzt aber nicht.
Minus Minus Clean.
Oder Minus Minus Clean einfach nur.
Download.
Man Page Completion.
Ja sowas in der Richtung.
Ja sowas in der Richtung.
Mit eingebautem Zeug machen.
Aber das.
Mit irgendwelchen eingebauten Sachen machen.
Aber das hat dann wirklich Probleme.
Aber das hat dann wirklich Probleme.
Mit wie splittet er das an der Hilfe und sowas.
Mit Minus Minus Clean Download finde ich eigentlich ganz gut.
Mit Minus Minus Clean Download finde ich eigentlich ganz gut.
Download all.
Download.
US Image again.
Even if it's already.
Even if it's already.
Present in cache.
Versteht man doch jetzt eigentlich.
Versteht man doch jetzt eigentlich.
Versteht man doch jetzt eigentlich.
Das machen wir aber nicht jetzt.
Da habe ich jetzt echt keinen Kopf mehr dafür.
Das hier noch einzubauen.
Muss mich jetzt erstmal ein bisschen.
Ah yes.
Anstrengende Sache.
Vier Stunden fast rumgebastelt heute.
Wir haben doch wirklich ordentlich was auf die Reihe gekriegt.
Wir haben doch wirklich ordentlich was auf die Reihe gekriegt.
Richtig schön.
GitHub Workflow am Start.
Our Packages.
GitHub, äh nicht GitHub.
Arch User Repos am Start.
Die automatisch aktualisiert werden.
Die automatisch aktualisiert werden.
Release Notes, die sich automatisch generieren.
Release Notes, die sich automatisch generieren.
Arbeite gerade an einem Comet.
Hab ein Logo erstellt.
Wie? Ein besseres Logo als
der VM Champ eh schon hat?
Also mein Code
soll ich noch eine Viertelstunde labern,
damit wir uns sein Logo angucken können?
Also bis 23 Uhr würde ich noch on bleiben.
Ain't Logo.
Also wie gesagt,
das Ding habe ich aus irgendeinem
Logo Generator.
Weil
es sieht halt doof aus, wenn du so
ein README hast, ohne irgendwie groß
Logo muss sein.
Die Leute, die die Sachen in Go
programmieren, die haben es einfach.
Die können sich irgendein komisches
Go Maskottchen hier
Gopher
Generator
Ja, da kann man, gibt es sogar schon
fertige, fertige
Generator, was man, was man
hier bauen kann.
Übrigens, da könnte man NFTs draus generieren,
oder?
Es ist halt
es gibt sogar eine Monka Corona
Maske.
Gopher NFT für alle Go
für alle Go Fans.
Guckt ihr mal den Gopher einfach mal.
Okay, Sirius Max
Moment, den kann man den QR Code scannen?
Das ist ein scannbarer
QR Code hier drauf.
Seriously?
Jetzt bin ich verwirrt.
Jetzt bin ich verwirrt.
Hier ist
kein QR Code drauf.
Warum ist hier kein QR
Code drauf, wenn ich das öffne?
Ist das
Ach, da sind mehrere
Bilder. Ne,
sind nicht mehrere Bilder.
Okay, ich scanne jetzt mal den QR
Code, weil
hoffentlich ist es
klein genug.
Okay, den QR Code ist zu klein.
Den kann man nicht scannen.
Ich muss mal vergrößern.
Okay, mal gucken, ob man jetzt scannen kann.
YouTube?
Das ist geil.
Das finde ich nice.
Ihr hört es vielleicht,
was es ist.
Hört ihr es?
Nice.
Hast du den auch?
Hast du den auch in so einem Generator raus
dir zusammengebaut?
Ja, wahrscheinlich, oder?
Ich gehe mal davon aus, du hast es aus dem Generator
und hast das Bild dann selbst
davor gesetzt irgendwie.
Die Kiste
mit dem QR Code.
Du hast es komplett selbst gemacht.
Wirklich.
Nice.
High IQ Graphic Skills.
Muss mal
Fullscreen jetzt.
Hast du die Lizenz schon angepasst? Nein.
Habe ich noch nicht gemacht.
Ist immer noch unknown.
Muss man noch anpassen
dann.
So, jetzt reicht es
aber für heute.
Vier Stunden am Start.
Gibt es noch irgendwas cooles, was wir uns so
zum Schluss angucken könnten?
Irgendwas kleines.
Irgendwas kurzes.
Morgen früh bin ich auch schon wieder am Start.
Oh ne, please.
Keine AI-Videos jetzt.
Fireship prügeln.
Die AI-Videos
raus, Alter.
Es ist ja irgendwann auch mal gut, Mensch.
Man kann es auch
übertreiben, ey.
Ich meine, die Videos kommen mega krass an.
Ja, aber
die machen irgendwie das Zehnfache an Views
wie teilweise die anderen Videos von ihm.
Aber trotzdem, irgendwann
ist doch auch wirklich mal gut.
Na gut, auf YouTube ist nix
gut. Bis es keiner mehr guckt,
dann ist gut.
Okay, du hast ein Pull-Request erstellt.
Pass auf, also
wenn das jetzt irgendwie
was Monka-Tossiges ist,
wäre ich sauer.
VmChamp. Hm.
Hast du das selbst gemacht oder
auch aus dem Logo-Generator?
Year of the Linux Desktop is
finally here. Ach ja,
wirklich. Bestimmt ein April-Scherz.
Okay, Chat.
Ihr dürft es euch aussuchen.
Was gefällt euch besser?
Der VmChamp
oder
Oh, das ist ein bisschen groß hier.
Welcher VmChamp gefällt euch
lieber? Der Link geht nicht
aufs korrekte Repo.
Welcher Link? Welcher Link geht nicht aufs
korrekte Repo? Ach, das hier.
Nee, der Link geht wirklich nicht aufs korrekte Repo.
Das stimmt. Wir machen
eine Abstimmung.
Welches Logo, Chat?
Ihr dürft abstimmen.
Steht zur Auswahl. Neues Logo.
Neues Logo.
Altes Logo.
Jetzt aufs richtige, okay.
Okay, die Leute sind sich ein bisschen
uneins. Das neue
sieht irgendwie aus wie Instagram.
Das stimmt schon.
Hat C Sharp
kein Maskottchen? Doch, das
ist so ein komischer Roboter.
Das ist aber, das ist hässlich.
Das gefällt, dieses Teil hier.
Das ist so hässlich, das verwende
ich nicht. Typisch Microsoft
Logo, Alter.
Das ist richtig
Dance Game, das Ding.
Okay, der Chat ist der Meinung
so zu zwei Dritteln.
Naja, eigentlich
sind es mehr.
Fast schon drei Viertel.
Nicht ganz, aber fast.
Also zu drei Viertel ist der Chat
der Meinung, das
Alte ist nicer und
die anderen. Ich muss sagen,
ich finde, es haben beide was.
Nee, nee, warte mal.
Ich finde, das haben beide was.
Man könnte durchaus,
also was ich viel schicker
finde, ist deine Schrift
und, also
ganz ehrlich, das
Logo hier
mit dem Icon vielleicht?
Ach, ich weiß nicht genau.
Keine Ahnung. Bin ich auch zu low IQ,
mir da gerade weiter Gedanken
drüber zu machen?
So lange war ich selten on, oder?
Vier Stunden.
Nein, wir haben angefangen
irgendwann
19 Uhr, ziemlich
bisschen
18.50 Uhr oder sowas.
Das ist halbe Arbeit.
Es ist mehr, ohne Scheiß.
Es ist krasser als ein Arbeitstag,
vier Stunden streamen, in dem Sinne, weil
es ist vier
Stunden am Stück
permanent Fokus
auf dem, was du machst
und alle gucken,
was du machst und du musst die ganze Zeit
halbwegs konzentriert sein.
Du musst die ganze Zeit was erzählen und machen.
Also, ohne Scheiß,
vier Stunden Stream
in dieser Form wie heute
ist heftiger als ein Arbeitstag.
Ich denke, das kann man so schon
sagen.
Ja, na gut,
das kann man glücklicherweise nicht so vergleichen
mit, hinter dir im
Stream steht einer.
Im Stream gucken Leute zu, wie steht hinter dir.
Wenn einer hinter dir steht, ist es schon
ein bisschen anstrengender, klar.
Vier Stunden hier,
gleich eine Arbeitswoche.
Naja, von
von sinnvoll
was gemacht?
Wahrscheinlich schon, weil
ansonsten muss ich ja die ganze Zeit mieten
und kann nichts machen.
Der Song gerade ist nice. Das ist irgendeine Playlist.
Irgendeine, ja,
Epic, Epic
Chillstep Collection.
Also, ich muss so viel mieten
normalerweise auf der Arbeit.
Mal gucken, wie es jetzt beim neuen Arbeitgeber wird nächste Woche.
Ich habe den Namecheap Logo Generator
verwendet und habe VM,
habe Virtual Machine beim Logo eingegeben.
Vielleicht winst du es ja.
Aber lass dir Zeit, es ist ja nicht eilig.
Das Logo ist, glaube ich, somit das unwichtigste da dran.
Ja, ich finde auch.
Also die Tabs reichen nicht.
Da muss schon noch, da muss schon noch
ein bisschen was hin.
Ich meine, man erkennt die Icons noch, das geht ja nicht.
Also, ach Moment, kleiner
geht es nicht mehr.
Na gut, ja.
Und sonst Chat?
Irgendwas
gewesen noch spannendes.
Die Overwatch Videos.
Ah ja, Overwatch spiele ich nicht mehr.
Ich habe Overwatch 2
noch nicht mal installiert.
Noch nicht mal aktiviert
bei mir auf dem Blizzard Account, falls man das irgendwie
aktivieren muss.
Ich war auch ganz brauchbar, würde ich
sagen. Ich meine, ich habe vieles
verkackt, das weiß ich im Nachhinein auch.
Gerade, wenn man sich ja, man, die, die richtig
guten Pro-Plays angeguckt hat.
Aber
so für,
für Public Matchmaking ging das mit
Lucio schon gut, klar.
Wer hat mich heute reingelegt? Keiner.
Ich ignoriere diesen ganzen April-Shit.
Also,
gerade an diesem Tag, da weiß ich, weiß
ich immer alles, was, ich habe mir
tatsächlich ein April-Scherz
Video angeguckt, aber mir war von
Anfang an klar, dass es
ein April-Scherz ist. Ich habe mir ein Video
angeguckt von ihm hier.
Why Java
is so much better.
Woran die Leute ein bisschen
cheebaitet, dass
Java Features ja viel
besser sind, als in C Sharp.
Also, ich wusste,
dass ich
cheebaitet werde.
Du wurdest gerade gerickrolled.
Das stimmt. Mit einem QR-Code.
Massive.
Aber da ist es, das ist immer
da. Auch wenn ich erst da
April ist.
Mache gerade einen Udemy-Kurs Linux
und frage mich, ob in
X11
zwangsläufig ein Window-Manager
braucht. Was?
Ne.
Nicht zwangsläufig.
Du kannst in X
auch direkt irgendwie das
Xterm starten im Fullscreen.
Oder im, im, im
als erstes.
Du brauchst keinen Window-Manager.
Aber ohne Window-Manager ist es nicht
schade zu bedienen.
Also brauchst du, du musst nicht.
Aber es macht eigentlich kaum einen Sinn
ohne.
1. April ist mega unnötig.
Komplett useless.
Shit.
Terminal-Only-Enjoyer.
Wisst ihr, was das Problem an
Terminal-Only ist?
Also, ich rede jetzt wirklich von
Terminal. Also nicht
Terminal in X offen, sondern
das, das, das
klassische
Frame-Buffer-Terminal.
Das Problem
ist, dass die
Auflösung so klein ist.
Deswegen geht das nicht gescheit.
Du hast doch für deinen Lokal...
Also was ich meine ist halt,
so, das hier ist ein Terminal im Fullscreen.
Das kann man enjoyen, das ist
alles gut. So, aber,
äh, wait a minute.
Das hier
ist halt
absoluter Crap.
Du hast halt keine Auflösung und sonst was.
Keine Unicode-Zeichen
gescheit, kein nix.
Das ist halt Mist.
Aber das hier ist Pog.
Und kein Browser und so.
Du hast doch für deine Lokale
Domains SSL-Zertifikate
für Cloudflare DNS Challenge
plus Let's Encrypt gezogen. Ja, das ist korrekt.
Muss dafür
irgendwas offen sein, oder geht das komplett ohne
Port-Freigabe? Das geht komplett ohne
Port-Freigabe. Das ist ja
gerade der Vorteil von DNS Challenge.
Das funktioniert folgendermaßen,
so mal so ganz, ganz grob gesagt.
Du benutzt
irgendeine ACME
Library.
Unsicher, ob man das so ausspricht.
Aber das ist dieses Let's Encrypt Protokoll
für Zertifikate. Oder
Tool, zum Beispiel Certbot.
So, ähm.
Der Certbot geht
über die Let's Encrypt API hin und sagt
hier, ich würde gerne ein Zertifikat haben.
Für die und die
Domain mit DNS
Challenge.
Und dann sagt dir Let's Encrypt,
aha, dann beweise doch mal, dass
du der rechtmäßige Eigentümer bist,
indem du dieses Secret,
was ich dir jetzt hier mitteile,
als TXT Record
in deinem DNS hinterlegst.
So, und dann
brauchst du halt irgendein Plugin für
Certbot oder was auch immer du verwendest,
was mit der API von deinem
DNS Server
weiterreden kann und was
dort das geheime Secret von
Let's Encrypt hinterlegt, was er dir
gerade mitgeteilt hat. Und dann versucht
Let's Encrypt das Secret abzurufen und
wenn es das Secret findet, hast du damit bewiesen,
dass du der rechtmäßige Eigentümer
von der Domain bist und dann kriegst du ein Zertifikat
übermittelt.
Ja, da musst du keine
Sachen weiterleiten.
Wenn du den Server public
im Internet hast, es ist einfacher
es direkt
so zu machen, weil da brauchst du halt keine
API Keys und DNS
Einträge und sowas, sondern
tja, nur einen offenen Port.
Ja, aber intern einfach
DNS Challenge nehmen und gut ist.
Du musst halt die Domain rechtmäßig
besitzen, also du kannst keine DNS Challenge
machen für eine reine privat
bei dir intern existente Domain.
Das geht nicht, logischerweise.
Das muss eine öffentlich
auflösbare
Domain sein mit ordentlich
hinterlegten DNS Servern, dann geht
das. Du musst dazu allerdings
nicht im Public DNS deine
wirklichen
A-Records eintragen, die du
intern vielleicht hast. Also
A-Records sind die
die eigentlichen
Namen von der Domain.
Also das da zum Beispiel.
www.snarecord
von twitch.tv
Machst du heute noch eine Challenge?
Du meinst
du meinst Dings hier, Zetge
Zet
Servers meinst du?
Nee, heute nicht mehr.
Aber es gibt eine neue,
die können wir demnächst machen.
Neue Challenge.
Ah, dafür muss man sich registrieren.
Okay.
Okay, jaja, natürlich.
Javascript. Nicht
Javascript, Java.
Man muss das cool aussprechen.
In Java.
Java.
Oder wie es die Amis immer sagen.
Javascript.
Du hast das Logo aktiviert.
Gut, das mache ich als letzte Amtshandlung
heute noch. Da reingucken und dann gehe ich
pennen.
Pass auf, jetzt ist es ein Rickroll Logo.
Nee.
Es hat was von Instagram.
Oder
irgendwie auch
das Runde und so.
Das sind fast die gleichen Farben.
Ich weiß
nicht, das ist, das ist, die Farben sind wir
fast ein bisschen zu...
Ah, nee, nee, nee, sind schon andere Farben. Sind schon, sind schon
andere Farben, ja.
Aber es ist doch ein bisschen sehr Instagram-like,
muss man sagen.
Alles klar, Leute.
Jetzt reicht's.
Bis denn, wir sehen uns morgen früh.
So wie üblich, übliche Zeit, so um
neun rum.
Macht's gut, bis denn. See you.
