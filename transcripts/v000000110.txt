So, jetzt schauen wir mal, ob wir jetzt Quality Options haben.
Haben wir jetzt Quality Options?
Tja Leute, dann streben wohl zu viele Leute und ich kriege sie gerade auf Twitch nicht.
Da kann ich leider jetzt nichts machen, außer ich werde Twitch Partner endlich mal irgendwann.
Dann kriege ich auch immer Quality Options.
Aber solange ich keinen Twitch Partner bringe, bin ich halt quasi streben so dritter Klasse, was Quality Options angeht.
Ich pause nochmal kurz auf Twitch.
Und, ey Leute, ich sage euch, ich habe quasi gestern den ganzen Tag rumprobiert, hier den Gift Player zum Laufen zu kriegen.
Also nicht den da, sondern den Highspeed, DirectX, FFM Pack, sonst was Gift Player.
Und was unglaublich schwierig war, also das Gegenteil von, warum geht Easy nicht?
Ah, das Fenster noch kleines.
Easy.
Also das Gegenteil von Easy.
Das ist, ey, Windows.
Es ist so undurchsichtiger Kack, ey, teilweise.
Ich weiß gar nicht, wie man dafür überhaupt irgendwas Ernstzunehmendes entwickeln kann manchmal.
So, auf Twitch gepostet.
Ey, auf Twitter.
Ich bin schon komplett, komm, wir im Kopf, äh.
So, machen wir mal hier unsere Chill-Steps, Chill-Steps-Sore-Geschichte an.
So.
Mal gucken, wie die Lautstärke ist.
Ja.
Joa.
Joa.
Machen wir den an.
Ach, das ist der.
Oh, und ein anderes Icon.
Icon.
Ey, ich meine Thumbnail.
Leute, das Windows-Zeug hat mich so kaputt gemacht im Kopf.
Ey, ich kann überhaupt keine Wörter mehr aussprechen.
Ich bin wirklich komplett, komplett hinüber, was das angeht.
Also, ich hab hier das, das, das, das ekligste überhaupt produziert, ne.
Also, man kann das, man kann das nicht mal mal lesen, was ich hier gebastelt hab letztendlich.
Das müssen wir jetzt aufräumen.
Ich hab hier quasi 365 Zeilen.
Irgend, irgendeinen Schritt zusammen gebastelt, dass es schnell ist.
Was ein Akt.
Ich zeige euch das jetzt gleich mal, was da alles dahinter steckt.
Ey, das ist, es ist der Wahnsinn.
Und es macht aktuell nicht mehr, außer ne noch nicht animierten Papagei-Anzeigen.
Mit 6000, na gut, das ist, weil OBS im Hintergrund jetzt auch noch ein bisschen CPU braucht.
Mit 6500 FPS ne nicht animierten Papagei.
Aber, man, man, man, man merke, der Papagei ist transparent.
Was meint ihr, was es für ein Akt war?
Diesen Scheiß transparent zu kriegen, das könnt ihr euch gar nicht vorstellen.
Das ist wirklich, also, was sie sich bei Microsoft dabei gedacht haben.
Es ist mir vollkommen schleierhaft.
Und es ist, es ist mir teilweise echt ein Rätsel, wie man, warum man dafür entwickelt.
Ey, das ist, also ich zeige euch das jetzt mal.
Sollen wir gehen in den Chat?
Warte mal, ich glaub meinen.
Ich muss mal kurz meinen Vorschau refreshen.
Okay.
Was ich sehe, ist der König, der Highmax geschrieben hat.
Ich glaube nicht, dass das das letzte war, dass er schon wieder, irgendwie, 6 Minuten her.
So.
Sagt mal was.
Ich weiß, dass es für ein Vorschau-Fenster geht.
So, ah ja, genau, jetzt, jetzt, Chat, jetzt geht der Chat wieder.
The boy next door, ja, genau.
Jetzt am, am Gachi-Bessen.
Okay, also ich zeige euch das mal, ey.
Das, das, das haltet ihr im Kopf nicht aus.
Also, das ist so ungefähr, also man.
Die, eh, wir räumen das jetzt auf, das ist wirklich ganz abartig, ne.
Also, das hier ist so ungefähr, was wir das letzte Mal auch hatten.
Bloß, dass es nicht skaliert war, weil das habe ich jetzt auch mittlerweile eingebaut, dass es, dass es hier schön skaliert.
Und, dass es nicht transparent war.
Und ich sage euch Leute, Transparenz unter Windows, ey, sowas undurchsichtiges ist der Wahnsinn.
Also, ähm, erste Mal, wenn man danach sucht, findet man nichts.
Was man findet ist, sind in irgendwelchen, äh, Cheaterstellungsforen, ist kein Witz, ja.
Also, wenn man hier irgendwie danach sucht, äh, wenn man jetzt hier zum Beispiel sucht, keine Ahnung, ähm, äh, Direct to, äh, Direct to the Transparent Overlay.
Wenn man irgendwie solche Dinger sucht, das erste, was man findet, sind irgendwelche Cheatforen, ja.
Weil das natürlich auch für viele Cheats unerlässlich ist.
Und das Schlimme ist, dass Microsoft dazu nichts Gescheites geschrieben hat.
Es gibt 20 Millionen Optionen, die du setzen kannst, hier beim Erstellen vom Fenster zum Beispiel, wo du nicht genau weißt, was der ganze Kram überhaupt macht.
Es ist, es ist, es ist komplett viel.
Achso, ja, das Ziel heute, das Ziel heute kann ich dir zeigen.
Also, das Ziel generell ist, einen schnellen, einen schnellen GIF-Player zu machen für mein Meme-Tool.
Weil, ich zeig dir das mal.
Du draufklickst, hör mal, hör mal, klicken, klicken, zack, das braucht 2, 3 Sekunden oder vielleicht, naja, so 1, 2 Sekunden hier, bis das geladen ist und angezeigt wird.
Aber kleinere GIFs gehen schneller, aber man merkt, man merkt die Verzögerung.
Bei kleinen GIFs geht, hier, hier hängt es schon wieder, weil ich den jetzt erstmal wieder groß machen muss, so.
Aber hier hängt es, man kann also klicken, so.
Und, was wir machen, äh, Moment, was wollte ich jetzt sagen?
Ja, genau, was wir machen, wir basteln einen eigenen GIF-Player, den, den ich anstatt hier meinem WPF-Fenster verwenden kann.
Alles in RAM-Laden macht er ja, wenn du hier nämlich im Hintergrund guckst.
Das Ding braucht, sobald du einen GIF aufmachst, 830 MB, weil er jeglichen Frame irgendwie in voller Auflösung, in voller Farbe, mit allem in RAM lädt, für jedes Bild.
So ein GIF ist dann unglaublich groß, vor allem in diesem komischen WPF-Plugin, was ich verwende und diese komischen WPF-Library, die ich verwende, fürs Anzeigen von GIFs.
Und das ist Müll.
Und, ähm, erstens will ich es schneller haben, ja, und das darf auch gerne ein bisschen weniger RAM verbrauchen.
Deswegen haben wir das letzte Mal angefangen, was eigenes zu basteln, mit, ähm, FFmpeg und, und Direct2D.
Man sieht schon, das braucht jetzt 85 MB, ich hab, wir haben so ein bisschen, so ein paar kleinere Memory-Leaks haben wir.
Hier, ja, ein paar kleinere Memory-Leaks haben wir.
Aber sagen wir mal so, das braucht halt 80 MB, ähm, und es ist gut, ja, und es geht halt mega schnell.
Guck, sobald man sieht, zack, GIF ist da.
Und der muss jetzt die ganze Anwendung noch starten, also das geht schon schneller.
Ähm, und die große Herausforderung, die es jetzt gab, das letzte Mal haben wir das eigentlich ganz gut hingekriegt, das GIF zu animieren.
Das GIF zu animieren ist auch kein Akt, das könnte ich jetzt auch wieder, wieder einfügen.
Da muss ich einfach hier, wie gesagt, wir müssen das alles auf, auf, aufräumen.
Ähm, das ist, überbleibsel von meinem Rumprobieren, äh.
So, und hier lesen wir das GIF, irgendwo lesen wir das GIF, wo lesen wir das GIF?
Packet.
Moment, wo lesen wir das GIF? Da lesen wir das GIF.
Hier lesen wir das GIF ein, also sprich, eigentlich, um jetzt das GIF zu animieren, müsste ich jetzt bloß noch den Kram quasi, ich kann es ja mal kurz zeigen, dass wir jetzt einen Stand haben, wo das GIF auch animiert.
Animiert.
Läuft.
Machen wir hier unten hin, irgendwie so, zack.
Und jetzt machen wir ein Sleep von, keine Ahnung, machen wir 100 Millisekunden, dass es nicht zu schnell läuft.
So, als sollte das GIF, äh, oder auch nicht.
Was auch immer, zumindest ist es nicht, kein, kein großartiger Akt, das GIF zu animieren.
Ähm, ich weiß gar nicht, warum er jetzt, was hat er jetzt für Schmerzen, äh.
Egal, es ist total wir, was ich hier gebaut hab.
Und das Schwierige war wirklich.
Die Transparenz hinzukriegen, also das jetzt zu animieren, das, das kriegen wir heute auch hin.
Also das Ziel ist heute, dass wir nen ordentlichen GIF-Player haben, nicht hier mein, mein hingerotztes Zeug, der schnell funktioniert und animierte GIFs abspielt.
Wie gesagt, das Animieren ist nicht das Problem, das haben wir das letzte Mal schon gemacht.
Da kann man sich einfach den nächsten Frame aus FFmpeg ziehen und gut ist.
Das haben wir auch schon hingebastelt.
Was wirklich schwierig war, und jetzt kommen wir mal wieder zurück zu dem, was ich eigentlich sagen wollte.
Also es ist wirklich schwierig.
Nennst du das mal?
Nen transparentes Windows, äh, Window zu machen, unter, äh, Windows.
Nen transparentes Window, auf dem man malen kann.
Und ich hab nur einen offiziellen Weg von Microsoft gefunden.
Alle anderen waren aus irgendwelchen Cheatforen, die irgendwelche Dinger abusen, die man nicht machen sollte.
Zum Beispiel, was ich ganz witzig fand, was ich rausgekriegt hab, ist, ihr kennt doch dieses Nvidia-Overlay, was ich jetzt aus irgendwelchen Gründen nicht einblenden darf.
Warum darf ich das denn nicht einblenden?
All diese, diese Geforce-Experience, das Ding ist so kaputt.
So, Moment, ich mach's mal an.
Overlay, Overlay, zack.
Ja, besser hier, will kein Account.
So, seht ihr das?
Seht ihr das Nvidia-Overlay?
Wie benutzt du FFmpeg mit C-Sharp?
Mit, äh, einem automatisch generierten Binding, was es auf Github gibt.
Such mal nach, ich zeig's dir gleich.
Seht ihr, seht ihr das Nvidia-Overlay?
Oder seht ihr das im Stream nicht?
Muss man auf meinem Vorschau, Vorschau-Bildschirm gucken.
Ja, also man sieht das.
Man sieht das Nvidia-Overlay.
Ähm, und da hab ich rausgefunden, ich zeig dir mal kurz die FFmpeg-Bindings, die du brauchst.
Das hier brauchst du für FFmpeg von C-Sharp aus.
Den hier.
FFmpeg Autogain von Ruslan B.
Und dann musst du quasi im Prinzip C-Style FFmpeg machen, halt, plus aus C-Sharp raus.
So, und ich hab rausgekriegt in diesen Cheat-Foren, die ich geguckt habe,
was da teilweise für komische Hacks am Werke sind, um nicht erkannt zu werden.
Das ist teilweise ganz witzig.
Und zwar, sie verwenden dieses Nvidia-Overlay, was quasi kein Cheat, keine Cheat-Engine der Welt flaggen wird,
weil es ja das Nvidia-Overlay ist, und das ist ja was Legitimes.
Die hijacken das so ein bisschen, ja.
Also die crappen sich quasi das.
Sie nehmen das Nvidia-Overlay und malen dann dort in das Nvidia-Overlay ihr eigenes Zeug rein.
Das ist, das ist eigentlich eine richtig geile Idee.
Ich mein, so Dinge kann man alles machen, aber wir wollen, wir wollen ja gar nicht wie ein Cheat aussehen,
weil wir sind ja kein Cheat.
Und, ähm, das heißt alles, was ich hier so gefunden habe, in diesen komischen hier,
hier, also, die meisten, ohne Scheiß, die meisten Treffer zu wie man transparente Overlays macht,
sind in diesem Cheat-Forum.
Das sind irgendwie 500 Stück oder so, ja.
Das ist gar nicht, danach kommt Stack-Overflow.
Aber es ist alles, ähm, nicht sonderlich intuitiv.
Das heißt, ich denke mal, und der Sibaro, der nimmt ja die Videos auch wieder auf, ähm,
das ist wahrscheinlich eine der wenigen Anleitungen, mit ne, also, was wir hier, was wir heute im Stream machen,
eine, wenn nicht die einzige, weltweit, die quasi nicht auf irgendwelchem Cheat-Scheiß basiert,
auf offiziellen Lösungen von Microsoft basiert, UND
ein funktionierendes Beispiel hier im Stream hat.
Transparente Fenster, ja.
Und, ähm, ja, gibt es Punktabzug, wenn der Player als Cheat erkannt wird,
dann geht die Anzeige raus an den Cheat-, äh, Anti-Cheat-Entwickler.
Also, mehr als den offiziellen Microsoft-Weg, äh, befolgen können wir nicht tun.
Können wir wirklich nicht machen.
Und der offizielle Microsoft-Weg ist, ähm, also, dass man hier so ein transparentes Fenster kennt,
der Witz ist ja, das Fenster muss nicht nur von der Farbe transparent sein,
sondern man muss auch durchklicken können.
Das Ding wird safe detected.
Ey, ohne Scheiß, ich, ich kann halt nichts dagegen, dagegen machen, ähm,
was, was, was soll ich tun letztendlich, ja?
Wenn die Funktionen, die in Windows eingebaut sind, vollkommen legitim sind,
sogar Microsoft in Anleitung verwendet, von irgendwelchen Anti-Cheat-Tools erkannt werden,
weiß ich auch nicht, tja.
Aber gut, was willst du machen?
Ich mein, die, äh, Cheat-Entwickler können den ganzen gleich, äh,
können den gleichen Kram verwenden.
Und ich hoffe ja mal, dass das Anti-Cheat-Zeug nicht wild flaggt,
sondern quasi schon mal guckt, zu welchem Programm gehört das und sonst was.
Weil ich mein, das Nvidia-Overlay wird ja auch nicht geflaggt.
Lol, Alter.
So, und, ja, der einzige Weg, den ich gefunden habe, wie man das offiziell macht,
ist ein Artikel von Microsoft.
Den muss ich jetzt mal finden.
Das war irgendwie, ähm,
wofür machst du das?
Zum GIFs-Anzeigen als Overlay.
Zum Beispiel, guck mal, ähm,
hier kann ich GIFs als Overlay anzeigen lassen.
Das funktioniert auch gut.
Das ist auf, das ist auf WPF-Basis.
Das, das klappt ganz gut.
Das Problem ist nur, dass, ähm, diese Library für WPF ziemlich lahm ist.
Bei großen GIFs wie dem hier zum Beispiel, guck mal, klickste,
und jetzt ist es erst da.
So, deswegen wollte ich selbst ein Overlay basteln, was, ähm, GIFs anzeigen kann.
Und es geht auch schon.
Guck mal da, zack, GIF da.
Und rendert so ungefähr mit 7000 FPS.
Wenn man es mal, wenn man es sich ein bisschen ein, einlaufen lässt, ja, so irgendwas.
Wenn man es sich ein bisschen einlaufen lässt, ja.
Wenn man es ein bisschen ein, wenn es ein bisschen gelaufen ist, dann hat es eben 7000 FPS.
Aber, ähm, es ist schon, es ist schon deutlich schneller.
Es braucht viel, viel weniger RAM.
Das andere braucht irgendwie 800 MB RAM für so ein publisches GIF.
Und das hier ist mit komplettem Fenster und allem irgendwie bei 80.
Ja, dann sollen sie mich halt als suspicious flaggen.
Wenn das Leute, wenn das, wenn das, äh, ganz viele verwenden.
Also viele, ich weiß nicht, was für die viele ist.
Irgendwie keine Ahnung, 30, 40 Leute.
Ja, und irgendwann werden sie ja mal nachgucken, um was es da eigentlich geht.
Ansonsten sind sie auch, ansonsten sind die Anti-Cheat-Hersteller auch nicht besser als irgendwelche Virenprogrammierer.
Wenn sie einfach blind da irgendwelche Sachen machen.
Vor allem, wenn es halt viele Leute haben.
Und dann muss man halt auch schon mal einfach gucken, was dahinter steckt.
Ich meine, der Source Code ist offen auf GitHub.
Kann sich jeder angucken.
So, und der einzige Weg, und jetzt, jetzt, pass auf, jetzt Leute, jetzt wird es übelst abenteuerlich.
Den einzigen Weg, den ich gefunden habe, bei Microsoft, wie man das macht, ist...
Ha, ich, wie hießen diese Artikel?
Ähm, da war irgendwas von 2014.
Ich muss euch den mal zeigen, weil der Artikel selbst ist schon wieder übelst abgedreht, ey.
Ähm, kann man das irgendwie nicht?
Das kann man doch auf Seiten einstellen.
Side.
So, und ich hab...
Das sind alle Artikel.
Der ist in C++.
Ich hab den so ein bisschen quasi für SharpDX übersetzt.
Dass der damit funktioniert.
Okay, Alter, wie hieß denn dieser komische Artikel?
Ah, da kommen wir der Sache doch schon näher.
Kann man nicht noch irgendwie nach Datum 2014 oder so suchen?
Okay, dann suchen wir mal nach Microsoft.
Das da.
Das ist es, glaube ich.
Ja, das ist es.
Das ist der einzige Artikel.
Das ist der einzige Artikel von Microsoft, den ich zu dem Thema gefunden habe.
Aber nicht auf Deutsch, sondern auf...
Wo stellt man hier die Sprache um?
Sprache...
Sprache?
Ich will das nicht auf Deutsch.
Wo stellt man...
Ah, da unten.
English United States.
Okay.
Gut.
So, und das ist der einzige Artikel, den ich gefunden habe.
Und das ist schon wieder...
Und das ist wohlgemerkt von 2014.
Und so macht's auch keine Cheat...
Kein Cheat, den ich bisher irgendwie da in diesem Anlass...
Ich hab's schon mal...
Ich hab's schon mal...
Ich hab's schon mal...
Ich hab's schon mal...
Ich hab's schon mal...
Ich hab's schon mal...
Ich hab's schon mal...
Ich hab's schon mal...
Keine Cheat...
Kein Cheat, den ich bisher irgendwie da in diesem anderen Forum gesehen hab, macht's
nach dem offiziellen Microsoft-Weg.
Die machen alle so krumme Dinge, also irgendwie Nvidia-Overlay-Hijacken, irgendwelche...
Irgendwelche Window...
Window-Manager-Geschichten...
Abgreifen und so.
Aber das ist der einzige Weg von Microsoft, den ich gefunden habe, ein transparentes Windows
zu machen, wo man schnell reinzeichnen kann.
Okay.
Ja, stimmt, Lesezeit ist keine schlechte Idee.
So, und jetzt nur mal so zu erklären, also der Typ labert halt hier ein bisschen rum,
so, und der Artikel ist halt in C, äh, C, C, C++, was ist das, ich würde sagen, das
ist eher C, ne, da ist noch nicht mal was mit C++, also die Beispiele, die sie da haben,
sind in C, und ich hab das versucht so ungefähr nachzubauen, was der Dude da treibt, ja, und
ey, es ist wir.
Es ist, es ist mega wir.
Es ist mega wir.
Also die Essenz aus dem Ganzen, ich zeig's euch mal, gleich bei mir im Code, ähm, stimmt
das in LAMP, das, das müssen C++ sein, ähm, so, und da zeigt er hier, bla bla bla, Window
erstellen, bla, transparentes Window erstellen, ja, also sprich, das ist, Microsoft sagt selbst,
so funktioniert's, also, ja, gut, kann sich nicht davor schützen, das ist irgendein Cheat-,
Anti-Cheat-Typ-Flag.
So, hier, guckt, transparentes Window, bla bla bla bla, DirectX, bla bla bla bla bla, ganz
viel bla.
So, Scheiß hab ich ausprobiert und in C Sharp, äh, SharpDX zu übersetzt, ja, also, so, bla
bla bla, dann steht hier zwischendrin irgendwas von der Direct Composition API, wenn du nach
Direct Composition suchst, findst du ein Video von Microsoft im Jahr 2013, also das ist wirklich
der Abgrund, der Abgrund, wirklich, der komplette Abgrund, den ich, in den du hier schaust,
von Windows wieder, ähm, so, und am Ende zeigt er dir dann halt, wie geil er ist, er hat ein
Fenster am Start mit nem grünen Kreis drauf.
Und letztendlich ist es ja das, was wir auch wollen.
Und das Einzige, was wir danach noch machen müssen, ist den Fensterrahmen weg.
War's aber kein Ding.
Wichtig ist erstmal, dass man ein trans-, dass man ein transparentes Fenster bekommt
und das man reinmalen kann.
So, und jetzt zeige ich euch mal, wie das geht, weil wir wollen uns ja nicht diesen
komischen Artikel von dem Typ angucken, sondern wie ich das gemacht hab.
Und, Leute, es ist Magic pur, es ist wirklich Magic pur.
Ähm, ich kann's euch, ich kann, wie gesagt, ich kann's euch gar nicht erklären, ich kann
euch erklären, was ich gemacht hab, aber nicht, warum das an manchen Stellen so aussieht.
Ähm, fangen wir erstmal oben an.
Ne, wir fangen, wir fangen beim, beim interessanten Teil an.
Also, das erste, was ich mach, den, wir räumen das jetzt gleich auf, das ist auch Ziel dieses
Streams, ne ordentliche Giftplayer-Klasse zu machen und meine ganzen, ganzen Scheiße
rauszuschmeißen.
Das Ding hat jetzt irgendwie 400 Zeilencode, danach hat's wahrscheinlich noch 150, wenn
wir fertig sind.
Ja, und das hier, diese Funktion ist das auch, was die ganzen Cheat-Tools immer verwenden.
Ich hab auch erst probiert, das damit hinzukriegen, funktioniert, aber, und jetzt kommt der Hit,
es ist langsamer als meine Lösung.
Layered Window mit, ähm, diesem, dieser Geschichte ist langsamer als das, was ich
gebastelt hab, also ist die offizielle Microsoft-Lösung wahrscheinlich gar nicht mehr so schlecht.
Aber wahrscheinlich nicht so flexibel, was, äh, natürlich wieder für, äh, Cheat-Geschichten
schlecht ist.
Ja, also hier kannst du halt auch wirklich nur dein eigenes Fenster malen, alles andere
kannst du vergessen.
Was halt bei den Cheat-Dingern nicht so ist, ne.
Aber wir wollen ja auch nicht cheaten, das ist, wie gesagt, die einzige offizielle Microsoft-Lösung.
So, ähm.
Also, wo geht's denn los?
Also, als erstes müssen wir irgendwie DirectX-Gedöns erstellen.
Äh, das ist für mich zum größten Teil Magic, was diese Optionen hier machen, allerdings
braucht man diese Optionen, sonst funktioniert's nicht.
Und ganz wichtig, auch, auch wirklich sehr praktischer Tipp, wenn ihr mal DirectX-Zeug
macht, wusste ich bis vor kurzem auch nicht, das Ding schmeißt laufend, wenn es sich an
irgendwas stört, Fehler.
Und die Fehler sind halt überhaupt nicht aussagegemäß.
Da steht dann einfach nur DirectX-Error oder sowas, da.
Da kann man, ähm, da kann man auch, Alter, wo war das denn jetzt versteckt?
Ich glaub hier irgendwo.
Da kann man hier in den Projekt-Settings unter Debug, kann man einstellen, Enable Native
Code Debugging.
Wenn man das eingestellt hat, und an sein DirectX-Device hier die Option Debug dran
steckt.
Dann.
Das geht jetzt zwar ein bisschen langsamer, bis man Debug wieder rausnimmt, aber dann
wirft DirectX sinnvolle, und überraschend sinnvolle, hab ich mich selbst gewundert,
Fehlermeldungen, allerdings nicht auf die Konsole, sondern hier in dieses Output-Window.
Also wenn ihr mal irgendwas mit DirectX oder irgendwelchen Windows-API-Geschiss macht,
macht Native Code Debugging an und schaltet die Debug-Geschichten hier für euer DirectX-Device
ein, dann bekommt ihr zum größten Teil recht sinnvolle Fehlermeldungen.
Und so hab ich mich auch hier so ein bisschen ran getastet.
Zum Beispiel, ich hatte keine Ahnung, dass ich Flipdiscard verwenden muss für meine Swapchain
anstatt Discard.
Weil, ich weiß es nicht, weil nur das das Supportete ist für dieses Szenario.
Weil, ich weiß es nicht, aber Microsoft sagt das in der Fehlermeldung.
So.
Ähm.
Ähm.
Achso, den Link, den Link kann ich dir geben, ja.
Du willst bestimmt jetzt dein Cheat updaten, gibst du?
So.
Wo lernt man die Grundlagen von C?
Ja.
Also, YouTube-Videos oder irgendwelche Bücher oder sonst was.
Wobei ich sagen würde, ich würde, also wenn du schon was programmieren kannst und was
Low-Level-mäßiges machen willst, ist nicht verkehrt, mit sich das mal anzugucken.
Allerdings muss man sagen, einsteigen würde ich mit C auf keinen Fall.
Äh, Sibaro, ich hab probiert Quality-Settings zu kriegen, hat nicht funktioniert.
So.
Okay.
Also.
Fangen wir mal an.
Die Magic kommt später.
Erstmal zur Erklärung, was am Anfang passiert.
Das ist relativ Standard-DirectX-Gedöns.
Man erst, man erstellt eine Swap-Chain.
Eine Swap-Chain, das ist, DirectX hat, also ich muss ja sagen, ich persönlich finde die
OpenGL-Sachen ein bisschen angenehmer benannt, vor allem wenn man sowas wie SDL oder irgendwie
OpenTK oder sowas verwendet, das ist irgendwie ein bisschen griffiger, finde ich, als vieles
DirectX-Zeug.
Wobei, das eigentlich nimmt sich nix.
Dafür ist OpenGL viel, ähm, nerviger, weil man viel mehr selbst machen muss.
Ähm.
Naja.
Also erstens muss man eine Swap-Chain-Description erstellen, damit man eine Swap-Chain erstellen
kann.
Ähm.
Eine Swap-Chain ist im Prinzip ne, im Prinzip mehrere Buffer, die du, die du austauschen
kannst.
Das ist eigentlich alles, was eine Swap-Chain ist, im Großen und Ganzen, ne.
Du hast, du hast einen Buffer, da wird gerade, also das, was da drin ist, wird angezeigt
und du hast in der Regel noch einen zweiten Buffer.
Da schreibst du dein Zeug rein und wenn du fertig bist, dein, dein neues Bild reinzuschreiben,
dann swappst du das Ganze.
Also sprich, den Buffer, den du gerade anzeigst, den schmeißt du weg und zeigst deinen Buffer
an, in den du gerade reingeschrieben hast und swappst halt, ne.
Deswegen musst du auch hier einstellen, der Swap-Effekt.
Und in dem Fall muss, muss man, warum auch immer, weil Microsoft, muss man FlipDiscard
verwenden.
Natürlich auch kein Hilfetext, warum.
Es gibt noch zig andere Varianten.
Das ist der Effekt.
Wenn man diese beiden Buffers switcht.
Also sprich, von dem Buffer, wo das angezeigte Bild ist, wenn ich dann switche zu dem Buffer,
wo ich gerade reingerendert habe, ne.
Dann, aber in dem Fall muss ich FlipDiscard oder FlipSequential nehmen, weil das Microsoft
gerne hätte.
Ähm, unterstützt wird aktuell generell wohl, so wie es aussieht, fast nur noch Alpha Mode
Premultiplied.
Da habe ich, ey, ohne Scheiß, da habe ich Stunden gebraucht für, bis ich gecheckt habe,
aber das zeige ich euch gleich noch, zeige ich euch gleich noch, wie ich mein GIF transparent
bekomme.
Also es gibt prinzipiell zwei verschiedene Alpha Modi, die, äh, DirectX, äh, Direct2D
und DirectX unterstützt.
Das ist einmal Premultiplied und Straight.
Der Unterschied ist im Prinzip relativ subtil auf den ersten Blick, weil, ähm, die Anzahl
der Bytes sind die gleichen.
Also ein Pixel, ja, ein Pixel ist zum, besteht zum Beispiel, also wenn man ein, ein, keine
Ahnung, rot, ein roter Pixel, ja.
Ein roter Pixel sind erstmal drei Bytes.
Sind erstmal drei Bytes.
Und zwar die Bytes 2, 5, 5, 0, 0.
Also hier, ne.
Erstes Byte 255, zweites Byte 0, drittes Byte 0.
So, das ist erstmal ein roter Pixel.
Jetzt gibt es da zusätzlich noch ein viertes Byte, der sagt, ähm, wie transparent dieser
Pixel ist.
Deswegen ist das normale, ist das sowas wie RGB, das hat ja jeder schon mal gehört.
Und, ähm, RGB, das ist dann quasi zwei, zwei Dinger.
Übrigens, falls ich irgendwelche Host-Donations oder sonst was vergesse, spammt mich mal voll,
weil ich hab wieder vergessen, meine Alert-Dinger anzumachen.
So, und wenn man jetzt, das sind Alpha, äh, also Alpha-Channel-Informationen, sprich,
wie transparent der Pixel ist.
0 ist transparent, 255 ist komplett nicht transparent.
Also wenn ich sowas mache wie 100, dann ist das so halb transparent.
Das muss natürlich das jeweilige, äh, Backend unterstützen, aber das ist eigentlich Standard,
Leute.
Deswegen nennt sich das nicht mehr RGB, sondern RGBA, also sprich, äh, Rot, Grün, äh, Blau,
Transparenz.
So.
Und intern, um die ganze Sache noch ein bisschen komplizierter zu machen, intern arbeitet
DirectX, beziehungsweise Direct 3D, äh, Direct 2D in dem Fall nicht mit RGBA, sondern mit
BGRA, weil, wahrscheinlich, weil's besser für das, äh, Speicher-Layout von Grafikkarten
ist oder so.
Ich weiß es nicht genau.
Ähm, zumindest intern verwenden sie das da.
Aber das macht im Prinzip keinen großen Unterschied.
Das ist ja im Prinzip einfach nur ein paar Sachen vertauscht.
Alpha-Byte ist immer das letzte.
So.
Und jetzt wollte ich ja erklären, was der Unterschied ist zwischen Pre-Multiply, und
das braucht ihr immer, wenn ihr irgendwelche Grafikgeschichten macht, müsst ihr euch das
merken.
Ähm, der...
Wie ist die Lage?
Ja, sehr verwirrend ist die Lage, ey.
Windows, Windows-Zeugs wieder am Start, äh.
Also der Unterschied ist, den Hilfetext hier könnt ihr, könnt ihr erstmal, könnt ihr
erstmal vergessen.
Also, Pre-Multiplied, also fangen wir mal an.
Straight, ja, jetzt, jetzt, äh, keine Feminism-Chokes oder sowas.
Also Straight bedeutet in dem Fall, die Pixel hier vorne stellen ganz klassisch, äh, die
sind rot, grün, blau da.
Und nur der letzte bedeutet, steht für den, für die, für die Transparenz von dem kompletten
Pixel.
So.
Pre-Multiplied bedeutet, die Transparenz ist quasi hier vorne schon mit eingerechnet.
Ganz ehrlich, Vor- und Nachteile habe ich nicht so wirklich gecheckt.
Also, ich weiß, sowieso, im Hinterkopf ist mir schon lange klar, dass es das gibt, aber
ich hatte damit noch nie Probleme.
Ähm, deswegen musste ich mir das heute erstmal angucken, so, was eigentlich auch genau der
Unterschied ist.
Ähm, zumindest Pre-Multiplied bedeutet genau das, was da steht, nämlich, dass der Alpha-Wert
schon eingerechnet ist in das normale RGB.
Das bedeutet Pre-Multiplied.
So.
Und nachdem, und ich muss jetzt ein bisschen ausholen, sonst versteht man nämlich das,
das eigentliche Problem bei der ganzen Sache gar nicht.
Nachdem jetzt quasi meine komplette Geschichte, die ich hier initialisiere am Anfang, zwingend,
zwingend dieses Format braucht für Pixel, also sprich Blau, Grün, Rot und Alpha-Channel
und sein Alpha-Channel Pre-Multiplied haben will, also es geht einfach davon aus, das
macht da keine Magic mehr oder so.
Also sprich, wenn, wenn der Pixel Pre-Multiplied nicht transparent ist, dann wird er einfach
nicht transparent angezeigt.
Da kann mein Alpha-Channel noch so sehr auf Null stehen, das juckt den dann überhaupt
nicht.
Ist dem vollkommen egal.
Ähm.
Und das heißt, ich kann meine normalen Bilder, also sprich die einzelnen Frames vom GIF,
nicht so einfach rendern, weil die sind nicht durchsichtig.
Und ihr seht ja, wenn man es hier anzeigt, hier sind sie durchsichtig.
Normalerweise hat er das immer weiß gerendert hier im Hintergrund, weil es nicht Pre-Multiplied
war.
So.
Ähm.
Einmal nochmal einen Schritt zurück.
Wir müssen ja irgendwie diesen Inhalt, bevor wir Probleme überhaupt mit Transparenz oder
sonstigen Dingern haben, wir müssen ja erstmal den ganzen Kram überhaupt in unser transparentes
Fenster reinkriegen.
Und jetzt, jetzt beginnt die Magic.
Also, wir erstellen hier mal unsere Swap Chain Description, habe ich ja gerade erklärt,
was die einzelnen Optionen machen.
Ähm.
Der Rest ist nicht so wichtig.
Höhe, Breite noch, wie das Fenster halt ist.
Dann erstelle ich das DirectX Device.
Muss ich sagen, ich nehme auch nochmal BGHA Support, das braucht man für Direct2D.
Äh.
Wir wollen plus das neueste DirectX haben, weil wir halt krasse Checker haben.
Ähm.
Krase Checker sind und nur das neueste verwenden.
Geht wahrscheinlich mit älteren Sachen ganz genauso gut.
Ähm.
So.
Dann speichern wir uns das hier in unserer Klasse, das DirectX Device.
Dann kommt, jetzt kommt Magic.
Jetzt kommt übelste Magic.
Ich habe keine Ahnung, warum man das genau machen muss.
Jetzt braucht man irgendwie so ein XDX, DXGE Device.
Danach muss man sich eine Factory erstellen von diesem DXGE Device.
Ihr wisst, was ich meine.
Äh.
In diesem DXGE Device.
Danach kann ich mal eine Swap Chain erstellen.
Das ist das, was ich vorhin erklärt habe, wo du deine Buffer switchen kannst mit.
Da braucht die Factory, die braucht das DXGE Device und die Description, dass sie weiß, was sie für Settings haben soll.
So.
Und jetzt.
Ich habe schon die Warnung hier reingeschrieben.
Jetzt kommt komplette Magic.
Weil.
Aktuell ist es so, ich habe ein Fenster erstellt, das ist transparent und hat keinen Hintergrund.
Das ist.
Ich habe es zuhause gemacht, wie der, wie der, wie der Dude hier im Artikel.
Ne.
Ich habe ein Fenster erstellt, was keinen Hintergrund hat.
Also kein.
Nein.
Was keine.
Ähm.
Was kein Bitmap quasi reserviert hat im Speicher von Windows, wo man überhaupt Content reinmalen könnte.
Also sprich, mit Windows-Bordmitteln kann man in dieses Fenster nicht zeichnen, weil es keinen Buffer hat.
Gibt es nicht.
Ja.
Also irgendwelche GDI Dinger oder so von früher.
Das geht da nicht.
Das geht direkt.
Haha.
Nice.
Ähm.
Warum entwickelst du eigentlich nicht auf Linux?
Weil das ähm.
Ziemlich Windows-Only hier ist, was ich gerade mache.
Deswegen mache ich es nicht unter, unter Linux.
Weil das ist halt, gibt es halt unter Linux nicht.
Naja.
Zumindest.
Wo bin ich denn jetzt stehen geblieben?
Genau.
Absolute Magic.
Wie gesagt.
Das Fenster.
Das, auf das kann man nicht malen.
Auf dieses Fenster.
Mit.
Das ist genau das gleiche, wie der Typ hier im Artikel macht.
Bloß, dass ich bei mir auch den Rahmen aufmache.
Bloß, dass ich bei mir auch den Rahmen ausgeblendet habe.
Ähm.
So.
Mit.
Ja, mit Qt könntest du das machen.
Aber ich.
Bringt mir in dem Fall auch nichts.
Weil ähm.
Das andere ist auch Windows-Only.
Das ist vollkommen wurscht.
Ja.
Ähm.
Und das mit Qt ist gar nicht so einfach.
Qt ist ja erstmal standardmäßig.
Äh.
Also.
Also du machst mit QML ist es ja auch nicht großartig beschleunigt.
Das heißt, da müsste es mit OpenGL irgendwas passen.
Kein Nerv.
Wir.
Wir sind eh relativ abhängig von Windows.
Und.
Dementsprechend.
Bleibt.
Ja.
Ja.
Ja.
Ja.
Ja.
In gewisser Weise noch nichts.
Okay.
Mache ich das nun mit reuse.
Wie Bloody Spirit es ist noch mehr Irunos.
Na also im Prinzip ist das das gleiche Fenster wie der Typ im Artikel.
Ähm.
So.
Und bloß, dass ich den Rahmen ausgeblendet habe.
Okay.
Und jetzt kommt.
Absolute Magic.
Ähm.
Nachdem wir ja wie ich gerade erklärt habe hier nichts rein malen können auf klassische
Art und weise in dieses Fenster.
Müssen wir.
Dem.
Was hab.
Wie heißt das eigentlich?
Korrekt.
DWM.
Desktop Window Manager wahrscheinlich.
unfeinlich, Dynamic Window Manager, das ist das Linux-Ding, Windows, für was steht denn das hier überhaupt?
Der Desktop Window Manager, also sprich, das ist der Part von Windows, der dafür zuständig ist,
so Sachen wie überlappende Fenster zu machen, halbtransparente, was ist denn ein halbtransparentes Fenster,
gibt es sowas unter Windows 10 noch standardmäßig, kann man auf jeden Fall, auf jeden Fall machen, ja,
also sprich, dass dieses Fenster über diesem Fenster ist oder das, was haben wir denn hier, halbtransparentes,
gibt es hier nichts noch, was halbtransparentes zum zeigen, zumindest, ich starte einfach jetzt mal mein Programm,
dass hier dieses Fenster da drüber ist und dieses Fenster dafür, dafür ist dieser Desktop Window Manager zuständig.
Das heißt, nachdem unser Fenster jetzt kein Buffer hat, in dem wir malen können,
müssen wir das Ganze quasi mit dem Desktop Window Manager in das Fenster malen.
Das ist das, was der Typ hier in seiner Anleitung beschreibt, wie das Ganze funktioniert.
Ach stimmt, der Calculator ist transparent, ja, richtig, oder auch, ich gebe dir aber recht,
der sollte eigentlich transparent sein, ich bilde mir auch an, dass der transparent ist.
Ach, ne, weißt du was, warum der nicht transparent ist, weil ich Transparenz abgeschaltet habe, lull.
Ich habe Transparenz abgeschaltet, weil mir Transparenz aufgekriegt gegangen ist, stimmt.
Der ist minimal transparent, ich glaube nicht, dass der transparent ist, der ist nicht transparent.
Ich habe das abgeschaltet.
Aber guckt mal, hier unten die Taskleiste ist ein bisschen transparent, seht ihr es?
Da, ne, das macht alles der Desktop Window Manager.
So, und mit dem müssen wir jetzt, mit Direct Composition, müssen wir in unser Fenster malen.
Wohlgemerkt, das hier ist immer noch ein transparentes Fenster.
So, und ich habe keine Ahnung, was diese nächsten paar Dinger machen, aber sie funktionieren.
Die habe ich mir mehr oder weniger eins zu eins hier aus diesem C++ geschwuppert,
äh, ja, doch, aus diesem C++.
Aus dem Artikel übersetzt nach SharpDX.
So.
Und was da jetzt passiert, ist folgendes.
Als erstes muss ich ein Direct Composition Device erstellen, aus meinem DXGE Device.
Warum, weiß nur Microsoft, ich habe keine Ahnung, muss man aber machen.
Als nächstes, und ey, das ist die übelste Magic, also wirklich, ich weiß nicht, was da passiert.
Als nächstes muss ich ein Target erstellen, was ein Direct Composition Target erstellt.
Als nächstes muss ich ein Target erstellen, ähm, was ist denn jetzt mit dem, irgendwie höre ich mich anders an, oder?
Ja, ich glaube, wartet mal, hatte ich gerade einen Wackelkontakt oder so?
Ja, jetzt geht es wieder.
Vielleicht ist mein, vielleicht ist mein Gehirn auch einfach nur kaputt langsam.
Zumindest muss ich jetzt ein Direct Composition Target erstellen, von meinem Fenster.
Also von dem transparenten Fenster, den ihr nicht seht.
Das ist das, was man jetzt hier an der Stelle nicht sieht.
Ähm, ja.
Davon muss ich ein Direct Composition Target erstellen, mit Handle von meiner Windows Form.
Und dem muss ich das Direct Composition Device übergeben.
Danach muss ich, es wird immer abgedreht, ohne Scheiß, ich weiß wirklich nicht, was hier passiert, aber es funktioniert.
Danach muss ich ein Direct Composition Visual erstellen, wo ich dann das Composition Device reinstecke, weil das es wohl irgendwie braucht.
Und danach muss ich sagen, dieses Visual.
Kriegt den Content von meiner Swap Chain.
Dann muss ich sagen, das Root Element ist dann das neue Visual.
Und dann muss ich das Ganze committen auf meinem Composition Device.
Und dann wird alles über den Desktop Window Manager, was ich hier in meiner normalen DirectX Swap Chain rendere, in mein Fenster beim Compositionen reingerendert.
So.
Alter, ja.
Was auch immer.
Ist komplett hier.
Also es ist absolut.
Für den Arsch, ja.
Dass das überhaupt so ein Riesenakt ist.
Aber zumindest ist es der einzige Artikel von Microsoft, den ich gefunden habe, der sich mit diesem Thema beschäftigt.
Und die sagen, so geht's.
Und.
Es geht tatsächlich.
Und es ist schnell.
Es ist wirklich schnell.
Es ist schneller, als dieses ganze Zeug, was man da zum Beispiel in irgendwelchen Cheat Foren findet, die auch Overlays machen wollen.
Das ist so um den Faktor.
20% ungefähr schneller.
Also es ist schneller als Layered Windows mit Client Area gedöhnt und so.
Es ist wirklich schnell.
Und das sieht man ja auch.
Windows ist oft schwarze Magie.
Es ist wirklich komplett schwarze Magie.
Aber es funktioniert an der Stelle.
Und ich bin wirklich froh, dass der ganze Camp funktioniert, weil es ist schnell.
Es ist transparent und es funktioniert.
Man sieht hier.
Guck, ich kann hier durchklicken.
Eigentlich ist es hier das Fenster.
Ist hier das Fenster drumherum.
Ich kann hier durchklicken.
Ohne Probleme hier.
Das einzige, was verdeckt sind die Visual Studio Menüs.
Warum auch immer.
Aber damit kann ich leben.
Immerhin gibt es einen Artikel von Microsoft, das ist richtig.
Immerhin.
Immerhin.
So.
Ja, und als nächstes zeige ich euch, was man machen muss, um das Bild transparent zu kriegen.
Weil wer gedacht hätte, damit ist die größte Hürde genommen, der hat sich wirklich getäuscht.
Aber vorher, Leute, muss ich mal kurz aufs Klo.
Ich mach mal mal einen Text hier.
Afg Klo.
So, ich bin gleich wieder da.
So, da bin ich wieder.
Weiß jemand, wann es losgeht?
Also, man beachte einfach hier da oben diese Überschrift.
Da sieht man, was gerade war.
Oder was da schon losgegangen ist.
So.
Okay.
Weiter geht's.
Ähm, Körbi aus.
Chills der Psoan.
Easy.
Progress.
So.
Also, wo sind wir stehen geblieben?
Genau.
Bei schwarzer Windows-Magie.
Schwarze Windows-Magie hab ich jetzt, äh, genug mich drüber ausgelassen.
Bob Ross können wir auch noch hinzufügen.
Gut.
Jetzt hab ich euch erklärt, wie man es schafft, quasi sein DirectX-Zeug in sein Window zu rendern.
Das ist ja quasi das, was hier beschrieben ist.
Dazu gibt es immerhin noch einen Artikel.
Zu dem anderen, was ich euch jetzt zeige, wie ich das Bild überhaupt transparent gekriegt hab, gibt's kein Artikel.
Aber ich vermute mal, jeder, der sowas öfters macht.
Und dem wird's wahrscheinlich halbwegs klar sein, wo das Problem gewesen ist.
In der Pause des 3DS-Unboxes mit dem Friseur.
Oh, das war noch Zeit.
Na, das war noch, das ist schon ewig her.
Das war ja 2011 oder so.
Ach, Pogers.
Okay, weiter geht's.
So, und jetzt kommt der nächste Knackpunkt.
Das Bild, was wir von unserem animierten GIF auslesen, also aktuell ist es nur das erste Bild, aber trifft für alle weiteren Bilder natürlich auch zu.
Das hat einen Alpha-Channel.
Also sprich, das hat eine Anzeige, äh, das, das hat transparente Farbe, hier, ne?
Außen drumherum sieht man ja, weil das Bild ist transparent, aber das Ding wurde die ganze Zeit nicht transparent gerendert.
Bis ich dann auf die glorreiche Idee gekommen bin, mir mal zu überlegen, warum das Ganze nicht funktioniert.
Ähm, erst mal hab ich wild gesucht, Google und sonst was, so, wie malt man ordentlich Bilder in Direct2D?
Aber, ähm.
Da gibt's zwar Anleitungen zu, aber so wirklich eine Beschreibung, wie ich transparente Bilder male, gibt's irgendwie nicht.
Und das liegt einfach daran, dass Bilder, die den korrekten Alpha-Channel haben, einfach standardmäßig transparent sind.
Problem ist bloß, und deswegen, jetzt nochmal zurückzukommen auf diese Geschichte hier, Problem ist nur, dass natürlich mein GIF, also der Frame von, äh, der erste Frame von diesem GIF, also das erste Bild von der GIF-Animation, ähm, das ist zwar im richtigen Farbformat,
das sieht man ja auch, weil die Farben sind richtig, also sprich, das ist zwar im Format, äh, BGRA, allerdings, es ist Alpha-Mode quasi straight und nicht pre-multiplied.
Und deswegen hat ich die ganze Zeit hier, wo ich, jetzt hab ich mich kaputt gesucht, war der Hintergrund weiß und nicht transparent.
Bis ich dann auf die glorreiche Idee gekommen bin, ich muss das Ganze einfach multiplien und dann geht's.
Und wie man das macht, zeige ich euch jetzt mal schnell.
Und danach fangen wir an, neue Sachen zu basteln, beziehungsweise das hier aufzuräumen und unser FFM-Pack-Zeug, Threadsicher, in der eigenen Klasse zu verpacken.
So, also jetzt zeige ich euch, wie man das Ganze macht.
Hier ist ganz viel Geschiss drin, was man eigentlich gar nicht mehr braucht.
Ich hab übrigens meinen komischen FPS-Counter, hab ich weggeschmissen, wir machen das FPS hier in der, in der Render-Loop drinne.
Ähm, das ist im Prinzip noch das gleiche hässliche Kram vom letzten Mal, nix Neues dazugekommen.
Äh, FFM-Pack, bla, GIF einlesen, äh, weiter.
Weiteres Rennen hab ich übersprungen, wir lesen, lesen bloß den ersten, wir lesen bloß das erste Bild ein.
Dann hab ich hier noch irgendwas, das brauchen wir gar nicht mehr, oder?
Loll.
Also, wie gesagt, der Code ist jetzt nicht mehr 400 Zeilen lang, der ist danach wahrscheinlich noch 150 oder so.
Ähm, den Scheiß können wir auch rausmachen, da wollte ich gucken, ob das auch im richtigen Farbformat ist.
Brander, gibt's da noch? Der Brander, der Bitmap-Brander, da brauchen wir auch alles gar nicht mehr eigentlich.
Ähm, ist eigentlich komplett.
Overrated, den können wir schon mal löschen.
Der Brander.
Der Name ist so geil, ey, der ist mir nichts eingefallen, der Brander, der Brander-Renderer.
Okay, und jetzt kommt der Knackpunkt, wie kriegt man das Bild von, ähm, straight zu pre-multiplied.
Und da gibt es was schönes, also entweder macht man das von Hand, das ist, äh, auch kein Ding.
Da muss man halt jeden Pixel mal dem Alpha-Value nehmen, durch 205.
Dann hat man das Ganze pre-multiplied.
Aber, da gibt es schon was Fertiges in DirectX, und zwar gibt es Effects.
Und ein Effect ist pre-multiply.
Und pre-multiply funktioniert relativ einfach, legt man als Effect an, und als Input sagt man einfach hier, dieses Bitmap.
Und dann macht er das für einen, da wandelt er quasi den Straight-Alpha-Channel in ein pre-multiplied.
Über alle Bytes von jeweils.
Und dann schaltet er den Pixel um.
Und danach habe ich noch was gemacht.
Danach skaliere ich das Bild noch, ähm, hoch auf die jeweilige Fensterbreite.
Mit dem richtigen Seitenverhältnis.
Das ist gar nicht so kompliziert.
Das ist, hier, hier kriege ich raus, Scale 1, Scale 2, warum heißt das so?
Weil, man weiß das nicht genau.
Die Dinger können wir dann auch mal ordentlich nennen.
Nennen wir mal, nennen wir, nennen wir das jetzt schon.
Also, das ist der Effekt für die Transparenz.
Und das hier.
Das hier ist der Scale-Effekt.
So, und ich gehe mal davon aus, dass er das halt ziemlich effizient in Hardware auf der Grafikkarte macht.
Hier unten habe ich nochmal Scales.
Die brauche ich aber wahrscheinlich nicht mehr.
So, ähm, und hier passiert jetzt das, was ich euch eben erklärt habe mit dem Bild.
Der schreibt das, äh, Alpha, den Alpha-Channel um, von Straight zu pre-multiplied.
Und skaliert das Ganze auf die, äh, also in der passenden, ähm, passenden Seitenverhältnis auf das Fenster hoch.
Das hat auch ewig gedauert, bis ich das rausgekriegt habe letztendlich.
Das steht in keinem Guide und in sonst nichts drinnen.
Ähm, nirgendwo.
Kannst, kannst du klicken.
Aber es ist im Prinzip ganz logisch, wenn man sich das überlegt.
Ich habe nämlich die ganze Zeit versucht, sowas hier zu machen.
Ich wollte nämlich sagen, alter, mein Bitmap ist nicht pre-multiplied.
Und wenn man das probiert, dann crasht das Ganze, wie man hier sieht.
Er macht nichts im Endeffekt.
Weil, eben in meiner Swap-Chain gar nichts passiert.
In der Swap-Chain gar kein Straight erlaubt ist.
Und ich habe wirklich ewig rumprobiert, bis ich dann mal so den Geistesblitz irgendwo hatte.
Ey, wandle doch einfach mal dein Straight in pre-multiplied um.
Und seitdem funktioniert das Ganze.
Und wird auch noch schön skaliert.
Und ist dementsprechend, weil es wahrscheinlich auf der GPU läuft, auch relativ zackig.
Ne?
So.
Und dann kommt im Prinzip das, was wir das letzte Mal auch gemacht haben.
Wir, ähm, das ist, das ist übrigens ganz wichtig, wenn man transparente Fenster malen will.
Dann, ähm, muss man hier sagen.
Äh, man cleart den Background mit 0.
Wenn man den, wenn man das nämlich nicht macht.
Wenn man zum Beispiel irgendwie sagt, keine Ahnung, äh, color, so, blue oder so.
Dann ist der Hintergrund halt blau.
Oder halt hellblau.
Oder, oder, keine Ahnung, oder, indian red oder sowas.
Ne?
Aber das, das will man ja nicht.
Das heißt, man muss hier sagen, clear 0.
Und dann ist nämlich, dann ist das quasi halt durchsichtig, der Hintergrund.
So.
Und da ist ganz viel geschwummelt drin, was man hier nicht braucht.
Und das hier ist der eigentliche, äh, Kniff, wie man dann den ganzen Krempel rendert, den
man hier oben zusammengebastelt hat.
Wir haben ja hier das Bild mit dem, mit den RGB-Werten vom GIF drinne.
Dann haben wir hier die Effekte, die quasi das premultiplyen und danach skalieren.
Und hier kann man dann quasi sagen, mal das Bild.
Als Output nimmst du das Bild von den Effekten.
Und dann kann man es auch ein bisschen verschieben.
Das müssen wir übrigens gleich machen.
Weil das Bild ist, äh, werden wir gleich sehen, wenn wir das Bild animieren.
Das Bild ist dann zwischenzeitlich ein bisschen abgeschnitten.
Das ist dann, das ist ein bisschen, äh, nicht so, nicht so praktisch, ne?
Das ist dann hier oben abgeschnitten und links und rechts ein bisschen abgeschnitten.
Deswegen müssen wir hier sagen, ähm, dass wir das Ganze ein bisschen tiefer, tiefer setzen.
Aber das machen wir dann, wenn es soweit ist.
Guck, ich zeig's euch mal mit den FPS zum Beispiel.
Wenn ich die direkt oben in der linken Ecke male, dann ist ein bisschen was abgeschnitten.
Warum, bin ich mir noch nicht so ganz sicher.
So, und das war's im Prinzip schon.
Ähm, und da hab ich gestern quasi fast den ganzen Tag noch dran rumprobiert, bis ich das auf die Reihe gekriegt hab.
Es ist wirklich, das sieht jetzt hier relativ simpel aus, aber es ist voll wirklich übelst kompliziert.
So, und jetzt werden wir den ganzen Scheiß ein bisschen aufräumen.
Und einen ordentlichen GIF-Decoder basteln mit FFmpeg, der nicht hier quasi alles, alles versaut.
Wir löschen erstmal alle möglichen Dinge, die wir nicht mehr brauchen.
Weil ich mein, offensichtlich, es läuft ja gerade, es läuft ja gerade.
Also sprich, warum, also brauchen wir ja anscheinend von dem ganzen Kram nix, der hier drinne steht.
Und das ganze Kommentarzeug rauslöschen.
So, mein Magic-Hinweis kann ich auch löschen.
Debug-Mode hab ich weg.
Den ganzen Mist hier oben kann auch weg.
Das kann auch weg.
Ähm, das brauchen wir auch alles nicht mehr.
Das hier brauchen wir noch.
Sonst geht's nämlich nicht.
So, siehste, allein durch das Löschen sind wir jetzt schon mal 100 Zeilen Code weniger.
Jetzt werden wir noch dieses ganze FFmpeg-Zeugs auslagern.
Und, ähm, ich überleg grad, wo wir da am besten mit anfangen.
Also erstmal sollten wir mal gucken, ob das hier unten schon halbwegs sinnig ist.
Wir zählen am Anfang unsere FPS, okay.
Wir skalieren.
Copy for Memory für das Bitmap.
Das müssen wir dann später in der Schleife machen.
Also, sprich, das müssen wir später, müssen wir das hier machen, weil wir updaten ja pro Durchgang unser Bild.
Ey, jetzt ist es nicht mehr skaliert.
Hab ich irgendwas, hab ich irgendwas zu viel gelöscht?
MonkaS?
Ach nee, ha, ich mach das andere auch noch außerhalb von der, ups, außerhalb von der Schleife.
Ja, das ist kein Wunder, dass das jetzt noch nicht, äh, äh.
Moment, was hab ich jetzt gemacht?
Was hab ich denn jetzt gemacht?
Ich hab doch gar nichts geändert.
Warum ist das Bild jetzt kleiner?
Ah, ich weiß warum.
Lol.
Weil ich die Größe gelöscht hab.
Was natürlich Blödsinn ist.
Die sollte ich mal lieber da lassen.
So.
Jetzt wird er ordentlich groß.
Ja gut, manchmal muss man sich auch nicht wundern, ne.
Oh.
Höhe, Breite.
Alles gut.
So, und ich würde sagen, wir fangen jetzt mal damit an, das ganze FFmpeg-Zeug auszulagern in eine eigene Klasse.
So, den Max-FPS, äh, FPS-Counter können wir löschen, den brauchen wir nicht mehr.
Wir counten das jetzt in der Schleife drin.
Es ist relativ einfach, ja.
Ähm, wir gucken, wann wir angefangen haben, ähm, von der Zeit her.
Dann gucken wir, was für eine Zeit jetzt ist.
Und dann gucken wir quasi, wenn quasi, also wenn jetzt größer ist als Startzeit plus eine Sekunde.
Also, dann ist halt eine Sekunde rum.
Dann gucken wir, wie viel FPS wir gezählt haben, schreiben es in FPS und setzen die Framestate auf 0.
Also, eigentlich recht einfach.
Ja, TeraFox, ich sage ja nicht, dass es hier nicht nur Optimierungspotential gibt.
Genau.
So, ähm, jetzt weiter im Text.
Wir machen jetzt eine eigene Klasse für den FFmpeg.
Für den Gif-Decoder.
Dass es hier ein bisschen aufgeräumt ist.
So, das Ding nennen wir auch ganz billig Gif-Decoder.
Das ist noch übrig.
The fuck?
Wir schreiben das jetzt einfach.
Gif-Decoder.
Do you want to check the file and replace it?
Replace it? Yes.
Schreckt.
Okay, ähm.
Also, wir machen jetzt einen Gif-Decoder.
Und was das Ding auf jeden Fall braucht, ist den Dateinamen von der Datei, die wir wiedergeben wollen.
Ich meine, wie soll das Ding was decoden können aus einer Datei, wenn es nicht weiß, ob es decoden soll?
Also, irgendwie logisch.
Wenn er nicht weiß, wo das Gif ist, kann er ja auch schlecht.
Das seht ihr ja auch hier.
Also, ich muss ja irgendwo das Gif angeben, wo es liegt.
So, also wir brauchen auf jeden Fall für unseren Gif-Decoder, brauchen wir den Pfad, wo das Gif liegt.
Und wir machen mal so eine Variable, die nennen wir irgendwie Loop.
Und die ist standardmäßig, keine Ahnung, also sprich, der soll das Gif in Endlosschleife basteln.
Und wir werden es jetzt ganz am Anfang, wir werden am Anfang keine Sleeps oder sonst was einbauen.
Wir gucken einfach mal, wie schnell man das Gif...
Das Gif, wie gesagt, mein Hirn ist schon komplett Matsch heute.
Wie schnell man das Gif quasi rendern kann, wie oft wir das in der Sekunde hinkriegen.
In Endlosschleife, also in Animationsschleife.
Von Anfang bis Ende, von Ende bis Anfang, von Anfang bis Ende.
Also, wie oft wir einfach das Gif loopen können pro Sekunde. Mal schauen.
Genau, so, jetzt gruppieren wir uns mal den ganzen Krempel, den wir hier quasi in unserer Render-Funktion drin hatten.
Gruppieren wir uns jetzt erstmal in unseren Gif-Decoder.
Weil, es sollte später so sein, dass die ganze Windows-Klasse, die ganze Form-Klasse überhaupt nichts mehr von FFmpeg weiß und wissen muss.
Das ist eigentlich Sinn und Zweck der Sache.
Alles mit FFmpeg machen wir hier drinnen.
Achso, unsave.
Das Ganze muss unsave sein.
Und das unsave können wir dann hier wieder rausmachen, wenn wir fertig sind.
Weil unsave, weil Pointer und Gedöns.
So.
Dann brauchen wir jetzt den Initialisierungs-Code von hier.
Also Format, Kontext.
Wir gruppieren uns das jetzt einfach mal rüber.
Jetzt kommt ein Constructor von unserem Gif-Decoder rein.
Das ist ja im Prinzip ganz logisch.
Wenn das Ding angelegt wird, wenn irgendjemand den Gif-Decoder anlegt, dann lese ich die Datei ein.
Und lege so die Sachen an, die ich brauche.
Damit ich, wenn man Play drückt oder wenn man abspielen will das Gif, dass schon alles geladen ist.
So.
Dann nehmen wir das hier.
Das müssen wir dann mal ein bisschen anpassen.
Weil das ist jetzt kein Hardcoded-Fart mehr, sondern der Fart, den ich übergebe.
So viel Setup für eine von außen einfache Sache.
Richtig.
Richtig.
Es sieht super simpel aus, ne?
Ein paar Gifs abzuspielen quasi als Overlay über allen anderen Fenstern.
Wenn irgendeiner sagt, ey, zeig mal ein Gif an quasi als Overlay.
Da denkt man doch, ey, das ist kein Akt.
Wahrscheinlich gibt es auch ein paar Programme dafür, wie man das machen kann.
Es gibt ja viele Programme, die quasi topmost Windows setzen können.
Und auch noch manche Fenster transparent machen können und so.
Aber das wirklich richtig zu machen, ordentlich und schnell zu machen.
Es ist tatsächlich gar nicht so ohne.
Würde man gar nicht denken, ja.
So.
Wir kopieren uns unseren ganzen FFM-Code, FFM-Pack-Code rüber, den wir schon das letzte Mal gebastelt haben.
Von dem wir wissen, dass er funktioniert.
Hier lesen wir ein Dateiformat.
Also sprich, was es ist.
Wie viele Frames es hat.
Also wie viel FPS es hat.
Wie lang es ist und sowas.
Dann brauchen wir den.
Ich krempel hier noch.
Mal gucken, bis wann wir alles in Constructor packen.
Und ab wann in die Play-Methode.
Oder wie nennen wir sie?
Decode nennen wir sie.
Wir nennen sie nicht Play.
Play wäre für den Decoder ziemlich blöd.
Find Decoder.
Decoder. Blah.
Package.
So. Mehr brauchen wir erstmal nicht.
Jetzt ist der Kram hier alles initialisiert.
Packages und Stream werfe ich weg.
Das machen wir später.
Legen wir das neu an.
Weil das brauchen wir bloß in der Methode, wo wir dann auch
unser GIF rendern.
Unser GIF-Decode.
Die brauchen wir nicht global.
So und jetzt können wir eigentlich schon anfangen das Ganze zu rendern.
Stream.
Ups.
Habe ich den aus Versehen gelöscht.
Habe ich aus Versehen gelöscht.
Wollte ich gar nicht.
Ich wollte Package löschen.
Package und Frame löschen und nicht Stream.
So.
Okay.
Können wir das hier irgendwie ein bisschen schöner schreiben?
So.
So.
So.
So.
So.
So.
Für die letzten drei Welten.
Okay.
Ich versuche immer so die Sachen immer so die Logik zusammen gehören.
So eine Block stehen zu lassen.
Eine Leerzahl dazwischen zu machen.
So.
So ein bisschen persönliche Ansicht, wie es einem am besten gefällt.
So.
Und jetzt braucht man als nächstes.
Also wir machen uns jetzt.
Ich zeige euch jetzt mal wie man das ganze Thread sicher macht.
Ich habe da nämlich schon so eine Idee wie wir das machen.
Das heißt an der Stelle legen wir jetzt einen neuen GIF-Decoder an.
Und übergeben dem mal einen hardcoded FAD wieder.
Und zwar.
Das nehmen wir den mal.
Was nehmen wir denn mal?
Komm, wir nehmen, wir nehmen.
Wir nehmen wieder den Papagei.
Der Papagei ist schon okay.
Mit dem Dateipfad im Constructor musst du für jede Datei eine eigene Instanz erstellen.
Ja, das will ich aber auch so.
So, ähm.
Decoder.
So, jetzt brauchen wir sowas wie.
Wir brauchen ein Task.
Damit wir das Ganze quasi in einem eigenen Platz laufen lassen können, das decoden.
Müssen wir ja letztendlich.
Wir wollen ja unser Gui-Zeug nicht blocken, was nicht unbedingt sein muss.
Ähm.
So, dann machen wir eine Methode.
Ich kann nicht schreiben.
Irgendwie decode.
Ne, ähm.
Wir nennen das Start.
Oh, ich hab eine Idee.
Wir machen das jetzt richtig pro.
Wir machen das jetzt richtig pro.
Passt mal auf.
Jetzt zeige ich euch mal was.
Jetzt kommt hier wirklich High IQ Progress Skills.
Also wir machen eine Startmethode.
Vorher sagen wir uns im Konstrukt noch.
Ähm, Task, irgendwie, äh, New Task.
Und dann brauchen wir noch eine Methode, die der Task ausführt.
Und das wird die Methode Decode.
Methode Decode.
Werden wir jetzt gleich nochmal einfügen lassen.
So.
Wunderbar.
Und in Start machen wir nichts anderes wie das Task, äh, Start.
Soweit, so gut.
Erstmal relativ einfach.
So, und jetzt, jetzt machen wir Trick 17.
Jetzt machen wir Trick 17.
Ähm.
Ich, wir, wir müssen, wir müssen danach nochmal gucken.
Ich hab nämlich im Hinterkopf, dass es irgendwie mit C-Sharp, beziehungsweise mit irgendwie einem der letzten .NET Updates, was gab, um das noch schöner zu machen.
Vielleicht weiß da ja einer was von euch.
Und zwar, von der Idee her, machen wir das jetzt so.
Wir haben ja hier einmal unseren, nennen wir es mal GUI Thread.
Also sprich das Ding, wo DirectX drinnen läuft.
Haben wir hier unser DirectX Zeug.
Und das hier, das Decode von dem GIF, läuft in einem separaten Thread.
Okay.
Und jetzt ist es ja so, ich muss ja irgendwie, dieses, das, ja, ich mach das gerne.
Es gibt Leute, die machen dann so Dinger hier wie, äh, Private, äh, Blub gleich 1, so, so Dinger, ja.
Also, so Dinger machen viele gerne.
Aber ich mag ehrlich gesagt, äh, das lieber, wenn meine Klassendinger quasi meine Instanzvariablen halt nicht unterstrich haben und ich jedes Mal ein This davor schreibe.
Das ist komplett.
Geschmackssache.
Kann jeder machen, wie er will.
Und, ähm, ein Task ist nicht zwangsläufig ein neuer Thread.
Das stimmt, aber in der Regel ist das ein neuer Thread.
Und zwar im Standard Threadpool, den es halt so gibt.
Und es sei denn, man macht den Task mit Long Running, dann ist es ein eigenständiger Thread.
Ansonsten kann es, ansonsten ist es ein Task in der Regel, aber ein anderer neuer Thread.
MI Int.
Ja, okay, man kann es natürlich immer noch weiter, weiter versauen, ja.
Ist auch eine Geschmackssache.
Äh, in welchem Fall ist denn ein neuer Task, in welchem Fall ist denn ein Task kein neuer Thread?
Mir fällt jetzt da gar nicht so viel ein, ehrlich gesagt.
Das muss ich jetzt mal Backup mit ein paar Beispielen.
Da sagt ja auch sogar hier irgendwo, dass, ähm, das standardmäßig halt im Threadpool läuft.
Dass es Default ist.
Guck.
Was, wenn der Main Thread nicht blockiert ist, dann ist es...
Ach so, ja.
Hm.
Ist das so.
Also ich dachte eigentlich, dass standardmäßig, wenn du einen Task anwirfst, dass das immer in den Standard Threadpool geworfen wird.
Steht doch sogar da.
Use specific work to run on Threadpool and return task object.
Oder ist es ein Unterschied zwischen Task Run und New Task?
Zumindest läuft es parallel.
Wir blockieren nichts, das ist ja das Wichtige an der Stelle.
Ja gut, das stimmt natürlich.
Nimmt irgendwas, was frei ist.
Oh.
Es geht aber hauptsächlich darum, quasi den Kram nicht zu blockieren und das erreichen wir auf jeden Fall.
So, ähm.
Genau, Decode, bla bla bla, Start.
So, und jetzt in unsere Decode-Methode werden wir uns die einzelnen Bilder aus dem GIF rausholen.
Jetzt war aber Trick 17.
Ich hatte nämlich gerade eine gute Idee.
Und das kann sein, dass es, wie gesagt, in C Sharp 7 oder in allen der neuen .NET-Versionen noch was Besseres gibt.
Ich bilde mir ein, dass ich irgendeinen Vortrag von der letzten Bild oder der vorletzten...
...Bild gesehen habe, wo sie genau was zu diesem Thema erzählt haben.
Ist das hier noch immer das Meme-Board?
Ja, es wird weiter verbessert.
Und zwar aktuell hast du das Problem, wenn du auf GIFs drückst, hast du ja gerade das Klicken gehört, das dauert ewig.
Wir basteln jetzt unser eigenes GIF-Overlay, dass das schneller geht.
Und das wird auch deutlich schneller gehen.
Geht ja jetzt schon schneller.
Viel, viel schneller.
Braucht anstatt 58 MB nur 80 MB.
Ähm, genau.
Wir machen jetzt...
Pass mal auf, jetzt kommt hier...
Jetzt...
Äh, wir nehmen jetzt...
Wir nehmen jetzt eine Plocking-Collection und zwar von AV-Frame.
Nennen das Ganze Frames.
So, Default-Value.
Das ist auch ein schönes neues, ich glaube, das ist die Sharp 7-Feature.
Du kannst jetzt sagen, ey, dieses Property hat nur einen Getter, also sprich, du kannst da nichts Neues reinschreiben.
Also, keine neue Collection zuweisen, aber du kannst einmal zum Initialisieren hier was reinschreiben.
Sonst müsstest du das halt hier im Konstant.
So, ähm, und Plocking-Collection hat eine ganz schöne Eigenschaft.
Erstens, das Ding ist Thread-sicher.
Und das Zweite ist, es hält quasi...
Es blockiert die andere Seite, wenn nicht genug Bilder da sind.
Wir probieren das jetzt mal aus, mal gucken, ob das das ist, was wir haben wollen.
Und ich denke aber mal, dass wir ziemlich schnell in der Lage sind, neue GIF-Bilder zu decoden und dass wir auch ziemlich schnell in der Lage sind, Sachen zu rendern.
Und eine Sache müssen wir noch machen.
Man kann nämlich der Collection angeben, dass wir maximal 100 Items queuen wollen.
Weil sonst hätten wir den Fall, ähm, mal genommen, wir hätten einen riesen GIF und unser GIF decodet viel, viel schneller, als wir es rendern können, würde das hier quasi volllaufen mit neuen Bildern.
Deswegen sagen wir, hey, 100 Bilder im Voraus berechnen ist erstmal genug.
Wir werden jetzt kaum ein GIF mit 100 Bildern finden.
Äh, äh...
Mehr als 100 Bilder im Voraus berechnen ist genug.
Im Zweifelsfall dann block halt hier dein Decoding, solange bis eins abgearbeitet ist.
Und auf der anderen Seite, sollte das hier leer sein, dann blockt das Rendern, was wir auch in einem separaten Task, ja, was wir auch in einem separaten Task laufen lassen, blockt das Rendern vom DirectX.
Sollte hier nichts drin sein.
Und da müssen wir uns nicht um irgendwelche Fälle kümmern mit, es ist nichts da.
Es ist null drin, es kackt ab oder sonst was in der Richtung.
Es hängt dann einfach bis auf beiden Seiten irgendwie was drin ist.
So, und das heißt in unserem Decode lesen wir jetzt die einzelnen Bilder vom GIF aus und schreiben dann die Bilder in diese Collection rein.
So weit, so, so weit, so gut, ne?
Ähm, also von der Idee her haben wir dann sowas hier wie...
An der Stelle brauchen wir hier Frame.
So, haben wir den Decoder, Decoder, Decoder, Frames, Take.
So, und an der Stelle ist es jetzt so, wenn hier nichts drin ist in Frames, weil unser GIF-Decoder mal angenommen zu lahm ist, dann würde es an der Stelle blockieren und nicht weiter rendern, bis das, ähm, bis was drin ist.
Das heißt, und es ist Thread-sicher, das ist natürlich ultra praktisch, das heißt ich muss mich hier um nichts kümmern.
Moin, du hast doch immer noch deinen Server zu Hause, wie hast du den gegen Angriffe von außen abgesehen, hier mit einer Firewall und TLS oder, ähm, es gibt keine Zugriffe von außen.
Deswegen muss ich da auch nichts absichern.
Das einzige, was es gibt, ist, ähm, ein OpenVPN.
Das ist das einzige, was es gibt.
Aber ansonsten, es gibt keine wirklichen Zugriffe von außen, deswegen muss ich da auch nichts großartig absichern.
Und mein Netzwerk...
...nextcloud und das ganze Zeug, das ist quasi nur intern verfügbar, oder wenn man per VPN angemeldet ist.
Also sprich, das funktioniert dann auch nur von meinen Geräten aus, wo ich auch ein VPN drauf installieren kann.
Ansonsten, äh, fragst du, weil du selbst was absichern willst?
Also ich kann dir erzählen, wie ich das machen würde.
Wenn ich es von außen erreichbar haben will.
So, ähm, Decoder Frames Take, Take Frame, das ist ein AV-Frame.
So, und das können wir die ganzen Krempel hier löschen.
Den brauchen wir drüben in unserer Decode-Methode drin.
Ähm, so, Frame, Frame.
Was muss ich den ganzen Krempel ersetzen?
Die ganzen Pointers ersetzen durch Punkte.
Und wir dürfen nicht vergessen, den Frame wieder aufzuräumen.
Wenn wir vergessen, den Frame wieder aufzuräumen, dann ist Memory Leak des Todes angesagt.
Okay, soweit.
Gut, gucken wir mal, ob das jetzt prinzipiell funktioniert.
Also, wir decoden den ganzen Krempel.
Bla, bla, bla, bla, bla.
Frame, Packet.
Also müssen wir hier ein neues Packet pro Durchlauf anlegen.
Sagen wir hier, Packet gleich new AV-Packet.
Und sagen, Frame gleich new AV-Frame.
So, bla, bla, bla.
Add.
Achso, ja, genau.
Dann müssen wir Referenz übergeben.
Und sagen, Add Frame.
So, und jetzt gucken wir mal, ob es funktioniert.
Es sollte eigentlich jetzt immer noch der Vogel rauskommen.
Macht er aber nicht.
Okay, dann habe ich an irgendeiner Stelle...
Achso, ich muss das Ganze ja noch starten.
Haha, haben wir noch nicht gestartet.
Decoder Start.
Kann ja nicht funktionieren.
Bam!
Es nimmt Formen an, Leute.
Es nimmt Formen an.
Was wird denn, wenn es fertig ist?
Das wird ein GIF-Player, der schneller ist als der normale WPF.
GIF-Player.
Guck hier, klick.
Wie lange das braucht.
Und meiner ist dann der Highspeed-GIF-Player mit 6000 FPS die Sekunde.
Wie im Titel steht, der schnellste GIF-Player der Welt wird das.
Also, Woosa, wäre cool, wenn du das mal erzählen würdest.
Also, wenn ich von außen was verfügbar machen würde.
Das Beste, was du machen kannst, ist natürlich erstmal VPN.
Da gibt es relativ wenige Probleme.
Das nächste sind Client-Settings.
Zertifikate, auch immer wunderbar.
Allerdings möchtest du dir das oftmals von außen zugänglich machen, ohne dass der andere eine Zeremonie abziehen muss,
dass er darauf zugreifen kann.
Und da ist das Einfachste, also erstmal brauchst du ein paar Zertifikate.
Wenn du das Ganze verschlüsselt machen willst, da empfiehlt sich Let's Encrypt.
Und ich würde nie meine Anwendung direkt Port weiterleiten oder direkt freigeben in der Firewall.
Ich würde das Ganze immer über irgendwie, wenn es HTTP ist, aber das meiste ist ja HTTP.
Würde ich das über eine Reverse-Proxy laufen lassen, dann nehme ich meistens NGINX für.
Aber es gibt auch zig andere Sachen, die du da verwenden kannst.
Ich verwende meistens NGINX für.
NGINX und Let's Encrypt mit Certport funktioniert auch wunderbar zusammen.
Dann hast du quasi einen NGINX zwischen deinem Dienst und zwischen außen.
Das heißt, da kannst du auch wunderbar quasi hinter einer Domain auf mehreren Ports quasi Dinger laufen lassen.
Ja.
Oder quasi mehrere Subdomains intern auf unterschiedliche Dinger mappen oder sowas.
So, und dann kannst du dir überlegen, ob du noch Authentifizierung machst über NGINX.
Du könntest beispielsweise, wenn du sagst, okay, ich will es möglichst einfach haben,
dann machst du halt einen NGINX als Reverse-Proxy dazwischen und holst dir Let's Encrypt-Zertifikate.
Und dann machst du halt, wenn du willst, dass es simpel ist und du noch ein bisschen Authentifizierung hast,
dann machst du dem NGINX einfach Basic Auth an.
Dann musst du halt Passwort und Username irgendwie mit deinen Leuten austauschen.
Aber das ist das Einfachste, was du machen kannst.
Und das ist dann aber schon relativ gut.
Natürlich gibt es dann noch unendlich viele weitere advancede Varianten.
Du kannst dir sogar eine To-Factor-Authentifizierung basteln mit, gibt es dann so Keycloak oder irgendwie sowas,
wo dann der NGINX einen Request dagegen macht, so nach dem Motto, darf der Typ und sowas.
Aber die einfachste Variante dürfte wirklich sein, Let's Encrypt, NGINX oder irgendeine andere Reverse-Proxy
und dann kannst du dann auch noch eine Authentifizierung basteln mit, gibt es dann so Keycloak oder irgendwie sowas,
wo dann der NGINX einen Basic Auth davor und gut ist.
Läuft schon. Es läuft mit einem Bild und ist transparent, Patrick.
Also es ist schon deutlich besser als das letzte Mal und du hast das ganze Intro verpasst,
wie sehr es mich genervt hat, ein transparentes Fenster und ein transparentes GIF selbst zu rendern.
Riesenakt.
Okay, Decoder start. Zack, da ist er.
Und sogar schön gescaled.
Okay, jetzt müssen wir natürlich noch einstellen, dass mehr Frames abgerufen werden.
Okay, kann ich noch ein bisschen was löchern?
Schon von dem ganzen Krempel hier, den ich da habe.
Bla, bla, bla.
Bla, bla, bla. Kann ich davon noch irgendwas wegschmeißen?
Ne, glaube ich nicht.
Okay, ähm.
Copy from memory, frame.
Decoder start, Decoder.
Gut, das hier muss ich in der Schleife machen.
Das Bitmap kann ich ja vorher schon anlegen, das ist kein Problem.
Das muss ich in der Schleife machen.
Und ich muss einmal pro Schleifendurchgang einen neuen Frame holen.
Also am Ende vom Durchgang.
So, jetzt sollte eigentlich das GIF animiert sein.
Und ist es auch, plus es ist viel zu schnell.
Ich vermute mal, dass es das ist.
Machen wir mal ein Sleep irgendwie dazwischen.
100 Millisekunden.
Da ist es.
Bam.
Bam.
Danach kackt es ab.
Logischerweise kackt es danach ab, weil es gibt kein Frame mehr.
Richtig so, ne?
Aber, Animation in Form an.
Warum genau kackt das ab?
Frame.
Na, eigentlich abkacken sollte es doch nicht.
Der letzte Frame ist doch immer noch drin, oder?
Jetzt muss ich mal überlegen, warum kackt das an der Stelle ab?
Also, wir müssen den Frame eh auf jeden Fall wieder löschen.
Weil das haben wir im Memory Leak.
Das wollen wir nicht.
Eigentlich, ja, prinzipiell funktioniert es so, wenn die Animation fertig ist, kackt der ab.
Weil, wahrscheinlich hier, da kam nicht, wo kackt, was war, Paint kackt der ab?
Das ist wahrscheinlich ein Bug, dass er war Paint abkackt.
Also, wahrscheinlich hat er hier irgendwie Probleme mit dem Speicherbereich.
Wobei, ist den Frame doch eigentlich, ach ne, ha, ne, Moment.
Der sollte hier doch eigentlich hängen, wenn nichts mehr drin ist.
Also, warum der abkackt, ist mir jetzt nicht so ganz klar, ehrlich gesagt.
Hm, warum kackt der ab?
Kannst du mal erklären, was Endpoint der für eine Datenstruktur ist?
Das ist quasi die Managed-Variante von, äh, einem Pointer.
Ja, alles gut.
Sharks Development.
Warum kackt der denn ab an der Stelle?
Ich meine, es ist nicht schlimm, wir laden ja eh die Bilder dann nochmal neu.
Aber er sollte nicht, er sollte definitiv nicht abkacken, wenn keine Bilder, also von der Idee,
hier sollte es folgendermaßen sein.
Ah, ich weiß, woran das liegt.
Das Ding hier kackt ab.
Wartet mal, ich hab ne Idee.
Äh, wir machen, wir machen mal, decoden mal wieder nur ein Frame.
Siehste, jetzt kackt's nämlich nicht ab.
Das kackt gar nicht ab, das ist, das ist, das ist Fail.
Es kackt in Wirklichkeit, ähm, in Wirklichkeit kackt nämlich der GIF-Decoder ab, was ganz klar ist,
weil, ähm, denn ich weiß nicht, was das ist.
Ich weiß nicht, was ich weiterlesen kann.
Ich muss hier nämlich gucken, if error ffmpeg, okay, das muss ich mir jetzt mal abgucken,
von dem, was wir das letzte Mal gemacht haben, äh, das waren das, äh, EOF oder sowas, ne?
Ja, genau.
Sprich, wenn das File fertig gelesen ist, dann muss er, dann darf er nicht weitermachen.
Da muss er machen, break.
Ha, guckt, und jetzt kackt das Ganze auch nicht mehr ab.
Das lag nämlich gar nicht an unserem Render, das lag am, am Decoder, der abgekackt ist.
Und die Exception.
Die Exception war nur an der komplett Fail-Stelle.
Äh, Memory Leaks werden wir gleich ordentlich produzieren.
Ich hab's, ich hab's im Gefühl, äh, so.
Und jetzt müssen wir eine Möglichkeit finden, wie wir das Ganze resetten.
Also, der Witz ist jetzt, ja, wir können, also, wir haben jetzt eine relativ lange Sleep drin,
dass wir sehen, dass die Animation funktioniert.
Wir machen das Sleep dann gleich mal raus, wenn wir, wenn wir es geschafft haben,
eine quasi endlos, eine endlos GIF-Schleife zu, zu decoden.
Also, von der Idee her würde ich mal sagen, was ich übrigens auch toll finde,
wir haben null FPS.
Ähm, wir müssen jetzt mal gucken, wie man mit, mit, äh, FFmpeg quasi zurückspringt hier.
Weil wir lesen ja immer noch, wir haben ja hier irgendwo einen neuen,
wir haben ja hier irgendwo einen Stream.
Und, ähm, wir lesen Frames, Frames, Frames, Frames.
Und irgendwann sind wir am Ende, End of File.
Und jetzt müssen wir irgendwie FFmpeg ja wieder sagen, geh an den Anfang des Files.
Zurück.
Ich habe keine Ahnung, wie man das macht, da müssen wir jetzt mal suchen.
FFmpeg Reset File.
Äh.
Ja, das kann man auch machen, wir könnten auch einfach alle Frames zwischenspeichern, das geht auch.
Aber ich will mal gucken, wie man resettet.
How to reset AV-Format Context so it could be reused.
Das ist schon mal gut.
Bäh.
Okay, der hat keine Antwort gekriegt.
Wisst ihr was, wir sollen jetzt mal...
Stack, Overflow oder was?
FFmpeg Reset Start Time of File.
AV-Frame.
Position.
Man muss einfach nur gut suchen können.
FFmpeg Position File.
Context.
Reset.
Seeking.
Seek.
Seek.
Avioca.
Ihr seht jetzt gerade...
Stack Overflow Driven Programming in Aktion.
Seeking with AV-Seek Frame.
I.O.
Stream.
Set.
Ich würde sagen, wir kommen der Sache...
Wir kommen der Sache langsam näher.
AV-Seek Frame.
Hatten wir das schon oder hast du...
Weißt du...
Hier ist doch...
AV-Seek Frame.
Das muss doch irgendwie funktionieren.
AV-Seek mit...
Mit dem Beginning Flag.
Also quasi...
Okay, lass mal überlegen.
Also sprich, wenn wir hier EOF haben...
Dann müssen wir sagen...
AV-Seek?
AV-Seek Frame?
AV-Seek Frame?
Context.
Was für einen Context brauchen wir denn an der Stelle?
Was für einen Context brauchen wir denn an der Stelle?
Ayaya! Format. Okay.
Format. Context.
Stream Index.
Stream Index ist 0.
GIF hat nur einen Stream.
Timestamp.
Wo wir hinwollen.
Seek to the Keyframe.
Timestamp 0.
Inflex.
0.
Ob das jetzt funktioniert?
Ob das jetzt funktioniert?
Ne, ich glaube nicht, dass das funktioniert.
Äh.
Scheiße, das funktioniert?
Krass.
Übrigens, wir haben ein paar Memory Leaks, aber...
Das funktioniert.
Ich bin echt, äh...
Überrascht jetzt, ne?
Guck mal.
Wir leaken ein bisschen Memory.
So ein bisschen. Ein bisschen.
Ein bisschen Memory leaken wir.
Das liegt aber daran, dass ich auch nichts freigebe.
Das liegt aber daran, dass ich auch nichts freigebe.
Okay, gucken wir mal.
Also, wir sagen... Okay, das Packet brauchen wir nicht.
Package freen können wir. Frame freen können wir nicht.
Also, FFM Pack.
Free Packet.
Free Packet.
Deprecated.
Deprecated.
Darauf geschissen.
Jetzt leaken wir schon
ganze Ecke weniger.
Free Packet. Ist optional. Use Packet Unref.
Use Packet Unref.
Machen wir.
Das das 1717, äh...
Kennst du dich mit FFM Pack aus?
Oder woher weißt du das alles?
Okay, wir leaken noch ein bisschen
an anderen Stellen, wie es aussieht.
Wahrscheinlich in unserem DirectX.
DirectX Krempel. Müssen wir mal gucken.
Ja, garantiert.
Garantiert. Wir müssen hier noch aufräumen.
Garantiert. Wir müssen hier noch aufräumen.
Wir müssen mal gucken, an welcher Stelle.
Wir müssen mal gucken, an welcher Stelle.
So, und jetzt müssen wir hier am Ende noch sagen.
FFM Pack.
Frame. Wahrscheinlich auch Unref.
Unref Frame.
Und jetzt sollten wir weniger leaken.
Und jetzt sollten wir weniger leaken.
Achso, bin ich blöd.
Vielleicht sollten wir das davor machen.
Bevor wir uns den neuen holen.
Guck mal, wir leaken nicht mehr.
Weil es, äh...
Wir machen das mit DirectX, weil es
Windows Only ist.
Also, so, und jetzt nehmen wir mal das Sleep raus.
Mal gucken, was passiert.
Mal gucken, was passiert.
Alter!
Ich sag doch,
der schnellste GIF-Player der Welt.
Hahaha.
Hahaha.
Wisst ihr, dazu passt jetzt richtig gut.
Ich bin begeistert.
Nice. Gut.
Mal in den normalen Modus wieder wechseln.
Warum ist die Musik gar nicht so leise?
Ich mein, guck mal.
Wir schaffen es jetzt. Meine Platte ist wahrscheinlich auch voll am...
Oh, ja.
Meine SSD ist ein bisschen am blinken, ja.
Ähm, ich mein, guck mal.
Wir, wir, wir, wir haben ja die, die
Frames noch nicht mal gecached oder so.
Wir, wir lesen das quasi immer neu ein,
erstellen immer neue Objekte und wir rendern das quasi mit
maximal 1200 FPS oder so.
Das ist doch schon mal
sehr ordentlich.
Allerdings soll das Ganze
natürlich nicht ganz so hektisch sein.
Aber nice, das funktioniert schon mal.
Und wir brauchen auch
nur 90 FPS, äh,
90, 90 MB RAM.
Habe ich hier überhaupt auf Release?
Soll ich auf Release stehen?
Wow.
Das ist kaputt.
Warum, warum geht das kaputt?
Warum geht das kaputt, wenn es auf Debug steht,
aber auf Release geht es nicht kaputt?
Wie dem auch sei,
wir wollen das ja eh nicht so schnell haben,
aber kaputt gehen sollte es eigentlich nicht.
Es sollte eigentlich
volle Pulle.
Wir, wir unraffen bestimmt irgendwas, was,
was schon kaputt ist oder so.
Triggered a breakpoint. Ja, welcher
Breakpoint auch immer.
Jetzt, ich mein, ist ja geil, wenn's, wenn's
Caption wirft, aber warum?
Unref.
Ja, Breakpoint.
Hab ich halt keinen.
Okay, ähm,
wahrscheinlich machen wir hier
irgendwie irgendwas, äh, blödes.
Beim Unref
kackt er ab.
Warum kackt der denn beim Unref ab?
Das ergibt ja überhaupt keinen Sinn.
Habe ich das vielleicht
in der falschen Reihenfolge irgendwie?
AV Frame Free?
Ne, ich dachte, das ist das neue Free.
Moment.
Das sind unterschiedliche Dinger, ne?
Wartet mal kurz.
So, wieder da.
Ich brauch gar nicht Unref.
Geht's, liegt's denn, wir gucken mal, ob's überhaupt am Unref
liegt. Ja, ohne Unref
geht's, allerdings, äh, ist mein RAM gleich voll.
Wenn's so weitergeht.
Moment, wie, wie mach ich das denn jetzt?
Jetzt, jetzt, oh, jetzt, jetzt, jetzt stoßen
meine krassen C Pointer Skills an die
Grenzen. Der möchte,
der möchte
einen Pointer haben.
Einen Pointer Pointer, also
einen Pointer zu einem Pointer
auf Frame. Ich hab allerdings nur
einen Pointer auf Frame zu bieten.
Was mach ich denn jetzt? Leute,
haben wir nicht den, haben wir nicht irgendeinen, der
hier, der Patrick, der ist so der krasse C Owner.
Was mach ich denn jetzt?
Also das geht, okay, probier mal aus.
Und, und.
Ey, das wär lustig, wenn das geht, aber das glaube
ich nicht.
Ne.
Was, AV Frame?
Äh, GFF.
Äh, wenn's das Richtige tippt.
Aber das ist dann immer noch kein Pointer
zum Pointer, oder?
Ha. HA!
Nein.
Hahaha.
Nicht wirklich.
Fast. Man weiß ja nie.
Haha.
Das funktioniert nicht.
Da kackt er ab.
Hier an der Stelle.
Hm. Ich hab keine Ahnung.
Was ich aber interessant finde, dass er das
im Release-Modus nicht macht.
Also.
Mit UnRef hat's ja im Release-Modus
wenigstens funktioniert.
Was ich halt interessant finde, UnRef ist doch eigentlich das
Richtige.
Im Release-Modus funktioniert der Campbell doch auch.
Boah, was hat der im Debug-Mode für
Schmerzen damit, äh.
Ha.
Na gut, wisst ihr was, wir machen mal Native
Code Debugging an. Ah, ne, haben wir schon.
Docs.
Wood. Wie geht?
Docs.
Ja, da stand, dass ein Breakpoint aktiv ist.
Ich glaub, das sagt Visual Studio einfach nur so.
Ja, das ist halt die Frage,
ob, ähm,
der Constructor das hier auch so macht.
Können wir jetzt nicht reingucken.
Aber wahrscheinlich, ja.
Habe ich hier irgendeine Logik drinne, die Fail ist?
Wisst ihr was, wartet mal.
Wir machen jetzt mal was anderes.
Wir rendern jetzt mal nichts.
Wir rendern jetzt mal nichts.
Gucken, ob der, ob der, ob
der Decoder jetzt läuft.
Ne, guckt mal, der Decoder
kackt schon ab. Warum?
Achso, ja, weil
100 Elemente voll sind.
Ich, ich free das Ding mal hier drin.
Kann ich mir nicht vorstellen, dass man
das hier irgendwie, was ist das denn?
Siehst du das richtig, dass FFmpeg komplett statisch ist?
In dem Fall schon. Das ist einfach ein Wrapper
um diese, um, um halt
die C
Library von FFmpeg.
Ja, FFmpeg ist, ist
C-Geschwubbel.
You can use frameunwrap
Oh, er drückt hier.
Donation sound.
Poggers.
1 Euro, 23.
Vom Hureboss, seine Konjunkturen sind immer interessant.
Nice, wenn's dir gefällt.
Sehr, sehr nice.
Da musst du das Objekt doch pinnen.
Weiß ich nicht, ob ich das pinnen muss.
Ich dachte, pinnen muss
ich nur, wenn ich quasi
irgendwelche managed
zu native Geschichten mache.
Was ich jetzt an der Stelle ja gar nicht mache.
Ich mach ja unter der Haube im Prinzip.
Alles unsaved native.
Da drückt man hier ein Beispiel,
wie die das verwenden.
Okay, da machen wir
das jetzt doch mal so.
Also wir machen jetzt ein frame.
Ups.
Frame.
Das funktioniert.
Interessant.
Warum funktioniert das so und anders nicht?
Ich mein, das ist okay.
Was machen die denn in dem Konstrukt
davon?
Das müssen wir jetzt mal nachholen.
So, das ist ein
AV-Frame.
Da muss ich mal nachgucken,
ob die da unter der
Haube irgendwas anderes machen.
Ja, ich mach auch, achso,
das ist das Package oben drüber.
Ich mach nur
free grade.
Das funktioniert und wir leaken auch
nix. No leaks.
Ich probier das jetzt nochmal andersrum.
Loopframe.
Warum hat der hier irgendwelche
Schmerzen mit?
Ich mein, das müsste hier lokal von der Funktion sein.
Okay, sind wir ja auch weiterhin.
Okay.
Das Problem ist anscheinend nur,
wenn ich das anre...
Okay, das funktioniert
auch.
Okay, das ist prinzipiell, prinzipiell ist alles
gut. Das Problem tritt nur auf, wenn
ich das von der anderen Seite
aus mache.
Warum das denn?
Das ist entweder...
Hm. Das ist entweder irgendeine
Threading-Geschichte?
Was ich mir eigentlich nicht vorstellen kann.
Oder die Adressen
stimmen einfach nicht.
Was ich allerdings merkwürdig finde.
Okay, warte mal, ich brauch den Frame. Hier brauch ich den.
Danach brauch ich den ja.
Ich mein, wir geben einfach den...
Wir speichern uns einfach den Pointer da drin.
Das geht natürlich auch.
Aber eigentlich will ich kein
Unsafe-Zeug rausgeben.
Okay, ich hab ne andere Idee, Leute.
Wir machen...
Weil ich will eigentlich hier in meiner Form
kein Unsafe-Zeug verwenden.
Das ganze Unsafe-Zeug hier hinterein machen.
Ich hab ne Idee. Wir machen jetzt noch
Public Class Frame.
Der
kriegt
ein AV-Frame.
AV-Frame.
Ähm.
Frame.
Was hat der für Schmerzen?
Achso.
Unsafe.
Wir können's auch noch anders machen. Wir können
den End-Pointer frame.
So war das. Also, ja.
Wir rappen den Krempl
noch mal in ner eigenen Frame-Klasse.
Da müssen wir da kein
Unsafe-Zeug rausgeben. Irgendwie so
probieren wir das mal aus gerade.
So von der Idee her
funktioniert.
Was programmiert er? Ich programmier nen GIF.
Einen GIF-Viewer.
Also, der
viewt ganz schön schnell das GIF.
Das ist als Ergänzung
zu meinem Overlay hier.
Weil das WPF-GIF-Zeug so langsam ist.
Guck, wenn du hier drauf klickst.
Hast
einen Klick gehört, wie lange das dauert.
Und das ist der schnellste GIF-Player der Welt hier.
Leider
funktioniert der nur im Release-Modus, im Debug-Modus
nicht. Das macht mich echt fertig
jetzt. Was ist das für ein Sch... Vielleicht liegt's am Debugger.
Das liegt am Debugger!
Wenn da Debugger attached ist,
dann spackt's rum.
Wenn da Debugger
nicht attached ist, dann spackt's nicht rum.
Liegt das am Native-Code-Debuggen?
Nee.
Also, mit attachedem Debugger
spinnt's?
Okay, dann ist das...
Ich glaube gar nicht, dass mein Code da irgendwie Probleme
hat, aber...
Oder doch? Komisch.
Aber...
Wir machen das trotzdem mal mit der eigenen
Klasse.
So, und dann kriegen wir jetzt hier einen AV-Frame.
So, überlegen wir mal,
wie wir das am besten machen. Ähm...
Also haben wir einen AV-Frame.
Ich probier das jetzt mal so.
Frame...
Suppose...
Weil das ist eigentlich das, was ich ursprünglich
ursprünglich vorhatte.
Also ich wollte
eh eine eigene Klasse dafür machen,
dass ich kein unsafe Zeug
rausgeben muss.
Weil...
Fixed...
Fixed...
Wie ging der Kram nochmal so, ne? Fixed...
Und da musste man quasi sagen...
Das wird doch da dran liegen.
AV-Frame...
Sternchen...
Pointergeschiss...
Ah...
Jetzt wirds schmerzen.
Achso...
Unsafe...
Ne, machen wir nicht. Unsafe...
Unsafe...
Unsafe...
Eieiei...
Ne, ich hab kein if...
Keine Debug-ifs irgendwo drin.
Also nicht, dass ich wüsste.
Unsafe fixed...
So...
So...
Was können wir in unserer Frame-Klasse sinnvolles geben?
Das ist eh was, was ich noch machen wollte.
Properties brauchen wir.
Wir brauchen...
Int-Pointer-Data...
Hier wird er mir wahrscheinlich wieder meckern.
Hier wird er mir wahrscheinlich wieder meckern.
Wenn ich sage...
Framedata...
Null... Das mag er wahrscheinlich nicht.
Ne, das muss unsafe sein.
Also sprich, brauchen wir hier
einen getSet
get...
Return...
So...
Das da brauchen wir...
Das da brauchen wir...
Hups, was jetzt?
Achso, unsafe...
Moment, Einrückung...
Einrückung...
Unsafe...
Unsafe...
Return unsafe...
So, gut.
Wenn er nicht mag, wird gecastet, klar.
Easy cast, easy life.
So, dann brauchen wir noch...
Int...
Int...
Int...
Int...
Int...
Int...
Int...
Int...
Int...
Int...
Falls das jetzt klappt, hat derjenige,
der von fix geschrieben hat,
doch recht gehabt.
Das Package können wir weiter anreffen.
Klar, das gibt's ja nicht. So, weil Frame
ist jetzt ja ein breiter, breiter
Dings da. Breite Höhe brauchen wir
noch. Das kann natürlich schon funktionieren.
Witz
und Heiz.
Wisst ihr, wo ich übelst Bock drauf hätte, Leute?
Also, nicht jetzt.
Aber wo ich gerade,
gerade so Bauchgefühl, gerade
so unbewusst dran gedacht
habe, wo ich übelst Bock drauf hätte.
Das ist, ich würde jetzt
gerne mit dem Fabian MW2 spielen auf der
360. So, ohne Scheiß, das habe ich
mir gerade so eingefallen. Am liebsten würde
ich mich jetzt einloggen. Xbox Party
Chat. Alter, war Xbox Party Chat geil.
Nicht diese verkackte Scheiße da, ja.
Stunden haben wir den
Krams gespielt. Außerdem waren wir da noch jünger.
Wobei
ist es nicht so, dass ich mir großartig alt vorkomme in der
Richtung. Aber das wäre nice.
So.
Witz.
So viele Witz und so viele Heiz.
Noch mehr.
Das ist
jetzt einfach nur noch Frame Data.
Das haben wir schön gewrappt.
Bin schon mal gespannt, ob der
Shit funktioniert, ja.
So, jetzt muss es erstmal funktionieren und wir
Memory leaken jetzt wie verrückt.
Wir Memory leaken ordentlich.
2 GB RAM schon weg. Bam in your face.
So, mal gucken, ob das
jetzt funktioniert. Frame. Dispose.
Scheiße,
Alter, was ist das für eine Kacke?
Ich bin voll auf den Sack, ja.
Ich bin mega auf den Sack, dass das nicht funktioniert.
Alter, wie ging das?
Free.
Kann ich mal tippen.
Free.
Frame.
Frame.
Ich kann nicht schreiben.
AV Frame.
Free.
Nee, nee, das mag nicht.
Ich weiß, woran das
liegt. Ich habe eine Idee.
Das liegt überhaupt nicht an den
Referenzen. Das liegt
hier dran.
Das liegt 100 pro hier irgendwo dran.
Ich sag's euch.
Das Rumgesieke
ist nicht richtig, was ich hier mache.
Weil ich guck mal,
das kackt ab, genau,
ziemlich genau,
nachdem es einmal durch ist.
Mein Gesieke ist falsch.
Jetzt kackt,
wischelst du dir noch ab, oder was?
Guck, das kackt mehr oder weniger
direkt nach. Ich siege falsch.
Das wird sein.
Es fehlt noch was,
oder sowas.
Ist das anders an der Stelle?
Fast. Das ist einfach nur
verzögert da.
Ich wette mir, ich siege falsch.
Ich hab das so irgendwie...
Mach einfach Try-Catch drauf.
Wahrscheinlich wird das sogar
funktionieren. Aber da haben wir auf jeden Fall
irgendeine Memory-Leak drin.
Ich muss mal suchen. Ich hab bestimmt
irgendwo was, wo ich mal
den Stream gesettet hab.
Ich such noch mal.
Ich such noch mal danach.
Seek File Position.
Okay.
Fmpeg Format Context
Seek
Stream Reset
Einfach nicht siegen und die Datei
selbst storen. Ja, das ist...
Es muss gehen. Man muss doch
an den Anfang kommen.
Nee, Flo.
Sowas mach ich nicht.
Also sag mal so,
das mit dem Storen,
das ist eh eine Sache, die ich vielleicht noch mache.
Aber ich will
wissen, wie ich ordentlich siege.
Position.
AV-Konec
Flush Buffers. Aha.
Können wir gleich mal ausprobieren.
Was? Als letzten Parameter 4.
Okay. Wäre das immer lustig,
wie interaktiv die ganzen Streams dann wären,
wenn ich mir irgendwann halt weiter weiß.
Nope. Ist ja schon gleich am Anfang abgekackt, ey.
Nimm doch irgendwas nett.
Warte mal. Ich spar mir jetzt mal
kurz das Disposen, dann kackt er auf jeden Fall
nicht mehr ab.
Aber mein RAM ist halt
relativ schnell voll.
Okay.
Okay. Also, nach was könnte man denn
nochmal suchen? Interessantes
ähm, SomaStack
Overflow. Also was, was ist
eigentlich, was wir machen? Wir wollen FFM-Pack
ResetStream.
Wollen wir vielleicht
RepeatStream.
FFM-Pack
RepeatStream.
Gibt's da irgendwas?
FFM für Videostream, du.
Ich finde das Wort ja überhaupt nicht.
Moment. Video
Stack Exchange, da will ich überhaupt nicht hin.
Repeating FFM-Pack Stream.
Was will der Max programmieren?
Warte mal, ich zeig's dir.
Das Memory liegt aber extrem, weil ich
gerade noch nicht free.
Der schnellste Giftplayer der Welt.
Aber eigentlich soll das
nicht so schnell wiedergeben, sondern so, dass es
normal schnell ist.
Was haben wir hier gefunden?
Repeating FFM-Pack Stream.
Ah, das ist der gleiche, Dude.
Streams.
A-V-I-O-Sieg.
A-V-Format-Sieg-File.
Okay.
V-I-O.
Nix F. Stream geht noch.
V-I-O-Sieg.
Video-Kontext.
Äh, äh, Moment. Was ist das hier für ein Kontext,
was der Typ da reinbastelt?
Heute sind wir mal richtig Stack-Overflow-Triven,
ich sag's euch.
Was ist das für ein Kontext?
Äh, der, der, der, der, äh...
Codec-Kontext.
Oder?
Oder?
Nee.
Nee.
Oder?
Format-Kontext.
Der Typ widerspricht sich irgendwie selbst.
Format-Kontext.
Offset?
Keine Ahnung. Null?
Äh, Null?
Ich weiß nicht, wir waren es einfach mal.
Wobei, der hatte doch irgendwas reingeschrieben hier unten.
PB.
PB.
PB.
I-O-Kontext.
Was es nicht alles gibt, ey.
Was auch immer, äh.
So, und als nächstes haben wir jetzt FFM-Pack.
AV-Format.
Was?
AV-Format.
Seek-File.
So, und da muss rein der komische Kontext hier wieder.
Äh, Kontext.
Index of Stream.
Null.
Smiles-Timestamp.
Null.
Long.
Target-Timestamp.
Long.
Timestamp.
Was macht der da?
Stream.
Stream.
Duration.
Null.
Jetzt bin ich ja mal gespannt, ob der Scheiß funktioniert, äh.
Ups.
Äh.
Hab ich was vergessen?
Äh, Moment.
Ich hab was vergessen.
Was hab ich vergessen?
Äh.
Null.
Min.
Null.
Target-Timestamp.
Null.
Null.
Null.
Max-Timestamp.
There.
Jetzt aber, ne?
Alter, was ist das für ein Tag da?
Okay, wir Memory-Leaken immer noch des Todes, aber das ist ja klar.
Okay, jetzt gucken wir, ob wir das pausen dürfen.
Aha!
Ich sag's euch, ich hab's euch doch gesagt.
Wir haben falsch gesiegt.
Das ist zwar kein richtiges Deutsch.
Ich weiß zwar nicht, was wir falsch gesiegt haben, aber wir haben falsch gesiegt.
Das ist halt einfach so.
Wir wieder.
Komplett wir, Alter.
Komplett.
Durch, äh.
Und wir Memory-Leaken auch nicht wirklich, oder?
Vielleicht ein paar Kilobyte, aber das...
Ne, wir Memory-Leaken nicht.
Guck mal hier.
1.200 FPS GIF-Animationen.
Was gesiegt bedeutet, das ist ganz schlecht eingedeutet, gesucht.
Ähm.
Ich mein damit hier das hier, guck.
Sieg.
Also, suchen.
Und zwar, also.
So wie ich das jetzt verstehe, macht er an der Stelle folgendes.
Ähm.
Hier, ich öffne ja hier die Datei.
Warte mal.
Hier, guck mal.
Hier öffne ich ja die Datei.
Also meine, meine Bilddatei öffne ich ja hier.
Open Input.
Im Fad steht die Bilddatei drin, also.
Und dann hab ich hier ne Schleife, wo ich quasi Inhalte aus der Datei auslese.
Irgendwann bin ich am Ende.
End of File.
Und dann muss ich, dass ich weiterlesen kann, wieder an den Anfang.
Seeken.
Also wieder an den Anfang.
Springen.
Also ich muss quasi den Anfang suchen.
Also ich gehe quasi wieder auf Position 0 zurück.
Das ist ja natürlich sehr umständlich.
Bei irgendeinem C-Sharp Stream würde ich sagen, bei einem C-Sharp Memory Stream, würde ich sagen, ähm, äh, Position gleich 0 oder mehr am Anfang.
Aber so einfach ist das hier jetzt natürlich nicht.
AV Format Sieg File.
Warum ich doppelt machen muss, weiß ich nicht.
Weil Stack Overflow das gesagt hat.
Kannst du ein Video von mir kurz anschauen?
Und sagen, wie es ist?
Und ob ich das Video schneller machen soll, also oder nicht?
Es ist ein Tutorial Video für einen Bot.
Einer hat mich gefragt, ob ich ein Anleitungsvideo machen möchte für den Bot.
Was ich auch gemacht habe, was für mich war eher zu langsam.
Die Aktion.
Um was für ein Bot geht's denn?
Gibt ja viele Bots.
Aktuelle SSD Temps.
Wie liest man das aus?
Naja, das geht, dass das das hittet ja gar nicht immer die SSD.
Das hängt ja schon irgendeinem File System Cache oder so.
Kommt mir trotzdem nicht ganz richtig vor.
Hast du probiert, ob man beides machen muss?
Nö.
Ich hab das Stack Overflow kopiert.
Warte mal.
Nö, muss man nicht.
Man muss nicht beides machen.
Jetzt gucken wir mal, ob das andere auch gehen würde.
Ne.
Okay, man braucht nur das erste.
Man braucht nur das erste, wie es aussieht.
Äh, oder auch nicht.
Äh.
Vielleicht braucht man doch beides.
Man braucht doch beides.
Das war eben nur Glück, oder?
Oder nicht?
Hä?
Wartet mal.
The fuck?
Man braucht doch nur eins.
Das ist das Spack drumherum.
Wir müssen mal ein cleanes.
Wir müssen mal ein neues bilden.
So, und jetzt nochmal.
Ne.
Es reicht.
Es reicht nicht.
Guck mal.
Man muss beides machen.
Kackt ab, wenn man nur eins davon macht.
Ab und zu mal.
So kackt es nicht ab.
Sehr interessant.
1200 FPS.
Die Sekunde, wohlgemerkt.
Ja.
Aber richtig cool, dass es...
...so schnell ist.
Ich mein, mit gecachten Bildern ist es mit Sicherheit noch ne ganze Ecke schneller.
Keine Frage.
Geh ich mal, geh ich mal von aus, dass es, ähm...
...mit gecachten Bildern noch ne ganze Ecke schneller ist.
Ich mein, wir könnten es mal ausprobieren.
Da müssten wir quasi...
Na, wir könnten uns quasi die Bilder hier intern zwischenspeichern.
Das können wir mal, das können wir mal probieren.
Gucken.
Äh, mal einfach nur mal testen.
Was es für'n Unterschied macht, wenn wir die Bilder zwischenspeichern.
Ne Möglichkeit, um die Framerate zu setten.
Warum soll ich denn die Framerate setten?
Der soll doch die Framerate messen.
Hä?
Du siehst ein Memory Leak.
Wo ist es?
Zeig her.
Äh, private...
...list...
...frame.
Äh, pff, keine Ahnung.
Frames.
Jetzt haben wir zwei.
Einmal Frames klein, einmal Frames groß.
While true.
Frames... äh...
Okay, mal gucken, ob das, ob das so funktioniert.
Das jetzt noch mal zu checken, was es für'n Performanceunterschied macht, zu cachen.
Wenn du das Programm jetzt startest, geht's nach oben.
Hä?
Wie jetzt?
Warum soll... Ich hab da gar nichts gemacht.
Das pendelt sich ein bei irgendwie um die 100.
Äh, da liegt nix.
Da liegt nix.
Warum ist da ein Stier?
Die... die Chills, Chills der Playliste.
Warum geht die denn immer?
Da liegt nix.
Guck.
Äh, was heißt Fehler?
Hätte durchaus sein können.
Und jetzt bitte das GIF noch mit Multithreading.
Äh, wir Multithreaden ja im Prinzip schon.
Wir, wir rendern das GIF in dem einen und die Grafik in dem anderen.
Also wir decoden das GIF in einem Thread und rendern die Grafik in dem anderen.
So, jetzt mal gucken, wie viel das jetzt bringt mit gecachten Frames.
Okay, so.
Das heißt, wir machen das, wir breaken, also wir gehen raus, nachdem wir einmal durch sind.
End of File.
Und danach machen wir endlos, zum testen, endlos add, äh, Frames von, von dem Ding.
Oder wie machen wir das jetzt am besten?
Ne, das muss man, das muss man vorschleifen.
Muss man das machen.
Oder, wie machen wir das jetzt am besten?
Sind sie, wir gehen ja, wir breaken, wenn wir End of File sind.
Wir haben uns alle Files zwischengespeichert.
Go to, ja.
Doch, wir machen das mit einer Walschleife.
Wie machen wir das?
Wie machen wir das?
Wir machen C-Style.
C-N-T.
So, und dann sagen wir, add, Frames, add.
Ich bin mal gespannt, wie viel schneller das ist.
Das lassen wir aber nicht so.
Ich finde das andere schon schöner, wenn das direkt, weil ich will ja gar nicht so viel
RAM verbrauchen.
Das ist ja eigentlich nur ein Zweck der Sache.
So.
Add, Frame.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
So.
irgendwo irgendwo ist meine meine logik fail größer gleich doch es muss
wahrscheinlich größer gleich sein auch nicht wo ist das problem
unser letztes problem ach so ich sollte die frames nicht die pausen das wäre
vielleicht ganz praktisch moment was stimmt jetzt an meiner logik ich meine
es kackt schon mal nicht mehr ab das ist schon mal gut 0 immer 0
ach ich mache es pro durchlauf alter bin ich dumm guck mal richtig dumm ist der
kaknub kommt mal hier beim gleich mal doppelte bis dreifache anzahl wieder
schwankt es liegt es liegt da da heftig liegt es warum liegt das denn das
soll
du jetzt aber eigentlich nicht liegen das soll
wo kommt das memory league jetzt bitte schon her ich höre jedoch auf einzulesen
kommt das her das muss jetzt mal irgendeiner erklären wo das herkommt
wirst du nicht alten frames aus der liste wie moven
ja das mache ich ja hier das immer wieder in cash eingelesen hast glaube
ich nicht kommt das jetzt um liegt das denn jetzt es können ja auch gar nicht
mehr als 100 rein oder moment ich hab das level rausgenommen ich habe das
limit rausgenommen für die kohle für die block in collection
der schreibt wirklich jetzt unendlich viel da reine kassel verpackt hallo an
die unter aller sau was ist ein memory league er war da mal
bockers gekämpfte bilder fair macht was aus
bockers gekämpfte bilder der macht was aus
Guckt es euch an.
Gekashte Bilder ist das nochmal.
Da ist der schnellste Giftplayer quasi noch schneller geworden.
Jetzt sind wir schon bei fast 5000 FPS.
Oh mein Gott.
Also, ähm, in Memory League ist eigentlich relativ einfach erklärt.
Das, was der Flo96 sagt, ist so schon gar nicht verkehrt, wobei das nicht den Kern trifft.
Wenn der RAM-Verbrauch permanent steigt, die Frage ist natürlich,
warum steigt der RAM-Verbrauch immer weiter an.
Und in Sprachen wie, sagen wir mal, C, dort wo du dich um die Speicherverwaltung selbst kümmern musst,
ist eigentlich auch das Einzige, wo Memory Leaks auftreten können.
Und warum ich in C-Sharp Memory Leaks habe, ist, weil ich eben eine C-Library verwende.
Im Prinzip ist ein Memory Leak ganz einfach damit erklärt,
wenn du Speicher anforderst, aber den Speicher nicht wieder zurückgibst.
Das ist ein Memory Leak.
Wenn ich jetzt sage, Betriebssystem, gib mir Speicher.
Speicher, ich möchte was damit machen, kriege ich, keine Ahnung, ein MB Speicher.
Und, ähm, nächstes Mal, wenn ich was sage, wenn ich was brauche nach Betriebssystem,
ich brauche wieder ein MB Speicher, ohne dass ich den Speicher jemals wieder, äh, sage,
hier, kannst du wieder verwenden.
Das ist ein Memory Leak.
Ja, also sprich, ich gebe einfach nicht den Speicher wieder frei, den ich mal angefordert habe.
Ganz, ganz simpel gesagt.
Und was heißt ganz simpel gesagt?
Genau das ist es.
Du forderst Speicher.
Speicher an und gibst ihn nicht wieder, oder vergisst ihn wieder zurückzugeben und forderst weiteren an.
Und dann leakst du halt quasi Memory, weil, naja, du hast es angefordert, gibst es aber nie wieder zurück.
Letztendlich führt ein Memory Leak aber nie dazu, dass was kaputt geht.
Das Schlimmste, was passieren kann, ist, äh, dass es irgendwann mal Out of Memory gibt und du halt keinen Rahmen mehr kriegst
oder dein Programm abgeschossen wird.
Das, äh, wahrscheinlich eher dein Programm abgeschossen wird.
Also, eigentlich passiert nichts.
Weil spätestens, wenn dein Programm beendet wird, wird auch jeglicher Speicher wieder eingesammelt, den, den es jemals bekommen hat.
Also sprich, du kannst nur, und das ist eine ganz wichtige Geschichte, die man sich merken muss, du kannst nur Memory leaken, solange dein Programm noch läuft.
Das ist ja auch gerade der, der Effekt, den man hat bei Zeug, was ein bisschen merkwürdig programmiert ist, und zum Beispiel war es am Anfang Battlefield 4,
dass man das teilweise nach 2-3 Stunden...
Neu starten musste, weil das dann irgendwann 5 GB gefressen hat oder so, RAM.
Und nach, durch den Neustart vom Game beendet sich der Prozess, das Betriebssystem sammelt allen Arbeitsspeicher wieder ein, den es jemals diesen Prozess gegeben hat,
das weiß es ja, das wurde ja von ihm angefordert, und, ähm, sagt, jawohl, kann es wieder verwendet werden.
Okay, bei, seit über 3, man sieht es natürlich anders aus, ja, wir reden jetzt hier rein von User-Mode-Geschichten.
Aber ich muss sagen, hier dieser, der Player, der ist richtig hübsch.
Jetzt, oder?
Wir können das hier nochmal einrücken, bisschen anders, ich glaube, wir machen das mal alles...
Gucken, ob das so besser aussieht, wenn wir das alles auf eine Ebene machen.
Sieht das jetzt besser aus?
Ah, ich weiß nicht.
Sieht kürzer aus.
Dsch, dsch, dsch, dsch, dsch, dsch, dsch.
Ich muss sagen, ich finde den, ich finde den Gift-Player eigentlich ganz, ganz hübsch, jetzt, so wie er ist.
Vor allem jetzt, nachdem wir den Frame nochmal quasi, ähm, gekapselt haben,
finde ich den echt ganz, ganz...
ganz nett.
Ach so, ja, gut, jetzt müssen wir noch einen Sleep einbauen.
Okay, dann machen wir hier noch einen Public.
Wusste man zwar nicht, aber finde ich schöner.
Stream-Index brauchen wir auch nicht, ist immer 0.
Ähm, können wir tatsächlich Read-Only machen.
Ähm, wir machen jetzt noch hier was.
PS.
FPS.
Und das setzen wir.
Äh, äh, ähm, Stream-Frame-Rate, oder wie heißt der Scheiß?
Watch-Frame-Rate.
So, jetzt kriegen wir noch die FPS.
So, jetzt werden wir das Ganze nämlich ein bisschen begrenzen noch, weil aktuell ist ein bisschen, ein bisschen viel, ne?
Guck mal, was der ganze Spaß für CPU verursacht.
Ah, ja.
Ah, also wir brauchen gerade mal läppische 30%, ah, sag mal 33% CPU.
Also, quasi von einem 6-Kerne lasten wir zwei Kerne quasi komplett aus, gerade.
Komplett.
Was auch irgendwie Sinn ergibt, dass wir zwei Kerne komplett auslasten, ne?
Wir haben hier unseren Thread, der GIFs decodet.
Und wir haben hier unseren Thread, der wie verrückt rendert.
Also, das passt schon, dass wir zwei Kerne ziemlich gut auslasten.
Und das ist ein Beispiel halt für ein Problem, was sich super multithreaden lässt.
So, und wir werden jetzt mal...
...sleepen.
Wir, wir sleepen jetzt allerdings, äh, nicht einfach random irgendwie, sondern wir sleepen jetzt anhand der...
...na, irgendwie Time...
...das ist hier Decoder...
...FPS...
...hier 1000...
...1000...
...durch FPS, dann müssten wir eigentlich die Zeit, oder?
Die Zeit in Millisekunden haben, die wir sleepen müssten.
Da ist ein Double.
Ja, ich will's ja in Millisekunden.
Eins, eins durch Framerate ist ja null Komma irgendwas, ich will's ja, ich will's ja in Millisekunden, das müsste so doch eigentlich passen.
Time.
Oder ist das jetzt genau falsch rum?
Ne, passt doch!
Guck mal!
Genau, 25 FPS, so soll's sein!
Das ist der alte GIF-Player, also man sieht, 25 FPS sind 25 FPS.
Wenn man sich das anguckt, wird man verrückt, ne?
Mit der Zeit.
Das wird, da wird's voll schwindelig.
Man sieht, es ist nicht ganz synchron.
Guck mal, es läuft auseinander.
Jetzt weiß man nicht, was richtiger ist.
Mainz oder der WPF-Timer.
Es läuft immer weiter auseinander.
Ja, mit dem Timer könnte man das auch machen.
Aber wir brauchen halt, also wir bräuchten halt einen sehr, sehr präzisen Timer.
Ja, also das wäre schon, also mit, mit nem Timer, den man auf, ähm...
Da reichen noch nicht mal Millisekunden.
Also mal angenommen, wir wollen was mit 60 FPS haben.
Ne, dann bräuchten wir quasi 16,6, ne?
Ja, also das wäre schon, also mit, mit nem Timer, den man auf, ähm...
Da reichen noch nicht mal Millisekunden.
Da reichen noch nicht mal Millisekunden.
Also mal angenommen, wir wollen was mit 60 FPS haben.
Ne, dann bräuchten wir quasi 16,66, also irgendwie soweit, wie es geht.
Millisekunden.
Die Differenz der Zyklen, ja, das muss man auch machen.
Ne, das ist, also und sprich, wenn man es quasi nur mit 16 macht, wird man ja irgendwie, dann läuft man ja mit knapp unter 25, äh, FPS.
Also müsste man, ne, mit knapp über 25, umso kürzer die Zeit, umso, umso schneller.
Knapp über 25 FPS.
Also bräuchte man irgendwie nen Timer.
Der halt auch wirklich hoch auflöst.
Gibt's, gibt's .NET mäßig, mäßig sowas?
Gibt's, gibt's .NET mäßig, mäßig sowas?
Timer, Intervall, kann man, kann man die Inter...
Timer, Intervall, kann man, kann man die Inter...
Warte mal, das müssen wir mal gucken.
Wie sieht es mit Sleep...
Nanosekunden aus? Mikrosekunden aus?
Ähm...
Es gibt, es gibt das hier.
Es gibt Thread, aber das ist nicht schön.
Es gibt Spin Weight.
Da kannst du irgendwie, ähm...
Ich weiß nicht, ob's...
Sind's Nanosekunden?
Ne, das ist, glaub ich, irgendwie...
Schla... äh, so Internet-Schleifendurchgänge oder sowas.
Wir können ja mal Stack Overflow bemühen.
Wir können ja mal Stack Overflow bemühen.
C Sharp, Sleep...
Nanosekonds.
Wir können mal gucken, was, was Task Delay hat.
Wir können mal gucken, was, was Task Delay hat.
Millisekonds, Millisekonds, Timespan.
Millisekonds, Millisekonds, Timespan.
Na, wenn das Ding ne Timespan frisst...
Na, wenn das Ding ne Timespan frisst...
Programmierst du auch beruflich?
Ja, aber was anderes als hier...
Ich mach ja keine hauptsächliche Scroller damit.
Ich programmier auch Sachen.
Ich mach so das, was man neudeutsch DevOps nennt.
Ich mach so das, was man neudeutsch DevOps nennt.
Kann man hier nicht sagen New Timespan?
Kann man hier nicht sagen New Timespan?
Also erstmal gucken, ob das generell mit dem...
Also erstmal gucken, ob das generell mit dem...
Delay... Wie macht man das jetzt? Weight?
Nicht wirklich, oder?
Was hat man? 40 Millisekunden für 25 FPS, ne?
Was hat man? 40 Millisekunden für 25 FPS, ne?
Okay, der Task Delay ist Fail.
Okay, der Task Delay ist Fail.
Der funktioniert nicht richtig.
60 FPS funktionieren hier.
60 FPS funktionieren hier.
60 FPS.
Ja, und hier sieht man jetzt, dass halt der...
Ja, und hier sieht man jetzt, dass halt der...
Das nicht so ganz stimmt.
Das immer ein bisschen schwankt.
Wie könnten wir denn das jetzt...
Wie sleept man denn hier ordentlich?
Wie könnten wir denn das jetzt...
Oder besser gesagt...
Moment.
Wie gut auflösend sind denn die Timer?
Wie gut auflösend sind denn die Timer?
System Threading Timer.
System Timer.
System Windows Timer.
Okay, was ist der Unterschied dazwischen?
Timer Callback.
Timer Callback.
Okay, der sieht kompliziert aus.
Der kann bestimmt was.
Period.
In Millisekonds. Alles in Millisekonds.
Timers.
Was haben wir hier zu bieten?
Intervall. Millisekonds.
Intervall. Millisekonds.
Was haben wir hier zu bieten?
Intervall. Millisekonds.
Intervall. Millisekonds.
Intervall. Millisekonds.
Intervall. Millisekonds.
Query Performance Counter...
Das gibt's bestimmt schon managet.
Das ist...
Ich mein...
Ich hätt ne ganz blöde Idee, ne?
Ich mein...
Flo, das hast du gut beobachtet.
Flo, das hast du gut beobachtet.
Das können wir mal ausprobieren.
Timer, Timer...
Er akzeptiert aber Double.
Er akzeptiert aber Double.
Das könnten wir echt mal ausprobieren.
Also sprich, dass man da jetzt...
Also sprich, dass man da jetzt...
16,777 oder nee, was war's?
16,777 oder nee, was war's?
Ja.
So. Mal gucken, wie wir das jetzt machen.
So. Mal gucken, wie wir das jetzt machen.
Also von der Idee her müssen wir uns jetzt ja die Schleife hier schenken.
Also von der Idee her müssen wir uns jetzt ja die Schleife hier schenken.
Und der Renderkrempel müsste eigentlich da...
Und der Renderkrempel müsste eigentlich da...
rein jetzt, ne?
Wenn ich das jetzt richtig sehe.
Es kann aber auch sein, dass wir es voll verkacken.
Achso, vielleicht sollte man mal starten.
Start.
33?
33?
Warum 33?
Check ich's jetzt nicht?
Das Ding sollte doch...
33?
Warum 33?
Ich glaub, der timet einfach nicht so genau.
Nee, der ist einfach nicht so genau,
der Timer, der ist schlecht.
Ich mein, wir wollen jetzt hier alle 40 Millisekunden
Ich mein, wir wollen jetzt hier alle 40 Millisekunden
einen Tick haben und...
Hast du noch einen Sleep drin?
Nee.
Ja, aber wenn's mit 40 schon halt geht...
Clocks HD...
Also, der Timer ist irgendwie nicht sonderlich
Precision-mäßig.
Das Drawn geht schon nicht.
Das Drawn braucht doch keine...
Das Drawn braucht nix.
Ja, aber mein Code braucht keine...
Ja, aber mein Code braucht keine...
Ohne Timer geht's ja auch
Ohne Timer geht's ja auch schnell.
Also, mit nem normalen Sleep funktioniert's ja.
Also, mit nem normalen Sleep funktioniert's ja.
Also, daran kann das schon mal nicht liegen.
Also, mit dem Timer klappt das nicht.
Ich hab aber ne ganz blöde
andere Idee.
Pass mal auf.
Ist bei GIFs nicht die Zeit
zwischen den einzelnen Bildern in der GIF selbst
hinterlegt?
Das kann durchaus sein.
Das kann durchaus sein.
Das kann durchaus sein.
Warte, wo schreib ich auf Englisch?
Warte, wo schreib ich auf Englisch?
Meinst du hier drinne?
Ja, Source Code schreibt man
immer auf Englisch.
Ja, aber Leute, das macht doch überhaupt
keinen Unterschied. Lass es mal ne Millisekunde
dauern, wie das
hier Ding. Das kann aber trotzdem nicht sein,
dass der Timer auf einmal anstatt 60,
obwohl ich die Zeit für 60 FPS angegeben habe, auf einmal
33 hat.
Achso, das Tastaturlayout. Hab ich nicht.
Ich hab das Tastaturlayout auf Deutsch.
So, also. Wir machen jetzt mal
sowas hier. While True.
Das ist natürlich
der Hardcore-Ansatz
sowas zu machen.
Also,
wir machen jetzt sowas wie
While True und dann
sleepen wir irgendwie zwischendurch.
Irgendwie sowas.
Das funktioniert.
Das wird auf jeden Fall funktionieren.
Können wir das irgendwie mit DateTime machen oder so?
Wobei, wir haben hier oben doch schon
ein DateTime gesetzt.
StartTime.
Warte mal, ich probier das jetzt mal aus.
StartWait.
Wobei,
ne, mit DateTime komme ich da wahrscheinlich nicht weiter.
Mit StopWatch.
Mit StopWatch könnte man
da irgendwas machen.
Mit StopWatch.
Was war eine Imageinstanz dort?
Den aktuellen Frame Index.
Und Last Update Millisekunden.
Image Update.
Leuchtet mir grad nicht ein.
Achso, du checkst vorher,
ob es Zeit zum updaten ist.
Du machst das nicht alles hier in
so einem riesen Durchlauf,
sondern du checkst quasi so nach dem Motto
gibt's ein Update, ist es Zeit zu updaten
und wenn es Zeit zu updaten ist, dann wird gemalt
und gestort.
Ticks. Oh, nice.
Ticks. Ticks brauchen wir.
Okay, die meinen das ernst.
Ticks.
Wie lang ist denn ein Tick?
Paar Nanosekunden
oder so?
Ne, Ticks sind nicht Millisekunden, Ticks sind irgendwas
mit Nanosekunden oder so.
How long is DateTime
Tick?
Nanoseconds.
Na, Ticks
mal 100
sind Nanoseconds.
Oder?
Sehe ich das hier richtig?
Ticks mal 100 sind Nanoseconds.
Okay.
Nanoseconds würden mir schon reichen.
Ah.
Haha.
Das ist ja nice.
Ticks per Millisecond.
Aha. Oh, das ist gut.
Stack Overflow.
Heute sind wir richtig Stack Overflow
driven.
Ich will das jetzt einfach mal rauskriegen,
ob das so funktioniert würde.
So.
Jetzt gucken mir gerade wieder 140 Leute zu.
Wie ich keine Ahnung hab,
was ich machen kann.
Gibt es nicht vielleicht einen
C-Sharp?
Das wäre mir natürlich am allerliebsten.
Da muss ich den ganzen Wait-Scheiß nicht selber machen.
High Resolution
Most Accurate Timer.net
Das hat doch bestimmt schon
irgendeiner programmiert.
Github C-Sharp Timer.
High Precision Timer
in .net
Zack. Easy.
Wie macht der das?
Ah, mit dem Windows Timer.
Das können wir auch machen.
Was ist das für eine
WinMM
DLL?
Media Timer muss ja genau sein.
Dann machen wir das doch damit.
Dann machen wir das doch damit.
Wobei mich ja doch interessieren würde,
wie man sowas hier hinkriegt.
Probieren wir das mal mit dem Windows Timer.
Ich glaube, das ist die bessere Variante.
Warum ist es hier schwarz?
Man weiß nicht.
Vielleicht gibt es aber schon fertige Projekte.
Da gibt es ein paar.
Okay, wir machen das mal wie hier.
Ich finde das hier klingt gut.
Time Set Event
Wir klauen uns jetzt mal
hier den Aufruf
von ihm, wie er das gemacht hat.
Also wir klauen uns das nicht.
Wir holen uns die API Definition raus.
Ah, hier hat er es nämlich.
Callback
Gucken wir mal, ob das funktioniert.
Wir rendern
mal gerade nichts.
Wir gucken einfach nur mal, ob das geht.
Blablabla
Time Set
Timer Callback
Das sieht von der
Methode her
relativ simpel aus.
Von der Signatur her.
Also.
Set
Time
Time Set Event
Time Set Event
So, und dann sagen wir
Kleine Stars
Diese Promifrauen sind unter 1,60m
Das wollte ich schon immer mal wissen.
Von gofeminin.de
Milliseconds?
Moment.
Ich will keine Milliseconds.
Wobei doch, Milliseconds
mit Komma ist okay.
Was sagt denn die Microsoft-Hilfeseite dazu?
Wartet mal kurz.
So, was sagt denn die
Microsoft-Hilfeseite dazu?
In Milliseconds.
In Milliseconds.
Ich will das doch nicht
in Milliseconds haben.
Warum ist das Scheiß auch wieder in Milliseconds?
Alter,
geht mir das auf den Keks jetzt.
Was?
Query Performance Counter
Was ist das?
Oh,
Times...
Oh, ja, das ist schön.
Das wollen wir haben.
Sag das doch gleich.
Dann machen wir einfach jetzt eine while-Schleife
while true und gucken einfach
Warum nennt man das
UTILAVOR des Milliseconds?
Ich fühle unsigned.
Weil das ein unsigned int ist.
Ich weiß, dass du es
gleich schon gesagt hast.
Query Performance Counter.
Query Performance Counter.
QPC und was ist QPF?
QPC und was ist QPF?
Query
Performance
Ah.
Frequency of the Performance Counter.
Frequency of the Performance Counter.
Die Frequenz, in der sich der Performance Counter
updatet, oder was?
Man sieht, wie groß die Sprünge sind
zwischen den
Countern.
Oder wie darf man das verstehen?
Query Performance Counter.
Jetzt, Achtung, schönes neues
C Sharp 7 Feature.
OUT
OUT war
COUNTER. Nichts damit extra Variable
anlegen und jetzt
COUNTER ausgeben.
Aha, jetzt bin ich mal gespannt.
Weil...
Flutscht.
Achso.
Und das heißt, hiermit sehe ich quasi den
COUNTER, der sich erhöht.
Nur mal so, dass ich das jetzt richtig verstehe.
Ich habe hier einen COUNTER, ich weiß allerdings nicht, wie genau, wie lang
eine Einheit ist. Wenn ich wissen will, wie lang eine Einheit
ist, dann muss ich hier reingucken, ne?
Oder ist das ein Timestamp
in...
in was?
Mikrosekunden, okay.
Können wir mal ausprobieren.
Beruflich mache ich das in vielen Sprachen.
Also, was natürlich,
wenn man ein bisschen mit Linux zu tun hat,
immer der Fall ist, ist
irgendwelche Shells. Bash.
Ich mache ganz gerne in Ruby was, wenn es nicht schnell
sein muss.
In Groovy habe ich auch ein paar Sachen
gebastelt schon. Wenn es geht,
.NET. Mit .NET Core geht der auf
Linux mittlerweile auch.
Mache auch die eine oder andere JavaScript
Frontend-Geschichte, wenn es sich nicht vermeiden lässt.
Ein paar Sachen. Also, am liebsten
mache ich eigentlich was in Ruby, wenn es
nicht auf Performance ankommt.
Ruby und .NET ist für mich so auf einer,
also C-Sharp und Ruby ist für mich so auf einer
Ebene.
Okay. Also,
das heißt, nur mal so. Wir machen das
jetzt mal ganz billig. Wir machen jetzt
eine Schleife und pranken die Schleife, sobald
wir quasi
ähm
40 Millisekunden
oder sagen wir mal 16
16, irgendwas
Millisekunden
gewartet haben. Irgendwie so.
So.
Oder besser gesagt,
äh, 16.000
Mikrosekunden
Also, gucken wir mal.
Äh, mal.
Query Performance Counter
Ich habe irgendwas im Hals.
So, und dann brauchen wir jetzt noch das andere.
Das heißt, dann brauchen wir jetzt noch
weil es die gleiche
Signatur hat, ne.
Okay, das müssen wir nur einmal querien.
Hab ich auch gerade gesehen.
Äh, ich weiß
jetzt gerade nicht, wie wir es nennen sollen.
Query
Performance Frequency
Out
War
Äh
Timespan
Irgendwie so.
Was machst du dort gerade? Ich bastel
ein transparentes
Gif-Overlay
für mein
Meme-Board.
Weil das Standard-WPF-Overlay, wie du hier siehst,
viel zu langsam ist.
Siehst du, du klickst.
Zack.
Klick.
Zack. Klick. Zack.
Viel zu langsam.
Bei kleinen Gifs geht es ganz schnell.
Aber ich habe jetzt was eigenes gebastelt.
Was viel schneller ist.
Das spielt Gifs
mit 4273
FPS ab.
Was kein Mensch braucht.
So, jetzt gucken wir gerade, wie wir am besten warten
auf das nächste Mal, wo wir rendern müssen.
Ja.
Ganz wichtig, nicht einfach FPS,
sondern FPS in der Sekunde.
So.
Performance Counter
Ups.
So, jetzt hängt er nach einmal rendern,
hängt er jetzt hier. Ja, genau.
So.
Das bedeutet doch jetzt
nur mal so von der Idee, also
wenn ich jetzt hier einmal ausgebe
quasi den, den, den, den
die Timespan
Also das da
ist quasi
die Zeit
zwischen zwei Ticks
von diesem Performance Counter.
Oder?
Wo habe ich das denn jetzt?
Frequency. Oder?
Nee, Moment, Moment, Moment.
Das ist das, nee, das ist wie, wie,
wie schnell der updatet, oder?
Gibt es das wieder aus 2000?
Aha. Genau.
Counter durch Frequency. Okay.
Was kommt dann da am Ende raus?
Nennen wir es nicht Timespan.
Nennen wir es
Frequency.
Das ist, ist das eine Sekunde?
Das ist jetzt pro Sekunde,
ne? Aha.
Okay, das, das ist aber echt
interessant.
Lange Mikrosekunden, ja.
Also ganz, so ganz habe ich es jetzt aber noch
nicht gecheckt, wie wir das machen.
Ähm.
Warte mal. Also sprich, was sehe ich
denn hier jetzt überhaupt?
Das updatet sich einmal in der Sekunde.
Das ist die, der Counter,
der geht permanent rauf und das
geteilt durch die,
durch die Frequency.
So, also das bedeutet
jetzt haben wir hier die Frequency.
Was?
Wahr,
das ist kein JavaScript, wahr.
Wie checke ich das nicht, was ich, was ich
da jetzt eigentlich für eine Zeit habe?
Also wenn ich das hier jetzt habe,
wenn das jetzt in der Sekunde ist,
also es leuchtet mir ehrlich gesagt
nicht ein.
Was soll das jetzt genau sein?
Ah.
Ah. Der query das hier
am Anfang an, speichert er sich das irgendwo?
Wo speichert er sich das? Da?
Muss ich das nicht hier oben speichern?
Warte mal. Äh.
Counter start, Counter start. Das ist im Prinzip
ein bisschen, was ich oben beim FPS-Counter
auch mache, oder? Ähm.
Also brauche ich hier sowas wie
Last.
Hä? Ich will im Prinzip
doch einfach nur wissen,
ob ich jetzt schon 60
Millisekunden gewartet habe.
Oder in dem Fall 16 Millisekunden.
Also. Äh.
Wie macht man das da draus?
Ähm. Oder scheiße.
Ist die Sharp stark von C++? Ja.
Was? Double counter?
Ich kann sowas nicht copy-pasten.
Ich muss das selbst ja erstmal checken, was ich da hab.
Jaja, dass das die Millisekunden
sind, das ist mir schon klar.
Aber ich will doch einfach gucken, ob ich mehr als
ob ich mehr als, ähm.
Ich muss die zwei Sachen
miteinander vergleichen.
Also ich muss mir einfach, ich muss mir
einmal start holen.
Start counter.
So, und im Prinzip muss ich doch jetzt eigentlich
nur gucken, ob ich jetzt
ob das hier
größer
Start counter.
So, und hier muss ich
jetzt dazu rechnen,
was ich brauche zur Zahl
für Millisekunden.
Also irgendwie, keine Ahnung.
Wie auch immer, wie viel das ist.
So, wenn ich das jetzt
dazu rechne, dürfte es dann
bei einer Sekunde sein.
Jaja, geh aus.
Ne, nicht plus Frequency.
Genau, das jetzt einmal in der Sekunde.
Wir können mal gucken,
was passiert. Genau, aus keinem Fokus.
Sowas in der Richtung hab ich auch gar nicht.
Wenn man die Krams voneinander abzieht,
da müsste ja was relativ Kleines
rauskommen. Genau.
So.
Und das?
Aber die Frequency
ist ja nicht in Millisekunden.
Irgendwie ist das der übelste
Brainfuck dieser Kram, ey.
Achso, Break soll ich doch einmal.
Das ist, das ist übelst
um die Ecke, ey.
Ich glaube, ich habe heute schon zu lange
vom Rechner gesessen, um das zu checken.
Stimmt das jetzt?
Gibt das jetzt irgendwie Sinn, was ich da gebastelt habe?
Ja klar kann man es mit einem kleinen Sleep ersetzen.
Das ist ja auch
genau genug.
Ich glaube, ich bin noch nicht in der Lage sowas zu checken mehr.
Das ist echt Wahnsinn.
Ich habe komplett...
Ich kann gerade keinen
klaren Gedanken fassen, was so ein bisschen
Logik anbelangt, ey.
Es war halt einfach
schon zu lange rumgebastelt.
Jaja, das GIF hat, das GIF
hat 25 FPS. Das ist easy.
Das ist überhaupt kein Ding. Aber ich will ja trotzdem gucken,
wie ich konstante 60 FPS
hinkriege. Würde mich einfach mal interessieren.
Ja, Timer, Timer
habe ich keinen gefunden, der genau genug ist.
Ich mache jetzt mal kurz was.
Ha, Flo, die Idee
ist gar nicht so schlecht.
Ich meine, von der Idee her war das am Anfang richtig.
Wenn mein Counter
größer ist als
Start-Counter und jetzt
halt hier quasi sowas wie
plus 16
Millisekunden in Ticks.
So, kann ich jetzt nicht sagen. Okay.
Frequency, Frequency ist
das was pro Sekunde, ne?
Frequency ist
Ticks.
Frequency ist Ticks von diesem Counter pro Sekunde.
Das heißt,
was kommt da jetzt raus?
Ist das jetzt Teil durch 16 Millisekunden?
Ich will
rauskriegen,
wie viel
Frequency
quasi 16
Millisekunden, also wie viele
Ticks quasi 16 Millisekunden
entsprechen, ne?
Was das bedeutet.
Ich muss was ausprobieren.
Einfach mal gucken, wie viel da ungefähr rauskommen muss jetzt.
Aha.
Also irgendwas in
dieser Größe.
Ich kann heute nichts mehr umrechnen.
Ich bin nicht in der Lage, irgendwas zu rechnen gerade.
So, also irgendwas um
50.000 muss da rauskommen.
Das ist irgendwie in dem Dreh und das ist auch
relativ konstant.
Ist das nicht...
Wenn ich 60 mal,
wenn ich quasi weiß, das ist
pro Sekunde und ich weiß,
das ist pro Sekunde. Da kann ich das nicht machen.
Kann ich das doch eigentlich durcheinander teilen, oder?
Oder? Ich meine, von der Idee
müsste es doch sowas hier sein.
Aber aus irgendwelchen Gründen ist es das nicht, oder?
Oder ist es das doch?
Was?
Kann man auch machen, müsste aber doch keinen großen Unterschied sein.
Ne, so
kein Unterschied.
Ist doch genau das gleiche im Endeffekt.
Weil es beides, ist doch beides
pro Sekunde. Das müsste doch im Prinzip,
das müsste doch eigentlich genau das gleiche sein.
Echt doch.
Ups. Äh. Moment.
Was habe ich jetzt falsch gemacht?
Ich kann echt nicht mehr denken heute.
Hä? Hä?
Ich blicke nicht mehr durch gerade.
Das würde doch keinen so großen Unterschied machen.
Nö.
What the fuck?
Warte mal, das ist irgendeine...
Das ist irgendeine
Conversion-Geschichte.
Ja, weil ich meine im Prinzip,
das da, wenn ich das
jetzt da von Hand eintrage, geht das ja auch.
Aber das... Warum
ging das vorher nicht?
Auch von 9000, ja.
Das ist irgendeine Conversion-Geschichte.
Stimmt. Ja.
Okay, das hatte ich doch vor 5 Minuten schon mal.
Was ist denn jetzt daran verkehrt?
Das ist doch von der Logik her okay, oder?
Das müsste doch...
Das sieht nicht so aus, wie man normalerweise performt.
Ich habe auch keine Ahnung, wie man das macht.
Wisst ihr was?
Da muss ich mir nochmal Gedanken drüber machen,
wie wir das am besten machen.
Hier drinnen zu sleepen ist eh keine sonderlich clevere Idee.
Aber ich meine, wir können das jetzt
als erstes mal kurz...
Als erstes mal...
Für heute können wir das so lassen.
Ich meine, prinzipiell funktioniert es ja, ne?
25 FPS GIF.
Passt.
Start Counter vorm Rendering Hall.
Okay, machen wir.
Ich mache jetzt alles.
Ich kann heute eh nicht mehr richtig denken.
Du meinst aber schon vorm Durchgang, ne?
Pro Durchgang.
Jetzt ist es sogar
ein bisschen zu schnell.
Aber das liegt daran,
wahrscheinlich, dass ich hier Kommastellen
verliere, irgendwie, ne?
Wobei mir das jetzt ja mal einer erklären muss.
Was hat er denn jetzt? Was macht er hier wieder für Conversion-Dinger?
Das sind...
Zack!
Ah...
Damit kann ich leben.
So...
Das sieht doch jetzt ziemlich gleich aus, oder?
GIFs übertaktet, yeah.
Ja, TiraFox, das klingt logisch.
Ich muss ja nochmal Gedanken drüber machen.
Von der Logik her müsste es doch stimmen,
weil ich da gewastelt habe, oder?
Ich meine, das GIF sieht jetzt auch schön Sync aus.
Das ist präzise genug.
Drawzeit abziehen.
Naja, das ist nicht lang.
Wollen wir mal messen, wie lange
das eigentliche Malen dauert?
Können wir mal gucken.
Gucken wir mal.
Wir gucken mal, wie lange das dauert.
Einmal malen.
Ja, und das stimmt, die Drawzeit wird tatsächlich abgezogen,
weil wir den Krams am Anfang nehmen.
Da habe ich jetzt gar nicht dran gedacht am Anfang.
Gucken wir mal, wie lange das dauert hier.
Also, wo fangen wir an?
Das eigentliche Malen ist ja hier.
Start.
Painter. Paint.
Bis da, würde ich sagen, ne?
Hier oben müssen wir übrigens...
Reset müssen wir an der Stelle machen.
Ne, nicht Reset. Stop.
So.
Gucken wir mal.
Ein paar Millisekunden.
So, und danach.
Aber Reset.
Äh.
Dauert keine Millisekunde.
Gucken wir mal.
Das braucht nichts im Endeffekt.
Ein Tick sind 100 Nanosekunden irgendwie an der Stelle.
Ja.
Das Drawn braucht nichts.
Das braucht wirklich
unter einer Millisekunde.
Ja.
Gucken wir mal.
Unter einer halben Millisekunde
braucht das Ganze.
Das Drawn.
Das ist nichts im Endeffekt.
Das ist wirklich nichts.
Eigentlich könnten wir anstatt...
Wir könnten auch den Stopwatch-Timer da unten nehmen, ne?
Was?
Wenn das Drawn länger dauern würde, wie lange würden dann 3D-Spiele dauern?
Lange.
Das muss schnell gehen.
Ich meine, wir Drawn ja hier im Endeffekt auch nichts, ne?
Ne, ne.
Das mache ich schon selbst alles.
Wir machen hier im Endeffekt auch nichts, ne?
Wir haben hier oben ein paar komische
Scale und...
ähm...
Na...
Transparenz-Geschichten und...
ähm...
Dann malen wir noch einen FPS-Counter unten im Bild.
Also...
Das ist im Endeffekt ja nichts.
Übrigens, das...
Das geht aus dem Bild raus, oder?
Das geht aus dem Bild raus.
Seht ihr es?
Den lassen wir mal...
Den lassen wir mal 20...
22 Pixels weiter unten starten.
Ja, jetzt ist es besser.
Wobei...
Nicht weiter unten,
20 weiter rechts starten.
20 weiter rechts starten.
Ja.
Oder?
Ne, ich glaube oben klippt er.
Oben klippt er.
Ja, oben hat er ein bisschen geklippt.
So, machen wir das Ganze erstmal mit 5 FPS.
Rechts...
Und oben...
Klippt er oben? Oben klippt er noch ein bisschen, oder?
Oben klippt er noch.
Aber es könnte sogar sein, dass das
im Bild so ist.
Machen wir mal oben ganz viel
Abstand.
Ah, ne, okay, nochmal 30 oben.
Muss ich mal gucken, warum das oben überhaupt klippt.
Ja, so ist gut.
Hier oben, das ist
im Bild so, dass der oben kurz geklippt ist.
Wunderbar.
Zack. Bäm.
Sehr schön.
Das ist doch nice.
Das gefällt mir.
Durchklicken.
GIF am Start.
Und, ich mein, guck mal.
Wir brauchen jetzt
90 MB.
Machen wir mal, stellen wir das Ganze
mal wieder um auf Window Only.
Window Only stellen wir das Ganze
um.
Release Mode.
Wir brauchen
ziemlich genau 88 MB.
Ah.
Oder auch nicht.
Äh.
80?
Hä?
Was für eine komische Anzeige.
Angeblich haben wir 80.
Gut, hier oben ist 89.
Also wir brauchen 80 MB
im Vergleich zu 850.
Und es startet übel schnell.
Also wenn man sich überlegt, dass
guck mal, es startet jetzt die ganze,
das ganze Programm startet jetzt.
Wohlgemerkt.
Und das, das startet,
das ganze Programm startet schneller
und zeigt das GIF an,
als das, das andere.
Jetzt nehmen wir mal ein großes GIF,
was beim anderen Probleme macht.
Zum Beispiel, ähm,
Brain, irgendwas mit Brain.
Mindblown heißt das Ding hier.
Mindblown.
Das GIF brauchen wir jetzt noch.
Ups, jetzt hab ich's gelöscht.
So.
Ich hab mich irgendwo verschrieben.
Und auch übelst flüssig im Vergleich
zum anderen, ne?
Wir könnten, wir könnten noch das,
das Bilder, das Bilderscalen könnten wir
noch ein bisschen schöner machen.
Weil hier sieht er besser aus.
Guck mal.
Fehlt da ein bisschen was?
Oder ich glaub mein, ich glaub mein Scaling ist nicht
ganz so sinnvoll.
Mein Scaling ist nicht ganz, äh, richtig,
würd ich sagen.
Nee, mein Scaling ist nicht so ganz korrekt.
Sagen wir mal so,
hier ist er schöner skaliert.
Wobei, Leute,
ohne Scheiß, ich würd fast eher sagen,
mein Scaling sieht mir irgendwie,
also,
von Abmaßen her scheint mir das aber,
guck mal, wie flüssig das hier ist.
Seht ihr das, wie flüssig das ist?
Und wie sehr es da rumbleckt.
Wir können das noch mal ein bisschen ändern,
wie er das Ganze macht.
Wir können jetzt mal hier,
Nearest Neighbor ist das Schlechteste von der Qualität,
mit dem Cubic.
Beste Quali.
Ja, guck, jetzt sieht's auch gleich besser aus.
Na doch, es ist nicht ganz gleich
groß, guck mal.
Wir müssen doch mal einen anderen Hintergrund
nehmen.
Guck mal, es ist nicht ganz gleich groß, es ist, äh,
es ist ein bisschen,
meins ist ein bisschen kleiner, ne?
Ich mein,
jetzt ist es gleich,
jetzt ist es ungefähr gleich breit,
aber das hier ist ein Stück höher.
Also, das heißt,
bei mir fehlt ein Stückchen.
Würde ich mal sagen.
Bei mir fehlen ein paar Pixels.
Ja, TeraFox,
guck ich mir an, ich muss wieder, ich kann heute nicht mehr
mir großartig Gedanken zu machen.
Normalerweise ist das bestimmt, äh,
eigentlich nichts schwieriges.
Ah, hier fehlt oben und unten ein bisschen was.
Aber,
das passt schon.
So, nice.
Das können wir jetzt dann einbauen, das nächste Mal.
In das eigentliche Tool,
wofür wir das Ganze gebastelt haben.
Und dann dauern GIFs nicht mehr
drei Sekunden zum Anzeigen, sondern sind instant da.
Äh, die PNGs
könnten wir übrigens auch noch mit, äh,
dann eigentlich auch noch mit FFmpeg
machen. Sehr schön.
Gefällt mir auch.
So, Leute, ähm,
genug für heute.
Der GIF-Player funktioniert ziemlich gut.
Sag mal, verlieren wir immer noch irgendwo
Speicher? Kann das sein? Ne, der muss,
der braucht einfach eine Weile, bis alles geladen ist.
Guck mal, das ist ein Riesenunterschied,
das fette GIF, komplett,
äh, gecached,
braucht 160 MB,
wohingegen das in WPF 850
braucht.
Das ist schon ein Unterschied.
Ja, das ist schon ein Unterschied.
Ne, der Server ist da nicht dabei. Insgesamt
braucht das Zeug irgendwie 180.
Das, ähm,
ASP.NET Core plus das WPF-Fenster.
Aber sobald ein GIF geladen wird,
geht's ja irgendwie hoch auf 850,
900 oder so. Also sagen wir mal so,
okay, sagen wir das GIF braucht, braucht
700. 700 braucht das GIF.
Und das liegt einfach daran,
wir können uns das hier grad nochmal angucken,
guck mal, ich hab jetzt ein paar GIFs
geladen, Instant 2G voll.
Alter, kann doch nicht sein.
Jetzt geht's wieder runter,
auf
760. Guck mal,
jetzt sind wir bei 760 und jetzt mach ich
das GIF hier an, äh,
das GIF hat eine schlechte Position.
Guck,
1,1.
Also da sind wir schon besser.
Na ja, nicht ganz, es ist, ähm,
es ist tatsächlich
nicht ganz so viel, aber es ist ordentlich.
Also irgendwie, keine Ahnung,
400 aus uns immer noch.
Und ich glaube,
hat er auch nicht alle aus dem Garbage Collector geschaufelt.
Also das ist nicht sonderlich
optimiert, ähm,
dieses, dieses WPF-GIF-Ding.
Da sind wir
hier doch schon deutlich besser mit dabei, oder?
Da sind wir schon deutlich besser
mit dabei. 120,
120 MB oder so.
Und wenn wir das Ganze nicht cachen,
das können wir jetzt, glaube ich, gleich auch nochmal ausprobieren,
wie viel wir dann haben,
und ich hoffe, ich hab mir den Kram irgendwo gespeichert.
So, mal das übliche.
Rückgängig, rückgängig,
rückgängig.
Rückgängig, rückgängig, rückgängig.
Wo hab ich mir gespeichert, den Scheiß?
Lol.
Wenn ich mich jetzt verdrücke, ist alles weg.
Ich muss ja nicht speichern. Da!
Und wieder vorwärts.
Dafür hat man eigentlich, äh, ein Git oder so was.
So, mal gucken,
wie viel das ist. Wenn ich's nicht cache,
dann für 25 FPS
reicht's natürlich immer noch.
Achso, ich muss ja die Frames freeen.
Sonst, sonst leaken wir.
Na, guck!
118. Das ist doch top. Da kann man sich
echt nicht beschweren.
Und ich könnte wetten, wenn wir das, wenn wir jetzt wirklich so
so RAW-Window aufmachen würden,
ohne Forms und ohne den ganzen Geschiss,
wären wir wahrscheinlich unter 100.
Ey, aber man darf nicht vergessen, ich mein,
Bilder brauchen halt einfach ein bisschen Speicher.
Platz.
Unkomprimierte Bilder, ne? Ich mein,
es hat ein bisschen was.
Kannst du aber ausrechnen.
600 mal
600 mal 4.
So.
Hallo,
Google, please.
So.
Bytes to MB.
Okay, das ist nicht so wirklich viel.
Aber, Bilder brauchen halt
ein bisschen was. Vor allem, wenn sie größer werden.
Warte mal.
Doch, hab ich richtig gerechnet.
Da hab ich noch was vergessen.
Also, kleine Bilder gehen noch.
Stell dir mal ein unkomprimiertes Video vor.
Das ist in der Regel, also
rein das, ähm, rein das Anzeigen
ist ziemlich, äh, angenehm,
weil du nix decoden musst.
Also, schnell, also, vorausgesetzt,
man kann es schnell genug lesen,
ist das super. Das hat kaum CPU-Last.
Unkomprimierte Videos.
Weil du halt nix decoden musst.
Die sind halt riesengroß.
Ja.
Also, wenn du mit deinem C++
Zeug dann quasi 60 MB
hast.
Ich hab hier noch ein bisschen Managed-Krempel drumherum.
Dann ist das, ist das mit 100 MB
oder sowas, was das hier hat.
Und wie viel hatte das hier jetzt?
Ja, dann ist das doch vollkommen okay.
Das ist ja 118, das ist doch top.
Kann man nix sagen.
Ja.
Denk ich auch.
120 MB ist wirklich
top. Und man muss sich mal angucken, wie
sauschnell das ist, ne.
Das ist halt einfach instant.
Und man muss es halt mal ohne Debugger machen hier.
Zack, da. Das ist nix.
Wir müssen uns noch
ein bisschen um das Handling kümmern, also wir müssen
noch Resizen und so einbauen.
Das müssen wir noch
machen. Da hat man noch
Resizen können, das Fenster.
Das müssen wir noch einbauen, das machen wir aber das nächste Mal.
Ja Flo, du machst
das nächste Mal den Gift Player in Assembler, easy.
Dann verwende ich den auch.
Wenn du mir den in Assembler
machst, auf, go, go.
Ja, da kannst du
im Prinzip, da muss ich jetzt
Theorafox schon recht geben, im Prinzip kannst du ja nicht
so viel unterschiedliches speichern, eigentlich, ne.
Du hast halt deine 3 Bytes
für Farben und hast halt 1 Byte für Transparenz,
man.
Was willst du mehr machen?
Das einzige, wo du variieren kannst, ist halt, dass
du wieder die RGB-Dinge
anordnest, jetzt halt BGRA,
RGB,
äh, GAA, was auch immer
es da alles für Varianten wahrscheinlich gibt.
Wie heißt
bei C-Sharp nochmal
der Krams, den man
mit, äh, Attribute meinst du?
Juff, gibt's auch noch,
ja, da ist da Colorspace ein bisschen
anders und
noch paar andere Sachen, die ich jetzt
weiß jetzt nicht genau.
Ja Patrick, auf geht's, Assembler,
go, go.
Also, Tyra Fox, ich hab mir grad mal dein C++
Beispiel angeguckt, was ich nicht checke
ist, du machst ja ganz unten
Sleep 4 Milliseconds.
So, und dann mal 1000.
Was für eine Zahl übergibst du denn
Sleep 4, was steht denn da drinnen so
als Beispiel? Sag mal ein Beispiel
als Zahl.
Steht da da irgendwie sowas drinnen wie
16,7 oder was?
Das ist richtig,
das hat der Auskennfuchs recht,
ähm, das könnte man noch viel
schöner, äh, darstellen, ja.
Aber, die Sache ist die,
FFM-Pack haut mir
ja quasi hier an der Stelle,
da müsste man schon sich richtig
das Bein ausreißen,
ähm, hier, da müsste man
sich ja schon richtig das Baum, äh, das Bein
ausreißen, weil das FFM-Pack,
ähm, die Code gibt dir
halt quasi ein, äh,
BGRA Memory
Block zurück.
So Leute, ich werd erstmal meine Pizza
futtern, äh, Patrick, er meint,
wenn du das
quasi in Millisekunden
schreiben würdest,
oder?
Also sprich,
wenn du die Sekunden in Millisekunden
haben willst,
was ja natürlich mehr wird.
Ah, ne, das ist der, der hat's verschrieben.
Hahaha, okay, oder auch nicht.
Weil das auch Sinn ergeben hätte, ja.
Also wenn du jetzt mal 1000 rechnest,
dann hast du halt das, was du in Millisekunden
schreiben müsstest, dass du wieder auf Sekunden kommst.
Max, kochst du nicht selbst?
Naja, kein Bock.
Lieferservice beste.
Aber ich bin echt
begeistert, wie flüssig das ist.
Ich finde auch, wenn man sich das hier anguckt,
im Vergleich jetzt zu,
zu der WPF-Geschichte,
ich finde auch,
es ist flüssig, guckt euch das mal an,
die Animation ist viel flüssiger.
Guckt mal, wie die Hände hier wackeln.
Seht ihr?
Moment, meins ist,
meins hat auch die falsche, falschen FPS
kann das sein?
Wart mal, meins hat die falschen FPS.
Nö, hat's
nicht.
Meins hat die richtigen FPS.
Meins hat die FPS, die im Pfeil stehen.
WPF kriegt's
nicht richtig hin.
Guckt mal, wie lahm das ist.
Ich hab zwei Durchläufe,
bis die einen haben.
Aber meins hat die FPS,
die das Pfeil sagt, dass es hat.
Und WPF hat, was auch
immer.
Das braucht doppelt so lang oder so.
Wahrscheinlich, weil's
CPU-mäßig hinterherkommt.
Keine Ahnung.
Das hier hat, keine Ahnung, 5 FPS oder so.
Und der hier hat 25.
Aber ich nehm das,
was das Pfeil auslässt.
Wir können ja mal gucken.
Wir können mal wirklich checken,
was das Zeug hat.
Ne, VLC, wir machen
FF-Probe.
FF-Probe.
Hat FPS
12,5
und
der Papagei
hat
25.
Allerdings, ah, Moment.
Ne.
Keine Ahnung.
Müsste er eigentlich richtig erkennen.
Macht er aber anscheinend nicht.
Läuft dein alter Play dann als Web-Overlay
oder lokal?
Das ist lokal.
Das Web-Interface ist ja dafür gedacht,
dass du es auf dem Tablet oder so verwenden kannst.
Das ist ein transparentes WPF-Fenster
und im Hintergrund
eine ASP.NET Core-Anwendung.
Das Web-Interface kannst du auf dem Tablet verwenden.
Klickst du drauf, dann geht's dir auf.
Das besteht aus quasi dem Web,
aus der ASP.NET Core und der WPF-Anwendung.
Ja, ich weiß, dass man
Gif-Play mit 25 FPS abgespielt hat.
Allerdings, ich hab's ja nicht gesetzt.
Guck da.
Ich sag hier, Decoder FPS.
Und Decoder FPS ist ja dann,
in meiner Meinung,
dass es 25 sind.
Was aber
anscheinend
nicht stimmt.
Wobei, FF Probe gibt es aus
und ich mach's auch mit FFmpeg.
Das ist irgendwie
ein bisschen
merkwürdig.
Doch, doch, ich bin demnächst off.
25?
Der denkt, das sind 25.
Guck da.
25, wo schreib ich denn hier hin?
Stream?
Ja.
Framerate.
Was haben wir noch zu bieten?
R-Rate.
Können wir auch nochmal machen.
Vielleicht sind die auch unterschiedlich.
25.
Was haben wir sonst noch so zur Auswahl?
Mal gucken, was die anderen Dinger für Framerates ausspucken.
Ray.
Ähm, wenn man das jetzt nochmal
vielleicht richtig schreiben würde, alles.
Bitrate. Sample Rate.
Was kommt denn da raus?
Null.
Frame.
Framerate.
Ich hab eine Idee, woran das liegt.
Aha!
Daran liegt das.
Ich lese das falsch aus.
Guckt mal.
Das Richtige ist Stream.
Das Richtige ist Stream.
Das hat total beknackt.
Das Richtige ist Stream.
Average Framerate.
Das da.
Geteilt durch.
Das da.
Und dann stimmt das nämlich auch.
Aber meins ist trotzdem noch flüssiger.
Was funktioniert denn schon alles?
Fast alles?
Resizen klappt noch nicht.
Aber GIFs abspielen geht.
Transparente GIFs abspielen geht.
Eigentlich funktioniert alles.
Also das Schwierige ist geschafft.
Musst du die FPS nicht später auslesen,
wenn das... Das Pfeil ist schon geöffnet.
Ich mach das Pfeile im Konstraktor auf.
Ich kann gar nichts vorher...
Ich kann quasi nichts vorher auslesen,
bevor ich überhaupt drauf zugreifen kann.
Das Pfeil ist auf jeden Fall da.
Ich hab's jetzt ja hier richtig.
Ich hab den...
Die zweite Komponente nicht ausgelesen
an der Stelle hier.
Jetzt stimmt's ja mit 12,5 FPS.
Leider gibt's keine halben FPS.
Es gibt im Prinzip nur 12 oder 13.
Ja.
Das ist schon... Das gefällt mir.
Das gefällt mir echt gut.
So Leute, ich geh jetzt mal
Pizza futtern. Wir sehen uns
demnächst. Macht's gut.
Bis denn. Tschüss.
Gibt's irgendwas zu hosten?
Wen kann ich hosten?
Irgendwas, den ich hosten kann?
Hosten...
Keine Ahnung.
Irgendwie keiner da.
Der Frasier, der spielt nicht.
Ne, dann geh ich jetzt einfach
auf ein Remix.
Aber Remix.
So, macht's gut.
