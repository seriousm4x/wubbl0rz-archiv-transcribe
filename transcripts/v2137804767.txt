Der Reaktionian hat...
Ich kann es ja immer richtig aussprechen.
Der Reaktionian hat
subscribed.
Ja, ich bin gerade aufgestanden vor
20 Minuten oder so.
Ich mache noch keine Runde Rennen, aber ich mache es
nachher. Es ist gerade nicht so geil das Wetter.
Deswegen ein bisschen früher
gestreamt heute.
Ich habe auch...
Ich meine, bei uns regnet es nicht, aber es
könnte durchaus demnächst
so sein.
Ich habe keinen Bock. Ich gucke mal, wie es heute Mittag aussieht.
Und wenn ich heute Mittag eine Runde...
Mittag ist glaube ich ganz
okay. Wenn ich hier mal gucke, Hanau-Wetter.
Ja.
Kann man vielleicht sogar Fahrrad fahren.
Das sieht eigentlich ganz brauchbar aus.
Sieht so aus, als zieht das meiste an Regenwolken
vorbei.
Wenn noch ein bisschen
mehr Sonne wäre, wäre
echt nice, aber das glaube ich nicht.
Machen wir mal einen Monitoring-Stream.
Wir haben doch schon ein paar... Prometheus haben wir schon
gebaut. Oh, CheckMK muss ich auf der Arbeit
benutzen. Da habe ich echt keinen Bock. Das ist mit das
undurchsichtigste...
Na, kann man so...
Ja.
Also CheckMK hat
das mit Abstand
wirste UI
von allen Monitoring-Tools, die ich
kenne. Bei Zappix ist es so,
Zappix hat auch ein wirres UI,
weil es sehr komplex ist, aber
es hat ein, sagen wir mal,
es hat ein gewisses System noch
dahinter. CheckMK wirkt so,
als hat man einfach
irgendwas entwickelt und es irgendwo auf die Webseite
geknallt und in der Hoffnung, man findet es
irgendwann wieder. Also das UI von
CheckMK ist wirklich grausam schlecht.
Yoho,
Dankeschön. Pog-Subscription.
PETG
machen wir nicht, weil Windows-Only.
Das ist irgendein Nagios-Fog.
Ganz ehrlich, ich...
Ich bin nicht wirklich
happy mit den ganzen Monitoring-Tools.
Es gibt keins, wo ich sage,
ja, finde ich umfassend
nice. Prometheus ist
cool, wenn man Metriken will und
vor allem, wenn man viel selbst bauen will.
Klassisches Monitoring
mit Prometheus geht alles, ist
aber eher, wir bauen unser
Monitoring-System selbst. Zappix ist
ganz cool, aber Zappix wirkt an manchen
Stellen doch schon ein bisschen altbacken.
Ja, und ja, von
CheckMK und jetzt habe ich mir... Es gibt ja noch
mehr, es gibt ja noch Observium und Libre
NMS und was es nicht alles gibt.
Es gibt auch noch den Klassiker Nagios,
wobei es den ja nicht mehr
irgendwie in der alten klassischen Version gibt,
sondern, ja, da blicke ich nicht mehr
durch, ich habe schon ewig... Wobei ich sagen muss, dass
als ich meine Ausbildung gemacht habe,
habe ich ja angefangen mit
Nagios. Und ich finde Nagios
immer noch cool.
Ich würde nicht unbedingt... Also, sagen wir mal so,
ich würde sogar
mal ein neues Nagios installieren,
aber es gibt ja anscheinend kein neues
mehr. Es gibt
es gibt dieses komische Nagios X
oder was?
Jetzt gibt und wie es
mit der normalen klassischen
Open Source Version, keine Ahnung, da blickst du
bei Nagios nicht mehr durch. Das
UI ist so grausam. Ich muss das auf der Arbeit
jeden Tag verwenden, da findest du nix.
Und das ist das... Wisst ihr,
ich habe keine Probleme mit irgendwelchen
komplexen Sachen. Ich finde es eigentlich cool, wenn
was, also wenn Software komplex ist, aber die
ein gewisses System hat, wenn man dann mit der
Zeit merkt, okay, man blickt da immer besser durch
und alles gut. Aber CheckMK ist so
ausgekotztes UI.
Ich will mich damit überhaupt nicht beschäftigen,
großartig. Habt ihr, habt ihr,
warum habt ihr Nagios auf der
Arbeit? Habt ihr das einfach die letzten
15 Jahre schon, 20 Jahre schon?
Oder habt ihr das neu installiert
und dann mit einem dieser,
was ist das?
Quick Look at my Homelab.
Das haben wir doch,
das haben wir uns doch letzte Woche angeguckt.
Das haben wir uns, das hatten wir auch schon
in den Vorstellungen, das haben wir uns letzte Woche angeguckt.
Da hab ich mich auch gefragt, wie viel Gerät der hat.
Der hat ja zwei Schränke und eins ist voll mit Netzwerk.
Da hab ich mich auch gefragt, wie viel Laser,
vor allem. Da hab ich mich auch gefragt, wie viele Dinge
hat der Typ eigentlich bei sich im Haus?
Ja.
Der hat auch, glaube ich, ein neues Video
gemacht, so was er,
was er alles in seinem Homelab macht,
aber da sieht man nicht viel, da steht er nur da und
erzählt.
Tipps for powering your Homelab.
Ja.
Kekona-Probleme müsste man haben, oder?
Kekona-Probleme müsste man haben.
Wobei, ich weiß gar nicht,
ist das U.S., U.S.A.?
So, ich mach mal kurz
Package-Updates.
Arch Linux, by the way.
I'm using Arch.
Benutzt du eigentlich deinen Bartosera noch?
Nee.
Der steht da.
Ich hab, ich hab sogar
die SSD ausgetauscht letztens.
Ich, ich, ich
hätte Bock, das Ding mal abzugraden auf die,
auf das neueste Bartosera und zu gucken, ob da
jetzt Xbox und
Sachen mittlerweile default sind, die
bei meiner Version noch nicht default waren.
Ich hab
die SSD getauscht und hab
Linux Mint für meinen Vater draufgehauen.
Ich, ich wollte ihm, ich wollte
ihm die Kiste geben, weil
mein Vater hat ja so, hat ja einen alten Desktop-Rechner
von mir gekriegt, mit Windows 11
drauf, die, die alte Xeon-Kiste,
weil er seine, seine
alte Kiste irgendwie zerstört hat.
Das Problem ist jetzt, das Ding ist so
vollgemüllt mit irgendeinem Scheiß,
der hat da, ey, was der da drauf wieder
installiert hat, Mann. Der hat
irgendwie fünf Browser,
irgendwie, Avast
Free Antivirus Browser
oder sowas, ähm,
TuneUp tut, boah, ich denk,
Alter, was ist denn los, ey?
Der verwendet die Computer auch schon seit,
weiß ich,
25 Jahren oder so,
oder 30 Jahren, der hat relativ
früh mit dem Kram, 30 Jahre, der hat
relativ früh mit dem Kram sogar schon damals im Büro
angefangen. Alter, wie
kann man immer so planlos sein?
Ja, ich hab da aber gar keinen Bock
mehr, irgendwie Support für
zu machen,
zumal er sich letztens verkackt hat,
denn letztens hat er
irgendwie seinen Monitor zerstört, ich weiß auch
nicht, wie er das geschafft hat, zumindest ging der Monitor nicht
mehr, wilder Egel, danke für den Sub.
Hab ich ihm gesagt, hey, ich bring dir, ich bring
dir einen neuen vorbei, also alten
gebrauchten von mir, und
hab ich das angeschlossen
und dann, dann hab ich festgestellt,
dass
das ist,
also das ist ein ganz normal
Full HD
60
Hertz Monitor noch gewesen,
den hatte ich auf dem Dachboden stehen,
ich mach mal Package Updates,
und
dann hab ich den angeschlossen, und dann hab ich festgestellt,
du kannst die Auflösung nicht mehr einstellen,
der geht, weil er die Grafikkarte
nicht mehr erkennt, da ist eine olle,
eine olle Radeon,
irgendwas, was vor 5 Jahren
mal aktuell gewesen ist drin, aber es reicht halt dicke,
für 1080p,
also er kennt die Grafikkarte nicht mehr, der hat seine
Windows-Installation so zerstört,
dass du auch keinen neuen Grafikkartentreiber
installieren kannst, jedes Mal, wenn du
von AMD was installieren willst,
ploppt irgend so ein komisches Tune-Up
Driver Utilities Ding
auf, und sagt, man soll
über die Webseite
den Treiber runterladen, also ganz
merkwürdiges Zeug, ey, das ist total
versaut, die Kiste vor ihm.
Hab ich ihm gesagt, ey,
du kannst das jetzt verwenden mit
1280, und,
und weniger Farben,
du müsstest hier mal, also wir müssten hier mal
deine Windows-Geschichte neu installieren,
dass das wieder ordentlich funktioniert,
aber das mach ich heute nicht,
weil Datensicherung, ich hab nix
dabei, für irgendwie USB-Signal, und außerdem dauert
das bestimmt 1-2 Stunden, bis das funktioniert, da hab ich heute
keinen Bock drauf, das war noch vor Ostern,
ich hab ihm vorgeschlagen, ey, weißt du was, wir können das
nächstes Wochenende machen,
aber dann hat er mich angerufen,
irgendwie abends, da war er auch
mit einverstanden, ne, äh, was soll
er auch sonst anders da machen, ich mein, ich bin ja
nicht irgendwie verpflichtet, on the fly alle Computerprobleme
der Welt zu beheben,
vor allem, wenn man es selbst verkackt
hat, äh,
Pog-Subscription will der Igel, falls ich euch vorgelesen hab,
exzellent, sehr.
So, und
dann hat er sich abends bei mir angerufen,
hat sich beschwert, warum ich
ihn hier mit nem kaputten Computer hab sitzen
lassen, und
irgendwie, er vermutet,
dass ich eh ihm einen Computer vorbeigebracht
hab, der kaputt ist, so,
um ihn zu ärgern, oder so,
und er, äh, er kauft sich jetzt, äh,
der ist alt und verwirrt, ja,
da kannst du nicht so viel drauf geben, wenn er so
zehn Dinger erzählt, mein Opa hat auch immer so
merkwürdige Dinger erzählt, als er alt war,
und, zumindest meinte er dann,
er kauft sich jetzt, er kauft sich jetzt
einen eigenen, er kauft sich jetzt einen neuen Computer,
hab ich gesagt, okay, gut, nice, muss ich nix mehr machen,
see you, und jetzt
hab ich ein paar Wochen nix von ihm gehört, und gestern hat er
angerufen, und da wusste er
nix mehr von, dass er sich einen eigenen kaufen will,
hat er wieder verdrängt,
und,
ja,
und, ja,
äh, zumindest,
also, die, äh, die, die Bildrate
wird ja immer noch nicht stimmen,
und, dann meinte er so zu mir,
ja, und wie verbleiben
wir denn jetzt, hab ich gesagt, hä,
wie, wie sollen wir denn verbleiben,
ja, wann machst du das denn richtig,
hab ich gesagt, wie, willst du dir keinen
eigenen Rechner mehr kaufen, die,
diese, weißt du, diese Art und Weise zu
fragen, allein schon, kann einen ja triggern, ja,
wie verbleiben wir denn,
willst du dir keinen, willst du dir keinen
neuen Rechner mehr kaufen, wie, warum
soll ich mir einen neuen Rechner kaufen, und, weil er das letzte Mal
gesagt hat, das wisst ihr, ich hab dem sogar
eine E-Mail geschrieben, wo das drinne steht, zumindest,
lange Rede, kurzer Sinn, wegen der
Bartos-Serra-Kiste, da bin ich ja drauf gekommen,
ich hab dem, damals,
vor ein paar Wochen, also kurz vor Ostern,
hab ich dem Linux Mint auf der Bartos, ich hab
die SSD getauscht, hab dem Linux Mint
auf der Bartos-Serra-Kiste installiert,
weil ich mir gedacht hab, ey,
selbst, wenn wir Windows
jetzt neu installieren,
äh,
auf der alten Kiste,
das sieht in zwei, drei
Monaten wieder so aus,
und ich glaube, ich stell dem da jetzt
einfach eine Linux Mint-Kiste hin,
und dann soll er gucken, wie er damit
klarkommt,
weil der macht ja eh nix, außer
einen Browser offen zu haben,
das Ding ist nur, ich will, ich will, dass der
sagt, dass der das
ausprobiert, und dass der das machen will,
weil sonst erzählt der mir nachher wieder, ich hätte
ihm irgendein Computer, was kaputt, das hingestellt,
ich will mich möglichst
wenig mit dem ganzen Mist beschäftigen müssen.
Ja, das gibt's aber für, für, ne,
Linux Mint kann er nix installieren, da weiß er
doch gar nicht, wie das geht.
Der wird im Leben nicht auf die Idee kommen,
Upt-Installs, also mal ganz
abgesehen, dass es das gar nicht gibt,
Upt-Installs zu machen, oder aber
jetzt irgendwelche
Software, das kriegt
er nicht auf die Reihe.
Theoretisch
könnte ich dem einfach Hutrechte entziehen.
Dann mach ich das.
Jexio, danke schön, nochmal hier für
fünf Gifted-Subs.
Gestern auch schon hier
zugeschlagen.
Extremely excellent.
Fünf Subs.
Was heißt denn
fünf auf Lateinisch?
Keine Ahnung. Fünffach nice.
Wir hatten Glück gehabt hier.
Die Erbsenraube, hab ich auch schon öfters gesehen.
SirKillerLot, Alex,
Sela, Edri und
Tuchti.
Hattet ihr schon mal das Problem, dass der öffentliche System
so viel...
Äh...
Nee.
Also, ich denke mal,
darauf wird's rauslaufen.
Ich werde jetzt aber erstmal nix machen.
Hab ich jetzt eigentlich schon rebooted?
Nee, gell? Aber ich hab alle Package-Updates
gemacht. Ich werde jetzt erstmal nix machen.
Ich werde jetzt warten, bis er sich wieder rührt
und irgendwas fliegen seinem Rechnermann.
Weil,
selbst wenn ich den Windows 11
neu installiere auf der Kiste,
dann fehlt ihm wieder irgendwas.
Oder, ähm,
nach zwei Monaten.
Und es sieht halt wieder genauso kaputt aus.
Ist halt richtig, richtig
für'n Arsch.
Äh, was hat die Chatbrains-Toolbox für Probleme?
Okay.
Oh, wir müssen updaten.
C-Line brauchen wir doch eigentlich gar nicht.
Das machen wir so selten, das können wir wieder uninstallen.
Ryder gibt's keine Updates, PyCharm-Golan gibt Updates.
Okay, let's go.
Du kannst ihm bei Windows auch die
Admin-Rechte wegnehmen.
Ja, das ist richtig.
Ich glaube aber nicht, dass das grundsätzlich was
leh... was behebt.
Es behebt sicherlich, dass er
Tune-Up und Geschiss installiert.
Aber es gibt ja mittlerweile auch
genug Müll, den er sich installieren kann
ohne Admin-Rechte.
Die sind halt nur in seinem Account, aber das Ding ist halt auch wieder nicht richtig
benutzbar. Ja, Windows-Admin-Rechte
entziehen wäre auch sehr sinnig, ja.
Am besten wäre, wenn er sich mit Linux Mint
irgendwie anfreundet.
Ja, das stimmt wohl.
Das ist eigentlich gar keine schlechte Idee.
Wenn er mit...
kriegt einfach keine Admin-Rechte, ja.
Wie geht... wie macht man das eigentlich?
Einfach einen neuen Account erstellen, ne?
Einfach einen neuen Account erstellen.
Den Admin-Account mit dem Passwort behalte ich.
Ne, ich lege da einen lokalen
Account an und
vielleicht haue ich... ich haue dem glaube ich
auch wieder Teamviewer oder sowas drauf,
dass ich zur Node Remote gucken kann.
So, zack.
So, das Ganze mal rebooten hier.
Package Updates durch.
Ja, ich glaube, das ist keine schlechte Idee.
Wobei ich
glaube, weniger Support
leisten zu müssen.
Unter Linux Mint unterwegs.
Ich meine, ganz ehrlich, der benutzt eigentlich
nur einen Webbrowser.
Der benutzt nichts anderes.
Der hat den ganzen anderen Schrott da drauf,
aber den braucht der nicht.
Tune-Up und Geschiss, ja.
Weiß gar nicht, ob es hier auf der Welt irgendjemand gibt,
der Tune-Up und diese hässlichen Windows-Dinger braucht.
Ja, ja, so ist es da auch.
Und...
Ja, ich glaube...
Und das Ding funktioniert halt einmal
und geht dann.
Das ist eigentlich ganz nice, ja.
Naja.
Ach ja, und was mir wieder aufgefallen ist,
ich habe Linux Mint draufgehauen
auf diese Kiste.
Ich habe, also, die...
Hallo Leute, hier ist der...
Ja, auf diese Kiste, und zwar ist das hier
so...
Moment, guck mal,
ich habe mich selbst debated mit meinem Werbelink.
Hallo Leute, hier ist der...
Ich habe mich selbst debated.
So eine Kiste hier habe ich.
Und ich habe darauf Linux Mint
raufgehauen.
Und jetzt ratet mal, meint ihr,
es funktioniert,
dass man Videos im Browser
GPU decodet?
Nein, natürlich funktioniert es nicht.
Wo wir wieder bei einem meiner Lieblingsthemen sind,
was unter Linux falsch läuft
in der Richtung.
Natürlich funktioniert kein GPU-Decoding
von Videos im Browser.
Warum? Ich habe keine Ahnung.
Irgendwas...
Was nicht in der richtigen Kombination ist.
Mesa-Treiber, GPU-Treiber,
Windows-Gedöns,
Browser-Version, whatever.
Keine Ahnung.
Aber das Ding ist schnell genug,
um Videos abzuspielen auf der CPU.
Das ist nicht so wild.
Ja, so ein Teil hier.
Ne, hat er auch nicht.
Ja,
das ist echt so ein leidiges Thema.
So.
Rebooted.
Nice.
Wichtigste Sache, wichtigster Check.
ASCII-Quarium geht noch, dann ist alles gut.
Oh man.
Ich warte jetzt erstmal, bis er sich wieder meldet.
Vielleicht, äh,
hofft er sich ja doch einen eigenen neuen Rechner.
Gut ist.
Ja, dann lasst uns mal kurz gucken,
was auf, äh, ne, Trend, Trend.
Ach ja,
wisst ihr, was wir übrigens auch mal wieder machen müssen?
Unbedingt.
Wir müssen Set-Servers mal machen,
weil, die haben
mittlerweile ganz viele neue Sachen
hinzugefügt. Guckt mal, die haben
mittlerweile 45 Szenarios.
Mein Problem ist, ich weiß gar nicht, was wir davon
schon gemacht haben und was nicht.
Wir haben höchstens 20 oder
30 davon gemacht, also,
wir haben bestimmt nochmal 10 oder 15 jetzt,
die wir noch nicht gemacht haben.
Manche, für manche neue Szenarios
brauchen wir übrigens sogar einen Pro-Account,
was ich sehr nice finde, ehrlich gesagt.
Dass es
mittlerweile die Möglichkeit
gibt, hier Abos abzuschließen.
Normalerweise finde ich sowas ja kacke,
ja, das ist ja, ah, warum gibst du mal Abos?
In dem Fall finde ich es aber gut, weil das ein
richtig nicer Service ist
und sich das ja irgendwie
finanzieren muss.
Die ganze AWS Sachen
kosten ja alle Geld.
Das hat der, das hat der halt früher
selbst bezahlt, aber mittlerweile ist der Service
relativ bekannt und ich denke mal, das kostet jetzt auch nicht
wenig. Und dementsprechend
irgendwie, irgendwie muss der Kram sich ja finanzieren,
ja, also finde ich es ganz gut. Zumal sich, zumal sich
es auch in, äh,
ja, und ganz ehrlich, 5 Dollar,
um das mal einmal durchzumachen, ist schon, ist, ist
auch in Ordnung, ja.
Direct Access to VMs, VMs with Internet
Access, das ist schon mal problematisch,
könnte ich mir vorstellen, weil du dann cheaten kannst.
Vielleicht sind es aber auch nur spezielle
Szenarios, weil viele von den
Szenarios kannst du easy cheaten, wenn du Internet
Zugang hast. Sachen nachinstallieren,
die das Leben einfacher machen und sowas.
Ich hab meinem Chef vorgeschlagen, ob er
sich nicht das hier kaufen möchte.
Für Vorstellungsgespräche.
Also wer den Service nicht kennt, man
hat hier kaputte, kaputte
Server auf AWS,
die man innerhalb von einer gewissen Zeit fixen
muss. Das ist quasi
sowas wie
Capture the Flag nur für
Linux Admins. Und die easy
Szenarios sind auch wirklich
easy. Ja, hier bei dem ersten
musst du, äh, LS
off machen auf einer Datei und dann kill auf
einen Prozess und sowas. Also ich finde,
das hier ist was, das kann man ohne Probleme mal
mit einem Linux Admin als
für ein Vorstellungsgespräch
in die Hand drücken, ein paar davon. Und sagen,
mach mal. Einfach um zu gucken, wie gut
er damit klarkommt. Weil die Dinger sind so
easy. Die kann wirklich jeder,
der ein bisschen Linux Erfahrung hat
und gerade jemand, der sich bewirbt für so eine Stelle
und selbst wenn er nervös ist bei der,
beim Vorstellungsgespräch. Also,
ein LS off auf einer Datei und ein kill auf einen Prozess,
das kann ich, das kann ich quasi machen,
wenn ich von einem Haifisch
verfolgt werde im Schwimmbad, so.
Kann ich das nebenbei machen.
Das kann, das kriegt jeder Linux Admin hin,
der selbst, wenn er super
nervös ist. Ja, bei den anderen Szenarien
würde ich sagen, okay, das
ist was, wo man halt gucken muss,
ob das den jeweiligen Leuten liegt,
weil beispielsweise, wenn, wenn du mich hier
an sowas setzen würdest, irgendwas mit
SQLite, äh, ne, mit
nicht mit SQL, mit MySQL,
da habe ich eh nicht so großartig Ahnung, könnte also sein, dass ich
sogar Medium-Szenarien verkacke.
Aber die easy Szenarien sind wirklich easy.
Haben wir hier im Stream auch schon gemacht.
Also wir haben damals,
wir haben damals alles,
ne, L ist oft zusammengeschrieben,
wir haben damals
alle Szenarien durchgemacht,
komplett, auch inklusive den schweren,
aber damals gab es noch nicht so viele.
Also das haben wir, das kann ich mich
daran erinnern, das haben wir auch gemacht.
Ich glaube, das hier hatten wir auch
gemacht. Das hier
bin ich mir nicht sicher, ich glaube auch.
Also uns fehlen, uns fehlen
auch, ich, ich glaube die Docker, Docker
Kubernetes App hatten wir auch, ich glaube, wir müssen
die alle nochmal machen und
ich, ich, also
Gamepad, danke für den Sub. Ich glaube,
ich mache mir einen Account
für 5 Dollar im Monat und wir machen
die nochmal im Stream alle zusammen durch.
Ja,
ich habe dies letzte Mal gemacht,
da gab es hier noch gar keine Registrierung
und dann habe ich, da haben wir nochmal 2, 3 gemacht
mit Registrierung.
Ja, ich glaube, ich kaufe mir einfach
irgendeinen
5, 5 Dollar
pro Monat und dann machen wir die, machen wir die
nochmal alle im Stream
zusammen. Schadet ja nichts, ich meine, wann haben wir das
das letzte Mal gemacht? Selbst wenn wir die doppelt machen,
es ist 3 Jahre her oder 2 Jahre her oder so.
Ich glaube, sogar noch vor Corona.
So, also, dann lass uns mal gucken, was auf Shithub so
trendet diese Woche.
DOS, ja, das habe ich mitgekriegt,
dass Microsoft den, den DOS
Source Code veröffentlicht hat.
Was auch immer. Ja,
Zeit geworden, dass mal DOS 4 veröffentlicht wurde.
Assemble erstellt.
Sind das nicht Sachen, die schon in C
sind? Ne.
Scheiße. Ach du
Scheiße.
F ist das doch bestimmt in C, oder?
Ja. Ho. Begin
End. Was ist das für ein weird
C-Dialekt?
Was soll das sein?
Begin End?
Ist das basic,
C-basic oder was?
What the, was ist, was hat
es mit diesem Begin und End auf sich?
Ach, keine Ahnung. Egal.
Also, DOS trendet.
AI, AI.
Ne. AI.
Ja, das sind so Dinger.
Ich kenne das ja bei uns.
Wie gesagt, Frankfurt Finanzbranche,
Versicherungen,
die haben auch teilweise so uralte
Software am Start.
Die ist aber so
in den ganzen Abläufen und Sachen
integriert, das, das wirst du nie
los. Deswegen, wundert mich nicht.
Und, und, und
an so einem
Asset Management System oder Warehouse,
der hängt ja auch, der hängt ja irgendwo alles dran, ja.
Ja.
Wahrscheinlich wird das auch nicht mehr supported.
Die Kasse läuft
auf Windows XP. Ja, wundert mich nicht.
Ich mein, wie war das letztens bei
der Warenstellenanzeige für Windows 3.11
Admins?
Gibt halt so Legacy Dinger.
Und man muss aber auch sagen,
es ist ja auch gar nicht schlimm.
Solange das nicht Systeme sind, die irgendwie
im Netzwerk hängen und Internet
Access haben, beziehungsweise umgedreht
noch schlimmer Access von draußen haben,
ist, ist das, ist das vollkommen
okay. Gestern habe ich irgendwie
einen Beitrag gehört im Radio beim Mittagessen.
Habe ich Radio angeschaltet.
Und da haben sie sich drüber ausgelassen,
über irgendwelche, ich finde das, kennen die das?
Ich finde das immer so cringe,
wenn die, wenn die sich im Radio und Fernsehen
auslassen über irgendwelche, die
Cyberattacken.
Ich sage dazu, keine Ahnung,
Hackerangriff oder irgendwas.
Ich sage halt meistens das, was es gewesen
ist, aber die sagen immer Cyberangriffe.
Ich finde dieses Wort Cyberangriff
immer so, ah, ich weiß nicht.
Zumindest da weißt du schon gleich immer, was kommt.
Und da haben sie sich drüber unterhalten,
wie Deutschland aufgestellt wäre
gegen russische Cyberangriffe.
Und dann haben sie irgendein
interviewt, der bei irgendeinem,
keine Ahnung, bei irgendeinem
Ministerium arbeitet, der für zuständig sind
und die haben natürlich gesagt, Deutschland ist
sehr gut aufgestellt dagegen, ja.
Und
dann haben sie sich weiter drüber ausgelassen,
Angriffe auf kritische Infrastruktur
sind hier an der Tagesordnung und
werden permanent abgewehrt.
Und an der Stelle musste ich mir mal denken, so, okay,
Moment, wisst ihr, was ich den jetzt mal gerne fragen würde?
Also kritische Infrastruktur, ja,
das ist für mich sowas wie
Flughäfen, Atomkraftwerke,
Trinkwasserversorgung und
ja, Verkehrsleits, so
kritische Infrastruktur. An der Stelle
hätte ich den Typ gerne gefragt, hätte ich gesagt, stopp,
stopp, was er denn genau
meint. Und ob er mir sagen möchte,
dass kritische Infrastruktur etwa
öffentlich aus dem Internet erreichbar wäre.
Das hätte mich echt mal interessiert.
Aber natürlich hat die, die den Radio
Feature hat absolut keine Ahnung von der Thematik
gehabt. Das hätte ich den gerne mal
gefragt, was meint der denn eigentlich
mit, gibt Laufen, Angriffe, wird
abgewehrt. Heißt das, wir haben kritische
Infrastruktur im Internet hängen, oder wie?
Oder wie
ist das gemeint?
Ich meine, mich würde es nicht wundern,
ja. Da machen die immer ein
riesen Ding draus.
Ganz ehrlich, wenn ich Windows
Windows 95 Systeme
heutzutage irgendwie öffentlich
erreichbar habe,
habe ich halt echt
es so grundlegend verkackt, dass man es gar nicht
kaum mehr verkacken kann.
Ich glaube der weit, die weit
überwiegende Anzahl aller
Cyberangriffe dürfte
weltweit irgendwelche Verschlüsselung
Trojaner Geschichten sein.
So nach dem Motto,
E-Mail kommt beim
Chef raus, bei der Sekretärin vom Chef,
bei der Personalabteilung
mit irgendeinem halbwegs gut
gemachten Text und einem
Screenslaver im Anhang. Und natürlich, was machen die Leute
Ah, guck mal da, da hat uns einer seine
Bewerbung geschickt.
Im Screenslaver-Format, haha, doppelt anklicken,
Warnung ignorieren,
continue, execute, oh nein,
unser File-Share ist verschlüsselt.
Das dürften wahrscheinlich die weit
meisten aller
Angriffe sein. So, was trenne
denn sonst noch?
AI, noch mehr
Blazingly Fast Powerful Editor,
was ist denn das jetzt schon wieder? Das ist doch
nicht dieses Ding, das ist nochmal ein
Editor in Rust.
Jetzt haben wir ja schon fünf konkurrierende
Editors in Rust. Wie hieß dieses andere
Ding, was es nur für Mac gibt?
Ich hab's schon wieder vergessen, das war mal, was jetzt ein paar Wochen
lang voll gehypt war.
Mac-only written in Rust Editor,
den sie jetzt ein bisschen
gehypt...
Ja, ja, genau, ich glaub das ist es.
Was ist das?
Steht grad keine Beschreibung.
No description?
No description.
Okay, jetzt weiß ich auch warum das keine Description
hat, dass Nintendo das nicht findet.
Äh...
AI...
AI...
China-Chinesen-Messenger...
China-Chinesen-Messenger...
A Based Rollup.
Jetzt weiß man
sofort Bescheid, was das
für ein Projekt ist, oder?
A Based Rollup. Ist Rollup
nicht sowas wie Webpack?
Nur nicht Webpack?
A Based Rollup.
Hä? Okay, ich hab keine Ahnung,
was das sein soll.
Hydra is a Game Launcher with its own embedded
BitTorrent-Client. Ja, wofür
der hier wohl benutzt wird, in nem Game
Launcher? Sicherlich nur, um
eigens angefertigte Sicherheitskopien
neu runterzuladen, oder? Was meint
ihr? Was könnte es sein?
Ich kenne das gar nicht.
Es ist ja nicht verboten,
sowas zu programmieren.
Nur für Linux-ISOs, genau.
Moment, NeoFetch
ist mittlerweile auch bloated, oder was?
Also, nur mal so,
NeoFetch ist ein Programm, was nichts
anderes macht, wie Infos über eure
Linux-Installation anzuzeigen.
Ich weiß nicht, warum das Blazingly
Fast written in Go, written in Rust...
Ey, ich wette mit euch, Moment, es gibt doch
garantiert schon sowas wie
NeoFetch written in Rust.
Natürlich.
Erfreshed...
Ist aber seit zwei Jahren unmaintained.
Und jetzt
die coolen Leute benutzen jetzt Fast
fetch, oder was?
Wird NeoFetch nicht mehr
aktualisiert, oder?
Oh, tatsächlich!
Seit April!
Seit 26. April ist
NeoFetch outdated,
overrated, jebaited.
Ich hab da vollstes
Verständnis für, wenn einer keinen Bock mehr hat auf
Open-Source-Projekte oder unmotiviert ist.
Also, wie heißt das andere? Light Fetch?
Nee, wie war das? Fast Fetch?
Fast Fetch, okay. Gucken.
Fast Fetch.
Alles klar. Yes.
Wir machen's
mal so. Okay, zack.
Fast Fetch versus
NeoFetch.
Ehrlich gesagt,
ich sehe überhaupt keinen Unterschied.
Außer, dass Fast Fetch
sogar noch ein bisschen mehr Infos hat.
Lokale IP.
Haben wir
noch? Okay, ja, nice.
Disk Space.
Swap Memory.
Oh nein! Fuck, Leute!
IP-Leak!
Ich hoffe, ihr seid nicht schon drin.
Okay, das heißt,
wir uninstallen NeoFetch jetzt.
Weil NeoFetch outdated,
overrated ist.
Aber nachdem ich mir das nicht merken kann,
würde ich sagen,
machen wir mal ein Alias.
Ein Alias
NeoFetch
auf Fast
Fetch.
So, jetzt kann ich
nach wie vor NeoFetch machen.
Das ist in Wirklichkeit Fast Fetch.
Excellent.
So, wo sind wir stehen geblieben?
Ja, das haben wir uns angeschaut.
Was, was auch noch?
AI-Zeug, juckt nicht.
So.
Ja, was trendet denn im
SAP ABAP Umfeld?
Die haben nicht mal genug Repos, Alter.
Ah, das offizielle
SAP
Examples trendet.
Okay.
Nice.
ABAP.
Was, Developers können auch trenden?
Nee.
Wusstet ihr, seit wann
können Developers trenden?
Bestimmt schon eine Weile und mir ist das nie aufgefallen.
Mal gucken, ob irgendwann der Wubblos
auch trenden kann.
Da müsste der Wubblos einmal mit seinen Projekten
weiterarbeiten.
ABAP.
ABAP trendet nix.
Moment, jetzt doch?
ABAP.
Da haben wir ja alle Bock drauf, ne?
Es ist ein bisschen, es hat ein bisschen was von Kobol.
Haben wir, haben wir, haben wir
ABAP Enjoyers?
SAP Leute hier im Chat.
Und falls ja,
eine ernst gemeinte Frage, haben wir wirklich Leute,
also macht ihr das nur, weil es einfach
fett Kohle bringt oder gefällt euch
ABAP und das SAP Umfeld?
Ich hab bisher nämlich noch keinen gesehen,
der sagt, oh ja, das ist richtig geil.
Alle, die ich kenne, die das machen, die machen das
eigentlich nur, weil sie es schon eine Weile machen
und man da richtig mit Kohle verdienen kann.
Ja, mich würde das auch abfucken.
Aber immerhin, immerhin
muss man sagen, dadurch,
dass wir das gemacht haben,
oh nee, fuck, doch nicht.
Ich dachte, ich hab Kobol
bei mir reingeschrieben, was
Programmiersprachen angeht.
Für meine Skill-Liste aus der Bewerbung.
Das ist nicht eins zu eins das, was ich in meine Bewerbung
geschrieben hab. Ich hab noch ein paar Sachen editiert,
aber im Großen und Ganzen
das.
We got an update for you.
Windows is continuous improving
and updates are a normal part of
keeping it running smoothly.
We'll restart and install this update
in 15 Minuten.
Nee, nee, nee, nee, nee.
Another time. Gehen wir nicht auf den Sack, Windows.
Also nicht auf dem
Rechner, sondern auf dem Vorschau-PC.
Schrott. Da wird nix
improved. Aber Microsoft sagt das doch.
Da muss das doch so sein.
Das ist wie unter Windows 95,
wo immer stand,
ist das beste
Windows, das
es je gab.
Oder sowas stand da doch immer.
Ist das beste
Windows-Installer. Da gab's doch immer unter
Windows. Wenn du Windows 95
installierst, das stand doch immer da irgendwie.
Windows 95 ist das beste Windows
aller Zeiten und ist das beste Windows, das es
je gab. Ich weiß, ich kenn die Formulierung grad
nicht mehr.
Und selbst da hab ich das bei Microsoft schon nicht
geglaubt.
Brauchen wir das hier noch?
Das sagt, glaube ich, so gut
wie jeder Hersteller jedes Jahr über sein
Zeug. Selbst wenn sich so gut wie nix verbessert hat.
Also eine Sache,
die wirklich weit davon entfernt
ist,
das beste zu sein, was es je gab.
Nee, sagt mir gar nix. Muss mal
gleich mal gucken. Also
wisst ihr was ganz
schlimm ist?
Ich muss damit glücklicherweise nicht allzu viel machen.
Ich hab eines
meiner Fire HD 10 Tablets,
die im Flur hängen als
Home Automation Dashboard.
Eines davon hab ich ausgetauscht
durch ein
durch ein
Samsung
A8
oder so Tablet.
Das hat mehr oder weniger bis auf ein paar Millimeter
exakt die gleichen Abmaße
wie das Fire HD 10.
Und es ist
ein bisschen nicht ganz so
outdated und lahm.
Aber das UI
da drauf. Ohne Scheiß, Leute.
Ich hab noch nie
sowas unbenutzbares gesehen.
Ich...
Wie heißt denn das Ding nochmal?
Das hat so nen doofen Namen. One UI!
Ja, hier sieht das alles ganz toll aus.
Ich hab noch nie sowas
unusable mäßiges gesehen aufm Tablet.
Ich hab legit
bis jetzt nicht gefunden,
wie man den ganz normalen
App Launcher startet.
Also ich weiß, wie ich
Apps starte, ja.
Ich geh auf dieses komische Übersichtssymbol
und dann oben auf
das Suchenfeld und dann stehen da manche drinnen.
Aber so nen ganz normalen App Launcher
mit nem Button unten, wie man das von Android kennt,
am besten in der Mitte.
Kannste vergessen. Also One UI
ist wirklich das mit
Abstand ekligste
UI, was ich je auf nem Smartphone
beziehungsweise aufm Tablet gesehen hab.
Vielleicht doch ein normales Android drauf.
Ich glaube, dafür gibt's keine Custom
ROMs.
Ich will da nen eigenen Launcher drauf machen.
Aber ganz ehrlich, ich will da dran eigentlich gar nix customizen,
weil ich mach damit nichts, außer
nen Browser im Fullscreen permanent laufen haben.
Bin seit Mittwoch in einer neuen Firma
und dort im Linux-Engineerteam. Du hattest dir die Ausschreibung
im Stream angeschaut. Nice!
War das ne Stellenausschreibung, die ich geflamed hab,
oder war das ne Stellenausschreibung, die ich ganz gut fand?
Ist das eine, die du gepostet hast,
oder eine, die ich zufällig im Stream
angeguckt hab und du hast dich
da drauf beworben? War das was, was du
vorgeschlagen hattest? Zum angucken?
Magst ans Trinken, ja.
Das ist gut. HyperOS.
Du hast sie vorgeschlagen.
Okay, ja, aber nice, wenn's geklappt hat.
Und wie ist so?
Also ich kann aus eigener Erfahrung sagen, ich bin jetzt ja über
ein Jahr im neuen Job,
also ich war ja schon, also jetzt quasi
ein Jahr und ein Monat,
dass man am Anfang sehr
begeistert immer ist und
man nach und nach aber genug Punkte
findet, die einem auch auf den Sack gehen. Also in meinem
neuen Job gibt's jetzt genug Punkte, die mich auch nerven.
Also diese Phase mit, man findet alles toll.
Ist vorbei.
Gerade die Bürokrate, die riesen Bürokratie
Dinger bei uns gehen mir extrem auf den Sack,
aber insgesamt
geht's mir deutlich weniger
wie der alte Laden.
Ja, nice. Siehste, und bei mir ist's umgedreht.
Ich werd gezwungen, Windows auf
meinem Laptop zu verwenden.
Was nicht so wild ist, weil ich noch genug
Linux-Kisten hab, die ich benutzen kann für
die täglichen Sachen, aber
dass auf meinem Laptop Windows sein muss, find ich ziemlich
kacke. Naja, jetzt hab ich
vergessen, irgendwas wollte ich grad noch erzählen, beziehungsweise
zeigen. Keine
Ahnung mehr.
.NET Framework Projekt, oh ja, da gibt's
halt immer noch genug.
Ich glaube, wie gesagt, ich bin ja kein hauptberuflicher
Entwickler und auch kein .NET Entwickler, aber ich glaube,
viele der .NET
Legacy, der .NET Framework
Legacy Projekte, die
wären sogar mit halbwegs vertretbarem
Aufwand umstellbar auf
das neue .NET.
Aber ich glaube, da scheitert's oftmals
dran, am Willen,
ja. Habt ihr analysiert? Warum
habt ihr sehr viel Windows-only Shit verwendet?
Beziehungsweise
Sachen, die es nicht mehr gibt?
Wie
beispielsweise dieses Windows Message Queue
Gedöns, was
.NET Framework konnte und
.NET nicht?
Es ist schon bescheuert, dass man
überhaupt nicht durchblickt, wenn man über
.NET Sachen spricht, was man eigentlich meint, ja.
Niemand der, die Microsoft
Versionierung ist so dumm, ja.
Wer soll denn checken, was
der Unterschied zwischen .NET Framework und .NET
ist?
So dämlich, ey.
Naja.
Okay, das stimmt, das stimmt, je nachdem, worauf das
läuft, ja. Okay, hab ich meine Kiste schon
rebooted? Ich glaub schon.
Alles klar, dann lass uns mal auf YouTube gucken.
Okay, wenn das noch altes
ASP.NET ist
und nicht ASP.NET Core,
dann ist es tatsächlich schwierig, weil das gibt's
ja nicht mehr in der Form, ja.
Das muss man dann
umschreiben auf
die Art und Weise, wie man
es jetzt mit ASP.NET Core macht, ja.
Also gerade, wenn ihr Entity Framework
verwendet habt, das alte Entity Framework mit
ASP.NET, das Umbauen auf
ASP.NET Core und Entity
Framework Core ist schon ein bisschen größerer Akt, ja.
Kann ich mir gut
vorstellen, zumindest.
Boah, ich bin so müd, gell.
Ich weiß auch nicht, warum.
Ich hab richtig gut
und lang gepennt. Vielleicht
deswegen.
Ja, das kann ich mir vorstellen. Auf so alten Kram hat mir
ich keinen Bock. WCF.
Das hab ich selbst nie verwendet, das kenn ich nur
aus
Geschichten und dass
das ganz eklig ist.
Das ist Windows Communication
Foundation oder sowas, gell.
Ja, das kenn ich
nur aus irgendwelchen Storys. Hab ich nie selbst
verwendet. So, was haben wir denn hier
auf YouTube,
was wir uns mal kurz anschauen können?
Am besten irgendwas, wo ich wach werde
bei Uni, The Cat
und Super Mario Galaxy. Okay, am besten
Whatever.
Hat aber sehr kurze Beine.
Okay.
Ja, kannst
Content konsumieren.
Irgendwas, wo ich wach werde bei.
How a leap day
took down Microsoft.
The Ultimate
Ambience System.
Okay, dabei werd ich bestimmt wach.
Dabei werd ich bestimmt
wach, weil da muss ich mich bestimmt wieder jeden
zweiten Satz aufregen darüber,
warum C++ so scheiße ist.
31
Nubi C++ Habits.
Ich weiß nicht,
ob ich das jetzt, ob ich das geistig
durchhalte.
Zumindest bin ich danach wahrscheinlich wach.
Was haben wir denn sonst noch?
Meine katastrophale Ausbildung zum
Fachinformatiker.
Schädlinge bekämpfen und Bauern beraten.
Feierschrift Video.
Da finde ich mich.
Okay, komm, scheiß drauf. Wir skippen.
Sachen, die ich blöd finde, die skippen wir.
Ich, komm. Ja, es ist Zeit, Leute.
C++ Rage. Auf geht's.
Vielleicht ist es
auch gar nicht so schlimm. Vielleicht ist es ja auch wirklich
ein Video, der, ja,
wo ich sage, okay, aber ihr wisst,
es ist C++, das heißt, es wird mich, es wird mich
aufregen. Okay, let's go.
To my list of Nubi C++ Habits.
C++ is an incredibly complex
language with a lot of history.
So, whether you're an actual Nube. C++ ist
nicht einfach incredibly complex. C++
wird auch absichtlich
incredible beschissen gemacht.
Weiß immer noch nicht, warum die Gremium-Leute,
na, egal.
Okay.
Alles klar.
Ja, das ist blöd.
Was zum Teufel ist denn das da unten eigentlich schon wieder?
S
Klammer auf, hello.
Was ist denn das da schon
wieder für komisches Zeug?
Warum gibt es,
warum gibt es fünf verschiedene Arten unter C++?
Egal, oh Mann.
Okay, aber das, das verstehe ich.
Okay, ja, gebe ich ihm recht,
es ist Blödsinn.
Next.
Number two,
using standard endline, especially in a loop,
you probably meant to just print out a
new line. Ja.
Jetzt mal ernsthaft,
standard new line
klingt ganz stark danach, als möchte man
eine new line printen, aber
selbstverständlich scheint das in C++
nicht so zu sein, sonst hätte er den Tipp nicht gemacht.
But endline does more than that.
Ach ja, ach ja, endline
macht mehr als endline. Logisch.
Logisch, na klar.
Obviously.
Macht endline mehr als endline.
Also flushes the buffer, which takes extra time.
Ah,
wer denkt sich das aus, Mann?
Ich weiß gar nicht,
was ich dazu sagen soll.
Wer denkt...
Wer denkt sich diesen Schrott aus?
But endline does more than that.
It also flushes the buffer, which takes extra time.
Instead, just use a newline character.
What the fuck?
Also, ich als C++ Noob,
ich hätte jetzt gedacht,
könnt
mir mal sagen, ob das bei euch auch so war.
Ich hätte gedacht,
standard endline
ist einfach ein Shortcut dafür,
dass man unter Windows,
backslash R, backslash N macht
und unter Linux nur backslash N.
Sodass man eben seinen Source Code
quasi OS-neutral
schreiben kann
und er funktioniert unter beiden
Betriebssystemen ordentlich.
Das hätte ich gedacht,
dafür ist standard endline da.
Wenn du es unter Linux kompilierst,
er einen backslash N draus macht
und wenn du es unter Windows kompilierst,
er backslash R, backslash N draus macht.
Das hätte ich gedacht.
Wenn es noch irgendwelches
secret hidden behavior drin hat,
das hätte ich nicht gedacht.
It also flushes the buffer,
which takes extra time.
Instead, just use a newline character.
Number three, using a for loop by index
when a range-based for loop
expresses the intent better.
In this case, I don't really care at all about the index.
Instead, use a range-based for loop.
Ja, das sehe ich genauso.
Das finde ich auch viel angenehmer.
Ich meine,
ich persönlich
hätte es ja durchaus nice gefunden,
man hätte das Ding einfach for each
genannt, so wie sie es in C Sharp
beispielsweise gemacht haben.
Aber so ist auch okay.
In JavaScript ist es ja auch so
und in, also in JavaScript
machst du ja auch normale Vorschreiben
und in Go ist es auch so, also
warum nicht?
There's no index, so one less chance
for an accidental typo or off by one error.
Ja, aber das sehe ich auch so.
Okay.
Und jetzt, okay,
da gebe ich eben voll und ganz recht,
es macht eigentlich keinen Sinn,
Sachen, die schon im Framework drin sind,
das Rad neu zu finden.
Das erste Vorkommen ist,
was darauf matcht und so.
Aber jetzt, Leute, Imagine,
das wäre ein gescheiter Syntax.
Überlegt euch mal,
man könnte einfach sowas schreiben
wie data.findif
wie data.findif
wie data.findif
und dann so eine Lambda hinten reinschieben
und gut ist.
Ich schiebe Lambdas
immer gerne hinten rein,
solche Funktionen.
Stellt euch mal vor, man könnte das ordentlich schreiben.
Stellt euch mal vor, man könnte das ordentlich schreiben.
Stellt euch mal vor, man könnte das ordentlich schreiben.
Man könnte, selbst wenn man das nicht ordentlich schreiben kann,
einfach sagen,
standard findif data ist positive
und nicht cbegin, cend.
Da müsste es sowas wie,
ich meine, es gibt ja Iterators
in C++,
aber das ist auch wieder so ein undurchsichtiges Ding,
wo es fünf verschiedene Varianten gibt,
wo ich mich frage,
warum, ich meine,
warum kann das Ding nicht
Iterator bereitstellen und die Funktion
möchte dann eben
eine x-beliebige Collection
die Iterator implementiert haben
und nicht diesen Scheiß mit cbegin und cend.
Und ein weiterer
großer Vorteil von,
dass das Vektor
sowas anbieten würde,
wäre ja auch,
man könnte es sich merken,
weil dieses ganze Standard-Doppelpunkt-Doppelpunkt,
da gibt es ja mittlerweile 1000 Sachen drin.
Ja, Link wird es halt
in C++ nicht geben, weil C++ keine
Extension-Methods hat.
Ich bin der Meinung, ohne Scheiß,
Extension-Methods wären
die Rettung für C++.
Du könntest quasi nahezu alle Features
rausschmeißen der letzten zehn Jahre
und dafür Extension-Methods einbauen.
Weil mit Extension-Methods
würdest du zum Beispiel auch das erschlagen,
dass jede Library seine eigene
String-Klasse mitbringt,
weil sie irgendwas eigenes machen wollen
und solche Dinger. Du könntest dann einfach
die Standard-String-Klasse extenden
mit den Sachen, die du brauchst.
Praktisch!
Und du könntest auch sowas wie Link beispielsweise,
wenn du das haben willst, bauen in C++.
Extension-Methods, ohne Scheiß, das wäre
eines der größten C++
Fixed-Features überhaupt.
Aber das kriegen sie ja nicht gebacken,
seit Jahren schon.
Find where the first positive element is.
Number five, using a C-Style-Array
when you could have used a standard array.
C-Style-Arrays often decay into pointers
and require you to pass the length of the array
along with the array itself.
Another opportunity to make a typo.
Instead, use a standard array.
Gäbe ich ihm recht, das ist okay.
Number six, any use
of reinterpret-cast.
Ich habe bis heute nicht gecheckt,
was diese Dinger in C++ machen.
Du hast irgendwie reinterpret-cast,
const-cast, es gibt irgendwie
drei, vier verschiedene Sachen.
Ich bin der größte Krankenhub, was das angeht.
Ich mache den Standard-C-Cast.
Bei mir sieht das dann einfach so aus.
Ich caste nach keckel, pointer,
hier, blub, so.
So sieht das bei mir aus dann.
Auch wenn das nicht modern,
tolles C++ ist.
Ich habe bis heute nicht gecheckt,
was diese ganzen Dinger hier machen.
Dann fragt man sich, wenn es bei C++
so viel undefined behavior ist,
warum ist, sobald was undefined behavior ist,
auch Compiler-Error?
Das frage ich mich an vielen Stellen von C++.
Ich meine, die Compiler-Fehlermeldungen
sind absolut haare raufend,
ja, du verstehst sie nicht.
Aber sobald was undefined behavior ist,
wäre es doch eigentlich sinnvoll,
das kompiliert gar nicht erst.
The same goes for C-Style-Casting.
So, sorry, famous Quake 3 algorithm
for computing the inverse square root.
Okay, das skippen wir den Rest.
Casting away const.
Ja, okay.
Ich meine, guckt euch,
guckt euch mal an,
diese hässliche Syntax.
const cast,
standard unordered map, standard string,
int, und,
okay, chat, was macht das und
an der Stelle?
Ist das eine Referenz, oder?
Für was ist das und
überhaupt an der Stelle da?
Keine Ahnung.
This function takes in a map
that maps strings to the number of times
the first word.
It takes two words and then returns back
to whichever one has a higher count.
The first way you might try to implement this
is by looking up the counts of the two words
and then if the first count is bigger than the second,
then returning the first word.
If I try to compile this,
I get a weird error message telling me
that the method isn't marked const.
And that's how we ended up with this code.
I know that I'm not modifying the map, right?
The correct thing to do in this case
is not to cast away const,
when const, const,
what? So was wird's in Rust
nicht geben, Leute.
Und es wäre auch blazingly fast.
At is a const version of operator square bracket
that throws if the word isn't in the map.
But you might ask, why don't they just
ask the const version so that this would compile?
Okay, I'll skip that for a moment.
This brings us to newbie thing number eight,
not knowing that operator square brackets
inserts the element into the map
if it doesn't already exist.
That's right, simply trying
to look up this word in the map
actually inserts it with a count of zero into the map.
Was?
Was?
Nee, oder?
What?
Was?
Ist das hier nicht ernst?
This brings us to newbie thing number eight,
not knowing that operator square brackets
inserts the element...
No, God!
No, God!
Please, no! No!
No!
No!
Bist du Max von YouTube?
Nein, nein, nein, ich bin Wobblos von Twitch.
Das ergibt ja überhaupt keinen Sinn!
Jetzt mal eine blöde Frage,
ja? Stellt euch mal vor,
ich hab
eine Map
vom Typ,
ach, keine Ahnung,
kekwint.
So, und ich,
ich mach jetzt ein...
Manche Typen sind, also,
insertet er dann...
Was insertet er überhaupt als Default-Wert
für irgendwas?
Das ergibt ja überhaupt keinen Sinn!
Warum ist ein Lookup ein Insert?
What the fuck?
Also, ich bin echt immer wieder
am Zweifeln an
dem ganzen
Prozess und
Erstellung von C++.
Wie kann man so einen Schrott designen?
Keine Ahnung.
Element into the map
if it doesn't already exist.
That's right, simply trying to look up this word
in there.
Ja, aber ich will, vielleicht möchte ich mal gucken,
ob was drinne ist.
Okay, ich geb zu,
an sich ist es natürlich blöd,
was mit nem
Index abzufragen,
um zu checken, ob es drinne ist.
Weil das Ding,
in der anderen Sprache würd's Exceptions werfen,
in C++, weiß ich nicht,
Crashs wahrscheinlich, und dass es nicht crasht,
macht so komische Dinger.
Normalerweise brauchst du irgendeine
Methode oder sowas, um sowas nachzugucken.
Oder, du machst das wie in Go,
was auch super hässlich ist,
go check
key exist, da muss ich nämlich immer nachgucken,
wie das funktioniert.
Ja, oder du machst sowas wie in Go,
ja,
was auch nicht schön ist.
Aber wenigstens insertet es nix ohne Zuweisung.
Ganz ehrlich,
irgendwas inserten sollte das nur,
wenn es entweder wordcounts.insert.add
heißt, oder aber
index gleich
irgendwas, und nicht einfach nur
index.
Absolut hängengeblieben,
komplett hängengeblieben.
Was?
Number ten, not knowing about
string literal lifetimes.
String literals like this one are guaranteed to live
for the entire life of a program.
Okay, das wusste ich nicht, aber
das macht Sinn.
Ja, das sind irgendwelche static strings,
die stehen im binary drin, die sind,
die expiren nicht, okay,
ergibt noch irgendwie Sinn.
So it's perfectly fine to return this,
even though it looks like it's a reference to a local
variable. Number eleven,
not using structured bindings.
Here we have a map of color names to their hex values.
Then we just loop over all the pairs
and print out the name and hex value.
It would be a lot more readable if we could refer
to these things as name and hex, rather than
Das kenne ich, ja.
Das ist tatsächlich relativ neu, ich glaube,
das gibt es erst seit C++20 oder sowas,
dass man die benennen kann.
Das geht ein bisschen wie
tuple deconstruction in C sharp.
...pair dot first and pair dot second.
Well, that's exactly what... Ja, genau.
Das ist tatsächlich eines der Features,
wo ich sage, ey, die sind echt gut,
die kann man so lassen, ja.
Die Syntax ist noch ein bisschen scheiße hier vorne,
aber das finde ich durchaus in Ordnung.
Das finde ich durchaus in Ordnung.
Das sieht seltsam aus, ja gut.
Es ist C++, das ist seltsam.
Und diese ganzen uns überall.
Aber das geht in Ordnung.
Aber das geht in Ordnung.
Aber das geht in Ordnung.
Ja.
Ja.
Ja.
Ja.
Ja.
Man kann auch einfach einen tuple return,
da braucht man das gar nicht.
Ja.
Ja.
Ja.
OK.
Ja, verstehe ich.
Ja, klar.
Ja.
Ja.
Ja.
Verstehe ich.
Ja.
Ja.
Das ist auch so ein Magic-Ding in C++, aber das ist cool.
Das ist tatsächlich eines der cooleren, also eines der, also das, was du Compile-Time-Checking und Compile-Time-mäßig machen kannst in C++, unter anderem halt auch mit Templates, ist, glaube ich, mehr als in jeder anderen Sprache so geht.
Das ist eines der größten Vorteile und gleichzeitig auch eines der größten Abartigkeiten, die es gibt.
Ich glaube, ich habe es kapiert, aber nicht sicher.
Was? Standard, Unique, Pointer, Base?
This will happen automatically, since I'm using a unique pointer.
But the same would be true if you just took in a normal pointer and then manually called delete.
If you pass a pointer to an instance of this derived type, then the wrong destructor gets called at the end.
What?
Ich blick nicht durch, aber ich glaube, ich weiß, was er mir sagen will.
Was war nochmal ein Virtual Destructor?
Virtual Methoden sind die, die du in Klassen, die von dir...
...die du von dir ableiten, überschreiben kannst.
...destructor is called, even through a pointer to a base class.
Wisst ihr, was ich nicht verstehe bei der ganzen Geschichte?
Warum ist es überhaupt welle, C++ das so zu schreiben, wie im ersten Fall?
Warum gibt es nicht einfach einen Compile-Fehler, wenn du was überschreibst, was nicht überschreibbar ist?
Oder warum gibt es nicht wenigstens ein Warning, dass du was überschreibst, was nicht als überschreibbar markiert ist
und dementsprechend sich vielleicht anders verhält, wie du denkst?
...you need to mark the function virtual.
It's also good practice to explicitly mark the derived class's destructor as override.
Ich dachte übrigens auch, dass das...
Siehst du, das ist so eine Sache, die ich nicht verstehe. Warum ist das nicht Pflicht, ja?
Wenn du was überschreiben willst, dann musst du halt auch override hinschreiben, dass das implizit funktioniert.
Das ist doch total bescheuert.
Number 15.
Thinking that class members are initialized in the order they appear in the initializer list.
Ja, ey, wie kann man auch davon ausgehen, dass in C++ was in der Reihenfolge passiert, wie es da steht?
Nee, das ist ja nicht...
Nee, nee, nee.
Nee, das kann nicht sein.
Das geht nicht.
Das muss anders sein.
Nein, nicht in der Reihenfolge, wie es da steht.
Reading left to right, this looks fine.
The actual order that members are initialized in is the order that they are declared in.
Wisst ihr, was ein sinnvolles Default-Verhalten wäre?
Das, was er sagt, nur dass es einen Compile-Fehler gibt, wenn man es in der falschen Reihenfolge reinschreibt.
Easy.
Oder zumindest ein Warning.
Warum erlaubt man das?
Warum erlaubt man das?
Man kann doch sagen, okay, das ist ja nicht so.
Man kann doch sagen, okay, die Sachen müssen in der Reihenfolge initialisiert werden, wie sie definiert werden.
Und die einzige Möglichkeit, das zu machen, ist, sie in der Reihenfolge zu initialisieren, wie sie initialisiert werden.
Also wenn ich es falschrum schreibe, wenn ich start zuerst schreibe und end danach schreibe,
also hier nicht, sondern end zuerst, dann gibt es einfach einen Fehler.
Warum kompiliert das überhaupt?
Wir initialisieren end als start plus size, aber dieses mstart ist Garbage.
Es wurde noch nicht initialisiert.
Wir können das natürlich mit dem Declaren von start zuerst fixieren.
Oder, weil start auch ein Parameter für die Funktion ist, können wir nur die Endvariable
in Bezug auf das Start-Parameter definieren.
Was auch immer.
16.
Nicht erinnern, dass es eine Unterschiede gibt zwischen Default- und Value-Initialisierung.
x und x2 sind Default-Initialisierungen.
Ich bin gerade am überlegen, was das überhaupt machen soll.
Also, int x verstehe ich.
Man deklariert.
Eine Variable x vom Typ int.
Die ist uninitialisiert.
Das verstehe ich noch.
Bis hierhin würde ich es auch noch verstehen.
Man deklariert einen Pointer zu einem int.
Der ist halt aktuell uninitialisiert oder man könnte auch schreiben gleich 0 oder sowas.
Verstehe ich auch noch.
Aber was macht new int an der Stelle?
New heißt ja im Endeffekt.
Das konstruiert ein Objekt im Endeffekt.
Ich wusste gar nicht, dass man new int überhaupt schreiben kann.
Aber okay.
Man kriegt wahrscheinlich hier einen int-Pointer zurück.
Also man kriegt hier quasi einen Pointer auf einen...
Okay, ich glaube, ich verstehe jetzt, was das macht.
Man bekommt new int.
Man bekommt einen Pointer zurück auf einen Arbeitsspeicherbereich.
In den ich ein int in Zukunft mal reinschreiben kann, der aber aktuell noch nicht initialisiert ist, würde ich mal sagen.
Also noch nicht auf einen Default-Wert gesetzt ist.
Im Prinzip wird Speicher allokiert für mich und ich bekomme einen Pointer dahin.
Aber der Speicher wurde vorher nicht genullt im Endeffekt.
Also ist jetzt quasi das hier ein Pointer, ein gültiger Pointer auf dem Speicherbereich.
Aber das, was in dem Speicherbereich...
Drin steht, auf dem der Pointer zeigt, ist einfach das, was die ganze Zeit drinnen steht.
Also potenziell random Kram von irgendwas.
Okay, das leuchtet so weit ein.
Okay.
Chat.
Warum schreibt man hier nicht einfach y gleich 0?
Warum schreibt man hier y Klammer auf Klammer zu?
Warum nicht y gleich 0?
Wäre y gleich 0?
Nicht irgendwie die für normal denkende Menschen logischere Variante davon?
Also so wie ich das interpretiere, ist y Klammer auf Klammer zu das gleiche wie y gleich 0.
Ja, Default-Wert.
Default-Wert von einem int ist höchstwahrscheinlich.
Rate ich mal 0.
Bei C++ weiß man das ja nicht.
Ist der Default-Wert von einem int in C++ 0?
Es könnte auch Maxint oder Minint sein.
Es könnte auch Minus 1...
1 oder so sein.
Man weiß das ja nie so genau bei den Leuten, die sich das...
Also int y gleich 0 wäre halt sehr nice gewesen an der Stelle.
Und warum das beides möglich ist und ob das ein Unterschied ist,
ey, keine Ahnung, was mit den Leuten falsch ist, die diese Sprache designen.
Hat jemand von euch einen Plan, was der Unterschied ist zwischen int Klammer auf Klammer zu
und geschweifte Klammer auf Klammer zu?
Also ich würde sagen,
int Klammer auf Klammer zu invoked den Default-Konstruktor von int.
Ich weiß nicht, was ein Default-Konstruktor von int sein soll,
aber sagen wir mal sowas wie 0 reinschreiben vielleicht.
Und das hier macht das gleiche?
Keine Ahnung.
Okay, wir fragen das jetzt mal.
Difference.
New int.
Das kann Google aber wahrscheinlich nicht.
Da müssten wir jetzt Chat-GPT fragen,
oder bin ich nicht eingeloggt?
Aha, hier, guck mal.
Nee.
Nee, nee.
Difference, hier, guck mal.
Difference between, ups, ah, geh fort.
Difference between new int Klammer auf Klammer zu und geschweifte Klammer auf Klammer zu.
Alles klar, war das die Difference?
Was?
Sind ints, ja, ich weiß auch nicht, was sind Default-Konstruktor von int sein?
Okay.
Expression list, expression initialize.
Warum will ich mehrere Werte an den int übergeben?
Ah, ich weiß, warum.
Ich glaube, das ergibt doch Sinn.
Ich könnte doch sowas machen wollen.
Guckt mal, new int und jetzt will ich das als irgendwie als Bytes da reinschreiben oder so vielleicht.
Ist das vielleicht der Grund, warum das geht?
Ich kann die Bytes einzeln reinschreiben in den int.
Ich kann entweder direkt eine Zahl reinschreiben oder ich kann die Bytes einzeln vielleicht reinschreiben.
Dann würde das tatsächlich sogar Sinn ergeben.
Dann würde das tatsächlich sogar Sinn ergeben.
Dann würde das tatsächlich sogar Sinn ergeben.
Dann würde das tatsächlich sogar Sinn ergeben.
Dann, okay, wenn das der Fall ist, dann macht es vielleicht doch Sinn.
Okay, wir machen das jetzt chat-gierig.
Was, chat, was, Dr. Go, ernsthaft? Das kenne ich gar nicht.
Dr. Go, chat, nee, wo, wo ist das?
AI-Chat, das da?
Okay, ja, das 356.
Was ist die Unterschiede zwischen NewInt und NewInt in C++?
Okay, ja.
Das ist gut zu wissen, das Chat-GPT über DuckDuckGo auf uns.
Okay.
Nach längerer Überlegung ergibt das hier tatsächlich Sinn.
Ist das wie in Go?
Also, ich glaube, in Go ist es nicht ganz so abartig, was du an unterschiedlichen Sachen...
Ich meine, in Go kannst du auch schreiben, war irgendwas.
Also, du kannst in Go schreiben, war blub.
Du kannst schreiben, blub das.
Es gibt drei Varianten, irgendwie die Sachen in Go anzulegen.
Aber da kommt C++ nicht mit aus.
In C++ brauchst du mindestens sieben verschiedene Varianten.
Okay, next.
Fault.
17. Overuse of magic numbers.
Ja gut, da gäbe ich ihm recht.
Introduce.
Introducing a basic constant in your code can make it many times more readable.
Da gäbe ich ihm recht, ja.
The compiler is going to optimize it away anyway.
Just give it a good name.
18. Attempting to add or remove elements from a container while looping over it.
Well, doing that is sometimes just...
Das ist eh meistens eine blöde Idee.
Da hast du in anderen Programmiersprachen auch Probleme,
wenn du, während du eine Liste iterate-est, die Liste modifizierst.
Es gibt je nach Sprache unterschiedliche Tricks,
wie man das handhaben kann.
Ja, irgendwie den Iterator sich vorher speichern und so.
Aber, also dass das Probleme gibt, das kann ich mir denken, ja.
Necessary.
But what I mean is, noobs often do it incorrectly.
We're trying to put a copy of the vector at the end of the vector.
Adding or removing an element to the vector may invalidate the iterators to the...
Nee, ich glaube, das ist was unterschiedliches.
Das ist, ja, in Go ist das Struct, Struct Initializer.
Der setzt quasi alle, also Playlist ist ein Struct,
und hier setzt er, soweit ich weiß, alle Werte in dem Struct auf den Default-Wert.
In C++ wäre das hier ein List Initializer.
Das heißt, du könntest hier mehrere Elemente hinten reinschreiben.
Wobei, wenn du vielleicht, nee, das könnte tatsächlich das Gleiche,
aufs Gleiche rauskommen, wenn du es nicht angibst.
Es ist zwar vielleicht was Unterschiedliches,
aber es ist, wenn du Werte reinmachst,
wenn du keine Werte reinschreibst, dürfte es sich aber ähnlich verhalten, ja.
Ja, ja.
Ich glaube, das kommt aufs Gleiche raus, ja.
Das ist ohne Scheiß, das muss man ja mitnehmen.
Ich weiß mittlerweile glücklicherweise in C++ auch nicht mehr wann.
Das ist, glaube ich, legit die hässlichste Vorschleife, die es in,
also mal so Sachen wie irgendwelche funktionalen Sprachen, mal außen vor,
das ist, glaube ich, die hässlichste Vorschleife, die es gibt in allen Sprachen, ey.
Das war früher der Standard in C++, die Dinger so zu schreiben.
Ja, gut, das ist klar.
Da sind wir uns einig.
Nummer 19, returning a moved local variable.
Ja.
Also ich hätte jetzt gedacht, dass das vollkommen okay ist
und genau der richtige Weg, sowas in C++ zu machen.
C++ hat ja vor einer Weile diese Sachen hier mit move eingeführt,
heißt im Endeffekt, man kann ein bisschen wie in Rust
quasi Ownership von, sagen wir mal, Variablen abgeben.
Also normalerweise ist das hier ja ein Problem.
Ja, du legst das hier an, quasi im Stack,
von dieser Funktion und wenn du das returnst,
würdest du ja normalerweise was returnen, was aufgeräumt wird nach dem Return.
Das ist natürlich in C und C++, gerade in C++ oftmals nicht so eindeutig,
wann was weiterlebt und wann was aufgeräumt wird.
Das finde ich auch immer sehr undurchsichtig.
Das ist was, was Rust wirklich nice macht.
Oder ob es gar kopiert wird, ja.
Es könnte ja auch sein, dass das erlaubt ist,
aber dass das eben nicht, dass es einmal kopiert wird.
Da blicke ich immer nicht genau.
Ja.
Also da macht C++ auch zu viel Magic dabei.
Also ich hätte jetzt aber erwartet,
wenn ich, obwohl ich den hier lokal in der Funktion angelegt habe,
ich den Vektor als Return-Type,
wenn ich den Vektor returnen will,
dann ist Standard Move genau der richtige Weg,
um zu sagen, ey, scheiß drauf, dass das hier drinnen angelegt wurde.
Quasi Rust-mäßig Transfer Ownership von hier zum Aufrufer.
Ich hätte jetzt vermutet,
genau das muss man machen.
Aber anscheinend nicht.
Ja.
Ja.
Genauso hätte ich mir das gedacht.
Und hier hätte ich gedacht, gibt es vielleicht Probleme.
Hier hätte ich gedacht, es gibt es Probleme,
weil eventuell der Vektor ja aufgeräumt wird danach.
In this situation, that's because of Return-Value-Optimization.
But what if the compiler can't do Return-Value-Optimization?
In all cases, the move is unnecessary.
The compiler always knows that it can move a local variable.
But in some cases, this actively prevents Return-Value-Optimization.
So that's why this is one of the few ways where I can say,
you should just never do this.
Whatever.
Oh nein, Templates.
Jetzt wird es eklig.
Which brings...
Warte, warte, warte.
Na gut, das geht ja noch.
Was?
Okay, es geht nicht.
Ich checke schon wieder nicht, was es macht.
Also, die erste Zeile kapiere ich ja noch.
Const, Express, Standard, Remove, Reference, T und und.
Ist das der Return-Wert hiervon oder...
Alter, what?
Ah, meine Güte, ey.
No, except...
Ich weiß nicht, was es macht.
Ja, wie kann man...
Wie kann man in C++ denn auch erwarten, dass Move...
Was macht was?
Hier ist ein Implementation of Standard Move.
The full templated definition might be a bit much to take in all at once.
So let's take a look just at the int case.
Move takes in an int l-value reference,
static casts it to an r-value reference...
Obviously, natürlich.
...and returns it.
The exact same thing happens in the r-value overload.
It just static casts to an r-value and returns it.
A more accurate name for Move...
Ich habe nichts verstanden davon.
...is...
...a more accurate name for Move.
...probably something like cast to r-value.
Alles klar, mach das nicht.
Falsch.
...thinking that evaluation order is guaranteed to be left to right.
Ja.
Ja.
Hätte ich jetzt eigentlich auch gedacht.
Here's a famous example.
We have a string that says,
but I've heard it works even if you don't believe in it.
We replace the first four characters with the empty string.
Then we find even and replace it with only.
Then we find don't and delete it.
With this reasoning, we should end up with...
...I've heard it works only if you believe in it.
But prior to C++17, the compiler is actually allowed to compute any subexpression in any order.
But why?
So, theoretically, it could find the location of even first,
and then replace the first four characters, making that location off by four.
Aber wenn ich es richtig verstanden habe, in den neueren C++-Standards ist das nicht so.
When the second replace happens, it would replace these four characters with only.
But why?
And you can see how this goes on.
You don't get the result you expected.
Well, the good news is that as of C++17, this example is guaranteed.
If you have a dot...
Das war so geil, Sid!
...b, then a is guaranteed to be evaluated before b is.
However, even in C++20, the order that function arguments are evaluated is still not guaranteed left to right.
This wouldn't matter much if a, b, and c were pure functions.
But if a, b, and c have side effects...
Okay, das ist natürlich...
Das ist vielleicht gar nicht so schlimm, das E-Wir, das so anzuschreiben.
...then the order that they're called in might actually make a difference.
22.
Using totally unnecessary heap allocations when a stack allocation would have been fine.
Here we create two customer records on the heap.
Das macht ja gar keinen Sinn.
Warum sollte ich das...
Und wenn ich es hier lösche, ist eigentlich unsinnig.
Then we do some work, and then we end up deleting those variables at the end of the function.
Ja, das ist unsinnig.
The only question we should ask ourselves is, did this really need to be a heap allocation?
Nö.
There's a good chance it would have been fine if we just stack allocated them.
So let's just say for the sake of argument that these objects are too big, and you really do want them on the heap.
That brings us to number 23.
Not using unique pointer and shared pointer to do your heap allocations.
What happens if an exception gets thrown in the middle here?
Then these deletes never occur, and the memory is leaked.
Das gleiche Problem hast du ja in Go auch.
Also, um zwei Ecken.
Nicht exakt das gleiche Problem.
In Go machst du sowas wie defer dann davor, so nach dem Motto, egal was passiert, am Ende der Funktion immer das ausführen.
Und ja, in C-Sharp würdest du ne exception handling mit finally block drumherum machen.
Oder, eines der neueren Sachen verwenden, sowas wie using var blub gleich new cackle.
So, und wenn cackle quasi...
...ein destructor hat, beziehungsweise eigentlich kein destructor, muss man sagen, disposable ist,
dann wird das automatisch aufgerufen, auch in for, auch wenn es exceptions gibt.
When you want to make sure that a resource is cleaned up, you need to put that cleanup code in a destructor.
So why don't we make a class that holds a pointer, and then in its destructor it deletes that pointer?
Well, that's exactly what unique pointer...
Du musst alle Errors handeln, das ist richtig, aber du kannst natürlich immer noch sagen...
Du kannst es natürlich auch immer ignorieren.
Aber du meinst, sag mal so, du musstest ihn handeln, indem du explizit sagst, ich ignoriere ihn, das ist schon wahr, ja?
...does.
You can give it a heap allocated pointer, and when it goes out of scope, it deletes it.
A shared pointer, on the other hand, uses a reference counting scheme, similar to what you might...
Den musst du nicht zwangsläufig in allen Sprachen.
Also Sprachen, die keine Error-Return-Werte haben, und da ist das...
...kannst du dich dafür entscheiden, exception handling drumherum zu machen oder nicht, also...
Also in Rust bist du wirklich gezwungen.
In Rust musst du alles explizit handeln oder unwrappen und Panic riskieren.
Aber das dann auch definiert.
Okay.
Ja.
Das kenn ich, das macht Sinn.
Man kann bei einem shared pointer, glaub ich, sogar eine anonyme Funktion hintendran schreiben, die ausgeführt werden soll, wenn das gekleant wird.
Also das ist tatsächlich mal ein ganz sinnvolles Feature.
...as the last shared pointer goes out of scope.
Okay.
of scope that shared pointer is in charge of the deletion this scheme is much more expensive because
reference incrementing and decrementing have to be done atomically that brings us to number 24
constructing a unique or shared pointer directly instead of using make unique or make shared
make unique and make shared will pass your arguments directly to the constructor of your
object okay whatever act 25 any use of new or delete there's no reason to rewrite functionality
that already exists here i'm trying to manage the memory
you have some resource and then delete it when it's done that's already what a unique pointer
does don't try to couple the purpose of your class to the idea of ownership of an object
that's a completely separate issue unique pointer and shared pointer together cover
pretty much every valid use of new or share pointer together
Aber manchmal geht es nicht anders.
Ja, manchmal geht es nicht anders.
Manchmal gibt es schlicht und ergreifend nichts.
Ich hatte letztens genau sowas.
Ich bin gerade am überlegen, was das war.
Das war irgendwas einlesen, aber nichts.
Aber nicht Dateien einlesen.
Ich kriege es nicht mehr zusammen.
Aber das ging mit C++ nicht.
Du musstest die standard, die olen C-Funktionen dafür verwenden.
Ich glaube, ich wollte irgendwas stand-out.
Irgendwas mit stand-out.
Ich wollte nicht von einer Datei lesen.
Ich wollte von irgendeinem Memory-Stream lesen.
Und da musste ich die...
Die Oldschool-C-Dinger verwenden.
Da gab es in C++ nichts.
...any kind of resource.
Then look to see if there's a...
...are released upon destruction.
Number 27.
Thinking that raw pointers are somehow bad.
Raw pointers sind das Beste.
Here's a basic max function.
This function is just reading...
Raw pointers sind beste.
Number 28.
Returning a shared pointer
when you aren't sure the object is going to be shared.
Ah, ist mir auch egal.
...pointer.
Number 29.
Thinking that shared pointer...
...beallwuscht.
...case.
And 30.
Confusing a const pointer with a pointer to const.
Wenn ich das schon wieder sehe.
Wenn ich das schon wieder sehe.
Ah, Mann.
Okay, bevor er das jetzt erklärt.
Lass mal überlegen.
Was könnte da der Fall sein, ja?
Okay.
Const int pointer.
Okay.
Das hier ist ein int pointer,
der nach dem Zuweisen nicht mehr geändert werden kann.
Rate ich jetzt einfach mal, ja?
Also was hier dran konstant ist,
ist der pointer.
Nicht das int.
Der pointer ist konstant.
Also sprich, ich kann jederzeit den Wert,
der quasi in dem Speicher steht,
auf dem der pointer zeigt, ändern.
Aber ich kann nicht den Pointer auf einen anderen Speicher...
Also ich kann nicht einen neuen Speicherbereich,
auf den er zeigt, zuweisen.
Ich darf nicht den Pointer ändern,
aber ich kann den Wert ändern im Speicher,
auf den der Pointer zeigt.
So, das sehe ich.
Das ist ein const.
Also der Pointer ist konstant.
Nicht der Wert, auf den der Pointer zeigt.
int const pointer.
Ich habe keine Ahnung,
warum das überhaupt valid syntax ist.
Und int Sternchen...
Hä?
Ich check's nicht.
Keine Ahnung.
Das Konzept von const pointer vs. pointer-to-const ist ziemlich einfach.
Sehr einfach, offensichtlich einfach.
Aber viele Neubi versuchen,
die Unterschiede zwischen ihnen syntaktisch zu erzählen.
Ja.
Es ist so offensichtlich,
das kann man eigentlich gar keinen Fehler machen.
Die Regel ist, dass const auf das,
was sofort auf der linken Seite ist, angepasst wird.
Außer es ist das linkste Ding,
in dem es auf das Ding auf der rechten Seite angepasst wird.
Äh, okay.
Warum?
Also was ja Sinn gemacht hätte,
ist sowas hier.
const pointer int
vs.
const int pointer.
So.
Das hätte ich ja noch verstanden,
so nach dem Motto,
das hier ist ein konstanter Pointer,
auf ne, also ein Pointer,
und das hier wäre quasi ein,
äh,
const int
auf der f...
Aber, okay, keine Ahnung.
Das muss man einfach so hinnehmen.
Ich glaube, selbst meins macht auch nicht mehr Sinn.
Ich glaube, selbst meins macht auch nicht mehr Sinn.
Hier, the const applies to the int,
not to the pointer.
And here, const applies to the pointer,
not to the int.
Number 31. Alles klar, oder?
Ignoring compiler warnings.
Ignoring them, or turning them off,
very frequently leads to undefined behavior.
Ja. Gut, das ist klar.
Meine Güte, Alter.
Meine Güte, das hat mich
super verwirrt jetzt.
Gucken, ob es neue Package-Updates gibt.
Ist schon ne halbe Stunde her, wo ich Package-Updates...
Nein, nicht.
Dann noch lieber Go oder Rust.
Ja, ich würde es tatsächlich auch bevorzugen.
Also, ich bin kein super
großer Go-Fan,
aber wenn ich die Auswahl hätte,
würde ich das machen. Ich bin jetzt auch nicht
irgendwie bei der Rust
Task Force, die überall Rust
anpreisen müssen, aber ich würde es auch
bei solchen Sachen bevorzugen.
Manchmal kommt es halt nicht drum herum.
Am letzten sind ESP32 wieder
dran rumgebastelt.
Die neue Variante mit ZigBee.
Und die offiziellen Sachen
kannst du halt am besten
nachvollziehen in
C++, so mit dem offiziellen Framework
von denen. Wann kommt KI-Stream?
Wann du KI-Tools ausprobierst? Wir haben immer mal
wieder KI-Tools ausprobiert.
Ich wüsste jetzt nicht, was ich da für
einen extra Stream machen sollte.
Meine Lieblingssprache bleiben
nach wie vor C-Sharp und
Ruby. Allerdings Ruby kann ich in letzter
Zeit sehr wenig, weil
es ist total outdated und
overrated, gbated.
Also outdated ist es nicht, aber niemand
verwendet es mehr. Ich mag Ruby
aber als Sprache.
Ich habe auf der Arbeit auch schon einige Sachen
in Go gebastelt mittlerweile.
Gerade für im Kubernetes Umfeld
beispielsweise letztens einen Prometheus
Exporter, den
wir als Sidecar injecten können
für unsere
Blockchain. Wir haben ein paar
Blockchain Pots laufen
und
die selbst bieten nicht alle Metriken an,
die wir haben wollen. Da habe ich
einen Prometheus Sidecar gebastelt,
der die API abfragt und daraus
Metriken in Prometheus Format
bereitstellt. Für sowas ist Go nice. Da kommt
im Endeffekt dann ein 3,5 MB Binary
oder sowas raus. Das packst du
in Minimal Image rein und da ist es am Ende
15 MB und let's go.
Ein Schocker!
Am Start. Dankeschön für den Sub.
So.
Irgendjemand hat sich doch gerade KI
gewünscht. Gucken wir mal KI.
13
Lead, Lead, Elite
Time. Das ist bestimmt
Absicht.
Oh ne, ne, ne, ne, ne.
Das ist mir zu viel over-engineert
für heute morgen wieder.
Wieso? Ich habe da noch mehr Tabs. Guck mal hier.
Da noch Tabs und
hier habe ich gerade neu gestartet. Hier habe ich auch
noch ein paar. Multisite
Homelab. Ist das überhaupt noch
ein
Homelab?
Wenn man sowas hat.
Wo hat er denn das hier?
Wir gucken uns das Intro
an. Das rumgemale
hier, das müssen wir uns dann nicht mehr angucken. Wir gucken uns
mal das Intro an. Weil das ist,
das hier ist der Meister des
Over-Engineerings für sein Homelab.
Das hat er auch bestimmt gesponsert bekommen, oder?
Ansonsten ist halt so, also
bisher war es schon Overkill,
aber was folgt nach
Overkill? Hyperkill
oder so?
In that video you saw most of my hardware choices,
which was giving my
Homelab servers a new life, in a
new rack, on a new network,
in a new location.
Warte mal, was ist das?
Überfordert durch Tabs.
Lust auf die Musik?
Ich bin verwirrt.
Ja?
Okay.
Achtung.
Ah, ich hab zu viel Zeug auf.
Ich blicke in meinen Tabs
nicht mehr durch, hier.
Ja, kann schon mal vorkommen,
aber es kommt relativ selten vor, müsst ihr auch
zugeben.
Ah, und am Ende,
wir wissen ja alle, was er laufen hat.
Irgendwie nen
Dashboard und
Uptime-Kuma, so.
Da hat er im Prinzip
nichts darauf laufen, was
wirklich jetzt
nutzbar Mehrwert
bringt. Er hat ganz viel Management
für das Management für
sein Hardware-Kram.
Das Ding ist so, also ich sag euch mal, wie es ist.
Das Setup von
ihm, ohne Co-Location,
zweiten Standort und so,
das Setup ist so komplex,
dass er definitiv,
ich meine, er ist auch nur ein Mann, der das
betreibt, ja, dass er definitiv
mehr Downtime bisher hatte
durch die Hochverfügbarkeit
als
durch eigentliche Hardware-Ausfälle.
Also durch Fehler
durch die Hochverfügbarkeit hat er
mehr Downtime gehabt als ohne Hochverfügbarkeit.
Wette ich mit euch.
Wir können starten.
Wir können starten.
Ich will mir nur den Anfang angucken, worum er
umzieht. Ähm, der Rest
interessiert mich eigentlich nicht so sehr.
Wo fängt der denn an?
Ich skippe das gleich.
Und ich dachte, bei mir ist schon übertrieben mit...
Ich habe...
Also streng genommen habe ich drei VLANs.
Eins für China-Chinesen-IoT-Geräte.
Dann das normale WLAN, VLAN und halt das Default-VLAN.
Ich weiß nicht, ob man das mitrechnen kann.
Der ist natürlich dann schon wieder absolut next level unterwegs.
Ich habe eine Site-to-Site-VPN-Setup.
Ich dachte, das wird wirklich hart sein.
Es wird viel einfacher sein, weil ich...
Ich habe die Möglichkeit, Unify-Site-Magic zu nutzen.
Das ist Teil der Grund, warum ich Unify-Devices auswählen wollte.
Weil es literally so einfach ist, als Checking...
Ich mag Unify nicht.
Und ihr wollt dann immer genau wissen, warum.
Und ich kann es euch gar nicht so hundertprozentig genau sagen.
Ich habe einfach kein...
Ich habe einfach kein...
Ich fühle es nicht, wie man so schön sagt heutzutage, Unify.
Unify ist auf der einen Seite easy,
auf der anderen Seite dann schon wieder für den Easy-Grad zu kompliziert.
Und wenn Sachen kompliziert sind, aber nicht ordnungsgemäß kompliziert,
so dass jemand, der sich damit auskennt, versteht, was damit gemeint ist,
sondern dass alles irgendwie dann wieder anders heißt an anderen Stellen ist.
Also ich bevorzuge entweder dumm
oder...
Kompliziert, aber wenn kompliziert, dann so, dass es eben gemacht ist für Leute,
die sich mit dem Thema auskennen.
Zum Beispiel, ja, mal ein Beispiel, ja.
Fritzbox ist für mich ein super Beispiel für easy für Leute, die sich nicht damit auskennen.
Du kannst in der Fritzbox viele Sachen gar nicht machen,
die man vielleicht mit einem ordentlichen Netzwerkgerät machen können sollte.
Zum Beispiel, glaube ich, kannst du bis heute...
also ich kann mich korrigieren, wenn ich falsch liege,
wir haben ja letztens in einem Video gelernt, dass das angeblich passiv-aggressiv ist, wenn man das so sagt.
Ihr erinnert euch noch, ja.
Aber ihr könnt mich wirklich gerne korrigieren, wenn ich falsch liege.
Ich glaube, man kann bei einer Fritzbox heute immer noch keine ausgehenden Firewall-Regeln machen.
Und wie gut die...
Sachen, die Firewall-Regeln zwischen Netzen sind, man kann ja auch gar nicht wirklich gescheit verschiedene Netze anlegen,
das geht nicht, ja.
Und das ist aber okay,
Weil die Fritzbox ist ein Gerät, das ist rundum, finde ich, gelungen, designt für Leute, die ein bisschen advancedere Sachen daheim machen wollen, ja auch mal ein Thermostat steuern, ein Gäste-WLAN haben, was auch immer, aber sich damit nicht wirklich tiefgreifend beschäftigen wollen.
So, das ist ein gutes Gerät. Früher hat man immer gesagt, die rote Pest aus Berlin, also AVM, aber mittlerweile muss ich sagen, ich mag Fritzboxen für das, was sie sind.
So, das Gegenstück dazu wäre beispielsweise ein Cisco Switch über CLI. Damit könnte kein Noob irgendwas anfangen, aber, und das muss man denen echt zugute halten, das Cisco CLI, ja ich hab mal vor Uhrzeiten ein CCNA gesehen,
also minimalste Ahnung, hatte ich zumindest zum damaligen Zeitpunkt davon, ist in sich schlüssig. Das ergibt Sinn, wenn du dich damit beschäftigst. Sicherlich hast du da schon ein paar angeflanschte Sachen und so ein paar Sonderdinger, die vielleicht nicht ganz dem entsprechen, aber zu 95% ergibt die CLI-Bedienung von einem Cisco Switch, ergibt das Sinn.
Auch wenn man sich erstmal dran gewöhnt hat, für einen Noob nicht. Der hat sich nie damit auseinandergesetzt, will sich damit nicht auseinandersetzen.
Wenn man sich erstmal dran gewöhnt, dass ein Port starten nicht Start ist, sondern nicht Shutdown und sowas in der Richtung, dann ergibt das Sinn bei Cisco.
Ja, auch dass man in die Untermenüs, dass man um einen Port einzurichten erstmal in die Port-Config gehen muss und dann dort die Sachen, ergibt Sinn.
Ein Negativ-Beispiel wäre C++, es ist kompliziert und ergibt keinen Sinn.
Also das eine ist ein Gerät, das richtet sich an Profis.
Macht aber auch keine Verwässerung drumherum und sorgt deswegen dafür, dass es konsistent bedienbar ist, wenn man sich damit auskennt.
Im Prinzip wie eine Fritzbox, die auch gut bedienbar ist, für jemanden, der sich nicht auskennt.
Oder für jemanden, der sich nicht im Detail...
Aber Unify ist in so einem komischen Spot dazwischen und das ist glaube ich das, warum es mir nie gefallen hat.
Die versuchen ein bisschen sich an die Noobs zu richten und dadurch verwässern sie die...
Eigentliche Komplexität, die aber dann doch da ist in den Settings.
Und ich habe mich da nie richtig drinnen zurecht gefunden.
MikroTik macht es auch nur so semi-besser, muss man sagen.
Also, wenn man sich mal hier RouterOS Demo anguckt.
Das ist ja das, die Dinger, die ich gerne empfehle für den Heimbereich, für alle, die ein bisschen mehr machen wollen.
MikroTik-Geräte.
MikroTik-Geräte.
MikroTik-Geräte.
MikroTik-Geräte.
Das ist nur so semi-viel besser.
Es ist schon eine gewisse Logik in diesem Webinterface drin.
Ja, hier findest du die Sachen.
Wie findest du?
Firewall-Settings.
Da ist schon eine gewisse Logik drin.
Vieles ist aber auch komplett unlogisch.
Wie zum Beispiel, wie man jetzt genau VLANs anlegt.
VLANs auf RouterOS gibt es drei, vier verschiedene Varianten.
Es gibt die Variante über Bridges.
Es gibt die Variante über Interfaces.
Es gibt noch...
Whatever.
Da blickst du nicht durch.
Du brauchst einen Guide dafür, wie du VLANs anlegst.
Jetzt eigentlich sollte Faulan anlegen, was super simples sein ist es aber nicht.
Ja, das ist auch was, wo sie es ein bisschen verkacken.
Mit den normalen Settings ist es aber echt okay.
Und die haben aber halt auch eine CLI-Bedienung.
Die ist ganz brauchbar.
Wenn auch nicht so hundertprozentig konsistent wie beispielsweise bei Cisco.
Aber mir ist es immer noch lieber als Unify.
Weil die hier wenigstens nicht so tun beim MikroTik, als wäre es eine super easy, unkomplexe Sache.
Eine Netzwerkkonfiguration mit advanceden Themen.
Und die nennen die Sachen halt auch so, was es ist.
Und das ist halt ein bisschen das Problem, was ich bei Unify hatte.
Ja, Unify ist Faulan-Config super easy, das stimmt.
Das ist eine Sache, die ist ja tatsächlich easy.
Die ist übrigens so easy, wie es eigentlich sein sollte.
Du überlegst dir, was es sein soll.
Ob das quasi ein, wie nennt das Cisco, ein Trunkport oder ein Accessport ist.
Richtig? Habe ich das noch richtig im Kopf?
Und dann trägst du halt ein, was getaggt werden soll, beziehungsweise was drüber gehen darf.
Und gut, das stimmt, das ist in Unify einfach.
Aber viele Sachen drumherum sind undurchsichtig gewesen für mich bei Unify.
Und aus dem Grund, weil sie eben auf der einen Seite noob-accessible irgendwie sein wollen,
aber auf der anderen Seite aber auch advancedere Konfigurationen bieten,
aber dann die Sachen oftmals nicht so nennen.
Und wo Unify bei mir komplett unten durch ist, zumindest was WLAN angeht,
also nicht VLAN, WLAN angeht, ist, dass sie für sehr sinnvolle Features,
die andere Hersteller schon lange haben, ewig gebraucht haben
und zu meiner Zeit, wo ich Unify hatte, sie nicht hinbekommen haben.
Mein Lieblingsbeispiel ist da DPSK für.
Damit kannst du, und Shared Key,
also jeder Hersteller nennt das ein bisschen anders, Unify hat das mittlerweile auch.
Das ist aber so für mich.
Das Feature schlechthin gewesen, was mich immer richtig geärgert hat,
dass Unify das nicht konnte.
Es kann, Rugus kann es, OpenWRT kann es, Mikrotik kann es, auch ein bisschen Umwege,
Cisco kann es, es konnte im Prinzip jeder etwas bessere Hersteller von WLAN-Equipment außer Unify.
Und Unify hat sich, keine Ahnung, sieben, acht Jahre,
gegen gewehrt, dieses Feature einzubauen, obwohl das eines der sinnvollsten Features ist
für WLAN-Geräte, die ein bisschen advancer sind, als
wir schalten ein WLAN in der Fritzbox ein.
Nein, AVM kann das ziemlich sicher nicht.
Ich sag mal so, für alles, was ein bisschen advancer ist als eine Fritzbox, die können das.
Und zur Erklärung, was das ist,
wenn ihr ein WLAN aufmacht, also im Prinzip heißt der WLAN auf,
heißt der, euer Access Point broadcastet eine SSID.
Ja, ich bin WLAN Max daheim oder WLAN Twitch, also der Name von eurem WLAN wird da geprodcastet.
So, und in der Standard-Config ist das so, jedes WLAN hat ein WLAN-Passwort.
Das müsst ihr bei den Geräten einstellen.
Da wählt ihr das WLAN aus, gebt das Passwort ein und das Gerät bekommt Zugriff auf das WLAN.
Soweit, so gut.
Wenn ihr jetzt allerdings wollt, dass Geräte im, das gleiche WLAN kommen,
aber unterschiedliche WLAN-Passwörter haben, dann wird es kompliziert.
Das einzige, was es da traditionell gibt, ist WPA Enterprise,
aber WPA Enterprise wird von so gut wie keinem normalen WLAN-Gerät unterstützt.
Ja, also eure IoT-Klühbirne, euren Receiver am Fernseher, whatever,
die unterstützen alle kein WPA Enterprise.
Das heißt, wenn ihr jetzt die Geräte in das WLAN packen wollt,
aber den Geräten unterschiedliche Passwörter geben wollt,
dann geht das einfach standardmäßig nicht.
Es sei denn, der Access Point, beziehungsweise das System, was ihr verwendet für WLAN daheim,
unterstützt sowas wie DPSK.
Das heißt, bei manchen Herstellern ein bisschen unterschiedlich,
bei manchen heißt es DPSK, bei manchen heißt es MPSK,
ich weiß gar nicht, wie es bei Unify heißt.
Mittlerweile können die das ja auch.
Aber wie gesagt, die konnten das sieben, acht Jahre lang nicht.
Hier, guck mal, hier gibt es Leute,
das versucht selbst einzubauen in die Access Points vor vier plus Jahren
und haben es nur semi-gut hingekriegt.
Und das ist kacke, dass das nicht funktioniert hat.
Und wofür ist das praktisch?
Jetzt fragen sich ja sicherlich einige so nach dem Motto,
warum will man mehrere Passwörter für das gleiche WLAN haben?
Also ich glaube, das beste Beispiel dafür ist,
wenn man viele IoT-WLAN-Geräte hat.
Ihr habt zum Beispiel eine Klühbirne,
ihr habt im Keller irgendwie was, was den Strom misst.
Ihr habt relativ viele IoT-Geräte.
Und jetzt stellt euch mal vor,
die Klühbirne an der Decke, die ihr im WLAN hängen habt
und darüber RGB-Steuerung macht, die geht kaputt.
So, jetzt nehmt ihr die Klühbirne und schmeißt die in den Müll.
Die Klühbirne ist kaputt.
Das heißt aber nicht, dass der Microcontroller in der Klühbirne
bzw. der Speicher in der Klühbirne nicht mehr euer WLAN-Passwort enthält.
Also jemand, der es drauf anlegt, könnte jetzt an euren Mülleimer gehen,
die Klühbirne rausholen, den Microcontroller rauslöten
und das WLAN-Passwort auslesen.
Das ist jetzt vielleicht ein bisschen konstruiert,
aber ich glaube, ihr wisst, worauf ich raus will.
Und sobald du mehrere WLAN-Passwörter vergeben kannst,
für unterschiedliche Geräte, hast du das Problem nicht mehr.
Sobald du die Klühbirne wegschmeißt,
löschst du einfach dieses Gerät aus deiner WLAN-Config
und selbst wenn jemand dann das WLAN-Passwort aus eurer Klühbirne im Mülleimer auslässt,
kann er sich damit nicht mehr einloggen bei euch im WLAN.
Das ist, finde ich, eines der sinnigsten Features,
die sie sich in den letzten Jahren für WLAN-Geräte ausgedacht haben.
Und UniFi hat ewig gebraucht.
Also bis zum Schluss, wo ich mein UniFi-Zeug rauskriegte,
hatten die das nicht.
Mittlerweile können sie es wohl seit einem Jahr oder seit einem halben Jahr oder sowas.
Und das hat mich übelst abgefuckt bei UniFi,
dass sie das nicht haben.
Was eines der Gründe mit war, warum ich UniFi rausgeschmissen habe.
So.
Ich skippe mal ein bisschen drüber.
Wo zieht er denn jetzt eigentlich in seine Co-Location endlich um?
Und das ist, was zwischen den beiden Seiten passiert.
Zuhause, natürlich, bin ich, und weg, bin die Co-Location.
Also wenn ich mir die Logos davon so ankomme,
gucke, fällt mir genau jetzt, fallen mir jetzt genau drei Sachen auf,
die man benutzen könnte, die nicht einfach nur für Infrastrukturzwecke da sind.
Und zwar GitLab, Hugo für irgendwelche Webseiten,
und das ist auch ein Static Site Generator, glaube ich.
So, fertig.
Das hier kenne ich nicht.
Der Rest ist Management fürs Management.
Pyhole, ja, das ist, okay, vielleicht noch das, ja.
Der Böse muss doch erstmal wissen,
wo dein WLAN ist, der hat ja nur die SSID,
und das ist richtig.
Aber in der Regel dürfte das WLAN auch dort sein,
wo die Glühbirne in der Mülltonne liegt.
Es sei denn, er geht auf die Müllkippe, ja.
Das stimmt schon, wie gesagt, ich habe ja gesagt,
das ist vielleicht, das ist ein bisschen konstruiert, das Beispiel,
aber man sieht, worauf es rausläuft.
Und ich möchte, ehrlich gesagt, nicht,
dass mein WLAN-Passwort quasi im Klartext im Mülleimer liegt.
Das ist einer von den Neuen, ja.
Ist das ein CRS oder ein CS?
CRSS-Switch.
CRSS oder CSS?
CRS, ja, dann hast du vollwertiges Router-OS drauf
und wahrscheinlich auch gar keine so schlechte CPU.
Dann kannst du da drauf auch, ähm,
also dann ist das quasi eher ein Router als ein Switch.
Ich habe es ja schon ein paar Mal gesagt
und mich dabei unbeliebt gemacht,
es gibt keine Layer-3-Switches.
Kannst du ja machen.
Moin.
So, gucken wir das Video weiter.
Ich dachte, man sieht hier ein bisschen was
vom Umzug, aber sieht man gar nicht, oder?
Dann gucken wir uns das jetzt auch nicht weiter an.
Ich dachte, man sieht ein bisschen was von...
Ja, ne, dann ist ja langweilig.
Wow, wow, ja, ich nicht.
Ja, das habe ich auch gefragt,
warum man so viele Reverse-Boxes hat.
Zeigt mal her.
Okay, und übrigens wisst ihr, was ich auch an MikroTik mag?
Die haben eine halbwegs konsistente Benahmung von ihren Produkten.
CRS bedeutet,
Cloud-Router-Switch, im Prinzip das Wichtige davon, ist das R.
Das bedeutet, das ist ein Router.
Es ist ein Router mit vielen Ports, okay?
Der allerdings von der Hardware eher darauf ausgelegt ist,
dass der beispielsweise hohe Bandbreite switchen kann
zwischen den Ports in Hardware.
Aber es ist ein Router, also das R ist das Wichtige.
Da ist auch Router-OS drauf.
So, 8G bedeutet...
Normalerweise früher bedeutet das 8 Gigabit-Ports.
Warum die Cloud... Verstehe ich auch nicht.
Gibt keinen Sinn.
Du hast 8 Gigabit-Ports.
Mittlerweile lese ich hier raus, es sind 2,5 Gigabit-Ports.
Und es hat 2 SFP-Plus-Ports, also 10 Gig.
Gucken wir mal, ob ich recht habe.
Das ist auch eine Sache, die finde ich bei MikroTik ganz sinnig,
dass die Teile sinnvoll benannt sind, ja?
Ich habe hier auch noch einen stehen, und zwar einen CRS-600...
Nee, ich habe hier einen CSS-610 stehen.
Das ist noch 8 Gig und 2 SFP-Plus-Ports.
Ja.
Und man sieht, wir haben 2,5 Gig-Ports und 2 SFP-Plus-Ports.
Und vermutlich ist das Ding preis- leistungsmäßig auch ganz gut, ne?
Ja.
Kannst du dich nicht dafür beschweren.
Das geht sicherlich noch günstiger,
wenn es die Teile dann auch mal ordentlich lieferbar gibt.
Das ist aber okay.
Unter 200 Euro ein 8-Port 2,5 und ein 2-Port 10 Gig.
Was ist denn das? USB?
Ich meine, man kann da drüber...
Das Ding hat einen Samba-Server.
Ich weiß, man kann auf den USB-Stick Dateien übertragen,
aber dafür ist es ja nicht wirklich gedacht.
Was macht man damit?
Firmware-Update?
Weil man das hochladen kann normalerweise.
Die MikroTik-Dinger sind preis- leistungsmäßig immer super.
Kannst du dich nicht beschweren.
Daumen-MikroTik-Access-Points.
Ja...
Ich mag die...
Ich mag die nicht so.
Ich mag MikroTik-Switches, aber die Access-Points...
Ich hatte lange keinen in den Händen mehr, muss ich sagen.
Vielleicht sind die mittlerweile besser.
Ich bin da kein großer Fan von.
Aber sie sind günstig, auf jeden Fall.
Wir können ja mal kurz gucken...
Wo finde ich hier überhaupt die Access-Points, Leute?
Die reinen Access-Points.
IoT-Products? Nee, oder?
Also, hier... LTE? Nee.
Wo sind denn hier überhaupt die Access-Points?
Seht ihr das?
Hier, Wireless-Systems.
Hier, Wireless for Home and Office.
Das sind die ganz alten Dinger.
Ja.
Das sind auch die ganz alten Dinger.
Die willst du eigentlich nicht mehr haben.
Hier habe ich welche von.
Schmoll Access-Point, ihr erinnert euch vielleicht noch.
Da habe ich hier welche von liegen.
Der hier ist übrigens mega-nice.
Wenn man beispielsweise nicht WLAN-fähige Geräte WLAN-fähig machen möchte.
Also, zum Beispiel, ihr wollt bei euch am Hoftor irgendwas betreiben.
Irgendwas betreiben.
Was man per PoE versorgen kann.
Aber ihr habt keine Möglichkeit, dort Netzwerk hinzulegen.
Also, ich mache mal ein konkretes Beispiel von meinem Hoftor.
Machen wir jetzt einfach mal.
Mein Hoftor hat eine Tür-Gegensprechanlage dort installiert.
Und hat ein paar Kabel durch die Wand liegen.
Nur für die Tür-Gegensprechanlage.
Davon sind zwei Adern unbenutzt.
Und ich wollte da eine Kamera hinbauen.
Die geht allerdings nur über PoE zu versorgen.
Und selbst möchte ich halt per WLAN auf die Kamera zugreifen.
Weil ich kriege da kein Netzwerkkabel durch.
Also, was habe ich gemacht?
Ich habe die zwei Adernpaare, die zwei Adern, die durch die Wand noch gingen.
Habe ich auf der anderen Seite ein 12-Volt-Netzteil drangehängt.
Habe das an den Access-Point angeschlossen.
Ich hoffe, das ist der nicht.
Nicht, dass ich euch jetzt Mist erzähle.
Ja, habe das an den Access-Point angeschlossen.
Es könnten übrigens auch 48 Volt gewesen sein.
Ich weiß es nicht mehr genau.
Das, was die, das, was die, ich glaube, 12, 24, nein, 24.
24, glaube ich, das normale PoE.
Oder 48.
Ich glaube, die Kamera lief mit 24, whatever.
Hast du das Netzteil drangehängt?
So, und jetzt konnte man folgendes machen.
Konnte ein Access-Point powern, hier drüber.
Also, hier kommen zwei Adern aus der Wand.
Auf der anderen Seite vom Keller hängt das Netzteil dran.
Gehen hier dran.
Die Kamera selbst wird per PoE versorgt.
Ihr Netzwerkkabel an die Kamera.
Die Kamera wird per PoE versorgt.
Und der Access-Point bringt sie dann quasi ins Netz.
Das ist ein echt nice Gerät für solche Nischenanwendungen.
Wo du zum Beispiel an irgendwelchen bisschen entfernteren Stellen
Kameras anbringen willst, die selbst kein WLAN haben.
Was ja durchaus sinnvoll sein kann, wenn es besonders klein sein muss.
Beispielsweise an der Wand, an der Tür-Gegensprechanlage.
Da wollte ich jetzt nicht so eine fette WLAN-Kamera hinlegen.
Aber was ganz Kleines, Dezentes an der Tür-Gegensprechanlage.
Die restlichen Kabel verschwinden auch dahinter.
Da ist so eine Front, ein bisschen Platz dahinter.
Dafür sind diese Geräte echt praktisch.
Ansonsten würde ich die für nichts verwenden.
Aber für solche Nischenanwendungen ist der richtig, richtig gut.
Der hängt bei mir übrigens da immer noch rum.
Hinter der Tür-Gegensprechanlage.
Und...
...macht er sein Ding.
So, und das ist auch alt, das Ding. Das taugt nix.
Auch alles alt und taugt nix.
Das sind...
Das ist vielleicht ein bisschen neuer.
Haben die keine AX?
Okay, hier. AX.
Die neuen kenne ich nicht.
Da weiß ich nicht, wie gut die Mikrotik-Dinger sind.
Da weiß ich nicht, wie gut die neuen Dinger sind.
Is the blazing fast wire...
Blazing...
Is that written in rust?
Was unterstützt denn der?
Ja.
Vielleicht mal Zeit, just for fun, so ein Ding wieder auszuprobieren.
Aber eigentlich unsinnig.
Weil ich habe ja meine zwei Access Points.
Und mit denen bin ich sehr zufrieden jetzt.
Aber meine sind noch AC, nicht AX-Geräte.
Reicht aber auch dicke.
What's that?
Most popular pro-climbing languages.
Okay, das müssen wir uns jetzt mal kurz anschauen.
Ich mag diese Statistik-Dinger.
Okay, ich predikte mal...
Den Ausgang des Ganzen.
JavaScript, ihr könnt ja mal mitraten.
Ich sage JavaScript auf der...
Die Frage ist, was most popular ist.
Meist benutzt, meist Interesse-Projekte auf GitHub.
Am meisten verkaufte Programmierbücher, weiß man ja nicht genau.
Also von der Verbreitung und dem aktuellen Impact.
So, wie das benutzt wird, würde ich sagen JavaScript erstes.
JavaScript auf dem ersten Platz, eindeutig.
JavaScript ist überall.
Darf nicht vergessen, SpaceX fliegt mit JavaScript ins Weltall.
Und Elektron, MonkaS.
JavaScript gefolgt von Python, gefolgt von Java.
Also ich predikte...
Warte mal hier.
Ich predikte JavaScript, Python, JavaScript.
Python, Java.
Go.
Da bin ich mir nicht so sicher.
PHP.
Der Scheiß ist immer noch verbreitet as fuck.
Vielleicht .NET.
Ganz ehrlich, C ist da bestimmt auch noch irgendwie dazwischen.
Quelle.
Rust ist eventuell auch dabei.
Aber Rust kommt relativ weit unten.
Irgendwo wird hier C auch noch rumspuken.
Vielleicht, ich hoffe, C++ ist irgendwo hier dann.
Gucken wir mal.
Also das ist so meine Prediction für die Top 1, 2, 3.
Top 8. Gucken wir mal.
Ich mein, 1965, da ist klar, dass dann sowas wie Fortran, Kobol, Ada kommt dann später.
Das ist so Zeug da vorne mit dabei.
Das ist logisch, ja.
Ja, C, Pascal.
Das ist noch pre-C.
Algol, ja.
Ich mein, das ist ja schon wie Antike hier.
C dauert noch kurz, aber dauert nicht mehr allzu lange.
Ich glaub, C kommt 1900...
Boah, frag mich nicht.
75 oder irgendwie gab's die erste C-Version.
Das dauert noch kurz.
Ja.
Ich wusste übrigens auch gar nicht, dass Pascal vor C war.
Die Basics werden hier gemacht gerade.
Dass Lisp so beliebt ist?
Bestimmt... Gab's damals schon Emacs?
Nee, 73 noch nicht.
Warte, Moment.
Emacs Release.
Wann gab's das allererste Emacs?
85, okay.
So, jetzt könnte langsam C.
So 75 oder so ist, glaub ich...
Irgendwie so in dem Dreh.
75, glaub ich.
Irgendwie ging's los mit C.
Ja, ey, Tschätke!
Hä?
Nicht schlecht, oder?
So, C wird jetzt erst mal den ganzen anderen Schrott überholen.
Pascal geht auch noch gut ab.
Pascal war eine ganze Zeit lang super beliebt.
Ganz viele Leute, die früher mal Mathelehrer waren
und dann in der Schule umgesattelt haben auf...
Ja, wir brauchen ja auch langsam mal einen Informatikkurs,
waren ja alte Mathelehrer.
Und das Einzige, was die konnten, war Pascal programmieren.
Das war bei Mathematikern super beliebt damals, Pascal.
Ich bin mir nicht ganz sicher.
Ich bring's manchmal ein bisschen durcheinander.
War es nicht sogar so, dass der C-Sharp-Erfinder bei Pascal...
Nee, der war bei Delphi mit dabei, oder?
Genau, bei einem dieser Sachen war er mit am Start.
Ich weiß es nicht, mal kurz hier anders...
Wie schreibt man den Typ?
Jelsberg oder irgendwie so, ja?
Der hat...
War das Pascal, oder war das...
Ja, Turbo Pascal, genau.
Ja, das ist der C-Sharp-Erfinder.
Der war da auch mit am Start, ja.
Der ist ja auch schon ein alter Sack mittlerweile.
Ich auch, aber glücklicherweise nicht ganz so alt.
So, C wird jetzt erst mal diesen ganzen Schrott da oben überholen
von Fortran und Gedöns, ja.
Ada!
Oh, nee! Fucking C...
Leute!
So, in dem Dreh ist die Welt ein Stückchen...
ein Stückchen schlechter geworden.
Wenn mal Zeitreisen erfunden werden und man der Welt einen Gefallen tun will,
dann sollte man zurückreisen zu 1980 und mit...
Ich weiß nicht, wie der heißt, Bjarne oder so,
mal jemand reden, wie man die Sprache ordentlich aufbauen könnte.
Und dann haben wir vielleicht jetzt ein gutes C++.
C geht steil.
Ada, mir war nie klar, dass das so beliebt war.
Als ich angefangen habe,
mich dafür zu interessieren...
Das dauert noch eine ganze Weile, ja.
Ich bin hier ein Jahr alt, gerade.
Ja, ein bisschen über ein Jahr bin ich gerade alt.
Da war Ada null Bedeutung, hatte das, wo ich angefangen habe.
Guck dir mal...
Wisst ihr, was mir auffällt, was sehr merkwürdig ist?
Wir sind über 100%.
Gut, ich meine, das kann ja durchaus sein.
Man kann ja parallel mehrere Sprachen verwenden.
Vielleicht sind das auch keine Prozent, sondern...
Was auch immer.
Das ist irgendein Score, ja.
Wie war das so?
Haben wir nicht schon in der Schule erklärt bekommen,
dass so Graphen ohne Einheiten nicht gewertet werden und so?
Dass das nix taugt, wenn da keine Einheiten dranstehen?
C, ja. Beste.
Ah.
Muss das sein?
Muss ich C++ verwenden?
Ja.
C++, der Ernst, haben wir auf dem zweiten Platz jetzt gesehen, ja.
Das schmerzt ja...
Dann ja doch lieber Ada.
So langsam aber sicher könnte Java auch mal an den Start kommen, oder?
Das dauert nicht mehr lang.
Oh, Perl.
Perl war mal eine Zeit lang super beliebt.
Ich habe es nie so ganz verstanden.
Oh, jawoll.
Wir sind verloren.
JavaScript ist am Start.
Java ist auch am Start.
Java.
Ja, das kann man ja auch so viele Leute nennen.
Java und JavaScript, das wundert mich nicht.
JavaScript geht durch die Decke ab dann, wo es mit Internet und Browsern anfängt.
Das ist jetzt so in dem Dreh.
Also 1998 war ich schon online.
Da war ich einer der Ersten bei uns im Ort.
Und dementsprechend PHP, JavaScript und halt im Enterprise Business Sektor Java.
PHP wird noch viel weiter abgehen jetzt.
Ja, Java, JavaScript, zack.
Ja.
Warum guckt da jetzt so eine Eule um die Ecke?
Also es wird uns, JavaScript wird uns auf jeden Fall hier in den Top 3 Sprachen bis zum Schluss erhalten bleiben.
Java geht wieder ein Stückchen runter vermutlich.
Oh, guck mal hier ist die Sharp, ploppt auch langsam auf.
2002, das dürfte .NET 1 gewesen sein, 1.1 oder so in dem Dreh.
Zwischenzeitlich müsste so 2000, ich predikte mal, 2006, 2007 rum und 2005, 6, 7, 8 wird Ruby auch mal kurz aufhören.
Und dann wieder verschwinden.
Mit Ruby, also Ruby on Rails war ja damals das Ding schlechthin.
So 2007 rum, 2006 rum.
Mal gucken, ob das stimmt, dass da mal kurz Ruby, Ruby hier so rein lurkt und wieder verschwindet.
Ruby, da sind wir.
Ja, das war die Ruby on Rails Zeit, wo ganz viele Leute sich als Rockstar Programmer bezeichneten.
Ja.
Wo ich bis heute nicht weiß, was das eigentlich sein soll.
Aber Ruby hatte ganz viele Rockstar Programmer.
Ja, also langsam aber sicher ist die Zeit von Ruby on Rails auch wieder vorbei.
Das verschwindet jetzt gleich wieder.
Ja, und tschüss.
Ah, Mac und äh, ja, jetzt auf jeden Fall auch schon iOS 2010 kommt glaube ich das erste iPhone.
Irgendwie so, gell.
Vielleicht schon ein bisschen früher.
Aber irgendwie so in dem Dreh.
Ah, 2007, ja.
Gut, das hat ein bisschen gebraucht mit App, App Store und allem.
Jetzt ist auf jeden Fall Mac und iOS Verbreitung nimmt zu.
Deswegen ist da jetzt auch Objective C mit dabei.
Visual Basic verschwindet glücklicherweise wieder in der Versenkung, da wo es hingehört.
Ist R und Matlab nicht das gleiche?
Zwift, okay.
Ruby ist wieder weg vom Fenster, klar.
Ja, JavaScript, das ist klar.
Ab hier ist das Internet Mainstream und die Leute haben auch festgestellt, dass man damit Geld machen kann und man Apps in JavaScript programmieren kann und allem.
Ich mein, seriously, das Internet war vorher schon Mainstream, aber jetzt so richtig, wo dann auch die Oma online ist und so.
Aber seriously, meine Prediction sieht gar nicht mal so falsch aus jetzt, oder?
Wir haben noch zwei, drei Jahre Zeit.
Das sieht schon, sieht schon nicht verkehrt aus.
Kotlin, okay.
Ja.
Go.
Oh, Go muss ich aber beeilen, wenn das soweit wird.
Rust, na klar.
Ach, TypeScript habe ich vergessen.
Da habe ich ja gar nicht dran gedacht.
Okay, jetzt gucken wir mal, wie akkurat meine Sache war.
Okay, das ist Schwachsinn.
JavaScript muss vor Python sein, egal.
JavaScript, Python, Java.
Also mit den Top 3 war ich schon mal ziemlich gut dabei.
Go ist weiter unten.
Aber ich gehe auch vom aktuellen Zeitpunkt aus, das ist Ende 2022.
Soviel war mit dabei.
PHP ist auch mit dabei.
C ist auch mit dabei.
C Sharp ist auch mit dabei.
Und sogar Rust ist dabei.
C++ ist leider höher, als ich gedacht habe.
War ich doch gar nicht so verkehrt.
Ja.
Nice.
Was haben wir denn hier noch zu bieten?
How a leap day took down Microsoft.
Das sind wieder irgendwelche uralten Sachen, wo darüber berichtet.
It has been over 10 years.
Ja.
Aber das ist 11 Minuten, das können wir uns mal angucken.
Die Videos sind immer ganz gut.
On leap day, February 29th, 2012.
By the way, leap day, ah ja, okay.
Das ist quasi Februar.
Also das, was bei uns...
Nee, wie heißt das bei uns?
Schalt... Schalttag?
Nee, wie nennt man das eigentlich?
Schaltjahr.
Und wie heißt der Tag bei uns?
Hat das irgendeinen speziellen Namen?
On leap day, February 29th, 2012.
Windows Azure.
Ich weiß, dass es 29...
Aber wir haben ja da einen extra Namen für.
Übrigens, wusstet ihr, dass Schweden mal einen 30. Februar hatte?
Die Story habe ich schon öfters erzählt,
aber das habe ich mal in irgendeinem Konferenztalk gehört.
Und zwar...
Schweden hatte mal einen 30. Februar,
weil Schweden vergessen hat, ihren Kalender umzustellen.
Die Schweden wollten den Kalender umstellen.
Und die wollten das nicht machen.
Und die wollten das nicht machen.
Und die wollten das nicht machen.
Wie alle anderen Staaten drumherum.
Quasi am Stichtag wird umgestellt.
Sondern die haben das über einen Zeitraum von...
Boah, keine Ahnung.
Zehn Jahren oder so wollten die das umstellen.
Von einem auf den anderen Kalender.
Sodass quasi der neue Kalender vom alten...
Dass der alte Kalender vom neuen quasi eingeholt wird.
Und es dann so smooth übergeht in den neuen Kalender.
Und es dann so smooth übergeht in den neuen Kalender.
Und es dann so smooth übergeht in den neuen Kalender.
Das Problem war nur,
dass sie es vergessen haben umzustellen, weil sie Krieg geführt haben.
dass sie es vergessen haben umzustellen, weil sie Krieg geführt haben.
In dem Jahr.
Und dann mussten sie den 30. Februar einführen,
um das Ganze wieder...
Dass es wieder funktioniert hat.
Und dann haben sie umgestellt auf den neuen Kalender.
Irgendwann, keine Ahnung, frag mich nicht, wann das war,
1650 oder so,
hatte Schweden mal den 30. Februar.
Azir, also known as Azir, Azor, Azor, Azuray and Asus,
Azir, also known as Azir, Azor, Azor, Azuray and Asus,
faced a major outage when its VMs, GAs,
faced a major outage when its VMs, GAs,
failed to generate transfer certificates.
Was?
Das war zu viel für mich.
... to report the servers as faulty to the FCs,
... to report the servers as faulty to the FCs,
which would trigger automatic service healing,
which would inadvertently...
Wenn du Smart Home richtig machen willst,
dafür musst du nicht wirklich eine Programmiersprache lernen.
Blockly geht auch, klar.
Also ich persönlich mag Home Assistant am liebsten.
Blockly klingt mir ein bisschen danach,
als benutzt du I.O. Broker.
Kann das sein?
Oder was benutzt du dafür?
Das ist nicht AI-generated.
Der hört sich schon immer so an.
Selbst vor AI-generated.
... able to rewatch this section and think,
huh, it all makes sense now.
Perhaps I learned something on YouTube today,
even if it was just a bunch of domain-specific terms
I'll never see again for the rest of my life.
So let's start with Azir,
which is just Microsoft's cloud computing platform.
So let's start with Azir,
which is just Microsoft's cloud computing platform.
So let's start with Azir,
which is just Microsoft's cloud computing platform.
Though you may be more familiar with its competitors,
like Alibaba Cloud,
Oracle Cloud, IBM Cloud,
maybe even Google Cloud,
the fundamental offering of these companies
is the ability to rent virtual machines.
These virtual machines
are servers simulated by software,
so a bunch of virtual machines
can run on the same hardware.
Just like how multiple virtual reality headsets
can run in the same reality.
Warum haben wir eigentlich Subtitel?
Egal, lassen wir mal an.
Subtitel an oder aus?
So companies and people like you
can rent and access them through the internet.
Ich muss ja sagen, mir persönlich gefällt das Azure Web Interface.
Die haben ja dieses zweigesplittete Web,
also wenn du das hier anklickst, klappt das noch mal aus
und hier sind die eigentlichen Daten dann erst.
Aber mir gefällt das Azure Web Interface.
Ich mag das mehr als Google Cloud.
Aber noch mehr Azure Web Interface enjoyers.
You see, rather than buying a bunch of hardware,
fitting it all together,
and maintaining it forever,
you can simply rent all of this in the cloud.
While they're not actually in the clouds,
it'll be a few more decades
before they figure out how to do that.
Ja, wir wissen, dass die Cloud auch nur Computer sind,
die woanders stehen.
Deswegen wissen wir auch,
dass das nächste Jahr wird das Jahr von Serverless-less-ness.
Oder wie war das?
Serverless-less-ness.
Also sprich, man betreibt die Dinger wieder selbst.
... a single VM in a server
in a cluster in a data center on the ground.
For the rest of this video,
I will be referring to these cloud-computed instances...
Ja, hier in Hanau um die Ecke hat Google jetzt auch ein Rechenzentrum.
Also, bin ich mir gar nicht sicher, ob sie wollen oder schon haben,
aber sie werden auf jeden Fall eins haben.
Gibt es hier in Hanau, gibt es Maps, Hanau, Wolfgang, Kaserne?
Irgendwo hier hinten.
Oh, das ist auch so ein Ding.
Wisst ihr, wie sehr mich das nervt,
dass man nicht mal auf Google Maps jetzt kommt,
beim Anklicken hier?
Das regt mich so auf.
Ich weiß, da sind irgendwelche EU-Regularien oder so was,
dass man das nicht mehr darf, aber es ist nervig.
Ja, irgend so ein altes Kasernen-Areal hat sich, genau,
hat sich Google jetzt gekauft
und will ein Rechenzentrum hier um die Ecke bauen.
... as VMs, but these terms are totally interchangeable.
AWS calls them Instances.
Microsoft wants to be different and uses VM instead.
I wonder what Google calls them.
Äh, Instances.
Ja, steht aber auch da, Instances.
A piece of software called the hypervisor runs on each server
to launch customer VMs.
This was likely Hyper-V or some internal implementation of it,
which is a Type-1 hypervisor that runs directly on hardware.
Compare that to Type-2 hyper...
Ich bin mir nicht sicher, was Google verwendet.
Wahrscheinlich irgendeine KVM-Geschichte für Linux.
Vielleicht auch ESX.
Ist da nicht gestern ein Lagerhaus abgebrannt?
Keine Ahnung.
... which you can install on your computer right now
to run Tempo OS.
This guest OS will be slower than your host OS,
as the VM needs to go through the host...
Wann geht's denn jetzt eigentlich los mit Ausfall bei Microsoft?
... to talk to the hardware.
This is fine for educational or hobbyist purposes,
but for enterprise-level performance,
Type-1 hypervisors are used to skip the host OS layer.
So we know Azure uses a Type-1 hypervisor, yet in this...
Wie will der mir sagen, dass meine VM kein Enterprise-Setup ist hier?
Das ist Arch-Linux. Mehr Enterprise-Hi-IQ geht nicht, by the way.
... as you see a host OS.
Furthermore, when you read the docs,
you see that there is a so-called root or parent partition,
which runs Windows and creates guest VMs.
So what's going on here?
Well, when you run Hyper-V,
it transparently converts the original OS into a special VM in the parent partition.
This host OS...
Also, mich wundert nicht, dass Hyper-V abgekackt ist.
Hyper-V ist ja eh so'n Ding.
Irgendjemand bei euch in der misslichen Lage, sich um Hyper-V kümmern zu müssen?
... behaves identically as before.
It can talk directly to hardware as if the hypervisor didn't exist and run Fortnite.
But you can now easily manage your guest machines from the host OS.
Although the interface makes it look like you're creating VMs on top of the host OS,
it is actually making hypercalls to Hyper-V.
Which spins up VMs in the child partition, which then talk directly to Hyper-V.
So there are a bunch of servers running these hypervisors,
and clusters of about 1,000 servers are managed by a fabric controller or FC,
which provisions and monitors VMs in its assigned cluster.
Dividing a data center into clusters is very...
Wann geht's denn los? Hier, der Incident. Wir gucken uns, wir skippen mal kurz.
A host agent receives a request to start a new VM and sends a hypercall to do so.
It patiently waits for the initialization to complete,
but little did it know that the VM was doomed to an unseemly fate.
The guest agent starts up and tries to generate the transfer certificate.
It nonchalantly passes in the expiration date it's been instructed to use.
Ich glaube mittlerweile doch, dass es AI ist.
Der Kerl hörte sich früher genauso an.
Hatte seine Stimme AI-isiert.
Wobei, vor einem Jahr gab's das auch schon.
Äh, vor einem Jahr? Wie gibt's das, seit einem Jahr?
Wir haben schon früher Videos von dem geguckt.
...but that would be the last thing that it ever...
Das ist AI-Stimme, oder?
So langsam aber sicher glaub ich auch, dass es AI-Stimme ist.
...does. The GA airs out and terminates, leaving the VM initialization in limbo.
The HA is still waiting.
Seconds pass, then minutes, then dozens of minutes.
Something wasn't right.
The HA checks its clock.
It's been 25 minutes.
This was the longest that the HA was instructed to wait for an unresponsive VM.
Let's try turning it off and back on, thought the HA.
Was meistens ja eine gute Sache ist.
It reinitializes the VM, which attempts the startup sequence a second time.
The same thing happens.
The VM never reports a success to the HA.
One last time, thought the HA, as it rebooted the VM once more.
It had been instructed to try three times, because two isn't enough and four is too many.
But inevitably the same result occurs.
Now the HA concludes it must be a hardware problem and that something was wrong.
Aber wisst ihr, was ich gut und schlecht zugleich finde?
Dass die so genaue Vorgaben haben, was sie machen sollen.
Das heißt, es gibt dann wenig so mit, ah, ich weiß jetzt nicht, was ich machen soll und so.
Und im Zweifelsfall kann der Support-Typ sich auch rausreden mit, wieso, ich hab doch genau das befolgt, was ich machen soll.
Auf der anderen Seite ist es auch wieder blöd, weil wenn da jemand gesessen hätte, der vielleicht ein bisschen Ahnung davon gehabt hätte,
man kennt jetzt das eigentliche Problem nicht, vielleicht wäre das gar nicht zu dem Unfall gekommen.
...was wrong with the server.
So it reports itself as faulty to the Fabric Controller and moves the server to a state called Human Investigate or HI.
Since the server is now considered unhealthy, the FC begins transferring VMs off the faulty server to different servers in a mechanism dubbed Automatic Service Healing.
This is the mechanism which would lead to the eventual downfall of the entire client.
The VMs running on the server since prior to Leap Day are doing just fine, but under the FC's orders, they are forcibly shut down and moved to a new server.
They all begin reinitializing, but as expected, they all fail to do so.
The FC is oblivious to the fact that it is basically infecting all of the servers under its control with the same issue and continues to move VMs from...
Okay, das Ding switcht zu Investigate.
...versucht die VMs zu migrieren und dabei kacken die wieder ab beim nach dem Migrieren gestartet werden.
Also okay, das ist so quasi Chain Reaction.
Es geht immer mehr kaputt.
Was man daran auch wieder schön sieht ist, DateTime ist einfach nur der pure Abfuck.
Egal in welcher Programmiersprache, in welchem Kontext, DateTime Handling ist einfach der größte Shit ever.
...from HI-Servers to healthy servers.
Two hours later, the cluster has seen better days.
There are so many servers in HI that the FC gives up.
It marks the entire cluster as HI and disables all further automatic actions.
Right, so all of this meant it was currently impossible to launch a VM and your VM would be toast if it was caused in automatic service healing.
But it actually gets slightly worse.
The GA also restarts when it receives updates and there was an ongoing deployment going out to update the GA and HA.
So any clusters which received this deployment would also blow up.
By 6.38pm the devs discovered and had a good laugh at the trivial Leap Day logic and the fact that they weren't going to sleep for the next 24 hours.
By 6.55pm the engineers disabled customer management of VMs which prevented them from fruitlessly deploying, updating or scaling their applications as all these would trigger automatic service healing and make the issue worse.
By 10pm they had a plan.
By 11.20pm they had the GA fix ready.
Only the...
So if you really want to leave them alone, this is already pretty fast.
By 11.20pm they had the GA fix ready.
They are already pretty good at this, but they also have a lot of money on them.
So if the VM management in Azure has problems, I mean 2012, maybe not as much as today, but they have a lot of money on them.
And in case of doubt, not only what they lose, because you can't use the service,
but if they run their SLAs,
in case of doubt they also lose some decisions and stuff like that.
This is really really fast, in really high amounts, if they don't do that.
GA fix ready.
Everything is being drummed together that can be drummed together.
Only those involved would know why preparing the fix to properly increment the dates by a year took 5 hours.
By 1.50am the next day they finished testing.
By 2.11am they had rolled out the new GA to one production cluster.
Finally,
by 5.23am the majority of the clusters had been fixed.
Cluster finally by 5.23am
This is really pretty fast, if you look at this.
I don't know, what is this, 16 hours or something?
20 hours or something?
By 3am the majority of the clusters
No, wait a minute.
No, that's only 8 hours, isn't it?
8 hours, look at this.
8 hours to one production cluster.
Finally by 5.23am
Here?
20?
To 4?
That's 8 hours, isn't it?
24?
To 4?
That's 8 hours.
23am
What?
12 hours?
Oh, I have this now.
I calculated from bug identified.
Bug identified to fixed?
That's not bad, right?
The majority of the clusters had been fixed.
Why not all of them?
Well, going back to 2am after they finished testing the fix,
there were 7 clusters in which the unrelated GA and HA deployment was in progress.
So some servers had the new software, while others did not.
In the other clusters they simply took the existing version and added the fixed GA,
but here there were two versions.
They could add the fixed GA to either, but in the end they decided to choose the old one,
since it was time-tested and likely safer.
But when they were creating this package with the fixed GA and old HA,
they somehow misclicked and included a networking plugin
from the new version, which if deployed would be a disaster
since it was incompatible with the old HA.
They had a second lifeline though, as according to standard practice,
they must first test the rollback package on a single server to see if it even works.
They did that and saw that VM started successfully and appeared healthy,
so they were eager to go ahead with the deployment.
So at 2.47am they started blasting,
which deployed to every server in all 7 clusters at the same time.
This incompatibility soon became
evident, as it would turn off network access for the VMs on the server,
rendering them essentially unusable.
To make matters worse, some major Azure services,
such as their access control service, happened to be hosted in these 7 clusters.
So at 3.40am they prepared a new deployment,
which had the compatible version of the network plugin and tested it more thoroughly,
before blasting out the fix once more at 5.40am.
Wisst ihr, was ich daran immer cool finde?
Man sieht daran,
dass die auch alle nur mit Wasser kochen.
Das wirkt von außen halt so Blackbox-mäßig und du denkst dir,
okay, das wird halt einfach, das geht halt einfach.
Das ist innen drinne genau der gleiche Mist wie überall anders auch.
Vielleicht ein bisschen besser getestet,
vielleicht auch ein bisschen besser durchdacht,
zentralisiert und auch wirklich gute Leute dran,
aber im Prinzip unterm Strich ist es der gleiche Mist wie überall anders auch
und es kochen alle nur mit Wasser.
Es ist nicht nur operativ,
aber ein paar bestimmte Server waren in korrupten Staaten von zu viel geblastet.
Die Entwickler und die Operationen-Staff arbeiteten furchtbar den Rest des Tages
und alles wurde 18 Stunden später vollständig nach 2.15 Uhr am folgenden Tag restauriert.
Das war ein ziemlich außergewöhnliches Event.
Wenn etwas wie das zu AWS oder Azure heute passiert,
würde das ganze Internet nicht mehr Klickbait sein.
Glücklicherweise ist das über eine Dekade hergekommen,
als der Cloud-Markt nichts war, als es heute ist.
Die späte Rückkehr könnte an den Fakt, dass der Cloud damals etwas neu war, bezeichnet werden.
Sie bemerken, dass sie eine Stunde oder so auf Detektion haben können,
da es keine Alarmen auf GA-Initialisierungsverluste gab,
sondern nur auf Servern, die mit HI bezeichnet werden.
Aber ein Leap-Day-Bug wie dieser ist schwer.
Ausfallschritte werden meist durch Deployment oder Kundenaktion getriggert,
beide von denen können zu einer Art und Weise kontrolliert werden durch Staggering und Sharding.
Aber nach meinen Kalkulationen wird es gleichzeitig 0 UTC auf der ganzen Zeit überall auf der Erde.
Also würde dieser Latent-Bug
auf jeden Azure-VM weltweit manifestieren.
Um für die Ausfallschritte zu kompensieren,
hat Azure einen 33%-Discount für alle Anwender dieser effektiven Geräte
für den ganzen Monat gegeben, egal ob sie beeinflusst wurden.
Das scheint eigentlich ein ziemlich guter Deal zu sein
und wahrscheinlich eine großartige Ausgabe für Azure,
aber es ist alles wert, um diese Kundenvertrauen zu restaurieren.
Ich habe vor 3 Stunden meinen Art-Schnitt geupdatet und es gibt keine neuen Packages.
Das ist aber nicht, was ich hier von Pleading Edge Rolling Release erwarte.
Ich brauche neue Packages.
Ja, stimmt, du hast recht.
Ja, das ist vorher passiert.
Ab Bug Identified waren es 8 Stunden.
Wobei man halt nicht weiß, ob Bug Identified mit dem Art-Schnitt
in der Art-Schnitt-Release stattfindet.
Ich weiß nicht, ob das so ist.
Ich weiß nicht.
Ich weiß nicht, was Art Identified bedeutet mit wir wissen, wo es ist
und was man fixen muss, sondern halt nur wir wissen,
es ist irgendwas auf unserer Seite und ungefähr, wo es sein muss
und das eigentliche Suchen.
Also ich habe das so interpretiert, dass die wussten, okay,
bei uns ist irgendwas verbuggt mit Date-Time-Handling
und dann mussten sie erst mal suchen, wo denn jetzt genau und was
und was machen wir dagegen.
Also ich finde das in 8 Stunden echt nicht schlecht.
Das ist ja nicht jetzt irgendwie da in einem Rack, was irgendwo rumsteht,
wo man mit einem USB-Stick hinrennst oder so.
Also in so einer großen Umgebung sind 8 Stunden nicht schlecht.
Ja.
Bei uns früher, sowohl damals noch beim Provider als auch bei der Bank,
wo ich gearbeitet habe, da wäre natürlich 8 Stunden Ausfall echt fatal gewesen,
aber das waren halt auch deutlich weniger komplexere Systeme als Azure.
Und bei 8 Stunden Ausfall haben wir auch hingekriegt.
Aber die meisten Sachen waren immer, immer sehr schnell gefixt.
Das war dann mal eine Stunde weg, zwei Stunden weg, eine halbe Stunde weg.
Wenn mal was war, da waren wir meistens deutlich schneller.
Aber das war dann auch oftmals
nur Probleme eben nicht auf, also nicht auf Infrastrukturebene, sondern Anwendungslogik.
Chatke, ich geh jetzt was essen, ich hab Hunger.
Hunger AF.
Ich habe euch ja versprochen, wir streamen mehr.
Und ich habe es mir zu Herzen genommen.
Wir haben ja gestern gestreamt, heute gestreamt, vielleicht streamen wir heute Mittag nochmal.
Und nächste Woche ist Feiertag, da bin ich auch am Start.
Eventuell bin ich Montag nochmal am Start.
Es gibt jetzt wieder ein bisschen mehr Streams.
Zumal es auch einiges gibt, was erledigt werden muss.
Aber jetzt erst mal PepoFatTime.
Ach ja, es ist Sonntag.
Ratet mal, was es heute gibt.
Lachsnudeln.
Nein, falsch.
Wrong.
Keine Nudeln mit Lachs.
Spaghetti Bolle.
Korrekt.
Es gibt ja eigentlich nur zwei Varianten sonntags.
Spargel.
Ey, ich habe letztens was gegessen.
Das war richtig nice.
Weil du sagst Spargel.
Das war, tja, grüner Spargel, dabei mit Kartoffel, Tomaten und Parmesan, Käse.
Sowas hier in der Richtung war das, ja.
Und das hat sehr, sehr nice geschmeckt.
Wenn es auch auf den ersten Blick mega öko gesund aussieht,
hat das wirklich nice geschmeckt in Kombination.
Ne, so sah das nicht aus.
Das sah besser aus.
Ja, eher so in der Richtung.
Das hat wirklich gut geschmeckt.
Hätte ich gar nicht gedacht.
Wie gesagt, das sah so öko gesund aus.
Aber ne, war echt nice.
Bis echt ist das so.
Aber das ist ja nicht schlimm, weil ich bin ja auch Boomer.
Ich werde dieses Jahr 40.
Könnt ihr euch das vorstellen?
Da ist man Boomer.
Aber sowas von.
Boomer ist ja ein weitreichender Begriff.
Und nachdem in der heutigen Zeit eh jeder alles sein kann,
gibt es bestimmt auch schon 20-jährige Boomer.
Boomer ist ja mehr eine Denkweise als ein Alter.
Aber wenn es das angeht, bin ich wahrscheinlich der jüngste Boomer.
In meiner Generation ist das halt, das zieht sich durch,
durch meine Generation zieht sich eben dieses Geboomere durch, ja.
Du hast welche, die sind mit Technik, Computer und Sachen aufgewachsen.
Die sind keine Boomer und werden es wahrscheinlich auch nicht.
Und du hast welche, die sind noch so oldschool.
Und das sind jetzt in meinem Alter schon die Ultra-Boomer.
Das sind die, die auf Facebook gehen und an Ostern anzügliche Witze
mit Teufel-Emoji posten und sich super lustig finden.
Eierwitze an Ostern in Facebook-Gruppen posten mit Teufel-Emoji.
Das sind die Ultra-Boomer.
Da gibt es auch irgendwie so ein Subreddit.
Ich bin 40 und lustig oder irgendwie sowas.
Wie geht das? Ich bin über 40 und lustig.
Irgendwie so in der Richtung.
Ich weiß nicht. Ja doch, ich glaube, so heißt das.
Egal, ich gehe jetzt was essen.
Vielleicht bin ich nachher noch mal da.
Kann aber auch sein, dass ich nicht da bin, weil MMO-Kreiselgrind ist strong.
Es hat doch vorhin irgendjemand einen Heiser-Artikel geschickt,
wo ich noch reingucken wollte.
Was war denn das eigentlich?
Keine automatische Lösung für 0x-Update-Fehler mehr geplant.
Ein Update für die Windows-Recovery-Umgebung
schlägt seit Längerem auf, mit dem ihr...
Was?
Jetzt sagt er, dass er sich nicht mehr an eine automatisierte...
Und? Was macht das jetzt?
Ich verwende keinen BitLocker, also juckt mich nicht.
Weiterer Grund, warum kein BitLocker-Schrott eingesetzt wird hier.
Okay, dann gehe ich...
Äh, nicht pennen, Essen.
Fressen gehe ich jetzt.
Bis dann, see you.
