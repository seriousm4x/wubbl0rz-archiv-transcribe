So, moin Leute, heute wird es ganz furchtbar schlimm, das weiß ich jetzt schon.
Ihr wisst, wie gerne ich C++ habe.
Es gibt keine beschissenere Sprache als C++, aber wir kommen nicht drum herum.
Wir kommen nicht drum herum, Leute.
Ich habe mir ein paar WebAssembly Tutorials durchgelesen und gerade wenn man Libraries
verwenden will, die eigentlich selbst C++ sind, kommst du im Prinzip nicht drum herum.
Radiant Taser, Dankeschön für den... Tracer, nicht Taser.
Danke für den Sub.
Das wird ganz, ganz schrecklich heute, ich sag's euch.
Ganz schlimm.
Wir probieren das gleiche, was ich gestern mit Rust probieren wollte, was überhaupt
nicht funktioniert hat.
Spiderschwein.
Pog-Subscription, Dankeschön.
Wir probieren FFM-Pack im Browser zu verwenden und zwar nicht wie die ganzen Noobs das machen.
Also nicht so wie es beispielsweise schon zig Github-Projekte gibt oder so, die im Endeffekt
einfach nur so die FFM-Pack-CLI rappen oder so.
Nee, nee, nee, nee, nee, das machen wir nicht.
Wir machen richtig echtes FFM-Pack.
AV-Package, Decoder, sonst was.
Und wir gucken mal, ob ich es hinbekomme, ein Video quasi mit FFM-Pack im Browser zu rendern.
Das ist natürlich...
äußerst ineffizient.
Allerdings, wenn man bestimmte Codecs abspielen will, die der Browser nicht kann, theoretisch
die einzige Möglichkeit, sowas zu machen.
Ansonsten ist es wahnsinnig ineffizient, ja.
Gucken wir mal.
Alter, hier steigt gerade einer mit einem Turban aus, gegenüber auf dem Parkplatz.
Gegenüber.
OKS.
Geh los.
Na gut, wenn er meint, oder?
Sonderlich stylisch sieht das nicht aus, finde ich.
So, ähm.
Also, wo sind wir stehen geblieben?
Genau, also, wir machen eine C++-Wrapper-Sampley und wie gesagt, ich weiß, dass ich kotzen werde,
das ist mir jetzt schon klar, aber vielleicht bekommen wir das hin.
Wenn wir es hinbekommen, wäre ich äußerst überrascht, weil gestern in Rust ging ja mal
gar nichts.
Aber FFM-Pack ist halt in C++ auch deutlich einfacher zu benutzen, als von Rust aus, mit
irgendwelchen Zwischenwrappern und hast du nicht gesehen.
FFM-Pack ist zwar nicht memory-safe, aber die Browser sind wirklich einfach zu benutzen.
Aber die Browser sind memory-safe, das heißt, kann nix passieren.
Im schlimmsten Fall crasht das Browser-Tab, wobei, da bin ich mir gar nicht so sicher.
Kann man es mit WebAssembly schaffen, den Browser crashen zu lassen oder crasht auch nur das
Browser-Tab?
Da bin ich mir gar nicht so sicher.
Bestimmt gibt es schon wieder tausend Sicherheitslücken dafür.
So, mal gucken.
Also, als erstes muss ich mal kurz den komischen Papagei wegmachen und ihn vor allem einschalten.
Also, Fireship hat sowas ähnliches gemacht, wie du vorhast.
Kann ich die Links teilen?
Ja, schick.
Ach du, das?
Nee, nee, nee, nee.
Das kenn ich.
Nee, das.
Der hat was anderes gemacht.
Der hat die Noob-Variante gemacht.
Ich mein, okay.
Man kann sich drüber streiten, ob es, wenn man mit WebAssembly, überhaupt nur die Noob-Variante
ist.
Was der macht ist, der verwendet, glaube ich, einen fertigen FFM-Pack-Wrapper.
Also, er verwendet entweder WASM, FFM-Pack-WASM oder FFM-Pack-JS.
Ja.
Und im Prinzip ist das quasi ein Wrapper für die FFM-Pack-Kommandozeile.
Wir machen richtig FFM-Pack.
FFM-Pack-Decoder, AV-Package reinschieben, AV-Package auslesen.
Also, das, was man Low-Level mit FFM-Pack macht.
Wir rappen nicht die Kommandozeile.
Stream war gemutet?
Nee.
Na, deiner.
Meiner nicht.
Also, hier kommt der Sound raus.
Wir machen den Real-Shit.
Ja.
Leute, das, was wir heute im Stream machen, das gibt es nirgendswo.
Im Internet.
Im Internet zu sehen.
Falls es klappt.
Ich hab, ich hab wirklich rauf und runter gesucht.
Es gibt da auch keine guten Beispiele für.
Ich hab einen Blogpost gefunden.
Den hat gestern schon jemand im Chat gepostet.
Wieder Urlaub.
Nee.
Warum?
Kommt's heute Samstag.
Heute hat, glaub ich, fast jeder frei.
Das gibt's sonst nirgendswo im Internet.
Also, hier.
Exclusive Content.
So, den ganzen Krempel müssen wir wieder, wieder wegmachen.
Ah, nee.
Moment.
Die Konsole lassen wir auf.
Die Konsole ist gut.
Da muss ich gleich wieder dran denken.
Den Chat unten.
Äh, ja.
Das, das machen wir dann.
Ich, ich muss, ich muss den Chat unten ja wieder einblenden.
Okay, diesen ganzen Krempel machen wir mal zu.
Repos.
Mkdir.
Monka.
Monka.
C++.
Bester Projektname.
So, mal schnell, schnell noch ein Update machen.
Wer weiß.
Vielleicht.
Brauchen wir das ja.
Habt ihr das eigentlich mitbekommen mit der Internet-Internet-Grundversorgung, was jetzt
als Internet-Grundversorgung geht?
Guckt mal.
1,7 Mbit Upload.
2022.
Borgers Upload.
Richtig krasse Bandbreite.
Richtig, äh, Breitband-Internet-Anschluss, ja.
Beim Download bin ich mir übrigens gar nicht sicher, was der Download.
Steht das überhaupt drinne?
Download.
Den Mbit.
Genau.
10 Mbit.
10 Mbit.
Und 1,7 Mbit Upload.
Ich mein.
What the fuck?
Was?
Was?
Und ein Mbit.
Damit kannst du noch nicht mal Full-HD-Streams gucken?
Das ist hier, so ist das.
Das ist ein äußerst passendes Gift dafür.
Genau das ist es.
Mit 4K-Video-Streaming musst du da erst gar nicht anfangen.
4K.
LOL.
Da kannst du froh sein, wenn es für 720p reicht.
Und das wird auch knapp.
10 Mbit ist wirklich nicht viel.
10 Mbit war der absolute Wahnsinn
Als der ganze Kram
Neu war
Ich meine, ich überlege gerade, was war mein erster
DSL-Anschluss
Das war ein Mbit, oder?
Ne
Was war das? 768
768K war das, oder?
Das aller allererste DSL
Oder?
Also quasi
Sogar noch unter dem Mbit, naja gut
Es kam einem wahnsinnig schnell vor
Damals
Du kannst alles knicken im Endeffekt
Mit 10 Mbit Download
Und 1,7 Upload
Wisst ihr, die 1,7 Upload haben sie auch bloß
Gemacht, dass die TCP-Bestätigungspakete
Überhaupt rausgehen
Ich mach mal kurz Update überall
Bald kommt eine Steuer
Für alle, die ein Auto fahren
Oh, geht mir mal nicht
Auf den Sack, Alter
Leute, wisst ihr was
Die letzten 10 Jahre
Ich bin mir nicht sicher, ob es an mir liegt
Oder an der Welt um mich drum herum
Ich glaube, es liegt an mir
Liegt weniger
Ich glaube, die Welt um mich drum herum war im Prinzip schon genauso
Aber was die letzten
10, 15 Jahre passiert ist
Also vor 15 Jahren hatte ich so
Ja, wie nennt man das
So standardmäßig, bauchgefühlmäßig
Oder meine Standards-Herangehensweise
War eigentlich
Die Welt will mich nicht verarschen
Und will mir nicht auf den Sack gehen
Und die Leute sind eigentlich gar nicht so nervig
Wie sie vielleicht wirken
Und
Die Welt will nichts Böses von mir
So, das hab ich so vor 15 Jahren gedacht
Mittlerweile denke ich
Die ganze Welt will mich nur noch abfacken
Egal was ist
Heute auch
Heute bin ich wandern gefahren
Und auf dem Rückweg
Hab ich an der Schranke gestanden
Schranke geht auf
Fährt los
War ganz schön viel Zeit
Viele Autos bestimmt
40 Stück oder so
Es geht dann langsam über die Straße drüber
Und auf einmal
Hält ein Typ an
Direkt hinter der Schranke
Ich steh mit dem Auto
Auf den Kleisen
Und er geht hinten zum Kofferraum
Macht den Kofferraum auf, holt ein Paket und geht in die Post
Ich komm natürlich nicht vorbei
Weil von der anderen Seite auch was kommt
So, ich hatte zum Glück das Fenster auf
Und ich hab wohl so rumgebrüllt
Oder so
Dass er ganz absichtlich
So, ich hab so rumgebrüllt
Kennt ihr das, wenn die Leute absichtlich
Weggucken
So nach dem Motto, ich höre dich gar nicht
Ich höre dich gar nicht
Ich wusste gar nicht
Also ich hab nicht in dem Moment dran gedacht, dass ich das Fenster auf hab
Aber es war eigentlich richtig so
Also ich hab mittlerweile das Gefühl
Alles will mich abfacken
Und mir ist auch immer wieder
Mir wird jeden Tag bewusst, wie unfähig
Irgendwie die
Ich bestimmt auch
Ich denke, die anderen Leute denken das auch
Aber man ist ja da halt ein bisschen
Wie soll ich sagen, ein bisschen
So ich bezogen bei den Sachen
Weil ich bin ja auch ein bisschen
Aber kann ja den anderen Leuten nicht in den Kopf gucken
Und mir fällt immer wieder auf
Jeden Tag, wie unfähig
Alles ist
Die Leute, die eigentlich nur dafür da sind
Eine Sache zu machen, können diese eine Sache nicht
Ja, guckt euch die Bahn an
Es ist unglaublich
Mittlerweile hab ich echt so die Standard
Wie gesagt, das hat sich die letzten 15 Jahre
Mega gewandelt bei mir
Früher hab ich immer gedacht, ach das meinen die bestimmt nicht böse
Oder ach so schlimm wie alle sagen
Ist das nicht
Und heute denke ich mir
Die Welt ist scheiße
Und ich glaube nicht, dass es an mir liegt
Also doch
Ich glaube, dass es an mir liegt
Ich glaube, die Welt war vor 15 Jahren auch schon scheiße
Aber
Die Wahrheit liegt wahrscheinlich dazwischen
Die Welt ist wahrscheinlich genauso
Nicht so viel scheiße, wie ich es gerade denke
Und bestimmt auch nicht so alles rosa
Wie ich es vor 15 Jahren gedacht hab
Also das ist so irgendwie
Wahrscheinlich hält sich es irgendwie in Grenzen
Und umso mehr beschissenes Zeug
Du mitkriegst, umso schlechter ist es
So deine Gesamtwahrnehmung
Die Welt ist gut
Ja das ist nice, wenn du da bist
So, also, weiter
Wo sind wir denn jetzt
Was wollte ich jetzt machen
Genau, wir wollten
Ja, so viel
Stream an, Instance sidetracked
So, also ich hab ein
Vielleicht das hier
Sowas nervt mich auch
Das sind so Sachen
Und auch Gegängele auf dem Computer
Mit irgendwelchen Programmen, die wir laufen
Und irgendwas unterschieben wollen
Letztens unter Ubuntu
Habe ich tatsächlich
Ich habe ja für zum Arbeiten eine Ubuntu-VM
Ähm, und
Da habe ich dann Update gemacht
Weil es mir dieser Software-Manager vorgeschlagen hat
Und auf einmal sagt es mir
Sie haben jetzt noch 13 Stunden Zeit
Oder sowas, ihr Firefox neu zu starten
Da habe ich gesagt, was
Wollt ihr mir ernsthaft vorschreiben
Dass ich mein Firefox gefälligst neu zu starten hab
Was ist das, was ist das
Das ist ja Windows-Taktik, Alter
Ja, das ist glaube ich auch
Wahrscheinlich, ja
Das ist im Prinzip das, was ich auch schon eine ganze Weile mache
Wie gesagt, ich bin ja auch in Twitter
Obwohl nicht auf Andorra
Ich gucke mir kaum was an
Ist natürlich auch blöd
Dass du wenig drumherum mitbekommst
Aber auf der anderen Seite
Eine Sache habe ich halt auch die letzten 15 Jahre
Über irgendwann mal realisiert, ja
Früher habe ich mir auch gedacht
So nach dem Motto
Ja, da kann man doch hier irgendwie
Könnte man da jemand mit unterstützen
Und warum können wir hier eigentlich nicht das machen
Und, ähm
Jetzt habe ich den Faden verloren
Weil ich, ich habe die Chat-Nachricht gelesen
Und ich habe die Chat-Nachricht gelesen
Und jetzt habe ich den Faden verloren
Ähm, keine Ahnung
Puma-Hirn
Es geht nicht weiter
Null
Was wollte ich denn sagen
Ja, ist bei mir aber auch so
Wenn ich, wenn ich, allein wenn ich Twitter-Zeug
Twitter-Zeug lese und so
Weiß echt nicht, was ich sagen wollte
Äh, sowas ähnliches
Wollte ich sagen, aber nicht das
Ja, egal
Ach ja, jetzt weiß ich wieder, was ich sagen wollte
Man muss, man darf einfach mal nicht
Äh, ich weiß nicht, was ich sagen wollte
Äh, ich weiß nicht, was ich sagen wollte
Äh, nicht, nicht, nicht drüber nachdenken
Dann, dann fällt es einem wieder ein
Also, genau
Was ich, was ich auch die letzten 15 Jahre über gelernt habe, ist
Dass man sich nicht darauf verlassen kann
Dass irgendjemand anderes, außer vielleicht
Ja, das muss man immer ein bisschen ein
Muss ein bisschen präzisieren, was ich meine
Also jetzt die Eltern und so meine ich nicht
Aber dass niemand was für dich in deinem Interesse macht
Das sagen zwar alle
Aber es macht keiner was
Also du kannst dich nicht darauf verlassen
Dass irgendjemand was in deinem Interesse macht
Also offensichtlich das Beispiel
Ist, keine Ahnung
Du arbeitest irgendwie im Mindestlohn
Und, äh, oder bist Krankenpfleger
Oder so, und du wählst dann
Zu irgendeiner Wahl
Die Partei, die sagt
Sie schauen, dass sie
Ja, das ist ernst gemeint
Du wählst dann die Partei, die beispielsweise sagt
Oder den Bürgermeister oder den was auch immer
Ist ja egal
Der sagt, wir heben das an
Wenn ich dann quasi was zu sagen habe, dann heben wir das an
Und dann gewinnen die vielleicht sogar auch
Aber das machen die nicht
Ja, das könnte man
Problem ist nur, dass das wahrscheinlich nicht sonderlich ineffizient ist
Das sind alle in dem Fall
Das sind alle
Die AfD sind bloß ganz besonders große
Ähm, Ablenk
Also die fahren immer irgendwelche Ablenkungsmanöver
Ich hab das ja im Wahlkampf auch ein bisschen
Not getrunken
Hat man sich da halt mal ein bisschen mit beschäftigt
In legit jeder Talkrunde
Wo jemand von der AfD drin war
Ähm, haben die
Als Argument
Zum größten Teil, ich sag nicht bei allem
Aber zum größten Teil
Haben die als Argument gebracht
Immer, ja ihr macht das alles schlecht
Und wenn die dann irgendjemand gefragt hat
Ja, wie würden sie das dann machen
Kam als Antwort so nach dem Motto
Ja, viel besser, aber die anderen machen das schlecht
So, also die haben im Prinzip immer nur gesagt
Sie haben nie erklärt
Wie sie es eigentlich besser machen wollen
Das hat mich dann auch ein bisschen
Ähm, wie soll ich sagen
Äh, verwundert
Weil anscheinend
Haben ja auch so ein bisschen
Einer viele Leute den Eindruck
Dass die voll krasses Zeug machen würden
Ich weiß es nicht, die haben sich immer rausgeredet
Und ich bin der Meinung, es soll jeder wählen, was er will
Meinetwegen auch AfD
Ähm, darf jeder persönlich entscheiden, was er wählt
Dafür würden mich wahrscheinlich jetzt auf Twitter
Wieder die Leute steinigen, allein schon, dass ich gesagt hab
Aber ich meine, solange das eine
Zugelassene Partei ist
In Deutschland
Warum, ne, die darf jeder wählen
Das heißt nicht, dass ich die wählen muss
Aber ist es nicht so, dass ich sage, ich bann euch
Wenn jemand sagt, ich hab AfD gewählt
Ich bin der Meinung, dass das nicht so ist
Das sollte jeder für sich selbst entscheiden
Was er da macht
Allerdings muss er dann natürlich auch mit der Entscheidung leben
Also
Das ist, das wird überall
Nur so viel Bullshit gelabert
Und
Das ist mir wurscht, ganz ehrlich
Das ist eure komplett persönliche Entscheidung
Solange ihr mich nicht versucht zu bekehren
Zu irgendwas
Ähm, oder
Ihr irgendwie rumnervt
Mit sonst was
Kann jeder wählen, was er will
Ich meine, damit du was wählen kannst
Muss das, äh
Offiziell, ja
Anerkannt sein
Und dann ist das auch okay
Ähm, ob man sich jetzt natürlich mit dem Programm
Und den Sachen identifizieren kann
Ist was anderes
Also wie gesagt, mich hat's im Wahlkampf
Überhaupt nicht überzeugt, dass man zu 80%
Immer die Ausrede gebracht hat
Ja, die anderen machen das so viel schlechter
So, und nachdem ich's die letzten Jahre über
Schon beobachtet hab
Oder die letzten 15 Jahre über
Schon beobachtet hab, dass man das nicht so gut macht
Dass eigentlich keiner
Wirklich irgendwas macht
Im Interesse
Also im eigenen Interesse
Also in meinem Interesse
Denk ich halt
Da kann man sich einfach nicht drauf verlassen
Du kannst dich nicht drauf verlassen
Egal was du wählst
Egal wo du hingehst
Du kannst dich nicht drauf verlassen, dass die Leute ihren Job erledigen
Das ist ganz ätzend
Du setzt dich in Zug
Der fährt nicht richtig
Du gehst zu irgendeinem Amt
Willst was holen
Die hat keine Ahnung, wie's funktioniert
Dann musst du denen das noch irgendwie erklären
Da gibt's zig Beispiele, ja
Du gehst zum Arzt
Und du denkst dir nur
Okay
Jetzt war ich da zwei Minuten drinnen
Das hat absolut gar nichts gebracht
Also
Es ist so viel
Nicht Unfähigkeit
Aber keiner macht wirklich was
Ja, keine Ahnung
Keiner macht wirklich was in der
Was man so erhofft, ja
Und irgendwann hat man dann halt leider
So die Einstellung wie ich
Ich find's ja auch nicht gut
Dass das Einzige ist, was man machen kann
Ist um sich selbst kümmern
Weil du kannst dich einfach nicht drauf verlassen
Dass irgendjemand anderes was in deinem Interesse macht
Ja, Vater, Mutter und so mal außen vor
Aber gut, mein Vater pumpt mich ab und zu an
Das war's dann im Prinzip
Aber du kannst dich einfach nicht drauf verlassen
Du kannst eigentlich nur noch gucken
Dass du selbst möglichst
Schaust
Dass du
Wie sagt man so schön
Deine Schäfchen im Trockenen hast
Und für dich das
So vorteilhaft wie möglich gestaltest
Das ist halt
Eigentlich kacke, ja
Das ist ja noch
Das Argument verstehe ich nicht
Das wird auch immer oft gebracht, ja
Zum Beispiel
Zum Beispiel
Ich kann mich noch dran erinnern
Als die Grünen
Und ich muss gestehen
Ich hab
Bin mir nicht ganz
Ich glaub ich hab die sogar damals gewählt
Also, nee, hab ich nicht
Glaub ich nicht
Wobei, keine Ahnung
Kann durchaus sein, ja
Ich hab das ja mal nicht alles so düster gesehen wie heute
So, ich hab in Hessen damals
Ich sag jetzt einfach mal
Ich bin mir nicht mehr sicher
Ähm
Die Grünen gewählt
Als sie gesagt haben
Ähm
Sie sind unter anderem für
Ähm
Das waren drei Dinger
Ich krieg jetzt bloß noch den Flughafenausbau zusammen
Genau
Nachtflugverbot für den Flughafen
Kein Flughafenausbau
Und noch irgendwas
Das krieg ich
Das krieg ich nicht
Das krieg ich nicht zu sagen
Mittlerweile find ich's auch bescheuert
Ich find's wichtig, dass der Flughafen ausgebaut wird
Das ist was anderes
So
Also
Ähm
Wisst ihr was davon passiert ist?
Nix
Gar nix
Und die waren in der Regierung
Gar nix ist davon passiert
Und die Argument war jetzt
Ja, hätten wir aber
Die hätten wir aber alleine regiert
Dann hätten wir das alles gemacht
Also ich find das ein bisschen
Komisches Argument
So nach dem Motto
Ja, wir waren jetzt vier Jahre mit in der Regierung
Wir haben nichts gemacht von dem was wir gesagt haben
Aber
Wenn wir die Arbeit machen
Einzigen gewesen
Dann hätten wir alles gemacht
Ja, seriously
Ganz bestimmt
Also sprich
Man hat Müll gewählt
Man muss noch mehr Müll wählen
Dass es dann besser wird
Oder wie
Ich, ich versteh's
Ich versteh's nicht mehr
Das macht
Das nimmt sich allerdings
Bei den anderen auch nix
Also
Ich gebe mich da nicht der Illusion hin
Dass es mit irgendeinem anderen Partei besser gelaufen wäre
Deswegen
Mir geht's mittlerweile echt alles am Arsch vorbei
Ich guck, dass bei mir gut läuft
Ich guck, dass ich genug Kohle hab
Ich guck, dass ich möglichst viel das machen kann
Woran ich Spaß hab
Und scheiß mittlerweile wirklich auf alles andere
Ist mir einfach egal
So kacke sich's anhört
Naja
Ist halt richtig Painstcher mittlerweile alles
Ja, und dann hast du überall
So Entscheidungen, wo du dir denkst
Da hat auch keiner drei Meter gerade ausgedacht
Beispielsweise wo diskutiert wurde
Bitte hier jetzt Leute
Wir wollen jetzt verbieten
Dass ihr mit Autos in die Innenstädte fahren könnt
Das ist so unüberlegbar
Das Schnellschuss-Dinger
Ich
Ich frag mich auch eh
Wie wir es machen wollen mit
Wir wollen auf der einen Seite
Unabhängig
Unabhängiger werden von russischen Lieferungen
Wir wollen alle Atomkraftwerke abschalten
Wir wollen keine neuen Verbrennerautos mehr haben
Wir wollen allerdings auch
Jetzt nicht wirklich Forschung und
Innovation fördern
Ja, was wollen wir denn eigentlich machen
Also wie soll das denn funktionieren
Ja, wir können ja schlecht alles nicht
Machen
Irgendwas müssen wir ja machen
Also keine Ahnung wie das wie das funktionieren soll
Naja
Ich mein Klima und ähm Meeresspiegel und Wetterphänomen ist das ziemlich egal
Ob wir was machen oder nicht
Das ist ja das Blöde daran
Du kannst ja nicht einfach sagen
Oh guck mal da
Überschwemmung
Ob wir verbieten jetzt aber Überschwemmung
Dann gibt's keine Verschwemmung mehr
Das funktioniert halt nicht
Du musst die Überschwemmung nicht machen
Du musst die Rahmenbedingungen drumherum verändern
Dass das nicht passiert
Und das ist halt ne Sache von
Nicht von heute auf morgen
Und du kannst nicht einfach Überschwemmung verbieten
Das sind keine Überschwemmungen
Das funktioniert halt nicht
Oh man ich hab keine Ahnung wie das werden soll
Deswegen
Ich hab vor 15 Jahren oder so
Hab ich mir immer ausgemalt
Mann wie geil muss es sein 2022
Oder wie geil muss es sein 2030
Was wir da für unglaublich geile Games haben
Was wir da für unglaublich geile Technik haben
Was wir da für unglaublich geile Sachen in der Zwischenzeit erfunden haben müssen
Und die Welt muss viel besser sein
Und die Leute bringen sich nicht mehr gegenseitig um
Und die Leute ziehen zusammen an einem Strang
Wir haben so viele coole neue Sachen
So viele innovative Sachen
Wo wir jetzt überhaupt nicht davon geträumt haben
Und jetzt 20 Jahre später
Ist eigentlich nicht viel Unterschied
WTF
Doch wir haben Smartphones
Das ist richtig
Das ist richtig
Das ist richtig
Das ist richtig
Das ist richtig
Das ist richtig
Das ist richtig
Das ist richtig
Das ist richtig
Das ist richtig
Ja
Ich weiß
Ich weiß
Ey ohne Scheiß
Ich war
Ich war ultra optimistisch
So vor 15, 20 Jahren
Ja ich hab gedacht
Mann was wir 2030 alles für mega geile Sachen haben
Und jetzt haben wir Diablo auf dem Handy
Ja das ist die Scheiße
Wisst ihr
Zu der Zeit
Wo richtig viele geile Games rausgekommen sind
Das war ja innerhalb von ein paar Jahren
Ist alles rausgekommen
Quake
Half-Life
Starcraft
Warcraft
Also
Später dann irgendwie noch
Warcraft
Warcraft
Gute MMOs
So hat
General donde?
werden wird. Und da habe ich gesagt,
Mann, ist das geil, was wir da alles haben werden.
Ich habe mir ausgemalt, wie richtig
Poggers 2020 MMOs
sein müssen.
Und in den letzten 10 Jahren gab es 2 gescheite
MMOs, ja? Und die besten
MMOs wurden damals, das hätte ich mir
im Traum nicht ausgedacht damals.
Und heute haben wir Diablo auf dem Handy. Ich habe
damals Diablo 2 gespielt und habe mir überlegt,
Alter, wie krass groß und unglaublich
geil könnte man das machen mit
Internet standardmäßig
Online-Integration
mit Technik
in 20 Jahren. Das muss das geilste...
Das ist dann quasi Diablo
MMO, habe ich mir damals vorgestellt.
Wir haben ein Diablo MMO mit
irgendwie
eine Riesenwelt
quasi Diablo 2, bloß noch viel geiler
und im Endeffekt, was haben
wir Diablo auf dem Handy mit
Microtransactions und
zwischenzeitlich dann auch ab und zu
irgendwelche NFT-Scam-Games, ja?
Also das hat sich leider nicht bewahrheitet, was ich
mir da so ausgemalt habe.
Ich glaube ja, dass das irgendeine Entwicklung
ist, die jeder durchläuft, mal der Dalai Lama
vielleicht außen vor, wobei ich mir
bei dem da auch nicht sicher bin, ob das
nicht teilweise auch ein bisschen schaue ist.
Aber da ist auch erleuchtet, ja?
Vielleicht...
Ich glaube, das ist eine Entwicklung, die durchläuft
jeder. Deswegen hast du
irgendwann 80-jährige Opas, die alles
hassen und alles scheiße finden.
Wahrscheinlich bin ich auf dem Weg gerade.
Es kommt ja auch nicht
von nix. Umso
mehr scheiß Erfahrung man macht, umso schlechter
schätzt man wahrscheinlich alles insgesamt
ein. Und ich krieg immer Anfälle,
wenn ich merke, wie dumm die meisten Leute
sind. Okay, wahrscheinlich bin
ich der Dumme.
Aber wenn ich mir das schon anhöre,
was da teilweise gelabert wird.
Ja, wahrscheinlich. Wahrscheinlich. Midlife ist
ja mehr oder weniger jetzt, ja?
Das ist alles so auf dem Niveau
wie von dem einen Mädchen aus dem
Arbeitsamt-Bewerbungskurs. Ich muss
nicht lesen und schreiben können, weil mein Mann kann
das.
Ja, ist echt so.
Ich mein, die Leute, du musst dir nur
YouTube-Comments durchlesen. Du musst
dir nur YouTube-Kommentare durchlesen. Dann sieht man,
wie unglaublich zurückgeblieben
viele Leute sind. Das ist echt der Wahnsinn.
Ich hab letztens ein Video geguckt
bei Trimax, wo er richtig krass reingecasht
hat in Diablo Immortal.
Ähm, und die
Comments in dem Video, Alter.
Die Leute sind so...
Keine Ahnung. So
minderbemittelt, Alter. Das ist der Wahnsinn.
Wenn ich die Comments da durchscrolle,
da krieg ich Augenkrebs von.
Wie sie das verteidigen, auch noch,
das Game.
Ja, gut.
Ja, wahrscheinlich ist
echt so. Aber
ich war wahrscheinlich... Ja, gut. Ich war als...
Sag mal ehrlich, ich war als 10-Jähriger oder
8-Jähriger auch so. Warte mal.
Das 19... Wann kam Mario 64 raus?
Hier liest du jetzt 96, 96.
Da war ich 12, ne?
Sehe ich das richtig?
84 geboren, war ich da 12, ja?
Ich hab... Leute, ich war
damals genauso. Ich war damals ganz
genauso. Ich hab, ähm, mal
nach meinem echten Namen, den ihr nicht wisst,
deswegen könnt ihr auch danach nicht suchen,
hab ich letztens in einer Newsgroup-Suche
gesucht. Da hab ich
News... News... Newspost... Newsgroup-Post
gefunden von mir damals.
In irgendeinem Mario 64, ähm,
nicht Subreddit, wie ist das denn?
User... Usergroup. Ja.
In der Usergroup.
Leute, ich war so ein richtig
kleiner... Heute würde ich sagen,
so ein richtig kleiner Call of Duty,
richtig nerviges
Call of Duty-Kind damals. Nur, dass es
keine... dass es keine Call of Duty gab,
noch kein Call of Duty gab, ja?
Ähm, ich hab... Ich hab in irgendeinem
Mario 64 Subreddit so richtig
auf dicke Hose gemacht, so irgendwie.
Irgendjemand hat... Bei Mario 64
Subreddit, Alter. Ne, äh,
Usergroup. Hat irgendjemand geschrieben,
ich hab Probleme... Ich kann mich noch gar nicht erinnern.
Ähm, hat irgendjemand geschrieben, ich hab
irgendwie Probleme bei dem...
dem und dem Stern. Und da hab ich Sinn
gemäß sowas geschrieben.
Cringe, wenn ich 120 Sterne hat.
Ich hab nicht wirklich...
Ich hab's anders geschrieben, so würde man das
heute sagen, ja? Ich... Ich war so
ein richtiger Kackspast, Alter.
Ich hab dem Typ dann irgendwie
geantwortet, lol, wer hat denn schon bei
80 Sternen irgendwie Probleme?
120, wer das jetzt noch nicht hat,
ist einfach nur schlecht. Oder irgendwie
sowas.
So ein richtiger, richtiger Spast,
Alter.
Ja, also richtig dummes Zeug,
hab ich in diese Newsgroups gepostet.
Absolut dummes Zeug. Also ich war
genauso dummes Kind
damals. Und
das Schlimme ist ja, die Generation
vor mir muss den Kram nicht lesen,
den sie damals verzappt haben mit 10.
Ich bin die erste Generation, die jetzt noch lesen kann,
was sie teilweise mit 10 Jahren, äh, mit 12
Jahren im Internet geschrieben haben.
Unglaublich dumm, Alter. Unglaublich
dumm. Ich dachte, aber eine Sache,
eine Sache hab ich damals wirklich
für wahr gehalten. Und zwar,
dass man mit Leuten reden kann und Leute,
quasi überzeugen, wenn man
stichhaltige, sinnvolle
ähm, Aussagen
trifft, ja. Also,
zum Beispiel, ja, was weiß ich,
wenn sich, wenn sich meine Mutter damals drüber aufgeregt
hat, dass der Chef im Krankenhaus irgendwie
ein dummer Sack ist. Ja, der damals im Krankenhaus gearbeitet hat.
Und da hat,
da hat die, da hat die das dann erzählt und gesagt, ja, aber
warum ist das denn so? Und da hat sie dann
erklärt, keine Ahnung,
man muss jetzt da was aufschreiben, obwohl da
eigentlich keiner guckt. Man müsste dann lieber besser da.
Und da hat, und ich, ich hab damals,
wirklich gedacht, ich, ohne Scheiß,
ich hab damals wirklich noch gedacht, ja, das
muss man dem halt sagen.
Und wenn man dem erklärt, warum
das an der anderen Stelle besser ist, dann
wird er das einsehen und das andere auch nicht
mehr wollen. Ich hatte keine
Ahnung von der echten Welt damals.
Weil ganz im Ernst,
versucht mal auf
Twitter, guckt in die Trends
auf Twitter, sucht euch irgendeinen
kontroversen Trend raus
und versucht mit sinnvollen
Argumenten jemanden zu überzeugen.
Das könnt ihr einfach vergessen.
Das könnt ihr komplett
klingen. Und das ist an vielen Stellen so.
Richtig, richtig weird,
aber ich hab damals wirklich gedacht,
ich hab damals wirklich gedacht,
Leute sind,
wie nennt man das, rational? Ne,
Leute sind
logisch, dachte ich damals.
Ja? Also ich dachte
damals, wenn man irgendwie logisch etwas
erklärt, nachvollziehbar
erklärt und es quasi
auf der Hand liegt,
dass es
so ist
und dass dann die Leute
sagen, ah, okay, ja, okay, das passt,
das ergibt Sinn, ja, dann,
dann ist das so.
Ist aber nicht so.
Es ist eher so,
in der echten Welt, ja,
dass leider bei den meisten
Leuten umso stichhaltiger
du quasi
belegst, dass etwas so ist oder
nicht so ist, also umso stichhaltiger
du etwas begründest,
umso aggressiver wird der
andere, weil er sich dann,
also weil er sich quasi
in seinem, ich nenn's mal, Glaube
nicht umstimmen lassen will
und sauer
auf dich wird, weil ihm nichts
einfällt, was er dagegen sagen kann.
Weil umso besser
du das begründest, umso weniger
Raum hat der quasi,
um erstmal mit sich selbst
im Hirn klar zu kommen, dass es ja Blödsinn ist
und das irgendwie zu verteidigen
und irgendwann fällt den Leuten nichts mehr ein,
außer wirklich sauer zu werden.
Und das, das hab ich damals nicht gedacht,
dass das so ist, aber leider ist das so.
So, aber, jetzt hab ich 35 Minuten
geschwätzt, jetzt können wir anfangen.
Aporet, Aporet ist auch so ein, so ein,
so ein, so ein, so ein spezieller
Kandidat. Ganz ehrlich, wisst ihr, was ich vermute?
Ich hab keine Ahnung, ich kenn ihn nicht.
Ich hab eine
PN jemals mit ihm
gewechselt, das war's.
Er kennt mich nicht, ich kenn ihn nicht.
Aber rein von dem, was ich in dem Video gesehen hab,
als er gesagt hat, der Insi
Modus ist aktiviert, ganz im Ernst,
ich glaube nicht, dass er Steuerbetrug begeht.
Ich glaube, der ist wirklich pleite
und möchte das einfach nur nicht
öffentlich eingestehen,
weil das
an seinem Ego kratzt
im Endeffekt, ja. Also,
er ist pleite und er ist
insolvent und er muss den Insi
Modus machen
und es ist natürlich
blöd,
wenn man sich eingestehen muss und öffentlich ins Internet
geht und sagt, Jungs, ich hab Scheiße gemacht,
ich bin pleite, dann ist es besser, man
sagt, ich hab den gleichen, ich hab den Insi Modus
aktiviert
und mach jetzt dickes
Business im Ausland.
Das ist einfach nur, um sich das Ganze schön zu reden.
Der ist wahrscheinlich einfach pleite.
Ist zumindest meine Überlegung,
nachdem ich das gesehen hab, wie gesagt,
wir kennen uns nicht.
Ja, ist ja ewig her noch zu Call of Duty Zeiten.
Das ist ja der Witz.
Ich kenne ja die meisten Leute noch von
aus der damaligen Zeit.
Flüchtig.
Ja, ihr kennt mich.
Ich hab damals schon nicht große Social-Dinger
gemacht.
Also, ich hatte mit keinem großartig was zu tun.
Aber zumindest flüchtig kenne ich die meisten noch.
Kennt man ihn? Oh, ne.
Geil.
Ja, C++, okay.
Okay, wo sind wir stehen geblieben? Also, ich hab
diesen
Artikel hier gefunden, den hat auch jemand gestern
im Chat gepostet, hab ich gesehen.
Und das probieren wir jetzt mal aus.
Ich hab jetzt lang genug
geschwätzt, 37 Minuten.
Jetzt bin ich in passender Laune zum
zum Proggas-Stelzen.
Leute, ich muss mal kurz meine Klimaanlage
anmachen. Wo hab ich denn hier mein...
Piep.
Was? 24 Grad.
MonkaS. Willst du warm?
Was ist das denn?
Geht das jetzt an?
Ja.
Okay, Klimaanlage ist an. Alles gut.
Was für eine Klimaanlage? Ich hab eine Mitsubishi Heavy...
Frag mich nicht. Keine Ahnung.
Findest du im Stream-Archiv irgendwo?
Wir haben nämlich mal ein Arduino für das Ding programmiert.
Ich will nicht schwitzen.
So.
Aber jetzt von diesen unangenehmen
Themen...
So, ich muss kurz was auf mein Handy gucken. Also,
jetzt von den ganzen unangenehmen Themen mal
zu Proggas-Zeug. Also,
diesen Artikel hab ich gefunden und da kriegt man erklärt,
wie man FFmpeg im Browser
macht. Und ja, bevor irgendjemand wieder auf die
Idee kennt, ich kenne
FFmpeg Wasm und ich
kenne FFmpeg JS.
Allerdings, der Unterschied
zwischen dem, was ich machen muss
und das C++ ist ein wahnsinnig
unangenehmes Thema. Das stimmt.
Von unangenehm zu C++
das ist ein Downgrade.
Arduino IDE verwende ich nicht.
Arduino IDE ist auch
Paintschamp. Was du verwenden musst
ist... Moment.
Hab ich gar nicht installiert?
Doch. Du musst Platform.io
verwenden. Viel besser.
Platform.io ist deutlich mehr...
Guck mal, der Coolchamp. Da ist er doch.
Wobei, war der Coolchamp das für die Klimaanlage?
Ach nee, das war das für den...
Der Coolchamp war
für den
Kühlschrank.
Secrets mache ich
jetzt nicht auf.
Ja. Ja.
Das willst du verwenden.
Du willst den...
Du willst Platform.io verwenden.
Arduino IDE
ist Paintschamp. Also, diese Projekte hier
kenne ich. Allerdings ist sowohl FFmpeg
WASM als auch FFmpeg.js
nicht das, was ich haben will. Ich will wirklich
low-level auf FFmpeg-Sachen
zugreifen. So.
Wir machen jetzt mal
dieses Tutorial durch.
Und dann probieren wir das mal aus.
Also, das ist ein Tutorial, wie man
FFmpeg in Docker selbst kompiliert
und dann darauf über
WebAssembly zugreift. Also, beziehungsweise
erstmal in ein WebAssembly Static Library
übersetzt und dann von WebAssembly
darauf zugreift.
Ich bin mal gespannt, ob das funktioniert.
Und wenn das Beispiel
funktioniert, wird das dann
im Browser ausgeführt. Genau.
Das ist der Sinn. Das ist der Sinn davon.
Also, zum Beispiel,
stell dir mal vor, du willst
im Browser irgendein Format abspielen,
was dein Browser nicht kann.
Dann hast du gelitten.
Kannst du nichts machen. Es sei denn,
irgendjemand hat einen JavaScript Decoder
dafür programmiert, was
sehr unwahrscheinlich ist. Also,
kannst du vergessen. So, mit FFmpeg,
das ist ja eine C++ Library, kannst du mit
FFmpeg
äh, kannst du übersetzen in WebAssembly
und dann im Browser verwenden. Allerdings natürlich
mit Einschränkungen. Du kannst jetzt nichts machen,
was irgendwie aus der Browser-Sandbox ausbricht.
Also, wenn du jetzt sagst, ja, ich mach da einen TCP-Server
auf, das geht nicht, weil Browser
können keine TCP-Sockets öffnen.
Listen. Dran.
Listen lassen. Das funktioniert nicht.
So. Ich copy-paste
mal diesen ganzen Krempel jetzt.
So. Ja, und Videos
abspielen über FFmpeg im Browser
ist sicherlich nicht die gute Idee, weil
bei Performance-Technik ist das ziemlich mies.
So. Wir haben einen Docker-File.
Pog. Wir machen das Ganze zum Beispiel
Studio-Code auf.
Yes, trusten.
Den...
Ach, Quatsch.
So.
Hier haben wir noch einen Terminal. Terminals kann man nie genug
haben. Brauchen wir wahrscheinlich.
So.
Ach nee, das ist das Dock-File.
Ich will ein Docker-File, nicht ein Dock-File.
Docker-File will ich haben.
So. Also,
wir gucken uns das gleich mal an.
Ähm...
Nein, kein Rust. Kannst du vergessen,
FFmpeg über Rust ist abartig.
Und mir wäre es deutlich
lieber. Mir wäre es deutlich lieber als C++.
C++ ist absolut kompletter Pains-Champ.
Aber was willst du machen?
FFmpeg kann Hardware beschleunigen. Ja, das
liegt daran. Also, hier, um das
zu beantworten. Ja, FFmpeg
kann mit dem passenden
Codec, also mit dem passenden Encoder
oder Decoder, kann das
ganze Hardware beschleunigt machen. Du kannst zum Beispiel
nvenc123,
wie viele nvenc
Implementationen es
auch immer gibt, kannst du verwenden.
Und wenn du die passende Grafikkarte hast, ist es damit schnell.
Aber dein Browser hat keinen Zugriff
auf die Grafikkarte für solche Low-Level
Encoding Sachen.
Ja.
Okay, also, Docker-File.
Was macht der Typ hier denn?
mscripten msdk
sbuild. Okay, dann macht
er irgendwie ein
64-Decoder von 2017.
Ich ändere da jetzt
mal nichts dran, weil ich denke,
sonst wird es nicht funktionieren. Oh Gott,
Pth-Threading auch noch
über WebAssembly im Browser.
Das wird, das wird ja
was. So, dann baut
er diesen ganzen Krempel. FFmpeg
Version lädt da runter.
FFmpeg Version lädt da was runter?
4.3
Das erscheint mir ein bisschen alt. Was ist denn die aktuelle
FFmpeg
Version History? Also 5er
gibt es schon, aber die 5er nehmen wir nicht,
weil die wahrscheinlich nicht funktioniert hiermit.
Ich meine,
wobei, doch, wir könnten die 5er,
wir können es ja mal mit der 5er probieren.
Von wo lädt er denn
runter? Download, Videoland, Pup,
Videoland, Snapshots.
Ne, das ist was Falsches. Quatsch.
Das da. FFmpeg Releases.
Was hat man da als letztes
zu bieten?
Modified. Die supporten
noch die 2.8er Version.
Boah, die sind ja krass drauf.
Die supporten die letzten
2.8er, die letzten 3.2er, die 3.4er
und die 4.2er.
WTF, was
ist denn mit denen los?
Das ist ja richtig, da
hast du ganz schön was zu tun, das zu maintainen.
So,
FFmpeg
5?
5.01 vom April.
Die Sache ist halt die,
ich habe keine Ahnung, ob das überhaupt funktioniert.
Habe ich denn hier überhaupt selbst schon
FFmpeg installiert?
Weil die Header brauche ich tatsächlich.
Ok, 5.0 habe ich installiert.
Es gibt was? Es gibt schon 5?
5.0? 7?
Hä?
Ach ne, das ist Patch 5.0.
Das ist ok.
Das ist merkwürdige Versionierung.
Also, dann nehmen wir das hier.
5.01 ist die Version,
die wir haben wollen. Ok.
5.
01?
Falls es... Leute, wisst ihr was?
Wir machen mal was. Wir gucken mal,
ob das Kompilieren funktioniert,
ohne dass wir was dran ändern.
Wir lassen es einfach so.
Und wir kompilieren das jetzt mal und gucken, ob es
funktioniert. Weil es hat ja keinen Sinn,
wenn ich da jetzt zig dran editiere und danach geht es
nicht. Wisst ihr, wir machen jetzt einfach mal...
Was ist das? Docker Build MP4
Info. Alles klar.
Den ganzen Krempel für C++ installiere
ich auch schon mal,
weil ich garantiert Header-Files und sowas brauche.
Und die bringen mir ja auch nix, wenn das...
Wenn die im Docker-Container drin sind.
Wieso sollte es funktionieren, wenn der Pass
nicht stimmt? Hä?
Weiß ich nicht, woraus sich das bezieht.
Ich meine, vielleicht funktioniert
es nicht mit der neuen Version.
Deswegen mache ich es mit der
Originalversion, wie das Tutorial geschrieben ist.
Und wenn das funktioniert, können wir es
ja immer noch umtauschen. Austauschen.
So. Also. Bam.
Build.
Was ist denn MSSDK?
Was ist denn da
die richtige Version?
Was ist da die letzte
Version?
3.1.13
Oh, da hat sich ein bisschen was
getan die letzten Jahre über.
Ich glaube, wir sollten das dann mal auch updaten.
Okay. Also, wir updaten dann FFmpeg.
Und hier können wir
wahrscheinlich auch den Codec updaten.
Ah ne, 2019 ist schon der neueste.
Version von
2017 macht der Dude hier.
Wir updaten dann einfach alles.
Wird alles geupdatet.
Oh. MonkaS.
Was jetzt?
Ich glaube, ich weiß, woran das liegt.
Dokka hat sich wahrscheinlich mit dem
Standby
mit dem Standby verschluckt.
Von der VM.
Das kommt manchmal vor.
Aha. Schon funktioniert es.
So. Gucken wir mal.
Wir haben jetzt gelernt. Htop ist out.
Btop ist angesagt. Ne. Btop.
Btop ist angesagt.
Die coolen Leute verwenden Btop.
Wobei ich ganz ehrlich Htop schöner
finde. Das ist
so schön simpel. Ich brauche keine True Color
Console Output mit sonst was.
Ich weiß auch überhaupt nicht, was jetzt genau
was verbraucht und so. Also,
ich persönlich finde ja
Htop schöner.
Zumindest out of the box.
IP League. MonkaS.
So. Machen wir Htop.
Ok. Das ist am
Compilen.
Tja. Dann
compile mal im Hintergrund. Wir lesen das Tutorial
und gucken, wie es weitergeht. Ok.
Dokka-File. Dokka-File. Build.
Writing the wrapper.
mpinfo-wrapper.cpp
Ok. Es wird Zeit für C++-Files, Leute.
Ähm. In welchen Ordner muss
ich den Kram überhaupt legen? Einfach ins
Hauptverzeichnis? Oder wie macht der weiter?
Dist. In Dist.
Ach nee. Oh Gott. Make-Files.
Alter. Hör mir auf.
Make-Files ist eines der
schlimmsten Sachen der Menschheitsgeschichte,
die da technisch je erfunden wurden.
Ich bin nur noch gefolgt von
C++-Header-Files.
Source. Ok. Ich brauche einen Ordner, der Source
heißt.
Srs. Srs-Ordner. Ein
Srs-Ordner. Alles klar. Srs.
So. Und da drinnen legen wir jetzt ein
Wie heißt der Krempel?
mp4-info-wrapper an.
Alles klar.
Show Recommendations.
Das C++-Extension-Pack.
Nein. Das C++-Extension-Pack
will ich nicht.
Ich will nur die normale C++-Extension.
Und die haben wir auch installiert.
Dann ist ja alles gut.
Gut. Excellent.
So. Und was machen wir da jetzt?
Reinde mit.
Gachibas.
Haha. Wusste ich doch, dass er
Moment. Habe ich das nicht eben installiert?
Wozu braucht man Make-Files?
Tja. Wenn man ein Build-Script
braucht. Also im Prinzip das, was man in Bash
machen kann. Halt bloß doch ein bisschen optimierter
für C++-Zeug. Ganz ehrlich. Ich verwende
in der Regel keine Build-Files. Und ich verwende in der Regel
auch keine Custom-NPM
Scripts. Noch keine
Cargo-Scripts. Und ich überlege
gerade, was das C-Sharp-Gegenstück davon ist.
Wahrscheinlich nichts. Und ich vermisse es
auch nicht. Warum Visual Studio
Code? Weil ich vermute, wir brauchen
C++, JavaScript, HTML
und Docker in einem. Und ich will nicht
tausend Sachen aufmachen.
Ähm. Wisst ihr was?
Wisst ihr was an C und C++ auch immer?
Gerade an C++ ist es immer so. Paintschamp ist. Immer
wenn es kompiliert, denkst du, gleich
bricht es ab.
Das ist wie beim Angry German Kid,
was Unreal Tournament spielen will.
Also du denkst gleich
ich will nicht, dass es lädt, weil
dann bricht es ab. Oh, ist fertig.
Guck mal, es hat funktioniert.
Die Header sind doch im Docker drin. Ja, das bringt mir aber nix.
Haha. Ich brauch die
Header ja hier. Wo sind denn
die Header überhaupt?
Ich hab's doch, ich hab's doch installiert.
Ich mein, ich könnte
den Docker-Container mounten.
Lokal. Oder
ich könnte in Visual Studio Code
mich in Docker rein
attachen. Das geht ja irgendwie.
Aber keine Ahnung. Ich nehm
die Header, die bei mir auf der Platte liegen.
Ich weiß, du kannst das.
Da weiß ich, aber ich will jetzt nicht
eine halbe Stunde raus outfigern, wie das
funktioniert.
Ähm.
Ich kenn das.
VS Code remote try
cpp. Was?
Sample to try out the
VS Code remote container extensions.
Oh, Pfeiffer der Kram. Ne, ne, das passt
schon. Ich muss bloß mal kurz gucken.
Pack pacman minus
Query
und dann
List.
Ah.
Include.
Wo müssen wir hin? Ne.
User
include.
Ne, wahrscheinlich net.
Okay, was ist hier drinnen?
Bind.h
Das da. Das brauchen wir.
User
bin m scripten system
include. Das da.
Das brauchen wir hier.
So. Und jetzt wirst du ihm sagen
edit
include path
und unbedingt sollst
du noch das hier nehmen.
Und freuen.
Es ist einfach wieder weggegangen.
Ah, siehste? Schon funktioniert.
Hat mich gebetet.
Okay. Nice.
Jetzt haben wir das.
Kompilieren von dem Kram hat auch geklappt.
So, haben wir jetzt
autocomplete? Haben wir jetzt autocomplete? Also zum Beispiel
ems. Oh, guck mal da.
Value.
Tatsächlich. Autocomplete funktioniert.
Die C++ Extensions in
Visual Studio Code sind halt ziemlich
also die sind langsam. Die gehen, aber die sind langsam
wie Sau. Also du brauchst
hier teilweise 2-3 Sekunden, bis das Syntax
Highlighting richtig stimmt und sowas.
Keine Ahnung, wer damit größere Sachen überhaupt
entwickeln kann.
So, das haben wir.
Ja, wir vertrauen ihm
einfach mal, dass es geht. Add a makefile.
Makefile.
Ach ne, Moment. Das gehört
dazu, ne. Makefiles haben ja so komische
komische Syntax. Das da oben ist der
Jobname und das hier ist irgendwie dann.
Was der ausführen soll.
Makefile. Okay, das heißt, wir sollen jetzt hier
noch ein Makefile anlegen.
Makefile.
Ne, nicht in Source, im
Dings, ne. So.
Ähm.
Add the following lines to your
Dockerfile.
Wenn der das sagt,
dann machen wir das einfach.
Und jetzt? Um wie viel
wollen wir wetten, dass es nicht funktioniert? Ne, ich
wette gar nicht. Wer weiß. Das ist, das
ist gefährlich mit dem Chat.
Ich glaube aber nicht, dass es funktioniert.
Ich
wusste es. Ich wusste es.
Es war mir so
klar, dass es nicht funktioniert.
Ja, ByteStrike, so ist es immer.
No makefile
found.
Hast du ein Makefile erstellt?
Ja.
Ich habe eine Idee, woran das liegt.
Vielleicht klappt das hier nicht.
Home.
Max.
Was? Home?
Wie geht da kein Auto complete?
Was ist denn das?
Home. Max. Depos.
Monka. Cpp.
No targets. Muss ich das vielleicht
nochmal bilden? Und der Typ hat das bloß nicht
Ja, wahrscheinlich muss ich das nochmal bilden vorher.
Run.
Ah, das ist was anderes.
Missing separator. Makefile.
Fuck.
Ich habe das vorher gelesen, nämlich hier.
Und das funktioniert nicht.
Ähm.
Was ist denn, wenn ich hier Make drinnen ausführe?
Okay. Mein Makefile ist syntaktisch
nicht korrekt. Obwohl ich das
1 zu 1 aus dem Beispiel gepastet
habe. Aber Makefiles haben so
ein paar dumme Angewohnheiten, dass sie
auf Einrückung und irgendwie auch auf
Tabs und sowas
Wert legen.
Ach, das geht jetzt, oder was?
Ernsthaft?
Das da in der Anleitung
steht doch überhaupt nichts drinnen.
Der bildet das an der Stelle und danach kommt
das raus. Und dieser Step geht nicht.
WTF?
Warum? Warum?
Kann mir irgendjemand logisch erklären, warum
das nicht geht und das geht?
Ey, es ist in Makefiles. Ich glaube,
vergesst es einfach. Ist egal.
Hauptsache, es geht jetzt.
Tabs? Ach, brauchen
die Tabs, oder was?
Tabs? Spaces?
Ist das da?
If a single Tab...
Only Tab Indentation.
Aha.
Alles klar.
Whatever.
Okay, wir können maken.
Mal gucken, ob das
jetzt ohne Fehler compiled.
Und wenn
das jetzt... Ah, guck mal, das ging ja
sogar relativ schnell.
Ja gut, unser Beispielprogramm
sind doch nur 5 Zeilen oder so.
Okay, nice.
Das hat funktioniert. Und jetzt habe ich hier,
was liegen?
dist mp4info
wasm mp4info
worker.js und mp4info.js
Das ist halt einfach
mal 2 MB groß.
Oh, das wird großartig was machen.
So.
Ja, dann
updaten wir mal das docker-File. Wobei,
das machen wir hier drüber, wenn ich es hier
schon auf habe. Jetzt schreiben wir mal aktuelle
Versionen rein. Also,
501 ist, glaube
ich, hier das aktuelle.
Das
SDK ist
3
3 1 13
und der
Decoder, das wird im Leben
nicht funktionieren,
der Decoder ist
Decoder ist hier
Ach, Stable.
Stable?
Gibt es das hier? Oh, Stable.
Ich muss das letzte
suchen, wo Stable drinsteht.
Äh. Hier, Stable.
Das da. Stable.
Minus, also
Minus
Stable.
So, noch was?
Da gibt es safe noch einen neueren?
Sieht nicht so aus.
Ne, das ist lib
x264, gell?
Gibt es da vielleicht ein GitHub? Sind die vielleicht auf GitHub mittlerweile?
Gitmirror
Shit, Shitmirror
Ah, vor 10 Tagen
aktualisiert. Sehr schön.
Es wäre interessant
zu wissen
Es wäre interessant zu wissen, von wo
das
gemirrored ist.
Ich meine, wir könnten auch einfach die Git-Geschichte
auschecken lassen.
Ist das überhaupt das gleiche, wie das hier, was ich da mache?
Also, ist das, was ich hier runterlade,
das gleiche, wie was wir uns hier auf
auf GitHub angucken?
Ich meine, wir können
einen Git-Clone machen.
In der Readme steht es drinnen bei den Snapshots.
Du meinst, ich muss den Snapshot
anpacken dafür, oder wie?
Ist das Bitbucket?
Ne, Gitlab ist das.
Okay.
Ich bilde das erstmal so,
wenn das geht, nehmen wir die neueste
Bleeding Edge Version von...
Wobei, ja, mal gucken.
Letztendlich für unsere Tests ist es doch egal.
Readme?
In dieses Repo nehmen sie.
Passt doch.
Das können wir dann nehmen.
Also, wir gucken jetzt mal, ob es funktioniert.
Also, wir haben hier ein Webpack aktualisiert,
den Decoder und das.
Wahrscheinlich wird es jetzt nicht laufen.
Bild.
Gut, dass wir gestern Platz gemacht haben.
Webseiten in C++?
Ja, man macht ja auch nicht wirklich die Webseite
in C++.
Die Webseite machst du weiter in HTML
und wenn du DOM-Interaktion brauchst,
dann musst du das auch mit JavaScript machen.
Aber du kannst von WebAssembly JavaScript aufrufen
und vor allem kannst du WebAssembly
von JavaScript aus aufrufen.
Was halt äußerst...
Ne, scheint noch zu funktionieren.
Was halt ziemlich pock ist,
wenn du C-Libraries oder sowas verwenden willst.
Oder Go-Libraries oder Rust-Libraries oder so.
Im Prinzip alles, was WebAssembly
als Target hat.
Das scheint zu funktionieren, Leute.
Oder COBOL.
Ich weiß nicht, kann man COBOL
WebAssembly machen?
282 Sterne!
Vom Cloudflare her.
Anscheinend brauchen die das. Ganz wichtig.
Das ist ja mal als April-Scherz oder was auch immer.
Haben die hier Release-Tags?
Wo ist denn in GitLab die Release-Tags?
Ich habe GitLab schon ewig
nicht mehr verwendet.
Ich hatte das mal self-hosted bei uns auf der Arbeit am Start.
Wo haben die Tags? Hier. Tags.
Gibt keine Tags.
Releases?
Wo sind die Releases? Releases gibt es wahrscheinlich auch nicht.
Branches? Ach, was auch immer.
Stable. Stable-Branches.
Stable ist von einer Woche.
Haben wir jetzt fertig
kompiliert? Nein, aber nicht.
Releases
sind unter Deployments. Aha.
Gibt es aber auch nicht.
Das musst du wirklich
alles selbst kompilieren. Na dann.
Zum Glück habe ich einen halbwegs schnellen Rechner.
So, okay. Das haben wir geschafft.
Jetzt wird FFmpeg neu kompiliert.
Cloudflare
Workers now support COBOL.
Aber die Workers laufen
doch bestimmt nicht mit WebAssembly, oder?
Ach, tatsächlich?
Ach du Scheiße.
Ist das ein April-Scherz?
Nee, 16.04.
Ja, das ist für die ganzen
äh, oldschool
Finanzdienstleistungsdinger, die noch Sachen in COBOL
haben, aber in die Cloud wollen.
Das ist gar nicht so schlecht.
Ja, finde ich auch.
Aber es ist trotzdem
pain in the ass.
Oh, guck mal. Es ist wieder kurz vor dem Abbrechen.
Die C++
Compiler-Fehlermeldungen sind auch die besten.
Solange es keine
ausgibt, alles gut.
Hey. Nice.
Make.
Pock. Alles klar.
Das funktioniert mit
den neuesten Versionen auch noch.
Na dann.
Dann wollen wir mal, ne?
Gut. Also,
wo ist die Anleitung? Wo sind wir stehen geblieben?
Also, SeriousMax, falls du
da mal den durchblickst, welchen Link ich verwenden
muss für die neueste Version,
dann mache ich das. Oder muss
ich das gar nicht wgetten, sondern in Gitclone
machen anstatt dessen.
Also, quasi anstatt den Kram hier
downloaden, in Gitclone machen
und dann da drinnen bilden.
Könnte man auch probieren später.
Ja. Aber jetzt machen wir erstmal weiter,
weil die Version wird es jetzt nicht so
großartig ausmachen.
So, Bild. So, das haben wir.
Writing JavaScript.
Alles klar.
Also, wir brauchen einen Ordner
für JavaScript Zeug. Gut.
Also, machen wir mal einen neuen
Ordner. Und zwar,
www, ne,
html.
wwwroot heißt das normalerweise.
wwwroot.
Jetzt html.
Ne, wwwroot.
Kann ich mir wenigstens was darunter vorstellen.
So, da drinnen gibt's jetzt
file index.html.
Zack.
So.
Two spaces, korrekt.
Alles klar. So, wie geht's weiter?
Was machen die hier denn jetzt?
Science Hour MP4 Info Wrapper
is compiled synchronous C++
code and can block browser's main thread.
Ach, juckt mich nicht.
Advantage of Webworkers.
Boah, die ziehen aber alle Register
hier, oder?
Webassembly in C++ aufrufen
aus Webworker.
Public HTML. Ne, unter Linux ist es eigentlich
ähm
meistens war www.
html.
Und bei vielen heißt es einfach www.
root.
public underscore html.
Keine Ahnung.
Now let's create a new worker.js file.
Wo create ich das?
Hier wahrscheinlich neben index.html.
Ok, Leute, ich seh schon, komm,
das müssen wir dann ein bisschen entschlacken
danach alles, weil
ich glaube, ich will das gar nicht über Webworker
machen. Schauen wir mal.
Aber erstes Mal das Ding zum
Exempel zum Laufen bekommen.
So, was auch
immer hier passiert.
fs
Wo kommt denn das her?
Das ist aber doch kein Standard-JavaScript-Zeug.
So ist es auch nicht.
Ist das
irgendein Webassembly-Krempel?
Ja, anscheinend multithreading-worker.js.
Ich bin mal gespannt, was der Typ hier
macht. So,
ähm, fs, wo kommt denn das
her überhaupt? Hier vielleicht.
mp4info.js.
mp4info.js.
fs.
Äh, achso.
mkdir können wir mal suchen.
mkdir.
Ok, das kommt hier aus diesem JavaScript-Ding.
Alles klar.
Ja, sowas hat JavaScript aber nicht.
Normalerweise.
Ja, das ist vom
vom FFmpeg
Webassembly-Ding, so wie es aussieht.
Ok, weiter im Text.
Script.
Unten einfügen.
Äh, ins Index
wahrscheinlich.
Ja, MonkaS, aber richtig. MonkaHyperS.
So.
Ach, der nennt es nur www. Egal.
Ach, man muss die Sachen da rein
kopieren. Leute, wir machen jetzt
Trick 17. Wir kopieren die Sachen nicht rein, weil
die Sache ist ja die.
repo.monka.cpp, ne.
monka.cpp
Die Sache ist
ja die.
Make. Wenn wir das
kopieren, kommt das in dist raus. Wir linken das
einfach. Hab das
x. Ok.
Ey, die werden jetzt nicht wahnsinnig neu.
Wir haben Highspeed schneller, viel schneller
das gemacht im letzten Jahr über.
Können wir dann später machen.
Ähm, der kompiliert das ja immer
nach dist. Wir linken das jetzt
einfach rein. Wir gehen hier nach www.
rutsachen.ln-s
dist
js. Weil ich glaube,
man könnte einfach Sternchen machen.
Wasm.
Und Worker.
So.
Weil wenn ich's jetzt neu kompiliere,
ist es immer das
aktuelle im www. root.
Das ist im Prinzip Verknüpfung.
So. Haben wir den Kram.
Before we load up
into the browser,
our wasm build uses pthreads.
Security issues
some browser. Ok, jetzt muss man noch
irgendwelche Header-Files einfügen.
Node Express.
Node.js mit Express braucht man
auch noch. Ok, dieses Tutorial
zieht aber alle Register.
Docker. C++.
FFmpeg.
WebAssembly. Node.js.
Express. Makefiles.
HTML. Da ist alles dabei.
Da ist
alles dabei. Ja, die benutzen
das nur, um die richtigen Header zu setzen.
Ja, aber trotzdem. Das ist schon
die Hardcore-Variante.
Ok, wo muss
das hin? Server.js.
Das ist
richtiger Fifehead-Shit hier.
Äh, wo sind wir denn?
Da. New-File. Server.js.
Ich glaube,
noch sind wir in der Copy-Paste-Phase.
NPM Install
Express. Na dann, gib ihm
alles da rein.
Wenn das funktioniert,
was wir heute basteln, kann ich es
nachher auch noch auf Shithub posten.
Wenn ihr euch das angucken könnt.
Ok.
Alles klar.
Starten wir mal den Server.
wwwroot.
Bam. Server gestartet.
Chrome.
Was zum?
Warum habe ich überhaupt ein Package
JSON in meinem Heimatverzeichnis liegen?
Was, was,
was macht das da?
Moment, das ist, weil ich Express installt habe?
Warum installiert er das nicht
da drin? Cringe.
So.
Ach, weil ich kein
NPM Init gemacht habe. Ja, genau.
Local Host.
Äh.
8080.
So. Da ist die
Webseite. Ok.
Und jetzt brauche ich
ein Video zum Testen.
Ich brauche ein Video zum Testen. Dann nehmen wir noch
eins von meinen. Leute.
Dann nehmen wir noch eins von meinen.
Irgendein kurzes, was ich mir
schnell runterladen kann.
Dieses Pixel-Spiel schlägt Battlefield und COD.
Genau, das wollte ich schon immer haben. Alles klar.
Ähm.
KajiBass.mp4.
Das können wir auch nehmen.
Wenn du das als MP4-Video oder
als H.264-Video hast. Nee, Quatsch. Nicht
Weh, Gerd. Ähm.
YouTubeDL.
Nee, nicht YouTubeDL. Wie heißt das andere?
YouTube...
D? Nee, ähm.
Äh. Wie hieß
der Krempel?
Ah, genau. DLP.
Krass.
So. Minus F.
No Matches Found.
Gut. Lade ich mal mein eigenes Video
schnell runter. Sollte ja
zackig gehen. Ähm.
Das...
Wisst ihr was? Wir können sogar schon...
Leute, wir nehmen mal ein bisschen was kleineres.
Komm, wir nehmen mal das.
Wobei, ich muss vom
Kodak her gucken.
Es tut nicht jeder Kodak.
AVC1 ist H.264,
ne?
FFprobe. Okay. MV. Das muss ich jetzt mal umbenennen.
Vid.mp4.
FFprobe. Vid.
H.264. Main.
AVC. Bla. Blub. Alles klar. Gut.
Wir haben ein Video.
Äh. Oder wir können es auch
FF... Play
machen. Vid.
Alles da. Ich hab mein Video ein bisschen runter
gescaled, dass das im Browser dann auch ordentlich funktioniert.
Falls wir es überhaupt
jemals schaffen, den Kram zu
rendern.
Ähm. Gut. Also
wir haben ein Video zum testen. So.
Also, ich hab diesen Blogpost ja vorher schon mal
gelesen. Ich glaube, was das
macht, ist,
der lädt das Video hoch
und dann lädt das
in FFmpeg und lässt sich ausgeben, was
das für ein Format ist. Und das war's.
Das, wir wollen ja noch deutlich mehr machen.
Repos.
Monka
Cpp. Ja, da hin.
Wo ist das Video?
Ah, wwwroot. Ne, ne.
Das machen wir eins hoch.
Kann man hier drin irgendwie copy-pasten oder so?
Ne.
Ups. Jetzt hab ich's
hab ich's zerstört.
Ähm. Monka
Cpp.
wwwroot. Vid.
Da hin.
Alles klar.
So. Vid.mp4.
Hey, das
geht!
Okay, das macht mich schon mal
zuversichtlich, dass das Tutorial
nicht schlecht war. Also.
Wir haben jetzt ein Video
hochgeladen.
Okay, das muss ich jetzt erst mal verarbeiten.
Was da... Jetzt müssen wir 10++...
Server.js brauchen wir nie wieder.
Duration 0.
Ja, das kann sein.
Ne, Duration minus. Der erkennt
die Duration nicht richtig. Der ist
zu pepega dafür.
Wir können's ordentlich machen.
YouTube hat das bestimmt
müllig encoded.
Minus i Vid.
Keine Ahnung.
Out.mp4.
Wir lassen's mal re-encoden.
Dann ist das bestimmt alles gut.
YouTube hat das bestimmt painzchampig encoded.
Okay, das dauert jetzt kurz, das Video.
Ganz ehrlich, so ein langes Video
brauchen wir doch gar nicht.
Wir machen mal noch was anderes.
Wir machen mal noch was anderes.
Wir machen noch Skip.
Geht aus, oder? Skip?
Äh. Boah. FFmpeg-Sachen.
Äh. Ne.
Ne, ne. First.
First 20, oder
First 10 seconds, genau.
Skip. Aha.
Skip von 0.
Time 10.
Time 20.
Ja, das mit dem Skippen kannst du, hätte ich mir
auch gedacht. Aber wer weiß.
So.
Vielleicht checkt er das
jetzt besser, wie lang das Ganze ist.
Out.
Duration. Guck da. Das Ding war
einfach müllig encoded von YouTube.
Duration.
Duration.
20 Milliarden
Microseconds, Milliseconds,
was auch immer.
Microseconds wahrscheinlich.
Gut. Das funktioniert.
So, jetzt muss ich hier erstmal kurz verarbeiten,
was hier eigentlich passiert.
Das brauch ich wahrscheinlich nicht mehr.
Okay, ich muss jetzt erstmal kurz verarbeiten,
was hier eigentlich, was hier eigentlich,
ähm.
Was hier eigentlich passiert. Okay.
Index HTML. Wir haben ein
Input-File zum,
also Input, äh,
Form-Element zum
Hochladen.
Dann starten wir einen
Web-Worker.
Ähm.
Wir subscriben zu
dem Change-Event von dem Ding.
Also sprich, dass wir mitbekommen,
sobald hier was hochgeladen wird.
Es funktioniert anscheinend auch bloß einmal,
weil ansonsten geht's kaputt. Auch nice.
So. On-File-Change.
Schick dann
zu unserem Web-Worker
das hochgeladene
File.
Dann geht es hier weiter.
Der bekommt das.
Das ist bestimmt fucking viel Overhead
mit Web-Workern und sowas.
So.
Dann macht der FS
irgendwas. Irgendwas eingebautes.
Von FFmpeg.
Also der legt ein Verzeichnis
slash Work an. Virtuell.
Weil der Browser hat ja kein Filesystem in dem Sinn.
Kann nicht aufs Filesystem zugreifen.
Dann
kopiert er wahrscheinlich diese Files
nach slash Work. Sowas in der Richtung.
Wird das wahrscheinlich sein.
Dann macht der Module
Run. Das ist wahrscheinlich das Main
aus meinem C++. Ne.
Es heißt Run.
Hier ruft er das C++ auf.
Dort bekommt er dann
zurück, wie lang das Video ist.
Das löschen wir.
Ich kann doch nicht mal
was löschen hier draus.
Haineschamp File Explorer.
So.
Dann hier bekommt er zurück
die ganzen Infos, wie lang das Video ist,
Duration, Format, wie viele Streams.
Das postet er dann zurück
in das Main.
Und dann kommt er hier raus und hängt es da unten an.
Ok.
Und dann unmountet er den Krempel wieder.
Ach du Scheiße. Ok.
Jetzt müssen wir C++ programmieren.
Weirdchamp.
Jetzt kommt der Fun Part.
Massive.
Fun Haver Part kommt jetzt.
Was war das Ergebnis von dem Wasim
FFM Pack?
Hä? Du meinst das Rust
Package von gestern? Das hat nicht funktioniert.
Also.
Wie
testen wir das denn jetzt?
Wir machen was kleines.
Wir fangen mit irgendwas wirklich Minimalem an.
Also.
Das mit dem Format, das können wir ja da lassen,
dass da nicht so viel kaputt geht.
Open können wir auch da lassen.
So.
Jetzt müssen wir FFM Pack machen.
Mein FFM Pack, gerade in C,
ist nicht so gut.
Ich habe meistens den C Sharp Wrapper verwendet.
Der heißt zwar zum Glück fast alles ähnlich.
Aber.
Ah.
Ich weiß wo wir abgucken können, Leute.
Wir haben
doch mal.
Der Overlay Champ.
Den brauchen wir jetzt.
Visual Studio 2019.
Ich weiß nicht, ob ich mal unter Windows was gemacht habe.
Der Overlay Champ.
Das ist was, was ich mal gebastelt habe.
Hierfür zum Ablösen.
Ich habe doch hier mal ein Tool.
Mit dem ich
Bilder anzeigen kann und sowas abspielen.
Und sowas, ja.
Und das Ding hat Probleme bei größeren Gifs.
Wie zum Beispiel dem hier.
Guck. Klick.
Und da habe ich mal mit FFM Pack ein Overlay für gebaut.
Und ich glaube, das ist der Overlay Champ.
Muss mal kurz gucken,
wie so meine Systemauslastung gerade ist.
Download MonkaS. Was macht das da?
Habe ich Edge Dinger laufen?
Egal. Will ich gar nicht wissen.
Desktop ist das Beste.
So. Also da können wir nämlich hier
FFM Pack Zeug abgucken.
Video Frame.
Video Decoder.
Aha.
Hier machen wir Sachen. Ok.
Open Input.
Stream Info. Find Decoder.
AV Read. Ok.
Wir machen jetzt was ganz einfaches.
Wir lesen das komplette Video ein.
Und geben uns von jedem
ähm
noch
komprimiertem Frame einfach mal
die Größe aus.
Also machen wir irgendwie sowas hier.
While True.
Immer Beste.
AV Read.
AV Read
Frame.
AV Format Context.
Ach du
große. Ob das funktioniert? Aber wir brauchen ein Package.
Zum Glück habe ich schon mal ein paar Sachen mit FFM
Pack gemacht.
Halt selten in C++ direkt. Aber
ähm. Alloc Package?
Nein. Es ist
Package Alloc.
Ha. Übrigens.
Wisst ihr, wisst ihr, dass euch
das euch FFM Pack richtig
krass debaten kann? Es gibt
Free Package.
Und es gibt Package Free.
Also
es gibt AV Package Free
und AV
Free Package.
Das ist Deprecated.
Aber das ist etwas
Pains Jam.
Aber anscheinend haben sie es mit Version
5 entfernt. So.
AV Alloc Package.
Package.
Und eigentlich
müsste ich dann hier unten
sowas machen wie
Free Package
oder so.
Aber scheiß auf Memory Leaks. Das ist der Browser.
Da kann ja nichts passieren.
Okay. So.
Ähm.
Result. Null.
Result. Wir machen
nicht while true. Wir machen while
Result Null.
Reden wir Frames.
Ihr sagt jetzt wahrscheinlich, man könnte das da auch da oben
reinschreiben. Da bin ich mir aber
noch nicht so sicher, ob das eine gute Idee ist.
Ich meine, man könnte
ja auch sowas hier sagen.
Aber
da bin ich mir unschlüssig, ob das...
Wobei, warum nicht?
Können wir doch machen.
So. Das werden wir noch öfters brauchen.
Den FFmpeg Fehler
anzeigen. Alles klar.
Was muss ich jetzt
machen? AV Read Frame.
Okay. Also Print F.
Ich meine, wir sind
in C++, aber ich fang
garantiert nicht an mit
std out kleiner kleiner
irgendwas.
Jetzt lese ich es nicht mehr in der Variable.
Das ist richtig. Aber
brauche ich auch nicht, weil das, was ich haben will,
ist das da. Das hier ist nur der Return
Code. Das einzige Dumme ist, ich kann den Return
Code nicht ausgeben, wenn es Fehler schmeißt.
Okay. Print F.
Size.
Und jetzt Dollar.
Ne. Ach.
Äh.
D?
D ist ein int, ne?
Pegged.
Size. Ist das überhaupt
ein int? Ist ein int.
Alles klar.
Okay. Mal schauen,
ob das noch, ob das
noch maked.
Ah. Pause Check. Oh. Es hat
gemaked. Nice.
So. Wenn es jetzt funktioniert,
kriegen wir die aus. Jetzt liest er das
komplette Video ein. Frame für Frame.
Und gibt uns
die Größe von jedem Frame
aus. Wenn er nix ausgibt, geht was nicht.
Er gibt nix aus.
Ah.
New Line vergessen. Das liegt bestimmt am New Line.
Zack.
Was ist denn
Dollar I in Print F?
Wenn es das gibt.
Fuck.
Das wäre jetzt auch
zu einfach gewesen, wenn das einfach funktioniert.
Oder? Dann brauchen wir doch
den Return Code.
Moment. Ungleich Null ist doch
falsch. Gleich gleich Null.
Gleich gleich Null
will ich haben. Alter.
Pepega Programmer hier am Start.
Wenn es Null ist, dann ist es okay.
Dann will ich weitermachen.
Ah. Oh. Guck mal.
Das funktioniert.
FFmpeg im Browser, Leute.
FFmpeg im Browser.
Wir lesen das Video ein.
Ultra Low Level.
Und das im Browser.
Alles klar.
Das
überrascht mich jetzt ein bisschen, dass das
einfach funktioniert.
Aber das Komplizierte
kommt ja erst noch. Also mein
Ziel, by the way, ist,
was ich mir gedacht habe, was man mal ausprobieren
könnte, ist SD-Videos.
Browser können in der Regel
nur HD-Videos abspielen. Und eigentlich
auch nur H.264,
äh,
VP8.
Ich glaube, das war es, oder? Ein Standard-Video-
Codex, die jeder Browser unterstützt.
VP9 und
H.265 ist, glaube ich, noch nicht überall gelandet.
Bin ich mir aber unsicher. Zumindest
die alten SD-Videos
sind ja MPEG-2-Video.
Und da habe ich mir
gedacht, man könnte so machen, dass man
damit alte SD-Videos
abspielen kann. SD-Videos brauchen auch nicht so viel
Leistung. So.
Okay. Jetzt kommt
aber der komplizierte Part.
Jetzt kommt
der komplizierte Part.
Wir müssen das Video decoden.
Wir lesen ja aktuell nur
das Video ein. Und jetzt müssen wir das Video decoden.
Video decoden.
Dafür, das können wir uns abgucken.
Das habe ich nämlich hier gemacht, vor ein paar Jahren schon.
Also, wie
funktioniert das?
AV-Format, ALOG-Context, haben wir.
Stream, Format, Stream.
Ich copy-paste mir das jetzt
einfach. Und dann
bauen wir das um.
In C++.
Kannst du
Dateien speichern? Ja, aber nur
über Downloads, also nur über JavaScript-Umwege.
Gut, ich könnte es im Local Storage
speichern. Aber ich glaube,
es ist ein bisschen klein für Videos.
Wie groß? 50 MB
oder so ist Local Storage-Maximum pro Seite?
Oder 20 sogar nur?
Ah ne, 10.
10 ist es nur.
Aber wisst ihr, wofür das cool ist?
Man könnte zum Beispiel einen qualitativ
ansprechenden
GIF-Converter machen,
der client-seitig läuft.
Das ist cool. Das klappt.
Wobei man
das auch, das kann man auch mit FFmpeg
WASM oder FFmpeg.js machen.
Aber hier kann man halt
deutlich mehr tunen, weil man Zugriff auf die
Low-Level-Sachen hat. Also wie, okay,
was muss man machen? Stream.
Stream, gleich.
Äh, warum machen die
das eigentlich da oben hin?
Jetzt mal ernsthaft, warum beschreiben die das nicht hier unten rein?
Die, die clearen den Kontext
auch nie.
Das ist Memory League.
Das ist Memory League, oder?
Normalerweise musst du das closen am Ende.
Normalerweise
musst du
close,
ne, äh, äh, äh,
av-close
close-input
musst du normalerweise zum Schluss machen.
fmt-context
Und dann einen Pointer auf
einen Pointer übergeben
und dann funktioniert's.
Weil Fifat C++ kam.
Und dann
können wir das nämlich auch
hier machen. Und brauchen
das da oben. Warum hat er das halt static
da oben gemacht? Das macht doch überhaupt keinen Sinn, oder?
Ich mein, wahrscheinlich kann der
deutlich besser C++ als ich. Das hat doch einen Sinn.
Äh, Raster nicht gut
funktioniert. Sonst würde ich heute nicht
C++ machen.
Warum haben wir eigentlich schon kaum was gemacht und 30 Milliarden
Files hier rumliegen? Was ist das? Was ist
da los? Amazing, dankeschön für den
Sub. So, ähm,
Format Open Red.
Red
brauchen wir doch nie wieder, oder?
Red brauchen
wir nie wieder.
Ah, doch, wir brauchen Red. Ah, ich kack noob.
0w, alter.
Okay.
Dann nehmen wir's so.
Alles klar. So, jetzt müssen wir das hier in C++
umwursten. Also, zum Glück
heißt das in dem Wrapper gleich. Also wir brauchen
jetzt Format Context
Stream
0. Das ist die
gleiche Syntax.
So, Codec.
Codec gleich AV
Codec Find Decoder.
Und dann
Stream
Codec. So.
Aha, alles klar.
Gut, dass wir das schon mal in C Sharp
gemacht haben damals, dass ich das jetzt einfach nur übersetzen
muss. So, das haben wir gemacht.
Das haben wir gemacht.
Äh, jetzt brauchen wir noch einen.
Wisst ihr was? Ich mag die
Schreibweise mehr.
Also.
Alter, okay, ist ja gut.
Muss ja alles umbenennen.
So, und jetzt müssen
wir. Wie geht's denn jetzt weiter?
Package Frame.
Na gut, so weit sind wir noch nicht.
Open.
AV Codec
Open. Oh, das gibt's
nicht. Äh.
Andere Header vielleicht?
Welchen
Header? Welchen Header brauche ich denn
dafür?
Gucken wir mal ein Beispiel an.
Von irgendwelchen anderen random
Dudes im Internet.
Include.
Was gibt's? Okay, AV Codec.
Wo könnt's denn da, in welchem
Header könnt's denn das geben?
lib AV Codec?
Codec? H?
Oder AV Codec Punkt H?
AV?
AV Codec Punkt H wahrscheinlich.
Include 5 Header.
Excellent. Das wird's sein.
Das ist.
Include 5 Header, included automatisch
alle Header richtig.
Weil es weiß, was man haben will.
Ach, guck mal, da haben wir's jetzt.
AV Codec Open.
Ähm, und.
Ne.
Sowas brauche ich noch.
Codec, oder
Decode
CTX.
Gleich
AV Codec
Analog Context 3.
Ganz wichtig, 3.
Nicht 1, nicht 2, nicht 4, 3.
Ich glaube nicht, dass dir das mit Blazor
irgendwie einfacher fällt.
Das stelle ich mir sogar ehrlich
gesagt fast, äh, schwierig
bis fast unmöglich vor.
P-Invoke
Gedöns über Blazor WebAssembly
auf irgendwelche C-Libraries.
Das wird was.
Wie soll denn
das funktionieren?
Wie willst du das machen?
Du bräuchtest erst einmal FFmpeg
als WebAssembly
Build.
Dann
müsstest du da drauf irgendwie
ich weiß ja nicht mal, ob man überhaupt mit Blazor
P-Invoke ordentlich
machen kann auf
WebAssembly Basis.
Boah, das glaube ich nicht, dass das so easy ist.
Da vermute ich, da ist es sogar mit C++
deutlich einfacher.
Okay, also wo sind wir denn stehen geblieben?
So, Analog
Context 3
So
Es gibt zumindest schon mal keine Syntaxfehler.
Und jetzt Open
Decoder
Context
Codec
Gut, dass ich das abschreiben kann.
Null, natürlich, was sonst?
Ah ne, wir sind ja in C++, da ist es null.
Ich habe meine Zweifel,
ob das jetzt so funktioniert.
Können wir irgendwie checken, ob es funktioniert hat?
FFmpeg Blazor
FFmpeg Blazor? Ach, zeigt mal her,
zeigt mal, guck mal
Interessant, das muss ich mir mal schnell angucken.
FFmpeg Blazor
FFmpeg und WebAssembly
FFmpeg provides, ability to utilize
Ne, FFmpeg
Wasim brauche ich nicht.
FFmpeg Wasim ist nicht das, was ich haben will.
Das ist ja
im Prinzip nur ein FFmpeg CLI
Rapper
für den Browser.
Also nur, nur, ja das ist auch schon
Sache. Aber wenn du interne Sachen machen willst,
fällst du dir damit schwerer.
So strange.
Ja, guck. Das ist ein
CLI-Wrapper. Na, das ist
Noob-Kram. Das braucht man nicht.
Wir wollen ja direkt auf einzelne
decodete Frames zugreifen. Das wird damit
nix. Also.
Gibt's hier irgendwie gescheite Return-Werte?
Hier. Red. Red gleich.
So, schauen wir mal,
ob das mit dem Codec funktioniert. Also.
Ähm.
Äh. Open.
Open. Ne.
Codec. Oder.
Ja.
So. Egal, wie ich's nenne.
So. Jetzt gucken wir uns
mal ein bisschen Debug-Ausgabe
an, ob der Kram funktioniert.
So. Make. Wir haben
anscheinend keine Syntax-Fehler drin. Das scheint
schon zu funktionieren soweit.
Es passiert jetzt noch nicht viel mehr.
Aber wir sehen
jetzt, ob das an sich...
Codec. No Error Information.
No Error Information ist gut,
weil No Error Information bedeutet,
es gibt keinen Fehler und das hat
funktioniert. Alles gut.
Also. Return-Code ist...
Hat funktioniert. Okay. Der hat das
geöffnet. Wir können das ja mal anders machen.
Ähm. Äh.
Codec.
Wir lassen uns mal den Name ausgeben.
Name.
Da sollte jetzt rauskommen. H264.
Sollte da jetzt rauskommen.
Bei dem Codec.
Als Name. Ja.
Super.
H264. Ja. Gut.
Das scheint bis jetzt zu funktionieren.
Alles klar.
Richtig.
Feilfeder. Gut. Und jetzt müssen wir
decoden.
Okay. Wie geht das?
Äh. FFM-Pack. AV-Codec.
Open. Das
funktioniert.
AV-Seek brauchen wir nicht. Das ist das,
damit das loopt bei GIFs. Das brauchen wir nicht.
So. Genau. So ging das jetzt. AV-Codec.
Send Package. AV-Codec.
Receive Frame. Exakt.
Und da brauchen wir noch ein Frame vorher,
aber das kriegen wir hin. Okay.
Also die die Logik bei FFM Pack ist,
falls das irgendjemand von euch auch mal
verwenden will, ein Packet ist das, was...
ne, es muss ja sein.
Ein Packet ist ein noch komprimierter Frame,
und ein Frame ist ein Videoframe, der decoded
wurde. Das heißt Packages schiebst du in den Decoder rein,
Decoder rein und Frames bekommst du
aus dem Decoder raus.
Umgedreht, wenn du was encodest,
schiebst du Frames rein und bekommst
Packages raus.
Weißt du was, Leute?
Ich nenne das Packet.
Ich nenne das Packet, weil ich habe das
andere Frame genannt und sonst müsste ich es auch
Frim nennen. Also, Leute, C++-Leute
würden es, die richtig Hardcore
C++-Leute würden es Picket und Frim nennen,
oder? Gebst zu.
Klare Schreibweise ist da
nicht so hoch im Kurs.
So, jetzt lesen wir den Frame
ein. Wir müssen jetzt
noch checken, falls das mehrere
Streams hat,
ob, ähm,
Packet,
P und F reicht eigentlich auch,
ob Packet Stream Index gleich
gleich Stream
Index ist. Das ist
wichtig. Ich meine, hier haben wir Hardcoded.
Theoretisch muss man
gucken, wie viele Streams in einem Video
sind, weil es könnte ja Video Stream sein,
Audio Stream, Untertitel Stream und dann
den rausfiltern, den man haben will, aber wir
machen es mal so. Aber nur, falls Audio,
falls Audio in dem Stream ist,
kann ich schlecht das Audio in den
Videodecoder pumpen.
Deswegen machen wir das mal so
zur Sicherheit. Wobei, wir sind
in C++. Coole C++-Leute machen
das wahrscheinlich so. Alles
klar. Okay, Send Packet,
Receive Frame.
Äh, Decoding
Context.
Red. Okay.
Jetzt bin ich mal gespannt.
Leute, irgendwo, irgendwo kommt
auch der Haken. Ich glaube einfach nicht, dass es
einfach jetzt decodet.
Make.
Also von der Idee her,
wenn alles funktioniert, sollte der
jetzt die einzelnen
Bilder von
dem Video nehmen und decoden.
Aber ich glaube
noch nicht dran, dass es funktioniert.
Moment, das ist noch
die alte Version.
Hä? Hä?
Was?
Warum?
Print, printet der hier denn nix?
Warum printet der nur Size?
Und?
Hä? Wo ist denn der Rest?
Wo ist denn meine andere
Ausgabe? Achso, ich bin ja
auch doof. Guck mal da. Ha!
Ich muss sagen, ungleich.
Ungleich Stream Continue.
Nicht gleich, gleich Stream Continue.
Lul. Low IQ
am Start. Ich brauch mehr Prime Subs.
Der muss, muss wieder raufgehen.
Oh, das sieht nicht so gut aus.
Was ist hier los? Input.
No Startcode is found.
Error splitting. Invalid data
found when processing.
Äh.
Okay, ich hab gehofft,
es gibt jetzt irgendeinen Fehler, mit dem ich was anfangen kann.
Und es kommt bei jedem
Frame.
Shit.
Invalid data when
processing. Ähm.
Ich würd sagen, wir googeln mal danach.
Äh.
Okay, jetzt wird's natürlich...
FFmpeg now says.
Okay.
Now says.
Ne, ne. Stackoverflow ist unser bester, bester
Bet hier. Ne, ne. Moment.
Ne, ne. Die, die machen ja alle Kommandozeile.
Wir brauchen, wir brauchen
schon AVPaget. Wir brauchen schon
die RAW-Geschichten.
Oh, shit.
Oh, shit. Alter, wie kriegen wir denn das jetzt gefixt?
Ähm.
Open not working. Der Chat googelt mit.
Das mag ich.
Ne, das ist, das ist alt.
Das braucht man nicht mehr.
Das braucht man nicht mehr. Das braucht man nicht mehr.
Der hat...
Es klappt ja auch alles.
Es klappt nur nicht beim Decode.
Vielleicht soll ich das andere
noch mit... No start code is found.
Oh, jetzt kommt Google
Action.
No start code.
No start code is found. Aha.
Ach, fuck. Wir brauchen
RAW FFmpeg-Zeug.
Nicht diesen, nicht diesen
Kommandozeilen-Crap.
Hm. Super-User.
Okay, also ich rate jetzt einfach mal was.
Ich glaube, unser
Decoder ist falsch
konfiguriert.
Manchmal muss man diesen Decoder nämlich noch
was einstellen. Sowas wie Höhe und Breite
und solche, solche Dinger.
Dass es funktioniert.
AVPaget.
Probier nochmal. Ne, vorher hat er nicht funktioniert.
MonkaS, was ist das?
Ne, das funktioniert.
Funktioniert nicht.
Okay, was machen wir denn da jetzt?
Man konnte doch irgendwie
den Kram kopieren.
Man konnte doch irgendwie
sagen
Kodek
Copy oder irgendwie sowas. Kodek
Kontext.
Ach du Scheiße.
Wie ging das jetzt nochmal?
Ne, das ist Doku von 2.8.
Ne, ne, ne, ne, ne.
Das brauchen wir nicht.
Ne, ne, es geht.
Es gibt, man konnte ihm sagen,
nimm den Input-Stream und mach
da raus einen Decoder.
Create-Kontext
oder sowas?
Hm. Ich,
ich wette, wir finden die Antwort auf Stack-Overflow.
Stack-Overflow ist
einfach
das Beste. Wir, wir, wir machen jetzt so lang
Stack-Overflow.
Set AV-Coder-Flag-Global-Header.
Ne, das wird's nicht sein.
Macht der Typ das hier?
Ja.
Failed.
Ach, der encodet das. Ne, ne, ne, ne.
Ich will es decoden.
Ah, shit. Wie war das denn nochmal?
FFmpeg
hat halbwegs brauchbare
Docs, aber nicht bei so Dingern.
Ja, das klingt doch ganz gut.
Ich Stack-Overflow
mich jetzt einfach kurz durch.
Das meine ich!
Das meine ich!
Parameterst du Kontext?
Das meine ich. Mir konnte nämlich
vom Input-Stream die ganzen Parameter
von Seite, Höhe, Bitrate, Geschiss
übernehmen für den Decoder.
Ohne, dass man die alle von Hand reinhält.
Das meine ich. AV-Codec-Parameterst du Kontext.
Das meine ich. Genau.
Ähm, soll man gucken, wie man das jetzt verwendet.
Ich glaube, GitHub-Copilot
versagt an der Stelle auch.
Aber das ist für Encoder.
Habe ich das für
Encoder verwendet?
Hm.
Mal schauen. Okay.
Wie, wie, wir probieren das jetzt
erstmal aus. AV-Dings.
Dings. Okay, was muss man dem übergeben?
Den Decoder-Kodec-
Kodec-Kontext
und die Kodec-Parameters.
Die Kodec-Parameters
gibt es von Stream
Kodec-Parameter.
So. Und wenn wir jetzt Glück haben,
funktioniert's.
Obvious. Pfeifert.
Chat. Was meint ihr?
Geht's oder geht's nicht?
Force-Champ? Brage?
Leute, wir brauchen mindestens 20
Brages im Chat. Sonst kann es nicht funktionieren.
Ich brauche, ich brauche, ich brauche
kurz mal den Brage-Spam.
Brage. Brage-Chat. Brage.
Massive Brage.
1, 2, 3,
4, 5 Brages erst. Das wird nix.
6, 7, 8,
9, 10 Brages. 11.
Na, nur 11.
12. 13, 14,
15, 16, 17, 18.
19, 20, 21.
Okay, gut. Wir haben genug gebrait.
Gucken wir mal, ob's funktioniert.
Wir sind vom Brain in das
Post-Champen übergegangen.
Okay, was erwarte ich denn jetzt
überhaupt? Ich erwarte, dass der Codec
decodet.
Das ist
eine andere Fehlermeldung.
Das ist eine andere Fehlermeldung. Das ist schon mal
gut, dass das eine andere Fehlermeldung ist.
Restores
Temporary Unavailable haben wir jetzt.
Ich weiß,
warum das ist. Das ist, weil ich den
Frame nicht aus dem Decoder raushole.
Der erste müsste geklappt haben.
Bam!
Der hat decodet. Die ersten 5
Frames konnte er decoden, da war der Decoder voll.
Es hat funktioniert.
Excellent.
Excellent.
Brage hat geholfen, Leute. Also, ab jetzt
immer Brage, wenn was nicht geht.
Okay.
Also, wir wissen jetzt ja, dass es funktioniert.
Äh,
Receive Frame.
Frame.
Ja. Also, so
decodet man in FFM-Pack.
So ist das gedacht. Du schiebst,
das Komprimierte rein in den Decoder
und bekommst vom Decoder, das ist der Decoder,
und bekommst vom Decoder das
Unkomprimierte raus. So.
So funktioniert das. So, jetzt holen wir
das mal ab und gucken, wir gucken jetzt einfach,
ob es durchläuft ohne Fehler.
Ich meine, zwischendurch kann's vielleicht mal
ein paar Fehler schmeißen, aber im Großen und Ganzen sollte es
sollte es laufen.
Out.
Das geht einfach, Leute.
Es geht ohne Probleme.
Geschmeidig decodet er.
Und dann geht das durch.
Wir können jetzt auch gucken, ob das funktioniert mit dem Decoden.
Äh, wir lassen den Errorcode,
der juckt mich jetzt nicht.
Package Size juckt mich jetzt auch nicht.
Was viel interessanter ist,
ist, doch wir vergleichen jetzt mal was.
Leute, wir vergleichen jetzt die
Size decoded und encoded.
Daran können wir ganz klar erkennen,
ob es,
also
zweimal Size hintereinander,
ob es Frame
Size.
Achso, das ist die
Package Size.
Ja, die müsste ja exakt gleich sein.
Äh, wie kriege ich denn überhaupt die Size
von einem Frame raus?
Brauchst du nicht noch
AV Package Free?
Doch, das müsste ich hier unten eigentlich machen.
Und Frame Free.
So.
Ich bin mir nicht ganz sicher, ob der das
dann, nee, das passt schon.
Das reicht einmal am Ende.
Was willst du hier sehen?
Ganz schlimme Sachen, Leute.
Winko, ganz schlimme Sachen.
C++, FFmpeg
und das im Browser.
Aber bis jetzt muss ich sagen,
erstaunlicherweise
funktioniert's
bis jetzt. Guck mal, wir können ein Video
decoden im Browser.
Ein H264 Video
decoden im Browser über FFmpeg.
Also, FFmpeg in WebAssembly
übersetzt und dann ein Video decoden im Browser.
Das ist schon Pfeifhatshit.
Wozu braucht man das denn?
Zum Beispiel, wenn du in deinem Browser Sachen anzeigen willst,
die dein Browser nicht abspielen kannst.
Oder wenn du jetzt beispielsweise
irgendeinen GIF-Renderer machen willst,
der High-Quality GIFs
kreiert oder so.
Oder Audioeffekte oder so.
Ich könnte mir tatsächlich ein paar Anwendungsgebiete
vorstellen.
Warum ich das machen will ist,
nicht weil es wirklich irgendwie super krasses neues Startup
oder so gibt.
Ich hab mir überlegt, ob man nicht damit alte
SD-Fernsehaufnahmen
oder Videos abspielen könnte.
Ist das schnell?
Ne.
Also im Vergleich zu normalem Video
abspielen im Browser, was der Browser
unterstützt, ist es sicherlich nicht schnell.
Aber ich vermute,
es ist für SD-Videos schnell genug.
Das müssen wir jetzt gleich ausprobieren.
Ja, es ist richtig.
Ne, ist es nicht. Alles gut.
C++.
So, also wir sollten jetzt die Size angezeigt bekommen.
Unterschiedlich.
Wobei, es kann sein, dass es nicht funktioniert.
Weil die Packet Size ist hier oben auch die Packet Size.
Ähm.
Ja doch, guck mal.
Guck mal Leute, es klappt.
Komprimiert ist das Bild.
642
äh
Kilobyte?
Ich hab keine Ahnung.
Und dekomprimiert
ist es 2,4
Ne.
242 Byte
zu 2,4 Kilobyte?
Ne, so. Ja. Ach, was auch immer.
Aber das funktioniert.
Das ist äußerst nice.
Dass das klappt.
Kannst du das nicht im Voraus transcoden?
Doch, das kann man auch machen.
Das muss man aber serverseitig machen.
Es geht ja um was kleinseitig ist.
Und um zu gucken, wie es funktioniert.
Um zu gucken, wie es funktioniert, ist eigentlich die Hauptsache.
Also, wir decoden ein Video.
So, wie geht's jetzt weiter?
Wie kommt man jetzt
an die Videodaten ran?
Eigentlich.
Size ist ja schön und gut.
Aber
äh
Frame
Data gibt es. Das kenn ich.
Aber Data ist quasi
nur ein
Moment, Moment.
Was seh ich hier?
Ist das jetzt ein Pointer
auf Arrays?
Oder ist das ein Pointer auf ein Array?
Also ist das ein Pointer auf ein Pointer?
Oder ist das ein
Also ist das ein Array mit 8
mal Pointern drinnen?
Oder ist das ein Pointer, also ist das ein Array?
Das bin ich jetzt unschlüssig.
Wie
bekomme ich
Pointer zum Array?
Aber warum steht da 8
dahinter?
Warum steht da 8 dahinter?
8 Elemente.
Aber, das ergibt keinen Sinn.
Wartet mal.
Auto Keg W
Guckt mal.
Das ist ein Pointer. Das ist ein
Array mit Pointern
auf weitere Arrays.
Guckt.
Das ist ein Pointer.
Also, das ist ein Array
mit 8 Pointern
zu weiteren Byte Arrays.
Also sind 8
Byte Arrays quasi.
Ach du
Scheiße, Mann.
Was soll ich denn damit jetzt machen? Wie kriege ich denn da die Größe
raus? Okay.
AV Frame
To
Size.
Was ist die Size von einem AV Frame?
Determining Size.
Das funktioniert auch
auf Mobile Browsern. Wahrscheinlich
schon, ja.
How to get raw frame data.
Genau das will ich haben.
AV Picture.
AV Picture
ist, soll man
nicht mal verwenden. Da kann ich mich dran erinnern.
Da ist was dran gewesen.
To Char Array.
Buffer Calculation.
AV Image
Get Buffer Size.
Das klingt doch gut.
Das will ich haben.
AV Image
Get Buffer
Geil.
Und was muss ich includen dafür?
Image Utils. Ich include jetzt einfach
Image Utils. Umgutes.
Image Utils. Include.
Image.
Ha.
Lip Image.
Utils.
AV Utils.
Image Utils. Alles klar.
Das muss ich sagen. FFmpeg hat die Dinger
wenigstens noch.
Funktioniert das auch in Safari?
Ja, ich glaube das funktioniert
sogar in Safari.
Wobei das natürlich nicht gegeben ist immer.
Safari ist der neue Internet Explorer.
Also was muss man da jetzt reinschreiben?
Pixel Format. Okay.
Frame Format haben wir.
Breite ist Frame Breite.
Nächste ist Frame
Höhe.
Int Align.
Was soll das sein?
Line Size Alignment.
Return Size and Bytes
of the amount of data
required to store an image.
Äh.
Was will das von mir?
Multithreaded geht nicht in Safari.
Es war klar, dass
irgendwas nicht in Safari geht davon.
Das
habe ich nicht anders erwartet, ehrlich gesagt.
Safari geht immer
irgendwas nett.
What is Line Size Alignment meaning?
Ja. Aha.
Wie macht der das hier?
Eins.
Ne. Eins ist es wahrscheinlich
nett.
32 klingt doch erstmal gut.
Leute, ich habe keine Ahnung, was da aligned wird.
Wahrscheinlich die Speicheradressen, wo es
anfängt oder irgendwas.
Keine Ahnung. So und jetzt kommt
D++ Shit.
Weil wir müssen das casten,
dass das funktioniert.
Gut.
Klar gibt es in Safari noch
was meins, was auf iOS und MacOS
verwendet wird für einen Browser.
Image
Keine Ahnung.
Image
Size
Ok. Printen wir mal.
Image Size.
Das ist wie groß der Buffer
also wie viele Daten
der decodede Frame hat.
Das brauche ich ja im Endeffekt,
dass ich weiß, wie weit ich das Array lesen muss.
Das ist natürlich
blöd, dass das so wissenschaftlich
Wissenschaft für sich ist.
So. Hat funktioniert.
Nice. Zack. Out.
Size.
Äh. Und das ist jetzt
wahrscheinlich Bytes.
Also 345 Kilobyte.
345 Kilobyte
pro Frame.
Decoded. Naja.
Das ist RAW RGB.
Nee. Nicht RGB.
Juff 420 oder so.
Das klingt doch
realistisch, oder?
So. Und jetzt ist natürlich die Frage.
Wir haben jetzt ja noch einiges vor uns.
Jetzt ist die nächste Frage.
Wie bekomme ich die Image-Daten
zu JavaScript rüber?
Ok. Wahrscheinlich muss ich mir die Image-Daten
erstmal in einen eigenen Buffer
kopieren.
Weil ich kann mir nicht vorstellen, dass ich
MonkaS.
vorstellen, dass ich Frame
Data
irgendwie
zu JavaScript zurückkriege.
Pointer to Picture Channels
Moment. Ein was?
Ein Pointer
to Picture Channel
Planes.
Was? Also ich glaube nicht,
dass ich
diese Daten so direkt
nach JavaScript
zurückbekomme.
Du kannst einfach die
Uint8-Arrays
Aber ich habe doch gar keine Größeninformationen.
Ich habe doch nur
die Gesamtgröße.
Du machst Wasim mit Go.
Ich finde die Technik
auch wahnsinnig spannend.
Deswegen dachte ich mir, ich muss mich da mal ein bisschen mit beschäftigen.
Also.
Wir machen das jetzt so.
AV Image Buffer
Wir kopieren uns
das jetzt in einen eigenen Buffer rein.
Also irgendwie
Image Data.
Ne Moment.
Das funktioniert bestimmt anders.
Das geht bestimmt.
Uint8 Destination
Also.
Oh. Ich brauche irgendeinen Buffer.
Ok.
Buffer gleich
sowas da.
Jetzt wird es wahnsinnig safe.
Size. Image Size.
So.
Und in was brauchen wir den Buffer jetzt?
Void. Klar.
Wenn schon, dann richtig C++.
Void Sternchen. Alles klar.
Also wir brauchen das in Uint8.
Buffer?
Buffer Size? Ne. Image Size?
Vielleicht soll ich es Buffer Size nennen.
Dann blicke ich mehr durch was es ist.
Ja.
Ist klar.
Jetzt kommt der Nächste um die Ecke und sagt uns
Übrigens du verwendest nicht Linux.
Du verwendest GNU Linux.
Allow me to interject for a moment.
Moment.
Was mache ich denn da?
Ne. Das brauche ich nicht.
Moment. Ah. Ich bin verwirrt.
Image Size. Buffer Size. Nur Buffer Size da rein.
So. Und jetzt hier Buffer Size.
Das funktioniert.
Source Data.
Ok. Das ist jetzt wahrscheinlich
Frame Data.
Und das hier ist Frame
Oh. Das gibt es zum Glück.
Line Size.
Pixel Format.
Hier oben schon mal.
Frame Breite.
30 Milliarden Parameter. Mann. Hi.
Alignment. Ja. 32.
Ich weiß nicht was es macht. Aber 32
ist Alignment.
Oh. Der Buffer ist falsch.
Was?
Ah. Ich caste das zu einem Int.
Ich muss es zu einem Int Pointer casten.
Alles klar. Oh.
Grip.
Ok.
Jetzt ging es auf einmal. War der Meinung geht nicht.
Aber jetzt geht es wieder.
Was ist denn nun mit Casten?
Ja. Wo ist denn der Casten?
Ewig nichts mehr gehört vom Casten.
So. Buffer Size.
Gut.
So. Wie kriegen wir den Kram jetzt zurück?
Wie kriegen wir den Krempel?
Also. Ich lasse es mal kurz laufen.
Und gucken ob es crasht.
Gucken wir mal.
Gucken wir mal ob es crasht.
Ach ja. Das ist ein C-Cast.
Stimmt nicht. Es crasht nicht.
Wie ist denn.
Wie ist denn die hässliche Variante
für C++?
Irgendwie Standard Cast?
Ne.
Const Cast. Static Cast.
Dynamic Cast.
Reinterpret.
Reinterpret.
Cast.
Ich weiß noch nicht mal wie das funktioniert.
Weil das so wirr ist alles in C++.
Wie würde ich das hier
jetzt in C++ schreiben?
Static Cast. Also.
Static Cast. Ne.
Static Cast.
Achso.
Also die C++ Variante
wäre
Static Cast
Uint
8 Sternchen
So?
Ne.
Alter C++
Achso natürlich.
So drum herum.
Ist ja eine Funktion quasi.
Okay.
Jetzt mal ernsthaft.
Warum sollte ich
das verwenden?
Das hat bestimmt irgendwelche
theoretischen
Freifad Vorteile, weil es
Compile Time Checks macht oder sonst was.
Aber das sieht ja so um Längen
hässlicher aus.
Als einfach ein stink
normaler Cast.
Ne. Das machen wir nicht.
Das ist mir so doch deutlich lieber.
Also.
Es ist nicht gecrashed.
Okay. Wie kriege ich diesen Krempel zurück
nach JavaScript?
Und noch viel interessanter. Wie mache ich denn ein Sleep?
Weil ich muss ein Sleep machen.
Damit ich auf die Frames warten kann.
Äh.
C++ Sleep.
Sleep for Milliseconds.
Sleep Function.
How to Sleep.
Was?
Für nen Sleep?
Was ist denn mit euch? Alter. Ich hasse C++.
Das ist so eine Dreckssprache.
Alter.
Ich mein.
Warum kann man nicht einfach machen?
Sleep Klammer auf
1000 Klammer zu.
Warum brauche ich
zwei Header?
Okay. Das lass ich mir noch gefallen.
Aber was ist das für eine Ausgeburt der Hölle?
Guckt euch das an.
Äh.
Ich nehm einfach.
Ich nehm einfach C Functions.
Wobei.
Moment.
Das ist ja WASM.
Da kann man bestimmt nicht so einfach sleepen.
Da gibt es bestimmt was hier für.
Asynchify.
Geil.
Geht da was von Sleep? Sleep?
Sleeping.
Emscripten Sleep.
Gibt es.
Alles klar.
Millisekunden.
Ne ordentliche Funktion.
Wo man was mit anfangen kann.
Okay.
Es ist immer noch die Frage.
Wie krieg ich diesen Campbell im Browser?
Was?
Unser C++-Prof im ersten Semester hat zwei verschachtelte Vorschleifen an Sleep benutzt.
Ja gut.
Wenn man möchte, dass man viel Akkuleistung
oder CPU-Kram.
Also viel Akku zieht.
Weil man CPU verbraucht.
Vor allem.
Wie sleepst du dann gleich lang auf unterschiedlich schnellen Rechnern?
Brauchst du...
Dann musst du erstmal ein Mini-Benchmark machen.
Wenn du sleepen musst auf den unterschiedlichen Rechnern,
dass es gleich lang sleept.
Der Typ war pepega.
Ja glaub ich auch, wenn du zwei Vorschleifen für einen Sleep machst.
Können wir zurück zu Rust?
Ich würde viel lieber Rust machen als C++.
Aber geht ja nicht.
So. Wie krieg ich den Kram im JavaScript?
Emscripten
Callback
Call
Call
JavaScript
Interacting with Code
Emscripten runs
Emscript
Aha.
Alert. Hi.
Das bringt mir nichts!
Ich muss in das Return!
Ne das Return bringt mir nichts.
Ich brauch die einzelnen Frames,
so wie sie aus dem Decoder kommen.
Ich kann nicht auf das Return warten.
Ich brauch hier nen Callback.
Also hier hab ich die Stream dann.
Und hier brauch ich nen Callback nach JavaScript.
Der dann im JavaScript
das Bild rendert irgendwohin.
Also. Das...
da kann man da irgendwie parameter übergeben oder so ein winter objekt da habe ich glaube
ich keinen zugriff drauf das muss ich alles über javascript machen mgs kann man da parameter
übergeben was für dinger ok das scheint gar nicht so einfach zu sein was zurück an javascript zu
schicken guck mal hier guck mal hier übergeben die argumente alles klar das ist so abgedreht
dass man das war ein formatter in der kommt damit nicht klar der ist überfordert das kriegt
er nicht das kriegt er nicht hin ok also i received was passiert denn jetzt ok ok ok so
baffo baffo und baffo stars so
dann gehen wir hier in den worker rein und sagen function wir kommen jetzt einfach mal
in sie call me so es gibt es gibt ein pointer gibt es und es gibt es sei es ok lockt heute
und lockt sei es okay ob das jetzt funktioniert da bin ich wirklich mal gespannt so call me
moment dollar 0 dollar 1 ok das heißt das ist ja absolute pfeife der sonntags hier so jetzt sollte
ich eigentlich hier auf die jetzt sollte ich den pointer bekommen und ich sollte dies sei es von
dem ich sollte den pointer zum array und ich sollte die sei es den sei es wie ich dann natürlich den
pointer wieder in die daten umwandeln javascript das steht noch auf dem ganz anderen platz jetzt
hoffen wir erstmal dass der kram überhaupt kompiliert
die siguiente test fände zeige ich dir die повie
und Show analyzed hat es die sprite hier ja ist vor allem nicht einfach zu Beubscribe
die suite
für jeden freimund Saying
und wie kriege ich jetzt den pointer
zu einen u 28
m quippen
using m script
T8-Array-to-JS-Blob, Web-Assembly-Memory, Accessing-Int, ach du Scheiße, was, New-U8-Memory-Buffer,
was zum, was, M-Scripten-Heap-U8, Pointer-Size, sowas da, okay, also ich bin Pfeifert, Leute,
bin ich Pfeifert, ich hab meine Variablen exakt so benannt, wie aus diesem Beispiel, way, way to dank,
gut, ich mein, Pointer und Size so zu nennen, wie Pointer und Size, ist jetzt, glaub ich, auch nicht so magic,
so, äh, Buffer, so, Lock, Buffer, au, Mama, ob das funktioniert, wahrscheinlich, wobei,
crashen kannst, Leute, wir sind im JavaScript-Land an dieser Stelle,
da kann man nicht mehr crashen, da kann man komische Fehler schmeißen, aber man kann nicht mehr richtig crashen,
wobei kann man mit Web-Assembly im Browser auch nicht mehr, out, hm, Moment,
wollen wir mal kurz rückgängig machen, vielleicht ist der erste, vielleicht ist der erste Callback,
vielleicht geht der, vielleicht geht der nicht, also, dass ich quasi noch checken muss,
wenn Size kleiner als, out, das funzt, ah, die ersten zwei Frames sind, sind im Arsch,
die gehen einfach nicht, aber das müsste doch eigentlich mein Decoder auch checken, Sekunde,
das müsste mein Decoder mitbekommen, eigentlich, bekommt das mein Decoder nicht mit?
Der Decoder sollte einen Fehler schmeißen, und dann kann ich sagen, wenn der Decoder einen Fehler schmeißt,
dann mach ich gar nicht erst weiter, hier, Resource Temporary Not Available, what?
Okay, dann machen wir es einfach so.
Wenn der Decoder ungleich 0 ist, dann machen wir auch Continue, und machen das gar nicht weiter.
So, damit sollte sich dieser Fehler eigentlich erledigt haben, ja, ups, Lock, Buffer,
jetzt sollte es eigentlich dieses Problem nicht mehr geben, schauen wir mal, also, ich hoffe jetzt drauf,
in 8, also, ein Byte Array kriege in JavaScript, was ich später weiterverwenden kann.
Aha, siehste, das funktioniert, UN8 Array, mit ganz viel Zeug drinne, das sieht ja im Prinzip schon mal gar nicht so schlecht aus.
So, ich vermute mal, wir brauchen noch ein bisschen mehr, ich vermute mal, wir brauchen auch noch die Frame Breite,
wir brauchen auch die Frame Höhe, wenn man das rendern wollen, das ist das Nächste, nämlich, wie rendert man eigentlich so ein Byte Array in ein Canvas?
JavaScript hat UN8 Arrays, hat auch UEU32 Arrays und so komische Dinger.
Gibt es seit ein paar Jahren schon.
U8 Image in JavaScript, excellent.
Guck mal, proaktives Googeln vom Chat, das finde ich gut.
Mit dem Unterschied, das ist kein RGB, das ist JUF 420.
JUF 420, weil das ist ein Video, die sind meistens nicht RGB, weil es schneller auf der Grafikkarte so geht, oder warum auch immer, ehrlich gesagt, keine Ahnung.
Also, Frame, so, wir haben Breite, Höhe, kriegen wir noch, wir machen da jetzt mal, wir machen da jetzt mal ein Object raus, so, Buffer, Size brauchen wir eigentlich nicht mehr,
und Höhe.
So, das müssen wir dann nämlich returnen an unser Frontend irgendwie noch.
Alles klar.
So, also, das funktioniert ja an der Stelle soweit.
Kann ich irgendwie mein Syntax Highlight Ding, ja, okay, jetzt, das, das checkt er.
So, so checkt das auch.
So checkt das auch noch halbwegs, aber Zeilenumbruch checkt er nicht mehr.
Zeilenumbruch ist zu, Six Head, das kriegt er nicht hin.
Wir machen das so, das sollte reichen.
Ach so, ja, Dollar 2 und Dollar 3.
Sehr schön.
Alles klar, so, wie kriege ich diesen Krempel jetzt in mein Frontend?
Call me?
Hm, FFM-Pack Wasim, weil FFM-Pack Wasim für die Noobs ist.
Nein, also, der Sinn ist davon, FFM-Pack Wasim wrapped quasi die FFM-Pack, FFM-Pack CLI, das Ding hier.
Im Endeffekt.
Was ich machen will, ist, ich will ja wirklich auf die RAW-Bildinformationen zugreifen.
Ich will ja einen richtig, einen echten Decoder verwenden, dort einzelne Bilder rausholen und die einzelnen Bilder dann im Browser rendern.
Ich will keinen CLI-Wrapper.
Weil der Vorteil davon ist, du kannst dann beispielsweise auch Inputs streamen.
Zum Beispiel, du lädst dir ein Video runter und während das runterlädt, kannst du schon anfangen, es zu rendern und so.
Da gibt es viel mehr Möglichkeiten.
Und es gibt noch nichts.
Deswegen, du findest dazu nichts im Internet.
Deswegen habe ich mir gedacht, das müssen wir mal selbst probieren.
Okay, also, wie kriege ich denn jetzt diesen ganzen Krempel von hier?
Post-Message brauche ich jetzt.
Creating the Uhr.
Ah, Chat, das gucke ich mir gleich alles an.
Ich vermute nur, dass das eh in die Hose geht, weil das eben keine RGB-Daten sind.
Aber gucken wir mal weiter.
Also, jetzt muss ich erstmal den Kram zurückbekommen.
Post-Message.
Plopp.
Post-Message.
Und zwar posten wir jetzt unser, ja, unser JavaScript-Objekt.
Posten wir da.
Alles klar.
Post...
So, und jetzt sind wir zurück im Index HTML.
On-Message.
Komplett unsinnig.
Den ganzen Krempel brauchen wir hier nicht mehr.
Hier unten schmeißen wir auch weg.
Post-Message hier.
Let's go.
Post-Message.
Post-Message hier.
Log davon schmeißen wir auch weg.
Brauchen wir alles nicht.
Okay.
So, jetzt bekommen wir das hier rein.
Jetzt muss ich nochmal checken, bekommen wir das wirklich auch hier rein?
Data.
Muss ich nochmal kompilieren?
Eigentlich nicht, ist ja nur Frontend-Zeug.
So, jetzt sollte ich das nämlich in meinem Main-Render-Loop-Ding im Browser rausbekommen, das Ganze.
Bam.
Da ist das.
Guck mal, Buffer haben wir am Start.
Die Breite haben wir am Start.
Und die Höhe haben wir am Start.
So, jetzt brauchen wir eigentlich ein Canvas.
So, jetzt brauchen wir eigentlich ein Canvas.
Aber wie?
Creating a URL representing contents of a typed array.
Creating a URL representing contents of a typed array.
Äh, und dann?
Und was mache ich damit dann?
Ich will es ja auf ein Canvas rendern.
Das ist kein JPEG.
Das ist ja kein JPEG.
Das ist, ähm...
Bytes.
Also...
Raw Bytes.
Das ist kein encodedes.
Ein Video-Frame decoded.
Blob-URL generieren.
Blob-URL generieren.
Kann das Canvas überhaupt RGB-Daten direkt rendern?
Kann das Canvas überhaupt RGB-Daten direkt rendern?
Kann das Canvas überhaupt RGB-Daten direkt rendern?
Okay, ich habe keine Ahnung, wie das funktioniert.
Oh, was macht der Typ hier?
I have Uint8-Array.
RGB-Daten auf Canvas.
Der Chat ist hier der Gute.
Der Google-Meister wieder.
Canvas-Rendering.
Put Image-Data.
Put Image-Data.
Put Image-Data.
Ja, sowas in der Richtung will ich machen.
Ja, sowas in der Richtung will ich machen.
Das sieht relativ ähnlich...
Das sieht ähnlich aus, was ich machen will.
Das sieht ähnlich aus, was ich machen will.
Image-Data.
Ja, das will ich machen.
Genau, das finde ich gut.
Also brauche ich ein Canvas.
Also brauche ich ein Canvas.
Ein Format muss es haben.
Ja, es ist quasi ein Bitmap, wenn man es so will.
Aber warum soll ich eine Blob-URL erstellen,
wenn ich es auch so direkt ins Canvas rendern kann?
Wenn ich es auch so direkt ins Canvas rendern kann?
Das ist doch dann viel besser.
Okay, das Test...
Das Problem ist, es ist kein RGB.
Es ist kein RGB.
Es ist JUF420.
Glaube ich zumindest.
Weil es halt ein Video ist.
Weil es halt ein Video ist.
Es ist...
JUF420.
Alter, der Chat ist hier am Hypergoogeln.
Wow.
Das ist aber nicht JavaScript.
Alter, was?
Ne, ne.
Ich mache jetzt erstmal das. Mal gucken, was passiert, wenn ich das rendere.
Wir brauchen auf jeden Fall...
Wir brauchen auf jeden Fall ein Canvas.
Also, Canvas.
Das Ding kriegt eine ID.
Das Ding kriegt eine ID.
Keg.
Wiss.
Ja, Breite, Höhe.
Okay, setzen wir es mal so.
Breite 640.
Höhe
360.
So, und jetzt?
Wo sind wir hier?
Create.
Jetzt Comments, Alter.
Wer braucht denn diesen ganzen Crap?
Geh weg.
So.
Comments overrated, outdated, cheap baited.
Einfach fehlerfrei
programmieren. Easy.
So, okay.
Hier ist eine Function.
Okay, zeig her.
What?
Eigentlich brauche ich nur die hier.
Aber WebGL bringt mir doch auch nichts.
WebGL braucht doch bestimmt auch RGB.
Oder?
Kann Pixi
JS das?
Nicht Pixi, Pixi
JS.
Anscheinend.
Also, wenn ich irgendwie eine Ahnung habe, wie man das macht.
Okay, aber erst mal.
Ich muss den Kram überhaupt erst noch in das Canvas
reinbekommen.
Also, Canvas, Canvas, Canvas.
Also, Cagquiz.
WebGL müsst ihr aufrendern können.
Tja, da müssen wir nur rausbekommen.
Wie?
So, Cagquiz.
Let canvas
gleich Document
by ID
Cagquiz
Kurz mal schauen,
ob das funktioniert, was ich da mache.
Canvas, da ist es, okay.
Cagquiz
Ähm
Chat, jetzt habe ich vergessen, was ich gucken wollte.
Das wollte ich machen, das wollte ich machen.
Hier aus dem Example.
Hier ist ein Post dazu.
Chat, kann das mal einer aufmachen?
Sieht aus wie ein Virus-Post.
Das ist quasi ein Custom-Play in einem
Canvas, wenn man so will, ja.
Okay, also CTX
und Image-Data.
Das ist ein
Chat-Post über Yuff, okay.
Play with Rasmus Serious
WebGL Yuff, ja nur im Image.
Äh, ja.
Ja, ist ja, ist, ist,
ja, ja, na klar.
Alles, mhm.
Dazu kann ich nur sagen.
Easy as fuck.
Easy, easy as fuck.
Überhaupt gar
kein Ding. Ich meine, solange man das copy-pasten kann,
soll mir das recht sein.
Also, wenn ich das einfach 1 zu 1 so copy-pasten
kann, ja, dann, dann
ist okay.
Cringe, wer das
nicht so schon kann, ja, finde ich auch.
Chat,
ich hab mal ne blöde Frage.
Angeblich
ist PutImageData
eine Methode von Context2D.
Also quasi
das da, PutImageData.
Ist es aber nicht?
Das definieren die irgendwie selbst.
Das verstehe ich jetzt nicht.
Ist das jetzt ne API-Beschreibung oder
ist das, oder ist das
selbst gebaut
da Kram?
Das checke ich jetzt nicht.
Okay, CD. Also, wir sagen jetzt mal eine Sache.
Fill, ne.
Canvas, Fill.
Moment, kann man da nicht,
sollte der das nicht checken?
Okay, das ist cringe, weil
kein TypeScript, ich weiß, aber.
Okay, okay, okay, nice.
Das, genau das habe ich
gesucht. Also, onMessage,
ImageData, NewImage,
was, ImageDate?
Ne, das gibt es, das gibt es
nicht. NewImage,
ImageData, ja.
Wollte grad sagen.
Ja, mein Autocomplete hat mich gebetet.
Array, Höhe, Breite,
okay.
Also, im Prinzip,
im Prinzip ist es
quasi,
ähm, das destructen
wir mal. Buffer,
Size,
ne, ne, ne, gebe ich Size zurück?
Okay.
Width, Height,
auch nochmal richtig schreiben.
So. Buffer,
ja, okay.
Um es ohne TS-Type zu bekommen,
kann man JS-Docs-Comment
rübersetzen.
Oh, Five-Header-Kram,
Massive, extremer Six-Kopf,
ja. Und jetzt,
ai, ai, ai,
guckt euch das mal an. Type-Annotations
mit Zeug hier, ja.
Gut.
Aber PodImageData
gibt es angeblich gar nicht.
Warum gibt es PodImageData
nicht?
PodImageData ist gebetet.
Achso. Ich muss Canvas
Rendering Content.
Ah.
PodImageData, alles klar.
Guck mal, hier lernt
man noch was. Also,
äh, PodImageData,
0, 0, 0 ist wahrscheinlich, woran das
drawen soll. Leute, wenn das, wenn das
geht, und selbst, also ohne
Scheiß, das kann nicht funktionieren,
weil es ist kein RGB. Da kommt das jetzt mit
Grünstich raus oder so. Aber wenn das
jetzt ein Bild rendert, was nach einem Bild aussieht,
dann flipp ich aus. Wenn das
wirklich so, in Anführungszeichen, easy
jetzt funktioniert,
auch wenn es nicht easy war, aber ohne größere
Probleme funktioniert, dann,
dann beiß ich, dann beiß ich
mir quasi sprichwörtlich in Arsch.
Pff.
Was hab ich, was hab ich falsch gemacht?
Data is not defined. Okay.
Äh.
Ach hier. Was?
Uncored.
Worker on message.
The provided value
is not of type
ImageData
settings. Äh.
Moment.
Moment, kommt da jetzt überhaupt ein Buffer raus?
Kommt ein Buffer raus?
Äh, okay.
Ähm, äh, wie macht man das? Da fehlt doch bestimmt
noch was. Okay. Also,
swnumber ist er der Meinung. Ich hab ein uint
Moment, ich brauch ein uint8
clamped array.
Ein was für nen Ding? Bitteschön.
Ein was?
Was ist denn der Unterschied zu meinem uint,
uint8 array?
Okay, swnumber?
Okay.
Width, height,
settings. Okay, was brauch ich?
Ein uint8
clamped array. Obviously.
Kann man das wenigstens constructen
aus dem Alten?
Kann ich, kann ich sowas hier sagen wenigstens? Geht das?
Keine Ahnung.
So, kekwe.
Was ist das jetzt?
Das ist aber bestimmt ineffizient. Das sollte ich gleich,
das sollte ich gleich zurückliefern
hier.
Eigentlich, eigentlich könnte ich doch
das gleich hier machen, oder?
Sehe ich das richtig?
Das müsste doch eigentlich auch funktionieren so.
Dann kann ich mir das nämlich hier sparen.
Äh, okay.
Waffe raus hier.
Es gibt keine Fehler.
Es gibt aber auch kein Bild.
Muss man auch
ctx draw oder sowas machen?
Draw? Gibt es irgendwie
draw image oder irgendwie sowas?
Leute, ich check diese Hilfeseite nicht.
Da steht noch kekwe.
Oh. Failed to construct
image data. The provided value must not
be shared at worker...
Was?
The provided value must not be shared.
Äh.
Was soll
mir das sagen?
Provided value must not
be shared.
Was? Okay.
U8 int clamped.
Wie heißt dieser Clampel überhaupt?
Wie heißt das?
Uint8 clamped array.
Habe ich noch nie gehört.
Must not be shared.
Ja.
Must not be shared.
If what
you have are raw, then
all you need to create
from uint16
array.
Ja, was denn nu? Aha.
Okay, man muss diesen Müll
irgendwie erstellen. Aha, aber man muss das hier
drinnen direkt new... Okay.
Okay, okay. Dann machen
wir das jetzt so. Also, das ist ein
uint8 array.
Kein clamped array, weil...
Weil?
So. Buffer.
JavaScript shit.
Fuck!
Was? The input
data length is not equal
to 4 mal
width mal height.
Das kann schon sein, weil das ein anderes Format
ist. Der will
rgba vermutlich, ja.
Und ich hab, ich hab weder, ich hab weder...
Warte mal.
Okay, wir googeln mal.
Juf canvas.
JS
class to draw. Juf image frame
buffer. Das klingt doch schon mal gut.
Probier mal buffer. Buffer?
Nee. Oder?
Nee.
Nee, nee.
Nein.
Must not be shared. Nee, nee.
Ist schon richtig so.
Guck mal. Log.
Guck mal hier. Log. Buffer.
Buffer. Ja.
Das da hat
gar keine Buffer-Methode. Das ist ein...
Das ist ein...
Array. Das hat keine Buffer-Methode.
Das gibt's nicht.
So. Also.
Okay.
JS class to draw.
Dings. Okay. Stack overflow.
Wir fragen jetzt Stack overflow.
How to draw Juf image
to HTML canvas. Exakt.
I found this
gist. Aha.
Function
Juf to canvas.
Put image data. Das ist gut.
Das ist genau das, was ich brauche.
Das ist genau das, was ich brauche.
Es ist halt dumm, dass man das umwandeln muss.
Das ist sehr rechenintensiv, denke ich mal.
Das ist sehr rechenintensiv, denke ich mal.
Okay.
Also. Ach, du meinst,
ich muss sowas hier machen?
Okay, das probieren wir jetzt
noch einmal.
Nope. Nope. Nope. Nope.
Das interessiert ihn nicht.
JavaScript. Zeug.
JavaScript. Zeug.
Also, wir machen jetzt mal das da oben drüber.
Wir machen das.
Wie macht denn der Typ das hier oben drüber? Guck mal.
Create image data.
Output data.
Output data.
Wo kommt denn Output data überhaupt her? Ach, da.
Output.
Create image data.
Ah. Das ist quasi ein leeres
mit der Größe und dann
und dann
schreibt er das da rein.
Doch, doch. Ich kann das mit FFmpeg
konvertieren. Aber das ist nicht
so schön zu machen in FFmpeg.
Ja, das geht.
Okay. Ich will erstmal überhaupt was
rendern. Ganz ehrlich. Der Rest
interessiert mich jetzt erstmal wenig. Ich will einfach, dass
sich irgendwas tut auf dem Bildschirm.
Weil, das wäre mega geil, wenn das einfach
Was ist einfach? Wenn das einfach
irgendwas rendert.
Yuf to Canvas.
Wie ruft man das jetzt auf?
So? Buffer?
Ja, wahrscheinlich.
Okay. Witz.
Heiz.
Und jetzt Canvas.
Canvas heißt, glaube ich, bei mir auch einfach Canvas.
Wir machen
nochmal was anderes. So, mal um zu gucken, ob es
prinzipiell funktioniert überhaupt, mein Canvas.
Nicht, dass es was rendert und ich sehe
gar nichts.
Ähm.
CTX.
Phil. Phil
Rekt.
00. Keine Ahnung.
200.
200.
Wie stellt man hier die Farbe ein?
Okay.
Ist okay. Es funktioniert.
Musst du nicht warten, bis alles da ist?
Nee. Ich will ja jedes einzelne Bild
rendern. Also, ich bekomme aus dem
Decoder immer ein Frame.
Und den will ich direkt rendern.
Es geht. Es rendert was, Leute.
Es kackt zwar ab, aber
es funktioniert. Es rendert mein
Video. Ich meine, viel zu schnell.
Viel zu schnell. Holy fuck,
Alter. Das tut
die Hand weh, Alter.
Ja, ich habe keinen Sleep drin. Das ist
5 Billionen, 5 Billionen
FPS. Guckt euch
das an.
Es braucht aber einfach 70%
CPU-Last.
Okay, wir müssen noch einen Sleep
reinhauen, Leute. Aber, aber
ohne Scheiß, das hier ist keine
sonderlich, also
das hier ist keine sonderlich
efficient Methode,
das zu rendern, glaube ich.
Gibt es nicht die
Möglichkeit, irgendwie, yuff mit
WebGL? Das hatten wir doch. Das hatten wir.
Hier, diesen komischen...
Wo, wo war dieser, Leute, wo war dieser
Fiveheader? Wo war dieser
Fiveheader-Blogpost?
Hatte noch jemand irgendjemand
auch so einen mega Fiveheader-Blogpost
gepostet? Hier, das da.
Das machen wir jetzt nicht, aber...
Oder haben die was Fertiges
am Ende, was man einfach copy-pasten kann?
Hier, einfach copy-pasten.
Easy. Copy-pasten.
Complete Code.
Jawoll.
Massive copy-paste.
Massive copy-paste, einfach
von dem Typ.
Ich hab keine Ahnung, was der Typ da macht, aber...
Geht nicht FPS-Angabe statt
Sleep? Nein. Du musst den FFM-Pack
selbst gucken, wie lange hat die Loop gedauert
und dann musst du sleepen.
Aber wir machen das mal ganz...
Wir machen das mal Pi mal Daumen jetzt.
Video ist
mit 30 FPS
1 durch
30, also
33 Millisekunden sleepen müssen wir jetzt.
33 Millisekunden sleepen.
Ich mein, eigentlich ist es
dumm, 33 Millisekunden zu sleepen,
weil wir müssten eigentlich
einen Frame rendern,
dann den
nächsten, dann sleepen
und im Hintergrund
schon den nächsten Frame
rendern.
Aber...
Nee. Sleepen war nur
20 Millisekunden, okay.
Geht nicht. Warum?
Ah, doch, geht.
Wobei, nee, das bringt dann nur am ersten
Frame was. Okay.
Also, sleep.
Make.
Okay, hat funktioniert.
Aha. So, mal gucken, jetzt sollte
es ja nicht mehr... Oh, Crash, was?
Uncord, please compile your program
with async support.
Wie macht man das?
mscripten async
support
asyncify
Ja, ja, ja, ja.
Minus s
asyncify. Okay, das muss ins
make-file.
Wo ist unser make-file?
Chat, irgendjemand
planen, wo das hin muss? Einfach hier rein?
Einfach hier rein, so?
Anscheinend.
Ich dachte auch nicht, dass wir das bis hierhin schaffen. Ganz
ehrlich, das funktioniert ausgesprochen
gut. Das funktioniert wirklich
ausgesprochen gut, also...
Und wisst ihr, was das Geile ist? Es gibt nichts
im Internet, wo das jemand mal gemacht hat. Das ist
wirklich hier bleeding-edge-shit.
So.
Out. Hey!
Das sieht jetzt ziemlich,
ziemlich legit aus, oder?
MLG legit.
So, wir machen mal ein bisschen ein längeres
Video und gucken, ob es uns dann um die Ohren fliegt.
20% CPU.
Ja, bei 640x360.
Wir machen mal, wir machen mal
ein anderes Video. Youtube...
10% CPU.
Ja, bei 640x360.
Wir machen mal, wir machen mal
ein anderes Video. Youtube...
minus F...
Wir laden das Ding mal in
720p runter.
F...
Ja.
AV...
Video only. Ja, sehr gut.
Mal gucken,
ob es das überhaupt abspielen kann, oder ob das Youtube
Encoding zu pepega ist.
Ob der das überhaupt da
reinladen kann, den Browser?
Okay. So, funktioniert.
Ah, da ruckelt's
jetzt aber schon ein bisschen. Das
liebe ich jetzt zu lange.
Aber mal ohne Scheiß, das ist schon
in Ordnung. Ach, Moment, da fehlt ja die Hälfte vom Bild.
Moment, da fehlt...
Da fehlt ja die Hälfte
vom Bild. Ja, vielleicht sollte man das hier machen.
Canvas
Width Height. Ah, viel besser.
Viel besser.
Exquisite 5 Header Cram.
Hier, guck mal.
Jetzt sind wir schon mal 50% CPU
Last.
Wo mach ich denn hier eigentlich diesen Console Lock?
Das Console Lock kann ich mir doch jetzt
eigentlich komplett
sparen. Hier, das
Printf kann weg.
Und das
kann auch weg.
Und jetzt irgendwas MPEG-2 encoded. Ja, das
funktioniert wahrscheinlich nicht, weil ich kein MPEG-2
Decoder drin hab.
Aber ich kann... Leute, ich bin 3 Stunden on. Ich kann mich auch nicht
mehr so deutlich lange konzentrieren, muss ich ehrlich
sagen. Oh, 6. Leute, Leute,
es verreckt.
Mein RAM war voll. Mein RAM ist voll
gelaufen. MonkaS,
mein RAM ist voll. Ich muss abbrechen.
Zack.
Habe ich ein Memory Leak drinne? Kann das
sein?
Habe ich ein Memory Leak?
Ich hab... Ah, ja.
Ich hab'n
Memory Leak. Guck mal.
Ich geb' meine Buffer nie frei.
Ich geb' meine Buffer
nie frei. Guck mal.
Ich leg' hier an.
Copy Buffer.
Das muss ich machen.
AV3.
Ähm...
Buffer wahrscheinlich.
Bloated, ja.
Lul.
Komm, wir lassen den mal so schnell
rendern, wie geht.
Kann ich dem, kann ich dem Parameter übergeben?
Ok, String.
Int. Äh, Sleep.
MS. MS.
Milliseconds.
Da muss ich nicht immer neu kompilieren, wenn ich
das Sleep anpassen will.
So. Worker.
Äh, Moment. Ich kann mich
schon nicht mehr richtig konzentrieren.
Soll ich das auf ShitHub pushen dann?
Run.
Nee, ich kann's grad nicht auf ShitHub pushen.
Weil ich kein...
Weil ich nicht eingeloggt bin.
Hier.
Ich hab mein Key und so, aber ich hab...
Ich bin nicht eingeloggt.
Auf dem Rechner.
Ok, 20 Sekunden.
Warum sleepst du in deinem C++ Internet beim Renderen
der Frames?
Ähm...
Es gibt in JavaScript kein Sleep.
Ich könnte ein Promise machen mit
setTimeout, auf den ich warte.
Oder sowas.
Ich muss ein Sleep basteln.
Nee, sowas gibt's nicht, oder?
Nee, nee, nee, nee. Das ist JavaScript da jetzt.
So. Ok.
Zack.
Ah, das ist das falsche.
So, ich sollte...
Ich sollte keine Memory Leaks mehr haben, zumindest jetzt.
Uh!
Was war das?
Macht der da für Dinger?
Wow.
Ich hab kein Memory Leak mehr, aber es kackt ziemlich ab.
Ach, ich weiß woran's liegt, Leute.
Ich weiß woran's liegt.
Ich mach Free...
Ich mach das Freeform Sleep.
Also, das hier ist ja bestimmt
asynchron, der Callback.
Und ich freee den Buffer...
Ich freee wahrscheinlich den Buffer,
während ich im JavaScript
noch am Rendern bin.
Geh ich jetzt einfach mal von aus.
Na, so ein kleines
Sleep ist nicht verkehrt.
Nee.
Daran liegt es nicht.
Vielleicht dauert das Rendern zu lang.
Hahaha.
Das ist auch...
Das hat 100% was mit dem Free zu tun.
Weil, wenn ich das Free wegmache...
Guck mal. Wenn ich das Free wegmache...
Da gibt's kein Problem.
Ja, das sind die
Battlefield 2042 Effekte, genau.
Die haben einfach
verbackten Renderer.
Du hast recht.
Nenas, das ist eigentlich viel sinnvoller.
Nee, kann ich nicht.
Die Frames sind unterschiedlich groß.
Oder? Sind sie?
Theoretisch schon.
Wobei, nee, die Frames sind immer gleich groß.
Die Frames sind immer gleich groß.
Du hast recht, ich kann's am Anfang anlegen.
Guck.
Kaum ist das Free weg,
hab ich... Jetzt hab ich aber Memory Leaks.
Jetzt hab ich Memory Leaks.
Guck, jetzt hab ich Memory Leaks.
Moment, ist das Free,
was ich hier... Oh, oh.
Jaja, das ist Free. Das ist Free.
Was ist das für eine bescheuerte Anzeige?
Null von...
Meine RAM-Auslastung
geht umgedreht.
Tag wait.
Aber du hast recht. Ja, wir machen das so.
Das ist korrekt. Das ist eine sehr gute Idee.
AV Free Buffer.
Und die Buffer Size...
Die Buffer Size
legen wir einmalig
an.
Und zwar...
So, wir haben jetzt ja hier keinen Zugriff auf Frame.
So, mal so.
Das verwirrt mich sonst.
Wir haben keinen Zugriff auf Frame,
aber wir haben Zugriff auf den Kontext.
Da muss ich aber jetzt erst noch sagen,
AV Stream Info
oder sowas. Sekunde, das haben wir doch hier irgendwo.
Find Stream Info.
Find Stream Info.
Find Stream Info.
Find Stream Info.
Format CTX.
Format CTX.
Null Pointer.
Ja, sonst lädt er das ja irgendwie nicht.
Warum das 13 GB RAM verbraucht? Das ist der Browser.
Warte, dass ich den Browser schließe.
Bam!
Ja, ich mein, okay. Da gibt er es wieder frei, wenn angefordert wird.
Aber das liegt, das liegt nur
am Browser und meinen komischen
Memory-Leaks hier.
So, also.
So, also.
So, Stream Format gibt es nicht.
Es gibt CTX Format.
Witz...
Ach, ne. Hm.
Stream?
Witz? Hm.
wie kriege ich jetzt die breite raus das geht das kriegt man raus das kriegt man
raus bevor man das kriegt man raus bevor man den ersten frame decodet das ist
format stream fmt fmt fmt format input format ne pixel das kriege ich schon raus
bevor stream codec parameter vielleicht stream codec x ah ja ja okay das ist gut
mir
minus codec parameter x fmt format das ist was anderes das ist ein anderes
format ach du scheiße man pixel format okay das haben wir oder kann ich codec
ah wie kriege ich denn jetzt die höhe und die breite raus ach so ok alles gut
breite
so jetzt legen wir das nämlich nur einmal anders ist viel besser der chat ist wieder
richtig fett gewesen jetzt kann man keine memory leaks es geht schneller und keine
pixel fehler die frage ist ob es funktioniert 6 herr chat rear aha und es ist auch gleich
schneller als dubedingt am anfang ist wohl normal weil da irgendwelche frames verbuggt sind ich mein ganz ehrlich das läuft echt brauchbar gelben
ich mein ganz ehrlich das läuft echt brauchbar gelb
ich mein ganz ehrlich das läuft echt brauchbar gelb
ich mein ganz ehrlich das läuft echt brauchbar gelb
Brauchbar, gell?
Das läuft wirklich brauchbar.
Ähm, machen wir mal.
Okay, ich muss nicht neu kompilieren.
Äh, hier.
Wir machen mal kein Sleep.
Es wird nicht gesleept.
Gibt kein Sleep.
Okay, jetzt rennt er da natürlich ein bisschen schneller.
Ja, der rennt jetzt schneller als es FPS hat.
Dementsprechend skippt er halt.
Oder sieht so aus, als würde er skippen.
So.
Oh, einfach refreshen geht nicht.
Weil er nicht im Sleep hängt.
Da kackt er ab jetzt dabei.
Mal zumindest, zumindest mal kurz.
Eine Millisekunde sleepen sollte ich.
Millisekunde sleepen.
Ja.
Also.
Ja, man kann das noch beliebig, man kann das noch beliebig optimieren, ja.
Äh, FFM-Pack Performance zum CLI.
Ha, wüsste ich jetzt, habe ich keine gute Idee, wie man das vergleichen könnte.
Da müsste ich mir mal was überlegen.
Machen wir mal.
To-Do-Benchmark-Vergleich, irgendwie sowas.
Ja, das geht.
Das hat FFM-Pack drinne stehen, das muss man sich ausrechnen.
Das ist, das geht.
Ja, ja.
Das ist aber ein bisschen Painstamp.
Du musst gucken, wie viel die Zeit ist.
Und dann musst du es abziehen vom Schleifendurchlauf.
Und dann musst du es ausrechnen aus den Frames.
Ich glaube eher, das Problem ist, dass bei zum Beispiel, okay, übernennen wir das mal kurz um.
Ähm, das hier ist...
720p.
MP4.
Und jetzt machen wir noch YouTube-Download.
Jetzt, jetzt, jetzt machen wir noch...
Den komm jetzt, naja.
Jetzt machen wir noch hier die...
Full-HD-Version.
Was ist denn hier der Unterschied, Leute?
AV-01 und AV-C, das ist irgendein anderer Codec, oder?
AV-C brauchen wir.
Und das ist...
Oh, Leute, jetzt wird es heftig.
Das ist nicht nur 1080p, sondern auch 60fps jetzt.
Okay, das kriegen wir nicht flüssig hin.
Das kriegen wir höchstwahrscheinlich nicht flüssig hin.
Gehe ich nicht von aus, dass das funktioniert.
Vielleicht, wenn wir das Rendern schneller hinbekommen.
Weil das Rendern ist schon ziemlich, ziemlich langsam.
Guck mal, da spielt es noch nicht mal ab.
Da spielt es nicht ab, weil das der falsche Codec ist.
Weil YouTube wieder richtig hardcore-pepeger ist mit ihren Codecs.
Das ist VP9.
Ich habe doch VP nicht VP9 runtergeladen, oder?
Oh, ich habe VP9 runtergeladen.
Ich habe mich verguckt.
Kein Wunder, VP9 ist nicht reinkompiliert.
299 brauche ich.
Ja, das kann man alles schon noch optimieren.
Das Synchronisieren und so.
Es gibt also ein paar Optimierungsdinger.
Zum Beispiel, dass wir jeden Frame vom internen Buffer...
Weil auch eine Sache, die ich auch nicht...
...schön finde, ist...
Guck mal, wir kopieren uns die Image-Daten von jedem Frame aus dem internen Buffer in diesen Copy-Buffer.
Das bräuchten wir wahrscheinlich gar nicht.
Man kriegt das bestimmt auch so...
...nach...
...ins JavaScript.
Das müsste man halt basteln, ja?
Also, hier muss man hier...
...to do no copy.
So, jetzt laden wir das mal und gucken, was...
...sache ist.
Moment, das müssen wir umbenennen.
Das müssen wir umbenennen.
Das ist 1080p 60.
60.
Das andere ist 720p 720p...
...720.
30.
So, mal gucken, ob es das halbwegs flüssig hinkriegt.
Aber ich glaube nicht.
Nope.
Nope.
Nope.
Canvas checkt so nicht.
Das ist nicht...
Aber, ich meine...
Das ist jetzt nicht...
Es fehlt aber nicht so viel, muss man sagen, ja?
Das ist so halbe Speed.
Halbe Speed, würde ich sagen.
70% Speed vielleicht.
Aber es ist okay.
Oh.
Oh, das lastet ihn aus.
Da ist Schluss.
Wir können mal was ausprobieren.
Mal gucken, ob er...
Nee, nee.
Ich hab den Sleep auf...
Auf...
...einer Millisekunde.
Ist das Spotlight jetzt das JS zum Rendern oder das C++ zum Decoden?
Ehrlich gesagt, ich glaube, das C++ zum Decoden...
...das könnte man ausprobieren, indem man das Rendern einfach weglässt.
Ja, das mit der GPU, das müsste man auch ausprobieren.
Also, ich vermute mal, das Rendern im C++ ist das Problem.
Das könnte man ausprobieren.
Wisst ihr, wie man das ausprobieren könnte?
Ich hab ne Idee.
Guck mal.
Ähm, wir machen uns jetzt ein 20...
20 Sek.
1080.
60.
Und dann stoppen wir einfach die Zeit, wie lange das durchläuft, ohne zu rendern.
MP4.
Auf, mach 20 Sekunden.
Der ist ganz schön...
Ich mein, der decodet und encodet jetzt auch gleich.
Also, was wir machen können ist...
Das Hin- und Herschicken zwischen Web-Worker und so ist auch doof.
Gibt es nicht irgendein globales Array, wo ich was reinschreiben könnte?
Dieses Post-Message ist auch nicht so geil.
Nee, nee, Copy...
Stimmt, ich hätte Copy machen können, du hast recht.
Ich brauch ja nicht re-encoden.
Also, was wir jetzt nämlich machen können ist...
Wir lassen das Rendern weg.
Guck mal, wir lassen das Rendern weg.
Wir machen das hier.
Und...
Wir stoppen die Zeit.
Ja, also wir sagen hier...
Beim Post-Message...
Ich mein, so ungefähr über den Daumen gepeilt.
Ja, wir sagen Time übrigens richtig nice.
Dass sowas mittlerweile eingebaut ist in JavaScript.
Console-Time.
Und dann sagen wir...
Console-Time-Log.
Und dann gucken wir, was die letzte Zeit ist, die er gebraucht hat.
Bei diesem 20-Sekunden-Ding.
Ja, bessere Performance als Battlefield ist ja keine Kunst.
So, 20 Sekunden lassen wir jetzt durchlaufen.
Und wenn er es länger braucht als 20 Sekunden...
Und wenn er es länger braucht als 20 Sekunden...
Dann wissen wir, dass es laggt.
Es laggt.
Der Decoder-Teil ist nicht schnell genug.
Guckt, der Decoder...
Das liegt nicht am Rendern vom Video.
Der Decoder-Teil ist nicht schnell genug.
Guckt, der braucht 36 Sekunden, um das Ding zu rendern.
Also, 1080p, 60fps kannst du vergessen.
Das ist aber auch nicht das, was ich damit machen will.
Wir reden ja von SD-Videos mit...
Äh...
Wie viel FPS?
hat 50 das sollte der hinkriegen und und mpeg mpeg 2 video ist wahrscheinlich auch nicht so
ressourcenintensiv wie hat 264 ja wie gesagt da lässt sich eines noch einiges habt ihr also
der ist der ist nicht so schnell also er sollte wir können es ja mal testen wenn ich das jetzt
ist das überhaupt 60 fps hier ff probe 60 ja wenn ich das jetzt hier um wenn wir können
mal 30 fps machen fps 30 ging das so nee oje das weiß ich aus dem kopf nicht einfach mpeg
fps minus er 30
ffmpeg
der chat weiß bescheid das muss man kurz ich meine guck mal das normale ffmpeg kriegt es
schon nicht hin das zu decoden und encoden mit voller mit voller mit mit zur laufzeit
hin wobei das auch decodet und encoded und das encoden ist aufwändiger als das decoden
glaube ich zumindest und der browser decodet ja nur so ff probe
also 60 fps das müssen wir jetzt zu senktieren ja erst mal angeben sadb
das gehe ich jetzt mal ein bisschen bei ihm aus
also 30 so guck mal mal das sollte fein sein eigentlich 30 guck mal, also wenn das bei ungefähr
20 sekunden raus kommt ist alles okay und da sollten wir auch kein slowdown sehen
tru
definitiv tru ja guck mit 30 fps kriegt das hin
Also, wir haben mehrere Probleme.
Wir haben die Render-
Wir haben die Render-Performance
von dem Canvas
und wir haben...
Na gut, das ist jetzt auch noch 30 FPS.
Guck, die Render-Performance
slowt das auch noch down.
Oh, Alter.
Mein Browser.
Oh, guys.
Ah, geht zu.
Nee, NVN kriegen wir an der Stelle
bestimmt nicht hin.
Also doch WebGL.
Oh.
Ich weiß nicht, ob ich das jetzt
nach 3 Stunden 20
noch auf die Reihe kriege.
Ich meine, ich kann es reinkopy-pasten
und gucken, ob es funktioniert, ja?
Das nächste Mal können wir gucken,
wie wir das optimieren.
Also, ich denke schon,
dass es möglich ist,
das hinzubekommen.
Nicht, dass man es bräuchte,
aber wir brauchen auch noch To-Do.
Neuere X-Dings-Version.
Können wir auch noch machen.
Ja, und das müsste man tatsächlich
ein bisschen entkoppeln.
Ja, ich nehme...
Ich copy-paste mir das jetzt aus
dem...
Ich klaue denen das jetzt einfach, ne?
Ähm, wohin?
Wohin macht man das jetzt?
Braucht man dann New File?
Äh, keine Ahnung, Render?
JS?
Okay, es geht schon mal ohne
Syntax-Fehler.
Das ist schon mal nice.
Ähm...
Oh, wie verwendet man denn Module
im Browser?
Jemand messe Fifed Plan?
Kann man da jetzt einfach sagen
Import
äh, Punkt,
Slash,
ne, ähm...
Wie macht man das jetzt?
Render.js?
Kq?
So?
Ne.
Script,
Type,
Module, okay.
Scheint funktioniert zu haben.
Kq?
Ja, ja, ja, alles klar.
So, wie verwendet man den Kram jetzt?
Ah, kein Auto-Complete.
Wie ging das mit Type...
Kann man Type Annotations...
Kann man...
Sag mal.
Let b gleich Kq.
So.
Kann man...
Ne, Moment.
Ich weiß gar nicht.
Kann man Type Annotations auch machen
für irgendwie dieses andere
JavaScript-File oder so?
Kann ich irgendwie sagen, äh...
Render.js oder so?
Ne, gell?
Ne, ich muss sagen...
Nicht Render.js?
Ich muss wahrscheinlich sagen,
Dings hier.
WebGL-Class.
WebGL-Screen.
Ne.
Hahaha.
Okay.
Wie ver...
Mach ich das jetzt...
Also verwendet man das jetzt so?
Ist das...
Ist das so gedacht, ja?
Okay.
Constructor, Canvas.
Jetzt muss ich das lesen, wie man das verwendet.
Oder haben die ein Beispiel, wie man das verwendet?
Ah, das ist...
Du hast gut...
Gute Idee.
Ja, du hast recht.
Wir können einfach sagen...
Function.
Kq.
New Web.
GL-Screen.
Canvas.
Ja, das machen wir jetzt.
Mal Alibi-mäßig hin.
Let's screen.
Screen.
Äh, Render Image.
Alter, wenn das funktioniert...
Kek-Tribble-You, dann...
Kek-Tribble-You, ist klar.
Hahaha.
Richtig dumme.
So, Canvas.
Äh, Cannot Read of Undefined...
Und...
Render Image.
Ach so, ja.
Da ist ja nichts drin.
Lull.
Gucken, ob das mit dem Screen klappt.
Äh, Fill Rect.
Ach so, ja.
Das...
Das funktioniert an der Stelle nicht mehr.
Das gibt es nicht mehr.
Okay.
Scheint zu funktionieren.
Moment, was macht...
Hier.
Screen.
Render Image.
So, und das kann ich mit diesen ganzen Krempel eigentlich sparen.
Und ich kann direkt sagen...
Äh, wie ging das?
Höhe, Breite?
Hab's vergessen.
Breite, Höhe, Delta.
Okay.
Breite, Höhe, Waffe.
Das klappt doch nicht.
Wow.
Das geht einfach.
Und es ist deutlich flüssiger.
Es ist deutlich flüssiger.
Aber es ist auch kleiner.
Es ist auch nicht 1080.
Ähm, so.
Machen wir mal das, das, das, das Console-Log hier raus.
Und...
PIME raus.
Wie kriege ich denn das jetzt mit dem Size hin?
Ah, mein Canvas ist ja noch 46...
Also...
1080.
Ne, ne.
120 mal 1080.
Gibt's ein Set Size?
Set Size...
Aha!
Es gibt eine Set Size Methode.
Tatsächlich.
Lull.
Na, dann machen wir das doch so.
Viel besser.
Aber die muss ich jedes Mal aufrufen.
Äh, komm, komm.
Ich lass es jetzt mal so zum Testen.
Zack.
Ey, Leute.
Das läuft erstaunlich gut, muss ich mal sagen.
Ohne Scheiß.
Das läuft erstaunlich gut.
Für das...
Guckt mal.
24...
Also für das, dass ich im Browser den Shit gerade decode.
Also...
Das läuft wirklich nicht schlecht.
60 FPS?
Okay, 60 FPS schafft er nicht.
60 FPS kriegt er nicht hin.
Der kriegt 60 FPS mit 30 FPS hin.
Deswegen sieht's aus wie Slowmotion jetzt.
Guck mal.
Der kriegt 60 FPS mit 30 FPS hin.
Es ist flüssige Slowmotion jetzt.
An der Stelle.
Also 1080p 30 FPS ist Schluss.
Aber eigentlich sehr cool, muss ich sagen.
Sehr, sehr nice.
Eine Sache probieren wir jetzt noch aus.
FFM Pack.
Ja, ich denke auch.
Ein bisschen was.
Optimiert kriegen wir da schon auch hin.
Wir probieren mal was aus.
Wir nehmen jetzt die 1080p.
Und resizen die.
Kannst du nicht jeden zweiten Frame rendern?
Doch, doch.
Das ist theoretisch auch noch was.
Wenn ich merke, dass es zu langsam geht, dann könnte ich theoretisch...
Nee.
Ich kann nicht so einfach Frames skippen.
Das macht der Decoder nicht mit.
Nee, nee, nee.
Das ist dann...
Das ist das...
Ja.
Nee, ich glaube, das...
Ich glaube, das klappt nicht.
Ich rufe eine Millisekunde Sleep auf.
Eine Millisekunde Sleep habe ich.
Das sollte nicht das Problem sein.
So, warte mal.
Also, wir machen jetzt was.
1080.
60 FPS.
Machen wir Input.
Output.
720.
60.
Und Rate 60.
Wobei, das ist egal.
Ist ja schon.
Äh.
FFM-Pack.
Äh.
Down.
Scale.
Scaling.
VF-Scale.
Was?
Okay, FFM-Pack.
1080p to 720p.
Stack Overflow.
Regelt.
Scale.
Was zum...
Einfach so?
Was auch immer das mit den Minions zu tun hat.
Keine Ahnung, ja.
Okay.
Also, mache ich einfach minus S, oder was?
Minus S.
1.208 mal 720.
Ah, Mist.
Das dauert jetzt ein bisschen, weil mein Video ist ja...
Könnte ich auf dem Haus mit FFM machen.
Mein Video ist ja 10 Minuten.
Ich will dem noch jetzt keine 10 Minuten beim Rendern zugucken.
Okay, ich lass ihn, ich lass ihn einfach...
Ich lass ihn einfach eine Minute rendern.
Das reicht.
30 Sekunden noch und dann breche ich ab.
Eine Minute zum Testen reicht.
Ich will eigentlich nur wissen, ob der noch Memory leaks hat und irgendwie out of memory liegt.
Und am abkacken ist.
Ich meine, wisst ihr, was wir auch machen können?
Wenn wir gerade dabei sind.
Wir machen das Sleep.
Wir machen das Sleep wirklich komplett raus.
Ja.
Oh, es laggt.
Wir machen das Sleep komplett raus.
Alter.
98% CPU.
Vom FFM Pack.
Ist vorbei.
Ich bin in der VM.
Da ist nichts mit GPU Accelerated.
So, und jetzt sagen wir an der Stelle, wo wir das Sleep haben oder wo wir das Sleep brauchen, machen wir es doch einfach so.
Wir testen mal, wie das ist mit einem Sleep.
Wir testen das mal ganz ohne Sleep, komplett ohne Sleep.
Und ansonsten hätte ich gesagt.
An der Stelle sind wir dann da an der Stelle, woran das dann rendert, das können wir mal kollapsen, woran rendert, mache ich ein JavaScript
Delay.
Oder so rein.
Dann ist halt die Frage, ob der auch wirklich das Asynchron macht.
Wahrscheinlich gibt da dann irgendwelche Frames oder so, weil.
Weil der wartet ja wahrscheinlich nicht, bis es returnt, wenn ich hier drinne.
Gucken wir mal.
Wie macht man ein Sleep in JavaScript gescheit?
Promise.
Okay, aber.
Sleep.
Sleep gleich New Promise.
Äh.
JS Promise.
Sleep.
Ist der geoverflowed.
Beste.
Excellent.
Nehmen wir die Function, das ist besser.
Okay, ich quitte.
Wir haben vier Minuten gerendert.
Das sollte reichen.
Äh.
720 60.
Hey.
Das flutscht, Leute, sogar schneller, sogar schneller, als das sein müsste.
Guck mal, das sind eher 90 FPS.
Da kannst du dich echt nicht beschweren, oder?
Das ist ziemlich.
Gut.
Von der Performance her.
Ich meine, für das, dass das Cross-Compiled ist, C++ im Browser ist, ist das wirklich nicht
verkehrt.
Wir checken mal, ob das mit diesem Sleep hier funktioniert.
Ich glaube nicht.
Ich glaube, dann skippt er Frames.
Das juckt ihn überhaupt nicht, aber das sind ja auch nur fünf Millisekunden.
Äh.
Moment.
Sind das Millisekunden?
Leute, ich warte ja gar nicht.
Lull.
So, jetzt.
Das interessiert ihn überhaupt nicht, das Sleep.
Und warum interessiert ihn das nicht?
Weil, ähm, das hier auch, das hier gecallt wird, ohne dass der wartet, bis der Rest durch ist.
Also keine Chance, hier irgendwie das Sleep einzubauen.
Das müsste man über irgendeine Queue machen.
Man bräuchte irgendwas, was rendert.
Und man bräuchte irgendwas, was displayt.
Und sich das dann aus der Wahrheit, irgendwie so.
Aber, genau.
Du musst, man, wir müssen das rendern.
Und dann, separat.
Und dann, separat machen, zu dem, zu dem, das, da muss ich mir mal was überlegen.
Das machen wir heute aber auf jeden Fall nicht mehr.
Ähm, ich mach jetzt mal das Sleep wieder rein.
Make.
Wo ist das mit dem Run?
Hier muss das Sleep rein, ne?
Ne.
Run.
Hier, Sleep.
Nochmal Sleep 10 oder so.
Oder 5, 5, 5.
Ja.
Leute, das sieht ziemlich gut aus.
Sogar noch ein bisschen mehr.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Acht.
Also, das ist performancetechnisch echt nicht schlecht.
Ich mein, ernsthaft, wenn der 720p, wir müssen jetzt mal gucken, meint ihr, das läuft
auf dem Safari?
Safari iOS?
Ne, wird's bestimmt nicht.
Ich find das sehr nice.
Also, ganz im Ernst, die Performance geht doch absolut in Ordnung.
na super erkennt man ja viele die performance geht doch absolut in ordnung das als elektron
anwendung und man hat eine media player leute das ist so verrückter scheiß mich wundert also
mich würde es nicht wundern wenn das jemand macht ffm pack erst mal in wasser um es dann
in elektron zu packen paint es gibt bestimmt leute die machen das ja ich könnte wetten es
gibt leute die machen das ok es ist also ich bin ich bin da wirklich überzeugt von ich finde das
cool series max jetzt können wir jetzt kannst du sowas nehmen hier damit geht das jetzt da
musste 10 plus plus krempel machen ok also
das war es für heute ich gehe jetzt was essen und wir machen alle mal weiter weil ich kann ich
kann mich nicht mehr groß konzentrieren jetzt an der stelle nächstes mal wir bauen aber noch
ein bisschen weiter auf jeden fall das haben wir gemacht wir probieren das nächste mal ob wir das
noch ein bisschen weiter optimiert kriegen wen soll ich hausten haben irgendjemand nee ich kann
ich bin nicht eingeloggt also das nächste mal optimieren wird es gibt ja noch einiges zum
optimieren und ich bin nicht eingeloggt also das nächste mal optimieren wird es gibt ja noch einiges zum optimieren
ja also zum beispiel diese geschichte hier dass man das jedes mal kopiert dass ich schon mal ziemlich
ppg habt ihr irgendeine ahnung könnte man könnte man das decoden auch multithreaded machen ich
glaube decoding multithreading ist paints champ das will man nicht weil ich meine der muss sich ja
sinken der muss ja die der muss ja die frames nacheinander decoden man könnte teilweise die
sachen parallel machen aber
ich glaube das will man eigentlich nicht aber es ist schon beeindruckend von der geschwindigkeit her
für das dass es im browser läuft ist schon wirklich in ordnung macht der ffm pack nicht schon multithreading ich wüsste jetzt nicht an welcher stelle es das machen soll ich meine das ist eine schleife ohne ohne jegliche multithreading geschichten das kann es ja auch nicht jemand wo wo soll es das machen hier hier das decoding multi
reds
auto use multithreading
da brauchst du mehrere decoder kontexte oder
das ist ffm pack in wassum in chrome in einer vm richtig aber die vm macht das kleinste problem hier
äh
das kann doch gar nicht funktionieren was der dude da macht
wie soll denn das funktionieren
meine schleife ist doch gar nicht multithreaded
also
hä
das ergibt keinen sinn was der typ da macht das ist doch gar nicht multithreading
also
auf der metal ist es noch performante außerhalb der vm das nimmt sich nicht so viel das nimmt
sich nicht so viel der duta macht ergibt überhaupt keinen sinn oder startet er das
startet er das jetzt irgendwie mehrfach multiswede decoding ach du scheiße ok das machen wir heute
definitiv nicht das wird das also das würde richtig und ich bin mir auch gar nicht sicher
wie man multiswede machen kann bei dieser anwendung jetzt mein dazu muss das muss ja
sinken irgendwie also muss auf jeden fall gucken dass die frames in der richtigen reihenfolge also
theoretisch müsstest du ein buffer machen oder eine queue machen da schreibst du die frames
rein und alle keine ahnung einmal in der sekunde
holst du dir welche raus oder die in die richtige richtung und dann rennt hast du sie so irgendwie
so weil du musst du musst auf jeden fall die frames in der richtigen reihenfolge ändern weil
sonst kommt ja nur müll raus man könnte auch sein lassen ja das stimmt aber muss machen was geht
einfach um zu gucken ob es geht leute wir sehen uns war ein sehr leiser stream wir haben deutlich
mehr auf die reihe bekommen als sie überhaupt gedacht
hätte als ich angefangen habe zu streamen und ich gehe jetzt was essen wir sehen uns bis dann macht's gut
